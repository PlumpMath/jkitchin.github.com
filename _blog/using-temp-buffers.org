* Using temp buffers
My aim here is to figure out how to use a temporary buffer to create content and insert it into a new buffer. The idea is related to the need to annotate text files. For simple notes, the minibuffer is adequate, but for complex notes, you may want a whole buffer in org mode to do it.

Here, we create a function that saves the current buffer in a global variable (the one with *ear-muffs*), create the new buffer, switch to it, and set it to org-mode. Afterwards when you are done editing, you run another command that saves the buffer-string, kills the temporary buffer, and inserts its contents into the original buffer.

#+BEGIN_SRC emacs-lisp
(defun j/an ()
  "open a new buffer in a new window to create a note"
  (interactive)
  ;; save current buffer
  (setq *annotation-current-buffer* (current-buffer))
  ;; create new buffer, switch to it, and set to org-mode
  (get-buffer-create "*note*")
  (switch-to-buffer "*note*")
  (org-mode))

(defun j/ax ()
  "kill current buffer, switch to the original buffer and copy the temporary buffer-string to *annotation-current-buffer* "
  (interactive)
  ;; make sure we are in the right buffer
  (switch-to-buffer "*note*")
  (let ((contents (buffer-string)))
    (kill-buffer "*note*")
    (switch-to-buffer *annotation-current-buffer*)
    (insert contents)))	
#+END_SRC

This works reasonably well, as long as you do not modify the original buffer before you insert your note; the note will be inserted wherever your cursor is.

Now, back to our annotation function. I want to have a command that by default uses the minibuffer for getting the note, but with a prefix command uses another buffer. Most of the time I will write short notes, but sometimes I may want longer notes with code in them.

#+BEGIN_SRC emacs-lisp
(defun annotate (&optional arg)
  "Goto ANNOTATION section and add a note with a link back to point.

if you use a prefix arg, then you will get a new buffer in org-mode to construct the note. Otherwise you will enter the note in the minibuffer."
  (interactive)
  (let ((POINT (point))
	(line-number (line-number-at-pos))
	(note nil))
    (org-mark-ring-push) ; save position
    ;; create section if it does not exist
    (unless (not (search-forward "* ANNOTATION" nil t))
      (goto-char (point-max))
      (newline)
      (insert "* ANNOTATION\n"))
    ;; point should be at the ANNOTATION section now
    ;; we save restriction in case there was any to start with
    (goto-char (point-max))
    (newline)
    (insert "- " (format "[[elisp:(goto-char %i)][line %i]]: " POINT line-number))
    ;; no prefix command
    (if (equal current-prefix-arg nil)
	(progn
	  (setq note (read-string "Note: " nil nil "note"))
	  (insert note "\n")
	  ;; finally go back to where we came from
	  (org-mark-ring-goto))
      ;; else, use annotation buffer. for now you have to go back on your own
      (j/an))))
#+END_SRC

This is almost what I want, but I have not figured out the last bit of using a separate buffer. The switching to a new buffer works fine, and when I close the old buffer with the command it also works fine, but the annotate function is not waiting for the temp buffer to close to do the next step. This is not quite as convenient as I want. I want something similar to how C-c' works in org-babel, but I have not figured that out yet

* ANNOTATION

- [[elisp:(goto-char 1772)][line 31]]: test
