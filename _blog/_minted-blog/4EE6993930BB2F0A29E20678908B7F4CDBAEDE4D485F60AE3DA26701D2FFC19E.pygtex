\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{defun} \PYG{n+nv}{mongo} \PYG{p}{()}
  \PYG{l+s}{\PYGZdq{}Run an inferior instance of `mongo\PYGZsq{} inside Emacs.\PYGZdq{}}
  \PYG{p}{(}\PYG{n+nv}{interactive}\PYG{p}{)}
  \PYG{p}{(}\PYG{k}{let*} \PYG{p}{((}\PYG{n+nv}{mongo\PYGZhy{}program} \PYG{n+nv}{mongo\PYGZhy{}cli\PYGZhy{}file\PYGZhy{}path}\PYG{p}{)}
         \PYG{p}{(}\PYG{n+nv}{buffer} \PYG{p}{(}\PYG{n+nv}{comint\PYGZhy{}check\PYGZhy{}proc} \PYG{l+s}{\PYGZdq{}Mongo\PYGZdq{}}\PYG{p}{)))}
    \PYG{c+c1}{;; pop to the \PYGZdq{}*Mongo*\PYGZdq{} buffer if the process is dead, the}
    \PYG{c+c1}{;; buffer is missing or it\PYGZsq{}s got the wrong mode.}
    \PYG{p}{(}\PYG{n+nv}{pop\PYGZhy{}to\PYGZhy{}buffer\PYGZhy{}same\PYGZhy{}window}
     \PYG{p}{(}\PYG{k}{if} \PYG{p}{(}\PYG{n+nb}{or} \PYG{n+nv}{buffer} \PYG{p}{(}\PYG{n+nb}{not} \PYG{p}{(}\PYG{n+nv}{derived\PYGZhy{}mode\PYGZhy{}p} \PYG{l+s+ss}{\PYGZsq{}mongo\PYGZhy{}mode}\PYG{p}{))}
             \PYG{p}{(}\PYG{n+nv}{comint\PYGZhy{}check\PYGZhy{}proc} \PYG{p}{(}\PYG{n+nv}{current\PYGZhy{}buffer}\PYG{p}{)))}
         \PYG{p}{(}\PYG{n+nv}{get\PYGZhy{}buffer\PYGZhy{}create} \PYG{p}{(}\PYG{n+nb}{or} \PYG{n+nv}{buffer} \PYG{l+s}{\PYGZdq{}*Mongo*\PYGZdq{}}\PYG{p}{))}
       \PYG{p}{(}\PYG{n+nv}{current\PYGZhy{}buffer}\PYG{p}{)))}
    \PYG{c+c1}{;; create the comint process if there is no buffer.}
    \PYG{p}{(}\PYG{n+nb}{unless} \PYG{n+nv}{buffer}
      \PYG{p}{(}\PYG{n+nb}{apply} \PYG{l+s+ss}{\PYGZsq{}make\PYGZhy{}comint\PYGZhy{}in\PYGZhy{}buffer} \PYG{l+s}{\PYGZdq{}Mongo\PYGZdq{}} \PYG{n+nv}{buffer}
             \PYG{n+nv}{mongo\PYGZhy{}program} \PYG{n+nv}{mongo\PYGZhy{}cli\PYGZhy{}arguments}\PYG{p}{)}
      \PYG{p}{(}\PYG{n+nv}{mongo\PYGZhy{}mode}\PYG{p}{))))}
\end{Verbatim}
