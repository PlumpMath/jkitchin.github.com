\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{(}\PYG{n+nb}{defun} \PYG{n+nv}{mongo\PYGZhy{}unquote\PYGZhy{}query} \PYG{p}{(}\PYG{n+nv}{query}\PYG{p}{)}
  \PYG{l+s}{\PYGZdq{}Json encodes QUERY, and unquotes any ObjectId calls.}

\PYG{l+s}{We don\PYGZsq{}t have syntax for the ObjectId call that mongo wants in}
\PYG{l+s}{ lisp, so a query has to look like this:}
\PYG{l+s}{\PYGZsq{}((\PYGZus{}id .  \PYGZbs{}\PYGZdq{}ObjectId(\PYGZbs{}\PYGZdq{}587babfaef131d0d4603b3ad\PYGZbs{}\PYGZdq{})\PYGZbs{}\PYGZdq{}))}

\PYG{l+s}{Mongo can\PYGZsq{}t have the quotes around the call, so this function}
\PYG{l+s}{removes them.}
\PYG{l+s}{\PYGZdq{}}
  \PYG{p}{(}\PYG{n+nv}{replace\PYGZhy{}regexp\PYGZhy{}in\PYGZhy{}string} \PYG{l+s}{\PYGZdq{}\PYGZbs{}\PYGZdq{}\PYGZbs{}\PYGZbs{}(ObjectID(\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZdq{}\PYGZbs{}\PYGZbs{}(.*?\PYGZbs{}\PYGZbs{})\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZdq{})\PYGZbs{}\PYGZbs{})\PYGZbs{}\PYGZdq{}\PYGZdq{}}
			    \PYG{l+s}{\PYGZdq{}ObjectId(\PYGZbs{}\PYGZdq{}\PYGZbs{}\PYGZbs{}2\PYGZbs{}\PYGZdq{})\PYGZdq{}}
			    \PYG{p}{(}\PYG{n+nv}{json\PYGZhy{}encode} \PYG{n+nv}{query}\PYG{p}{)))}

\PYG{p}{(}\PYG{n+nb}{defun} \PYG{n+nv}{mongo\PYGZhy{}requote\PYGZhy{}output} \PYG{p}{(}\PYG{n+nv}{output}\PYG{p}{)}
  \PYG{l+s}{\PYGZdq{}Adds quotes around ObjectId in OUTPUT.}
\PYG{l+s}{When mongo outputs json, it has unquoted ObjectIds in it that}
\PYG{l+s}{emacs cannot interpret as json. \PYGZdq{}}
  \PYG{p}{(}\PYG{n+nv}{replace\PYGZhy{}regexp\PYGZhy{}in\PYGZhy{}string}
   \PYG{l+s}{\PYGZdq{}ObjectId(\PYGZbs{}\PYGZdq{}\PYGZbs{}\PYGZbs{}(.*?\PYGZbs{}\PYGZbs{})\PYGZbs{}\PYGZdq{})\PYGZdq{}}
   \PYG{l+s}{\PYGZdq{}\PYGZbs{}\PYGZdq{}ObjectId(\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZdq{}\PYGZbs{}\PYGZbs{}1\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZbs{}\PYGZdq{})\PYGZbs{}\PYGZdq{}\PYGZdq{}}
   \PYG{n+nv}{output}\PYG{p}{))}

\PYG{p}{(}\PYG{n+nb}{defun} \PYG{n+nv}{mongo\PYGZhy{}find} \PYG{p}{(}\PYG{n+nv}{db} \PYG{n+nv}{collection} \PYG{n+nv}{query} \PYG{k}{\PYGZam{}optional} \PYG{n+nv}{projection}\PYG{p}{)}
  \PYG{p}{(}\PYG{k}{let*} \PYG{p}{((}\PYG{n+nv}{query\PYGZhy{}json} \PYG{p}{(}\PYG{n+nv}{mongo\PYGZhy{}unquote\PYGZhy{}query} \PYG{n+nv}{query}\PYG{p}{))}
	 \PYG{p}{(}\PYG{n+nv}{projection\PYGZhy{}json}
	  \PYG{p}{(}\PYG{n+nb}{and} \PYG{n+nv}{projection} \PYG{p}{(}\PYG{n+nv}{json\PYGZhy{}encode} \PYG{n+nv}{projection}\PYG{p}{)))}
	 \PYG{p}{(}\PYG{n+nv}{output} \PYG{p}{(}\PYG{n+nv}{mongo\PYGZhy{}requote\PYGZhy{}output}
		  \PYG{c+c1}{;; add [] to make an array of output in json,}
		  \PYG{c+c1}{;; and separate results by a comma}
		  \PYG{p}{(}\PYG{n+nv}{concat} \PYG{l+s}{\PYGZdq{}[\PYGZdq{}}
			  \PYG{p}{(}\PYG{n+nv}{replace\PYGZhy{}regexp\PYGZhy{}in\PYGZhy{}string}
			   \PYG{l+s}{\PYGZdq{}\PYGZbs{}n\PYGZdq{}} \PYG{l+s}{\PYGZdq{}\PYGZdq{}}
			   \PYG{p}{(}\PYG{n+nv}{shell\PYGZhy{}command\PYGZhy{}to\PYGZhy{}string}
			    \PYG{p}{(}\PYG{n+nb}{format} \PYG{l+s}{\PYGZdq{}mongo \PYGZpc{}s \PYGZhy{}\PYGZhy{}quiet \PYGZhy{}\PYGZhy{}eval \PYGZsq{}db.\PYGZpc{}s.find(\PYGZpc{}s).forEach(function(myDoc) \PYGZob{} printjsononeline(myDoc); print( \PYGZbs{}\PYGZdq{},\PYGZbs{}\PYGZdq{}); \PYGZcb{})\PYGZsq{}\PYGZdq{}}
				    \PYG{n+nv}{db} \PYG{n+nv}{collection}
				    \PYG{p}{(}\PYG{k}{if} \PYG{n+nv}{projection}
					\PYG{p}{(}\PYG{n+nb}{format} \PYG{l+s}{\PYGZdq{}\PYGZpc{}s, \PYGZpc{}s\PYGZdq{}} \PYG{n+nv}{query\PYGZhy{}json} \PYG{n+nv}{projection\PYGZhy{}json}\PYG{p}{)}
				      \PYG{n+nv}{query\PYGZhy{}json}\PYG{p}{))))}
			  \PYG{l+s}{\PYGZdq{}]\PYGZdq{}}\PYG{p}{))))}
    \PYG{p}{(}\PYG{n+nv}{json\PYGZhy{}read\PYGZhy{}from\PYGZhy{}string} \PYG{n+nv}{output}\PYG{p}{)))}
\end{Verbatim}
