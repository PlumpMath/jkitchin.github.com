* DONE Scoring elfeed articles
  CLOSED: [2017-01-05 Thu 11:18]
  :PROPERTIES:
  :categories: emacs,elfeed
  :date:     2017/01/05 11:18:29
  :updated:  2017/01/05 21:12:13
  :END:

I use [[https://github.com/skeeto/elfeed][elfeed]] to read RSS feeds of scientific journals, python, emacs, and lisp blogs, and the emacs stackexchange feed. Here are the current feeds I follow.

#+BEGIN_SRC emacs-lisp
(mapcar 'list elfeed-feeds)
#+END_SRC

#+RESULTS:
| (http://syndic8.scopus.com/getMessage?registrationId=ADEJAEEKHFESCDEOCDFOAHGSCDHSAKHREFMSADHNJA cmu)              |
| http://feeds.feedburner.com/acs/accacs                                                                            |
| http://feeds.feedburner.com/acs/enfuem                                                                            |
| http://feeds.feedburner.com/acs/esthag                                                                            |
| http://feeds.feedburner.com/acs/jacsat                                                                            |
| http://feeds.feedburner.com/acs/jpcbfk                                                                            |
| http://feeds.feedburner.com/acs/jpccck                                                                            |
| http://feeds.feedburner.com/acs/jpclcd                                                                            |
| http://feeds.feedburner.com/acs/cmatex                                                                            |
| http://feeds.feedburner.com/acs/jctcce                                                                            |
| http://feeds.feedburner.com/acs/jcisd8                                                                            |
| http://feeds.feedburner.com/acs/iecred                                                                            |
| http://feeds.aps.org/rss/recent/prl.xml                                                                           |
| http://feeds.aps.org/rss/recent/prb.xml                                                                           |
| http://www.sciencemag.org/rss/current.xml                                                                         |
| http://feeds.nature.com/nature/rss/current                                                                        |
| http://feeds.nature.com/nmat/rss/current                                                                          |
| http://feeds.nature.com/nchem/rss/current                                                                         |
| http://rss.sciencedirect.com/publication/science/09270256                                                         |
| http://onlinelibrary.wiley.com/rss/journal/10.1002/(ISSN)1521-3773                                                |
| http://scitation.aip.org/rss/content/aip/journal/jcp/latestarticles;jsessionid=6k76xb11z253.x-aip-live-06?fmt=rss |
| (http://planetpython.org/rss20.xml python)                                                                        |
| (http://planet.scipy.org/rss20.xml python)                                                                        |
| (http://planet.emacsen.org/atom.xml emacs)                                                                        |
| http://planet.lisp.org/rss20.xml                                                                                  |
| http://catalysis-preprint-archive.github.io/updates.rss                                                           |
| https://www.cmu.edu/policies/news/rss-feed.rss                                                                    |
| (http://emacs.stackexchange.com/feeds emacs)                                                                      |

I get a lot of articles this way. The current size of the database is:

#+BEGIN_SRC emacs-lisp
(elfeed-db-size)
#+END_SRC

#+RESULTS:
: 79721

Elfeed tells me I have over 300 unread entries to review at the moment.

#+BEGIN_SRC emacs-lisp
(elfeed-search--count-unread)
#+END_SRC

#+RESULTS:
: 341/363:24

To deal with this deluge, I have done a couple of things. I set up some new key-bindings so I can alternate marking entries as read if the titles do not look interesting. These keybindings let me alternate fingers, so they do not get too tired (that really happens some days!).

#+BEGIN_SRC emacs-lisp
;; help me alternate fingers in marking entries as read
(define-key elfeed-search-mode-map (kbd "f") 'elfeed-search-untag-all-unread)
(define-key elfeed-search-mode-map (kbd "j") 'elfeed-search-untag-all-unread)
#+END_SRC

I also set up some auto-tagging of the emacs and python feeds, and setup some custom faces so these tags are highlighted so they are easy to see. Anything highlighted in blue is related to emacs, green is related to python, and pink is related to my department, and I can type s, then the tag to see only those entries.  Here is what my feed looks like:

#+attr_org: :width 600
[[./screenshots/date-05-01-2017-time-08-42-33.png]]



Today I want to explore adding tags to entries to further prioritize them. There is a way to tag entries that is described here: https://github.com/skeeto/elfeed#tag-hooks where you can create patterns to match an entry feed title, url, title or link. Basically, you create a function that takes an entry, amd have it add or remove a tag conditionally.

I want to tag entries that meet certain criteria, for example keywords, and set a tag based on the number of matches. Ideally, one day this would be integrated with machine learning so it could rank entries by other entries I have liked, but today we setup code that will create a score for an entry based on the number of matches, and then tag it so that it will get highlighted for me.  First, we define two custom faces and setup elfeed to use them. I will use two tags: important and relevant. relevant will be for entries that get a score of at least 1, and important for entries that get a score greater than 1.

#+BEGIN_SRC emacs-lisp :results silent
(defface relevant-elfeed-entry
  `((t :background ,(color-lighten-name "orange1" 40)))
  "Marks a relevant Elfeed entry.")

(defface important-elfeed-entry
  `((t :background ,(color-lighten-name "OrangeRed2" 40)))
  "Marks an important Elfeed entry.")

(push '(relevant relevant-elfeed-entry)
      elfeed-search-face-alist)

(push '(important important-elfeed-entry)
      elfeed-search-face-alist)
#+END_SRC

In elfeed, each entry is a structure, and we can access the title and content for matching. Here is an example of a simple scoring function. The idea is just to match patterns, and then add to the score if it matches. This is not as advanced as [[https://www.gnu.org/software/emacs/manual/html_node/gnus/Scoring.html#Scoring][gnus scoring]], but it is a good starting point.

#+BEGIN_SRC emacs-lisp
(defun score-elfeed-entry (entry)
  (let ((title (elfeed-entry-title entry))
	(content (elfeed-deref (elfeed-entry-content entry)))
	(score 0))
    (loop for (pattern n) in '(("alloy" 1)
			       ("machine learning\\|neural" 1)
			       ("database" 1)
			       ("reproducible" 1)
			       ("carbon dioxide\\|CO2" 1)
			       ("oxygen evolution\\|OER\\|electrolysis" 1)
			       ("perovskite\\|polymorph\\|epitax" 1)
			       ("kitchin" 2))
	  if (string-match pattern title)
	  do (incf score n)
	  if (string-match pattern content)
	  do (incf score n))
    (message "%s - %s" title score)

    ;; store score for later in case I ever integrate machine learning
    (setf (elfeed-meta entry :my/score) score)

    (cond
     ((= score 1)
      (elfeed-tag entry 'relevant))
     ((> score 1)
      (elfeed-tag entry 'important)))
    entry))

(add-hook 'elfeed-new-entry-hook 'score-elfeed-entry)
#+END_SRC

#+RESULTS:
| score-elfeed-entry |

Now, new entries automatically get tagged with relevant or important, depending on the score that function gives them, and they get color-coded. Now, the feed looks like this:

#+attr_org: :width 600
[[./screenshots/date-05-01-2017-time-11-10-42.png]]


I saved some bookmarks to see just the important or relevant ones (http://nullprogram.com/blog/2015/12/03/) so I can see new relevant entries with C-x r b and selecting the relevant bookmark. These work from anywhere in Emacs.

#+BEGIN_EXAMPLE
  @6-months-ago +unread +relev  @6-months-ago +unread +relevant
  elfeed @6-months-ago +unread  @6-months-ago +unread +important
#+END_EXAMPLE

I usually access elfeed from a command that shows me everything. Here, I define key-bindings to show me just the important or relevant ones. I could not see a way to get an or in there to show me both of them. These keys make it a one key press to show only these entries, and then get back to the full list.

#+BEGIN_SRC emacs-lisp
(define-key elfeed-search-mode-map (kbd "i")
  (lambda () (interactive)
    (elfeed-search-set-filter "@6-months-ago +unread +important")))

(define-key elfeed-search-mode-map (kbd "v")
  (lambda () (interactive)
    (elfeed-search-set-filter "@6-months-ago +unread +relevant")))

(define-key elfeed-search-mode-map (kbd "c")
  (lambda () (interactive)
    (elfeed-search-set-filter "@6-months-ago +unread")))
#+END_SRC


That summarizes the experiment of the day. There is clearly some room for improvement on the scoring function, e.g. moving the patterns out of the function and into a customizable variable, making the patterns be specific to either the title or content, etc. I am going to try this for a few days and see if it is actually helpful first though.
* Track changes with overlays
  :PROPERTIES:
  :ID:       E2A816F1-8293-457C-8945-18ABF636839D
  :END:

the idea here is to use overlays to mark text that is deleted or inserted.

[[file:~/vc/jkitchin-github/scimax/elpa/cm-mode-20160310.829/cm-mode.el::;;%20Keywords:%20text,%20markdown]]

These are snippets{-- that--} make track changes work in cm-mode with some document markup

test{++ ok++}
#+BEGIN_SRC emacs-lisp
;; activate
(progn
  (add-to-list 'before-change-functions 'cm-before-change t)
  (add-to-list 'after-change-functions 'cm-after-change)
  (setq cm-follow-changes t)
  (message "Follow changes mode activated."))

;; deactivate
(progn
  (setq before-change-functions (delq 'cm-before-change before-change-functions))
  (setq after-change-functions (delq 'cm-after-change after-change-functions))
  (setq cm-follow-changes nil)
  (message "Follow changes mode deactivated."))

(defun cm-before-change (beg end)
  "Function to execute before a buffer change."
  (unless (or undo-in-progress
              (and (= beg (point-min)) (= end (point-max)))) ; this happens on buffer switches
    (if (= beg end)                   ; addition
        (cm-make-addition (cm-markup-at-point))
      ;; when the deletion was done with backspace, point is at end.
      (setq cm-current-deletion (list (buffer-substring beg end) (= (point) end))))))

(defun cm-after-change (beg end length)
  "Function to execute after a buffer change.
This function marks deletions. See cm-before-change for
details."
  (unless (or undo-in-progress
              (not cm-current-deletion))
    (apply 'cm-make-deletion cm-current-deletion)
    (setq cm-current-deletion nil)))
#+END_SRC


help:before-change-functions 
Documentation:
List of functions to call before each text change.
Two arguments are passed to each function: the positions of
the beginning and end of the range of old text to be changed.
(For an insertion, the beginning and end are at the same place.)
No information is given about the length of the text after the change.

help:after-change-functions
Documentation:
List of functions to call after each text change.
Three arguments are passed to each function: the positions of
the beginning and end of the range of changed text,
and the length in chars of the pre-change text replaced by that range.
(For an insertion, the pre-change length is zero;
for a deletion, that length is the number of chars deleted,
and the post-change beginning and end are a#  ov-highlight-data: KCgxMjAwMCAxMjAwMCAob3YtdHlwZSAiZGVsZXRlIiBvdi1oaWdobGlnaHQgdCBmYWNlICg6Zm9yZWdyb3VuZCAicmVkIiA6c3RyaWtlLXRocm91Z2ggdCkpKSAoMTIwMDAgMTIwMDAgKGZhY2UgKDpmb3JlZ3JvdW5kICJyZWQiIDpzdHJpa2UtdGhyb3VnaCB0KSBvdi1oaWdobGlnaHQgdCkpKQ==

(setq inhibit-modification-hooks nil
(ovh-track-changes)
#+BEGIN_SRC emacs-lisp
(add-to-list 'before-change-functions 'ovh-before-change t)
(add-to-list 'after-change-functions 'ovh-after-change)
#+END_SRC

#+RESULTS
| ovh-after-change |




# Local Variables:
# eval: (ov-highlight-load)
# End:

#+RESULTS:
| ovh-after-change |
* Superpowered email in Emacs

Gmail does a few things right: awesome search, email completion. I am not a big fan of writing email in a browser though. You know, because I like editing text in Emacs.

I treat email primarily as an inbox of messages I need to do something with. My preference is to read an email, and either respond and archive, archive or delete it. If I can not do one of those things, the email should go on a todo list for me to handle later. If a message is in the inbox, it means it is waiting for me to do something. I try to keep under 50 emails in my inbox at any given time, and those are emails I usually plan to handle within a few days (or it goes on a todo list).

** TODO Attachment reminder
** Highlight some words from specific users

I get some automated reports from a computer cluster. These reports tell me if the RAID array is in Optimal, Degraded or Missing status. To make it easier to read these, I want those words to be highlighted in color. I especially want words like Degraded and Missing to be red so they stand out! This snippet highlights those words, but only in emails from the cluster. This is an example of conditionally changing the appearance of an email.

#+BEGIN_SRC emacs-lisp :results silent
(defun gilgamesh-fontify ()
  (loop for (name . email) in (mu4e-message-field-at-point :from) 
	do
	(when (string= email "root@gilgamesh.cheme.cmu.edu")
	  (hi-lock-mode 1)
	  (highlight-regexp "Optimal" 'mu4e-modeline-face) ; a greenish color
	  (highlight-regexp "Degraded" 'mu4e-warning-face) ; a reddish color
	  (highlight-regexp "Missing" 'mu4e-warning-face))))

(add-hook 'mu4e-view-mode-hook 'gilgamesh-fontify)
#+END_SRC

** Mail merge

Many times I collect information from people by email. I like to send individual emails, rather than one email to the whole group. It makes it simpler for me to aggregate the data they send me, and I get individual email threads. If the information is sufficiently structured, it is easy to use the mail-merge feature of scimax to generate and send the emails. 

Mail merge is a multi-step process

1. Create a data source (usually a table) that has all the information you need. Each row in the table will end up being one email. Give the table a name, so it can be the input for a source block later.

#+name: mail-merge-data
| email              | first name | last name | file       |
|--------------------+------------+-----------+------------|
| some@person.com    | Some       | One       | tees.org   |
| another@person.com | Another    | Person    | shorts.org |

2. Create a template using ${identifier} tags that will be replaced by things in the template by data from the data-source using s-format. I like to put these in a named example block like this so it is easy to include in a source block later. This block uses a personal name to address the person, tells them to check on a file, and attaches the file to the email. Note this also puts an id link in the message. If they reply, and that link is there, I can type C-c o on it and jump back to the heading where I sent the message from. I might copy some data from the message there.

#+name: email-template
#+BEGIN_EXAMPLE
Dear ${NAME},

Please check this file: ${FILE}. It is attached.

-----------------------
Please do not delete this.
[[id:${ID}]]

<#part type="application/octet-stream" filename="${PATH}" disposition=attachment>
<#/part>
#+END_EXAMPLE

3. Generate the messages using `mail-merge-make-headings'. You need to create a new data-source that defines the fields in the template, and the heading properties TO and SUBJECT. This will generate a subheading called Messages in the current heading. Each message will be a subsubheading, and initially tagged :unsent:.

#+BEGIN_SRC emacs-lisp :var data=mail-merge-data template=email-template
(let ((data-source (loop for (email fname lname file) in data
			 collect
			 `(("TO" . ,email)
			   ("SUBJECT" . ,(format "Meeting notes about %s" file))
			   ("HEADLINE" . ,(format "Message to %s %s" fname lname))
			   ("NAME" . ,fname)
			   ("FILE" . ,file)
			   ("PATH" . ,(expand-file-name file))))))
  (mail-merge-make-headings template data-source)))
#+END_SRC

#+RESULTS:

4. Inspect each message. You can edit these messages by hand, or modify the template/code above and re-run them. If a message is good, send it with M-x mail-merge-send-heading (which opens a message buffer and you have to C-c C-c to send it). I always do this for the first few to make sure the messages are formatted correctly. Once I am sure of that, C-u M-x mail-merge-send-heading will send the message directly. Both tag the message as sent, and add some properties about when the message was sent, stores a link to the sent message, and  move the point to the next unsent message. I actually use speed keys for this. When you are on the first star of the message headline, pressing m will open the message buffer for you to send, and pressing s will just send it. If you are super confident, you can use M-x mail-merge and it will send all headlines that are tagged unsent with a TO property with a 0.2 second delay.




*** Messages
**** DONE Message to Some One                                          :sent:
     CLOSED: [2017-01-07 Sat 15:17]
     :PROPERTIES:
     :ID: 35BD9490-4380-4062-A445-AF14718584FD
     :TO:       some@person.com
     :SUBJECT:  Meeting notes
     :SENT-ON:  Sat Jan  7 15:18:07 2017
     :Message-ID: [[mu4e:msgid:m2pojyfwua.fsf@Johns-MacBook-Air.local][Meeting notes (Sat Jan  7 15:18:07 2017)]
     :END:
Dear Some,

Please check this file: tees.org. It is attached.

-----------------------
Please do not delete this.
[[id:35BD9490-4380-4062-A445-AF14718584FD]]


**** Message to Another Person :sent:
     :PROPERTIES:
     :ID: A32AF98B-DC16-48BE-88FA-A3B7C879D931
     :TO:       another@person.com
     :SUBJECT:  Meeting notes
     :SENT-ON:  Sat Jan  7 15:17:48 2017
     :Message-ID: [[mu4e:msgid:m2shoufwut.fsf@Johns-MacBook-Air.local][Meeting notes (Sat Jan  7 15:17:48 2017)]]
     :END:
Dear Another,

Please check this file: shorts.org. It is attached.

-----------------------
Please do not delete this.
[[id:A32AF98B-DC16-48BE-88FA-A3B7C879D931]]

<#part type=\"application/octet-stream\" filename=\"/Users/jkitchin/vc/blogofile-jkitchin.github.com/_blog/shorts.org\" disposition=attachment>
<#/part>

** Triggering followup actions on replies

A sent message has a message-id and when people reply to it, that id should be in a references header field. We can set up a hook that alerts us when someone replies to a specific email. This will be triggered on every view, so you might be careful about what the action does.

#+BEGIN_SRC emacs-lisp
(setq email-notifications '(("m28tqmhobn.fsf@Johns-MacBook-Air.local" . (message-box "Followup!"))))

(defun check-for-followup ()
  (loop for (ref . action) in email-notifications
	do
	(message "%s: %S against %S"
		 (-contains? (mu4e-message-field-at-point :references) ref)
		 ref (mu4e-message-field-at-point :references))
	(when (-contains? (mu4e-message-field-at-point :references) ref)
	  (message "confirmed")
	  (eval action))))

(add-hook 'mu4e-view-mode-hook 'check-for-followup)
#+END_SRC

#+RESULTS:
| check-for-followup | gilgamesh-fontify | mu4e-auto-tag | email-fontify | #[nil \301\300!\210\302\211\207 [bookmark-make-record-function make-local-variable mu4e-view-bookmark-make-record] 2] |

** Tagging emails

** Automatic tagging
