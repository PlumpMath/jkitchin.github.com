* Tab in org-mode
  :PROPERTIES:
  :ID:       47FE9730-983C-4732-953B-E7D5D2E36FED
  :END:


#+BEGIN_SRC emacs-lisp
(defun org-mode-tab (&optional arg)
  "In org-mode make tab cycle on headlines, or insert 4 spaces."
  (interactive "P")
  (cond
   ;; Cycle headlines
   ((org-on-heading-p)
    (org-cycle arg))
   ;; expand source blocks
   ((looking-back (format
		   "^<%s"
		   (regexp-opt (mapcar 'car org-structure-template-alist)))
		  (line-beginning-position))
    (org-try-structure-completion))
   ;; or insert 4 spaces
   (t
    (insert "    "))))

(define-key org-mode-map (kbd "<tab>") 'org-mode-tab)
#+END_SRC

#+RESULTS:
: org-mode-tab


* DONE Asynchronously running python blocks in org-mode
  CLOSED: [2015-11-20 Fri 11:46]
  :PROPERTIES:
  :categories: emacs,python,orgmode
  :date:     2015/11/20 11:46:45
  :updated:  2015/11/20 14:33:31
  :END:
If you run long Python blocks from org-mode, you might want to keep working while it runs. Currently Emacs gets blocked and you have to wait patiently.  In this post we consider some ways to avoid this that run our code asynchronously, but still put results where they belong in the org-buffer.

This is a long post. You may want to see the video: https://www.youtube.com/watch?v=VDyoN8yipSE, or skip to the [[id:D8F2CBB5-31B2-4477-A363-E3C0063214DE][end]] where the best and final version is shown.

** The async module

Here we consider an approach that uses https://github.com/jwiegley/emacs-async module. The idea is to tangle the Python block at point to a temp file, then asynchronously run it. We capture the output and put it back in the buffer. We use a uuid to find the place to put the results in org-mode format. Here is the code that implements this idea.

#+BEGIN_SRC emacs-lisp
(require 'async)

(defun org-babel-async-execute ()
  "Run a python block at point asynchrously."
  (interactive)

  (let ((current-file (buffer-file-name))
	(uuid (org-id-uuid))
	(temporary-file-directory "./")
	(tempfile (make-temp-file "py-")))

    (org-babel-tangle '(4) tempfile)
    (org-babel-remove-result)
    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    (async-start
     ;; what to start
     `(lambda ()
	;; now we run the command then cleanup
	(prog1
	    (shell-command-to-string (format "python %s" ,tempfile))
	  (delete-file ,tempfile)))

     `(lambda (result)
	"Code that runs when the async function finishes."
	(save-window-excursion
	  (save-excursion
	    (save-restriction
	      (with-current-buffer (find-file-noselect ,current-file)
		(goto-char (point-min))
		(re-search-forward ,uuid)
		(beginning-of-line)
		(kill-line)
		(insert (mapconcat
			 (lambda (x)
			   (format ": %s" x))
			 (butlast (s-split "\n" result))
			 "\n"))))))))))
#+END_SRC

#+RESULTS:
: org-babel-async-execute

Here is a block to test it on. We can run the block, and keep on working while the code runs. The results seem to get inserted correctly at the right point even if I am in another window or frame! We don't get easy access to continuous output of the command. This wouldn't work if we close Emacs, but who does that?


#+BEGIN_SRC python
print 'hello world'
import time
time.sleep(5)

import os
print os.getcwd()
print time.asctime()
#+END_SRC

#+RESULTS:
: hello world
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 10:17:53 2015

There are some limitations to this approach. One of them is it assumes the src block is a stand-alone block that will run on its own. That is usually how I run mine, but I could see having other modules that should be tangled out of a file too. I think the script is being run in the current working directory, so it probably will find any local imports it needs.

You don't get any intermediate feedback on this process. It seems to be possible to do that with a different approach that puts some output in a new buffer, e.g. with start-process. But, you still need some clever code like the async model to know when to insert the results back into this buffer. We consider Emacs processes and sentinels next.

** Emacs process approach with tangling
We can start a process in Emacs, and attach a sentinel function to it that runs after the process completes. Here is an example of that. We still tangle the src-block here.

#+BEGIN_SRC emacs-lisp
(defun org-babel-async-execute ()
  (interactive)
  (let* ((current-file (buffer-file-name))
	(uuid (org-id-uuid))
	(temporary-file-directory "./")
	(tempfile (make-temp-file "py-"))
	(pbuffer (format "*%s*" uuid))
	process)

    (org-babel-tangle '(4) tempfile)
    (org-babel-remove-result)

    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))

    (setq process (start-process
		   uuid
		   pbuffer
		   "python"
		   tempfile))

    (set-process-sentinel
     process
     `(lambda (process event)
	(when (string= "finished\n" event)
	  (delete-file ,tempfile)
	  (save-window-excursion
	    (save-excursion
	      (save-restriction
		(with-current-buffer (find-file-noselect ,current-file)
		  (goto-char (point-min))
		  (re-search-forward ,uuid)
		  (beginning-of-line)
		  (kill-line)
		  (insert (mapconcat
			   (lambda (x)
			     (format ": %s" x))
			   (split-string
			    (with-current-buffer ,pbuffer (buffer-string))
			    "\n")
			   "\n")))))))
	(kill-buffer ,pbuffer)))))
#+END_SRC

#+RESULTS:
: org-babel-async-execute

#+BEGIN_SRC python
print 'hello world'
import time
time.sleep(10)

import os
print os.getcwd()
print time.asctime()
#+END_SRC

#+RESULTS:
: hello world
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 10:20:01 2015
:

That works well from what I can see. There are some limitations. I doubt this will work if you use variables in the src block header. Next we consider an approach that does not do the tangling, and that will show us code output as it goes.

** Emacs process approach with no tangling
   :PROPERTIES:
   :ID:       D8F2CBB5-31B2-4477-A363-E3C0063214DE
   :END:
As an alternative to tangling to a file, here we just copy the code to a file and then run it.

UPDATE: I eliminated the send string approach because it caused some problems with blank lines in loops and such. This new approach eliminates that issue.

#+BEGIN_SRC emacs-lisp
(defun org-babel-async-execute ()
  (interactive)
  (let* ((current-file (buffer-file-name))
	 (uuid (org-id-uuid))
	 (code (org-element-property :value (org-element-context)))
	 (temporary-file-directory ".")
	 (tempfile (make-temp-file "py-"))
	 (pbuffer (format "*%s*" uuid))
	 process)

    (org-babel-remove-result)

    (save-excursion
      (re-search-forward "#\\+END_SRC")
      (insert (format
	       "\n\n#+RESULTS: %s\n: %s"
	       (or (org-element-property :name (org-element-context))
		   "")
	       uuid)))
    (switch-to-buffer-other-window pbuffer)

    ;; Create temp file
    (with-temp-file tempfile
      (insert code))

    (setq process (start-process
		   uuid
		   pbuffer
		   "python"
		   tempfile))

    (set-process-sentinel
     process
     `(lambda (process event)
	(save-window-excursion
	    (save-excursion
	      (save-restriction
		(with-current-buffer (find-file-noselect ,current-file)
		  (goto-char (point-min))
		  (re-search-forward ,uuid)
		  (beginning-of-line)
		  (kill-line)
		  (insert
		   ;; This clunky code mostly cleans up the output so it looks
		   ;; more like org-mode output
		   (mapconcat
		    (lambda (x)
		      (format ": %s" x))
		    (split-string
		     (replace-regexp-in-string
                      "\\(>>> \\|\\.\\.\\. \\|: $\\|: >>>$\\)"
		      ""
		      (mapconcat 'identity
				 (butlast (split-string
					   (with-current-buffer
					       ,pbuffer
					     (buffer-string))
					   "\n"))
				 "\n"))
		     "\n")
		    "\n"))))))
	(when (get-buffer ,pbuffer)
	  (kill-buffer ,pbuffer)
	  (delete-window))
	(delete-file ,tempfile)
	(delete-process process)))))

#+END_SRC

#+RESULTS:
: org-babel-async-execute



Let us try it out again.

#+BEGIN_SRC python
print 'hello world'
import time
time.sleep(1)

for i in range(5):
    print i

    time.sleep(0.5)



import os
print os.getcwd()
print time.asctime()
#+END_SRC

#+RESULTS:
: hello world
: 0
: 1
: 2
: 3
: 4
: /Users/jkitchin/blogofile-jkitchin.github.com/_blog
: Fri Nov 20 14:32:23 2015


It works fine for this simple example. Again, this example doesn't do anything particularly sophisticated with src-block headers or imports, etc... We also get to see the output as the code executes, which is a pleasant change from the usual way of running python blocks.

Maybe some org-moder's out there can try this and run it through some more rigorous paces?

* DONE Functional and display math in technical documents
  CLOSED: [2015-11-19 Thu 06:07]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/11/19 06:07:15
  :updated:  2015/11/19 14:43:12
  :END:
I have been thinking about a way to have functional and readable mathematics in technical documents. It has always bothered me that I have to write a LaTeX version of an equation, and then a separate implementation of the equation in code somewhere. At least twice in my life these separate representations have not agreed!

One solution might be if my functional code could be converted to LaTeX easily. I explore one simple approach to this here. It is somewhat inspired by this work here http://oremacs.com/2015/01/23/eltex/ on writing LaTeX in emacs-lisp, and from my work with org-mode in mixing narrative text, LaTeX and code.

The idea is to use emacs-lisp for the code, so it is functional, but provide an alternative output for the /same code/ for a document conversion. In other words, we accept there is more than one version we need: a functional version for working, and a consumption version for presentation. We will generate the consumption version from the functional version.

I know emacs-lisp is not ideal for mathematics the way we are accustomed to seeing it, but it enables the idea I want to explore here so we will try it.

Here is the simplest example I could come up with for functional math. We can run it ourselves, and verify it is correct.

#+BEGIN_SRC emacs-lisp
(+ 1 2 3)
#+END_SRC

#+RESULTS:
: 6

Now, I can change the meaning of this code temporarily, so that it not only evaluates the form, but also represents the equation and result in LaTeX code. If this was incorporated into a preprocessor of the document, we could have a functional version representing our equations, in code form, and a presentation version generated from this version. The code that follows isn't how I would do this is in some production setting; it is only to show that you can /temporarily/ change the meaning of "+". In a production setting, there would just be (+ 1 2 3) in the text, and a preprocessor would find all the sexps in the text, and replace them with the export format using code like this. At least, that is what I am imagining. It might be feasible to do this already with inline org-babel calls and an org-mode export filter, but I didn't try it here. So, here is the proof of concept code.

#+BEGIN_SRC emacs-lisp :results raw
(cl-flet ((+ (lambda (&rest args)
	       (format
		"$%s = %s$"
		(mapconcat #'number-to-string args " + ")
		(eval `(+ ,@args))))))
  (+ 1 2 3))
#+END_SRC

#+RESULTS:
$1 + 2 + 3 = 6$



Here is an example that generates a fraction from a division.
#+BEGIN_SRC emacs-lisp :results raw
(cl-flet ((/ (lambda (&rest args)
	       (format
		"$\\frac{%s}{%s} = %s$"
		(car args)
		(mapconcat 'number-to-string (cdr args) " \\cdot ")
		(eval `(/ ,@args))))))
  (/ 1.0 2.0 3.0))
#+END_SRC

#+RESULTS:
$\frac{1.0}{2.0 \cdot 3.0} = 0.16666666666666666$

As a proof of concept, this idea looks feasible, but this implementation has some limitations. Getting this to a complete workable approach would require a lot of work, basically creating transformation functions for many, many kinds of mathematical functions, and a lot of other kinds of logic. For example, (+ 1 2 (+ 3 4)) would not render correctly with the codes above. It isn't even clear what it should render to. I think you want 1 + 2 + (3 + 4) as the rendered output.

Anyway, it is an interesting idea, one that blurs the lines between code and mathematics. We are so used to the equation representation of mathematics, rather than the code representation that being able to go back and forth seems like a good idea, especially when one is derived from the other.


* [[http://emacs-fu.blogspot.com/2009/05/getting-your-ip-address.html][emacs-fu: getting your ip-address]]

#+BEGIN_SRC emacs-lisp
(defun get-ip-address (&optional dev)
  "get the IP-address for device DEV (default: eth0)"
  (let ((dev (if dev dev "eth0")))
    (format-network-address (car (network-interface-info dev)) t)))

(get-ip-address)

(format-network-address (car (network-interface-info "en0")) t)
#+END_SRC

#+RESULTS:
: 192.168.1.154

* TODO LDAP lookups from Emacs

Now that I have email and Cisco Jabber totally integrated into Emacs it would be nice to tap into the CMU LDAP director to find emails and phone numbers. I followed the directions [[http://blog.jimjh.com/passwordless-kerberized-ssh-for-cmus-unix-machines.html][here]] to set up Kerberos authentication.

Here is how I authenticate to get a "ticket". This prompts me for my password.
#+BEGIN_SRC sh
kinit --renewable jkitchin@ANDREW.CMU.EDU
#+END_SRC

#+RESULTS:

That allows me to use the ldapsearch command-line utility to query our LDAP service like this to find an email address.

#+BEGIN_SRC emacs-lisp
(shell-command-to-string "ldapsearch -LLL -h ldap.andrew.cmu.edu -b ou=Person,dc=cmu,dc=edu cn=\"John Kitchin\" | grep mail")
#+END_SRC

#+RESULTS:
: SASL/GSSAPI authentication started
: SASL username: jkitchin@ANDREW.CMU.EDU
: SASL SSF: 112
: SASL data security layer installed.
: mail: jkitchin@cmu.edu
: cmuHRISmail: jkitchin@andrew.cmu.edu

We actually get LDIF data from ldapsearch with a lot of details. Some of the data are on the private side, like home address and phone, so I don't show them all here. Next we wrap the output in a function that converts each result from ldapsearch into a p-list that we will use later in a helm function to help us select a match.

#+BEGIN_SRC emacs-lisp
(defun ldap-query (query-string)
  "Send QUERY-STRING to our ldap server and parse results into a
list of p-lists for each entry returned."
  (interactive "sLDAP query: ")
  (let ((output (split-string
		 (shell-command-to-string
		  (format "ldapsearch -LLL -h ldap.andrew.cmu.edu -b ou=Person,dc=cmu,dc=edu %s" query-string))
		 "\n"))
	(lines '())
	(result '())
	(results '(())))
    ;; cleanup trailing lines and ignore initial lines
    (loop for line in output
	  do
	  (cond
	   ;; ignore starting lines
	   ((s-starts-with? "SASL" line)
	    nil)
	   ;; join lines that run over
	   ((s-starts-with? " " line)
	    (setf (car (last lines))
		  (concat (car (last lines)) line)))
	   ;; ignore this
	   ((string-match "Size limit exceeded" line)
	    nil)
	   (t
	    (add-to-list 'lines line t))))

    ;; now we need to parse the lines. A new entry starts with a dn: line.
    (dolist (line lines)
      (cond
       ((s-starts-with? "dn:" line)
	;; add new entry
	(add-to-list 'results `(:dn ,line)))
       ((string-match ":" line)
	(let* ((s (split-string line ":"))
	       (prop (intern (concat ":" (s-trim (car s)))))
	       (val (s-trim (cadr s))))
	  (setf (car results) (plist-put (car results) prop val))))))
    results))



(defun helm-ldap (query-string)
  (interactive "sLDAP query: ")
  (helm :sources `(((name . "HELM ldap")
		    (candidates . ,(mapcar (lambda (x)
					     (cons
					      (format "%20s|%30s|%30s|%s"
						      (s-truncate
						       20
						       (or (plist-get x :title) " "))
						      (plist-get x :cn)
						      (plist-get x :mail)
						      (or (plist-get x :telephoneNumber) " "))
					      x))
					   (ldap-query
					    (if (string-match "=" query-string)
						query-string
					      (concat "cn=*" query-string "*")))))
		    (action . (("Email" . (lambda (x)
					    (compose-mail)
					    (message-goto-to)
					    (insert (plist-get x :mail))
					    (message-goto-subject)))
			       ("Call" . (lambda (x)
					   (cisco-call (plist-get x :telephoneNumber))))))))))

#+END_SRC

#+RESULTS:
: helm-ldap

So, now our results

#+BEGIN_SRC emacs-lisp
(length (ldap-query "cn=*Anna*"))
#+END_SRC

#+RESULTS:
: 550


* unlatexifying strings in org-ref

cite:zou-2014-cobal-embed

#+BEGIN_SRC emacs-lisp
(find-file (car org-ref-default-bibliography))
(bibtex-search-entry "zhuo-2010-co2-induc")
(bibtex-set-dialect (parsebib-find-bibtex-dialect) t)
(let ((s (org-ref-bib-citation)))
(setq s (replace-regexp-in-string "  " " " s))
(loop for (pattern repl) in
      '(("{\\\\'i}" "í")
	("{\\\\ae}" "æ")
	("{\\\\'c}" "ć")
	("{\\\\'e}" "é")
	("{\\\\\"a}" "ä")
	("{\\\\`e}" "è")
	("{\\\\`a}" "à")
	("{\\\\'a}" "á")
	("{\\\\o}" "ø")
	("{\\\\\"e}" "ë")
	("{\\\\\"u}" "ü")
	("{\\\\~n}" "ñ")
	("{\\\\c{n}}" "ņ")
	("{\\\\~n}" "ñ")
	("{\\\\aa}" "å")
	("{\\\\\"o}" "ö")
	("{\\\\'A}" "Á")
	("{\\\\'i}" "í")
	("{\\\\'o}" "ó")
	("{\\\\'o}" "ó")
	("{\\\\'u}" "ú")
	("{\\\\'u}" "ú")
	("{\\\\v{s}}" "š")
	("{\\\\v s}" "š")
	("{\\\\v{r}}" "ř")
	("{\\\\.I}" "İ")
	("{\\\\u{g}}" "ğ")
	("$\\\\delta$" "δ")
	("{\\\\c{c}}" "ç")
	("{\\\\ss}" "ß")
	("$\\\\le$" "≤")
	("$\\\\ge$" "≥")
	("$<$" "<")
	("$\\\\theta$" "θ")
	("$\\\\mu$" "μ")
	("$\\\\rightarrow$" "→")
	("$\\\\leftrightharpoons$" "⇌")
	("$\\\\times$" "×")
	("$\\\\deg$" "°")
	("{\\\\c{s}}" "ş")
	("$\\\\gamma$" "γ")
	("$\\\\gamma$" "ɣ")
	("degC" "º")
	("$\\\\eta$" "η")
	("$\\\\mu$" "µ")
	("$\\\\alpha$" "α")
	("$\\\\beta$" "β")
	("$\\\\epsilon$" "ɛ")
	("\\textrm{VI}" "Ⅵ")
	("\\textrm{III}" "Ⅲ")
	("\\textrm{V}" "Ⅴ")
	("$\\\\lambda$" "λ")
	("$\\\\pi$" "π")
	("$\\\\infty$" "∞")
	("$\\\\chi$" "χ")
	("\\\\textasciitilde{}" "∼")
	("\\\\textemdash{}" "‑")
	("\\\\textbullet " "•")
	("\\\\textemdash{}" "‒"))
      do
      (setq s (replace-regexp-in-string pattern repl s)))
;(setq s (replace-regexp-in-string "{" "" s))
;(setq s (replace-regexp-in-string "}" "" s))
s)


#+END_SRC

#+RESULTS:
: Zhuo, Shengchi and Huang, Yongmin and Peng, Changjun and Liu, Honglai and Hu, Ying and Jiang, Jianwen, "\ce{CO2}-induced Microstructure Transition of Surfactant in Aqueous Solution: {I}nsight From Molecular Dynamics Simulation", The Journal of Physical Chemistry B, 114:6344-6349 (2010)


* splicing lists

#+BEGIN_SRC emacs-lisp
(let ((a '(1 2 3)))
  `(a b ,@a))
#+END_SRC

#+RESULTS:
| a | b | 1 | 2 | 3 |

whoa....
* TODO Fontifying LaTeX fragments in org-mode


#+BEGIN_SRC emacs-lisp :results silent
(setq font-lock-extra-managed-props (delq 'help-echo font-lock-extra-managed-props))
(font-lock-add-keywords nil
 `(,(mapconcat (lambda (x)
		 (nth 1 x))
	       (append org-latex-regexps '(("@@" "@@latex:[^@]*@@" 0 nil)))
	       "\\|")
   . '(face font-lock-comment-face
	   test-property t
	   help-echo "Click to toggle overlay.")))
#+END_SRC






 Here is one equation: $e^2x$ and another one \(e^{x^2}\). $tree$

\[\sin x = 0.5\]  $tree$ \(tree\)

With double dollar signs: $$x^2 = 66$$.   Next, inline notation @@latex:\ce{CH4}@@.

Next an environment.

\begin{equation}
x^3 = 9
\end{equation}



This post examines fontifying LaTeX fragments in org-mode, and making them functional. I want the highlighting so they stand out more clearly from text, and it would be nice to make them clickable to toggle the image.

The variable org-latex-regexps contains a list of lists which seem to contain regular expressions for latex fragments. The inline LaTeX  doesn't seem to be covered there, so we add them here. These don't seem to be affected by the preview code, but it is still nice to see them in the text.

#+BEGIN_SRC emacs-lisp :results code
(append org-latex-regexps '(("@@" "@@latex:[^@]*@@" 0 nil)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("begin" "^[	]*\\(\\\\begin{\\([a-zA-Z0-9\\*]+\\)[^ ]+?\\\\end{\\2}\\)" 1 t)
 ("$1" "\\([^$]\\|^\\)\\(\\$[^	\n,;.$]\\$\\)\\([-	.,?;:'\") ]\\|$\\)" 2 nil)
 ("$" "\\([^$]\\|^\\)\\(\\(\\$\\([^	\n,;.$][^$\n]*?\\(\n[^$\n]*?\\)\\{0,2\\}[^	\n,.$]\\)\\$\\)\\)\\([-	.,?;:'\") ]\\|$\\)" 2 nil)
 ("\\(" "\\\\([^ ]*?\\\\)" 0 nil)
 ("\\[" "\\\\\\[[^ ]*?\\\\\\]" 0 nil)
 ("$$" "\\$\\$[^ ]*?\\$\\$" 0 nil)
 ("@@" "@@latex:[^@]*@@" 0 nil))
#+END_SRC


#+BEGIN_SRC emacs-lisp
(defun match-next-org-latex (&optional limit)
  (when (re-search-forward
	 (mapconcat (lambda (x)
		      (nth 1 x))
		    (append org-latex-regexps '(("@@" "@@latex:[^@]*@@" 0 nil)))
		    "\\|")
	 limit t))
(message "found one"))

(setq org-mode-latex-overlay-face
      '((match-next-org-latex . (face 'font-lock-keyword-face
				      'local-map (prog1
						    (copy-keymap org-mode-map)
						  (define-key map [mouse-1] (lambda ()
									      (interactive)
									      (let ((pos (mouse-position)))
										(save-excursion
										  (goto-char (window-start))
										  (forward-line (cddr pos))
										  (forward-char (cadr pos))
										  (if (get-text-property (point) 'org-overlay-type)
										      ;; we are on a overlay, remove it.
(let ((ov (loop for ov in org-latex-fragment-image-overlays
			   if
			   (and
			    (<= (overlay-start ov) (point))
			    (>= (overlay-end ov) (point)))
			   return ov)))
	     (when ov
	       (delete-overlay ov)))

										    ;; else, add image
										    (org-preview-latex-fragment)))))))
				      'mouse-face highlight
				      'help-echo "Click to toggle overlay"))))

(define-minor-mode org-mode-latex-overlay-mode
  "Fontify on emacs keybinding syntax. Adds a tooltip for
keybinding, and make the command clickable to get to the
documentation. Turning this off does not undo the properties though."
  :lighter " OL"
  (if org-mode-latex-overlay-mode
      ;; turn them on
      (font-lock-add-keywords
       nil
       org-mode-latex-overlay-face)
    ;; turn them off
    (font-lock-remove-keywords
     nil
     org-mode-latex-overlay-face)))
#+END_SRC

#+RESULTS:
 jkitchin@cmu.edu


#+BEGIN_SRC emacs-lisp
org-latex-fragment-image-overlays
#+END_SRC

#+RESULTS:

org-latex-overlay

#+BEGIN_SRC emacs-lisp
(defun ttt ()
  (interactive)
  (message "%s" (-filter (lambda (ov)
			   (eq
			    'org-latex-overlay
			    (overlay-get ov 'org-overlay-type)))
			 (overlays-at (point)))))

(defun ttd ()
  (interactive)
  (mapc
   'delete-overlay
   (-filter (lambda (ov)
	      (eq
	       'org-latex-overlay
	       (overlay-get ov 'org-overlay-type)))
	    (overlays-at (point)))))
#+END_SRC

#+RESULTS:
: ttd

(delete-overlay

* TODO Adding emacs command key-bindings and help functionality to org-mode
  :PROPERTIES:
  :categories: emacs,orgmode
  :ID:       1B122428-E8FF-476B-B07B-79A7541003DC
  :END:
The documentation of functions in emacs allows you to put some light markup into function doc strings that will render as the key sequence required to run the command when you look up the help on the function. I would like to have something like that in org-mode. You can look up the key-binding to a command like this:
#+BEGIN_SRC emacs-lisp
(substitute-command-keys "\\[org-toggle-latex-overlays]")
#+END_SRC

#+RESULTS:
: C-c C-x C-l

We are going to explore a way to recognize the syntax shown above, change its appearance to alert us that we are looking at an emacs command, add a tooltip, and make it clickable to open the documentation, and s (super) clickable to find the function code. Font lock is the tool we will use for this. Basically, we need a regular expression to match the syntax, and a function to find the next instance, and put some properties on the matched text.

Here we use the `rx' library to build up a regular expression for this. It is a bit easier to document than a raw regexp. Since we are matching \ in the pattern, there are some obligatory escaping \ characters in there too. Here is how to set it up, and use it on a string.

#+BEGIN_SRC emacs-lisp
(require 'rx)

(let ((rex (rx
	    (and
	     (eval "\\[")
	     (group (one-or-more (not (any "]"))))
	     "]"))))
      (string-match rex "\\\\[org-toggle-latex-overlays]")
      (list (match-string 0 "\\\\[org-toggle-latex-overlays]")
	    (match-string 1 "\\\\[org-toggle-latex-overlays]")))
#+END_SRC

#+RESULTS:
| \[org-toggle-latex-overlays] | org-toggle-latex-overlays |

So, we can find these, and all we need is to integrate this into font-lock. We define a function that will move the point to the end of the next match, and put properties on the match. We will go ahead and make the text clickable so we can access documentation and code easily. The tooltip will show the key-binding to run the command.

#+BEGIN_SRC emacs-lisp :results silent
(require 'rx)

(defvar elisp-symbol-keybinding-re
  (rx
   ;; opening \\[
   (eval "\\[")
   ;; one or more characters that are not ]
   (group (one-or-more (not (any "]"))))
   ;; The closing ]
   "]")
"Regexp for an elisp command keybinding syntax. \\[some-command]
Regexp group 1 matches `some-command'.")

(defun match-next-keybinding (&optional limit)
  "Move point to the end of the next expression matching
`elisp-symbol-keybinding-re', and put an overlay on the match
that shows the key sequence. Non-bound commands are not
fontified."
  (when (and (re-search-forward elisp-symbol-keybinding-re limit t)
	     (fboundp (intern (match-string 1))))
    (let* ((beg (match-beginning 0))
	   (end (match-end 0))
	   (s (match-string 0))
	   (command (match-string 1))
	   (describe-func `(lambda ()
		    "Run `describe-function' on the command."
		    (interactive)
		    (describe-function (intern ,command))))
	   (find-func `(lambda ()
		     "Run `find-function' on the command."
		     (interactive)
		     (find-function (intern ,command))))
	   (map (make-sparse-keymap)))

      ;; this is what gets run when you click on it.
      (define-key map [mouse-1] describe-func)
      (define-key map [s-mouse-1] find-func)
      ;; Here we define the text properties
      (add-text-properties
       beg end
       `(local-map ,map
	 mouse-face highlight
	 help-echo ,(format
		     "%s\n\nClick for documentation\ns-mouse-1 to find function."
		     (substitute-command-keys s))
	 keybinding t)))))
#+END_SRC

Now we need a way to turn them on and off. We do that here with a minor mode.

#+BEGIN_SRC emacs-lisp
(define-minor-mode emacs-keybinding-overlay-mode
  "Fontify on emacs keybinding syntax. Adds a tooltip for
keybinding, and make the command clickable to get to the
documentation."
  :lighter " KB"
  (if emacs-keybinding-overlay-mode
      ;; turn them on
      (font-lock-add-keywords
       nil
       '((match-next-keybinding 1 font-lock-constant-face)))
    ;; turn them off
    (font-lock-remove-keywords
     nil
     '((match-next-keybinding 1 font-lock-constant-face)))))
#+END_SRC

#+RESULTS:

Here are some sample uses.
You can use  \\[org-toggle-latex-overlays] to toggle latex overlays.

You can use \\[org-ref-helm-insert-cite-link]  to insert citations.

That more or less does it! I don't know if this is the canonical way to do this, but it works nicely here. You can also use overlays, but I found them a little confusing because they are not editable, and you have to toggle the minor mode to see them. Here we have unobtrusive tooltips. One downside is these won't export in any fashion in org-mode since it is not part of the syntax.

Maybe it would make sense to do this for this syntax too: `helm', which is also commonly used in doc strings too.
* TODO Improving cite link context with text properties
  :PROPERTIES:
  :categories: orgmode,emacs,orgref
  :END:
Org-ref uses timers to give you messages about the cite link at point. I am not so crazy about the timer, there is always a (short) delay, and I have had trouble debugging timers in the past, and you have to put the point on the link. Since I wrote that code, I have learned some new things about Emacs, including dynamic tooltips. This will allow me to use the mouse to see what a cite link refers to. While reading documents, I am more likely to use a mouse than when typing a document.

Here, we explore using dynamic tooltips on cite links. The idea is pretty simple, we tie into font-lock to add a function to the :help-echo property of a cite link. The function will go to point, and compute the citation string at point, which will be displayed as a tooltip when the mouse hovers over the citation.

Font-lock allows you to specify a function that sets match-data and that can have other side-effects, e.g. setting text properties. Org-ref has a regexp that defines cite links, which we use here, and a function that gets the citation string at point. We just go to the mouse position, and get that string, wrapped in a save-excursion macro so that point does not actually move. Then, we add the function to font-lock keywords, and we are done!

Here is the short code required to do this.

#+BEGIN_SRC emacs-lisp
(defun match-next-cite-link (&optional limit)
  (when (re-search-forward org-ref-cite-re limit t)
    (put-text-property
     (match-beginning 0) (match-end 0)
     'help-echo (lambda (window object position)
		  (save-excursion
		    (goto-char position)
		    (let ((s (org-ref-get-citation-string-at-point)))
		      (with-temp-buffer
			(insert s)
			(fill-paragraph)
			(buffer-string))))))))


(font-lock-add-keywords nil
			  '((match-next-cite-link . 'org-ref-cite-face)))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results silent
(defun org-ref-match-next-cite-link (&optional limit)
  (when (re-search-forward org-ref-cite-re limit t)
    (add-text-properties
     (match-beginning 0) (match-end 0)
     (list
      'help-echo (lambda (window object position)
		   (save-excursion
		     (goto-char position)
		     (let ((s (org-ref-get-citation-string-at-point)))
		       (with-temp-buffer
			 (insert s)
			 (fill-paragraph)
			 (buffer-string)))))))))

(add-hook
 'org-mode-hook
 (lambda ()
   (font-lock-add-keywords
    nil
    '((org-ref-match-next-cite-link (0  'org-ref-cite-face t)))
    t)))
#+END_SRC

  _te^{st}_ tre^{test}

 cite:kitchin-2015-examp,kitchin-2015-data-surfac-scien

   cite:zou-2014-cobal-embed,zlotea-2014-nanoal

test cite:zhu-2015


bibliography:~/Dropbox/bibliography/references.bib

* TODO org-element contextual help
org-mode is great, plain text and all, but it can be difficult to figure out all the things you can do at any particular place in the buffer. Here, we explore some ideas on making org-mode a bit more discoverable. One way to do this that we explore here is to create a help function that you run, and it tells you about the org element at point, and gives you some hints of what you can do there. To do this, we create a series of functions for each kind of element we provide help on.

The kind of help we want is a description of the element, some commands we can run on the element and what they do, and if there are some the key-bindings. We also want to make sure if the user has changed the key-bindings, the right values get shown. We can get that with emacs-lisp documentation syntax like this:

#+BEGIN_SRC emacs-lisp
(substitute-command-keys "You are on a link. Click on it or press Enter to follow the link.

You can toggle the link display with `org-toggle-link-display'.

If you are on an image link, you can toggle it with \\[org-toggle-inline-images] or `org-toggle-inline-images'.

See Info node `(org) Hyperlinks'.
\n\n")
#+END_SRC

#+RESULTS:
: You are on a link. Click on it or press Enter to follow the link.
:
: You can toggle the link display with `org-toggle-link-display'.
:
: If you are on an image link, you can toggle it with C-c C-x C-v or `org-toggle-inline-images'.
:
: See Info node `(org) Hyperlinks'.
:
:

So, here is the lengthy block of code we use for this purpose.

#+BEGIN_SRC emacs-lisp
(defun ore-latex (element)
  "`ore' documentation for latex fragment."
  (substitute-command-keys "You are on a LaTeX fragment or environment.
\\[org-toggle-latex-overlays] or `org-toggle-latex-overlays' to toggle LaTeX images on it.

"))


(defun ore-link (element)
  "`ore' documentation for org links."
  (substitute-command-keys "You are on a link. Click on it or press Enter to follow the link.

You can toggle the link display with `org-toggle-link-display'.

If you are on an image link, you can toggle it with \\[org-toggle-inline-images] or `org-toggle-inline-images'.

See Info node `(org) Hyperlinks'.
\n\n"))


(defun ore-src-block-header-p (element)
  "Return whether point is in a src-block."
  (and (eq 'src-block (car element))
       (save-excursion
	 (let ((cp (point))
	       (lp (line-number-at-pos)))
	   (goto-char (org-element-property :begin element))
	   (= lp (line-number-at-pos))))))


(defun ore-src-block-header (element)
  "`ore' documentation for src-block header."
  (concat
   "You are in a src-block header. This line tells org-mode that
   it is a src-block, and language of the src-block. There are
   also optional header arguments. See Info node `(org) Header arguments'

"
   (format "The default headers are described here: `org-babel-default-header-args:%s'

" (org-element-property :language element))))


(defun ore-src-block (element)
  "`ore' documentation for a src-block."
  (concat
   (substitute-command-keys "You are in a src-block.

C-c C-c to execute this block.
\\[org-babel-tangle]  org-babel-tangle

You can edit the block with \\[org-edit-special] or `org-edit-special'.

See Info node `(org) Working with source code' for more details.\n\n")))


(defun ore-headline (element)
  "`ore' documentation for a headline."
  (if (bolp)
      (format  "You are at the beginning of a headline.
TAB to cycle Info node `(org) Global and local cycling'.

`org-use-speed-commands'\n\n")
    ;; in a headline
    (substitute-command-keys
     "You are in a headline. You can change:
 visibility with [TAB]
 TODO state \\[org-shiftleft] and \\[org-shiftright] or `org-todo'.
 Priority \\[org-shiftup] (`org-priority-up') and \\[org-shiftdown] (`org-priority-down')
 Tags  \\[org-ctrl-c-ctrl-c] or `org-set-tags'

 Set a property with \\[org-set-property] `org-set-property'.
 Delete a property with \\[org-delete-property] or `org-delete-property'.


")))

;; timestamp
(defun ore-timestamp ()
 "`ore' documentation for timestamps."
 (substitute-command-keys "You are on a timestamp.
If you click on it, you will see the date in the agenda.
With the cursor on the <> or [] \\[org-shiftup] and \\[org-shiftdown] will switch from active to inactive timestamps.

You can change the date by putting the cursor on a date part and using \\[org-shiftup] and \\[org-shiftdown] or \\[org-shiftleft] and \\[org-shiftright]

See Info node `(org) Dates and times'."))

;; table table-row table-cell
(defun ore-table (element)
  "`ore' documentation for tables."
  "You are in a table.

Move cell to cell with [TAB]. When you are in the last cell, TAB adds a new row.

Move rows up and down with \\[org-metaup] and \\[org-metadown].
Move columns left and right with \\[org-metaleft] and \\[org-metaright].

Sort a column with \\[org-sort] `org-sort'.

Insert a row with `org-table-insert-row'.
Delete a row with `org-table-kill-row'.

Insert a column with `org-table-insert-column'.
Delete a column with `org-table-delete-column'.

`C-c -     (`org-table-insert-hline')'
     Insert a horizontal line below current row.  With a prefix
     argument, the line is created above the current line.

`C-c <RET>     (`org-table-hline-and-move')'
     Insert a horizontal line below current row, and move the cursor
     into the row below that line.

You can transpose a table with `org-table-transpose-table-at-point'.

Info node `(org) Tables'.
")

(defun ore-plain-list (element)
  "`ore' doucmentation for plain lists."
  (substitute-command-keys
   "You are on a plain list.
See Info node `(org) Plain lists'."))

(defun ore-item (element)
  "`ore' documentation for items in a list"
  (substitute-command-keys
   "You are on an item in a list.
You can move items up and down with \\[org-metaup] or `org-metaup' and \\[org-meta-down] or `org-metadown'.

You can add a new item with \\[org-meta-return] or `org-meta-return'.

You can change the indentation of an item with  \\[org-metaleft] or `org-metaleft' and \\[org-meta-right] or `org-meta-right'.

You can change the bullet of the item with  \\[org-shiftleft] or `org-shiftleft' and \\[org-shiftright] or `org-shiftright'.

See Info node `(org) Plain lists' for other things like sorting, cycling, checkboxes, etc...

"))

(defun ore-keyword (element)
  "`ore' documentation for a keyword."
  (substitute-command-keys
   "You are on a keyword. You may need to run \\[org-ctrl-c-ctrl-c] or `org-ctrl-c-ctrl-c' to refresh its value if you change it.

You can move keywords up and down with \\[org-metaup] or `org-metaup' and \\[org-meta-down] or `org-metadown'.

"))



(defun ore ()
  "Help function for the element at point."
  (interactive)
  (with-help-window (help-buffer)
    (let ((oeap (org-element-context))
	  (s "No doc found.\n\n"))
      (cond

       ((and  (eq 'src-block (car oeap))
	      (ore-src-block-header-p oeap))
	(setq s (ore-src-block-header oeap)))

       ((or (eq 'table (car oeap))
	    (eq 'table-row (car oeap))
	    (eq 'table-cell (car oeap)))
	(setq s (ore-table oeap)))

       ((eq 'src-block (car oeap))
	(setq s (ore-src-block oeap)))

       ((or (eq 'latex-fragment (car oeap))
	    (eq 'latex-environment (car oeap)))
	(setq s (ore-latex oeap)))

       ((eq 'headline (car oeap))
	(setq s (ore-headline oeap)))

       ((eq 'timestamp (car oeap))
	(setq s (ore-timestamp)))

       ((eq 'link (car oeap))
	(setq s (ore-link oeap)))

       ((eq 'keyword (car oeap))
	(setq s (ore-keyword (oeap))))

       ((eq 'plain-list (car oeap))
	(setq s (ore-plain-list oeap)))

       ((eq 'item (car oeap))
	(setq s (ore-item oeap)))

       (t
	(setq s "No documentation found.\n\n")))

      (princ s)
      (princ "\n\nHere is how org-mode sees the element.\n\n")
      (pp oeap))))

#+END_SRC

#+RESULTS:
: ore

** TODO elements

headline
 - at beginning, speed commands
 - cycle
 - TODO
 - priority
 - tag
 - archive
 - refile

table [[info:org#Tables]]
 - sort
 - add column
 - add row
 - move tables and rows

| a | b |
| 3 | 4 |

#+keyword: test

list (plain/numbered)
 - add element
   - move elements (up/down indent/outdent)
 -


1. item 1
2. item 2
3. item 3

checkbox
- [ ] check it

links

[[./11-eos.png]]

[[info:org#External links]]

$latex_fragment$

\(latex fragment\)

\begin{equation}
2-3
\end{equation}

#+BEGIN_SRC emacs-lisp
(+ 3 4 5)
#+END_SRC

#+RESULTS:
: 12

<2015-10-18 Sun>

* alternative solutions to [[id:1B122428-E8FF-476B-B07B-79A7541003DC][Adding emacs command key-bindings and help functionality to org-mode]]
** font lock solution

#+BEGIN_SRC emacs-lisp :results silent
(defvar elisp-symbol-keybinding-re "\\\\\\\\\\[\\([^]]*\\)]"
  "Regexp for an elisp command keybinding syntax.")

(defun match-next-keybinding (&optional limit)
  (when (re-search-forward elisp-symbol-keybinding-re limit t)
    (put-text-property (match-beginning 0) (match-end 0)
		       'face 'font-lock-constant-face)
    (put-text-property (match-beginning 0) (match-end 0)
		       'lisp-symbol t)
    (put-text-property
     (match-beginning 0) (match-end 0)
     'help-echo (lambda (window object position)
		  "Tooltip of the keybinding"
		  (save-excursion
		    (goto-char position)
		    (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		      (string-match elisp-symbol-keybinding-re s)
		      (substitute-command-keys (match-string 0 s))))))))

(font-lock-add-keywords nil
 '((match-next-keybinding 0 'font-lock-constant-face)))

(defvar elisp-symbol-syntax-re "`\\([^']*\\)'"
  "Regexp for an `elisp' command syntax.")

;; make clickable syntax
(defun match-next-symbol (&optional limit)
  (when (re-search-forward elisp-symbol-syntax-re limit t)
    ;; set face
    (put-text-property (match-beginning 1) (match-end 1)
		       'face 'font-lock-constant-face)
    ;; add property
    (put-text-property (match-beginning 0) (match-end 0)
		       'lisp-symbol (match-string 1))
    ;; clickable text
    (let ((map (make-sparse-keymap)))
      (define-key map [mouse-1]
	(lambda ()
	  (interactive)
	  (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
	    (string-match elisp-symbol-syntax-re s)
	    (describe-function (intern (match-string 1 s))))))
      (put-text-property (match-beginning 0) (match-end 0)
			 'mouse-face 'highlight)
      (put-text-property (match-beginning 0) (match-end 0)
			 'local-map map))

    ;; tooltip
    (put-text-property
     (match-beginning 0) (match-end 0)
     'help-echo (lambda (window object position)
		  "Tooltip of the keybinding"
		  (save-excursion
		    (goto-char position)
		    (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		      (string-match elisp-symbol-syntax-re s)
		      (save-window-excursion
			(describe-function (intern (match-string 1 s))))))))))

(font-lock-add-keywords nil
 '((match-next-symbol 0 'font-lock-constant-face)))
#+END_SRC



   `put-text-property'

** button-lock
#+BEGIN_SRC emacs-lisp
(defvar elisp-symbol-keybinding-re "\\\\\\\\\\[\\([^]]*\\)]"
  "Regexp for an elisp command keybinding syntax.")

(defvar elisp-symbol-syntax-re "`\\([^']*\\)'"
  "Regexp for an elisp command syntax.")

;; make clickable syntax
(button-lock-set-button
 elisp-symbol-keybinding-re
 (lambda ()
   (interactive)
   (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
     (string-match elisp-symbol-keybinding-re s)
     (message (substitute-command-keys (match-string 0 s)))))
 :face font-lock-constant-face
 :help-echo (lambda (window object position)
		(save-excursion
		  (goto-char position)
		  (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
		    (string-match elisp-symbol-keybinding-re s)
		    (substitute-command-keys (match-string 0 s)))))
 :keyboard-binding (kbd "RET")
 :additional-property 'lisp-symbol)


(button-lock-set-button
 elisp-symbol-syntax-re
 (lambda ()
   (interactive)
   (let ((s (get-surrounding-text-with-property 'lisp-symbol)))
     (string-match elisp-symbol-syntax-re s)
     (describe-function (intern (match-string 1 s)))))
 :face '((:background "Lightsteelblue1"))
 :help-echo "click for help"
 :keyboard-binding (kbd "RET")
 :additional-property 'lisp-symbol)


#+END_SRC

#+RESULTS:
| `\([^']*\)' | (0 (quote (face ((:background Lightsteelblue1)) keymap (keymap (13 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote lisp-symbol)))) (string-match elisp-symbol-syntax-re s) (describe-function (intern (match-string 1 s))))) (mouse-1 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote lisp-symbol)))) (string-match elisp-symbol-syntax-re s) (describe-function (intern (match-string 1 s)))))) button-lock t lisp-symbol t mouse-face button-lock-mouse-face help-echo click for help rear-nonsticky t)) append) |

* Modifying link export

#+BEGIN_SRC emacs-lisp
(setf (elt  (assoc "info" org-link-protocols) 2)
      (lambda (keyword desc format)
	(cond
	 ((eq format 'html)
	  (format
	   "<a href=\"https://www.gnu.org/software/emacs/manual/html_node/%s/%s.html\">%s</a>"
	   (car (s-split "#" keyword))
	   (car (last (s-split "#" keyword)))
	   keyword)))))
#+END_SRC


info:emacs#Packages


end


* DONE Clickable telephone numbers in mu4e messages
  CLOSED: [2015-11-04 Wed 12:45]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/11/04 12:45:12
  :updated:  2015/11/04 12:45:12
  :END:
We recently updated our university phone system to a VoIP system that uses Cisco Jabber. I am excited about that because finally I can make phone calls from Emacs with a little applescript automation! So, spoiler alert, this post mostly only applies to Macs, unless you know how to automate a Jabber client to make calls. How to make the telephone numbers clickable is general though, and could be used to do other things as well.

#+BEGIN_SRC emacs-lisp
(defun cisco-call (phone-number)
  (interactive "sPhone number: ")
  (do-applescript
   (format "tell application \"Cisco Jabber\"
	activate
	tell application \"System Events\" to keystroke \"n\" using {shift down, command down}
	tell application \"System Events\" to keystroke \"%s\"
	tell application \"System Events\" to key code 36 #return
end tell" phone-number)))
#+END_SRC

#+RESULTS:
: cisco-call

I would like to go a step further, and make clickable phone numbers in my Emacs buffers. Let's take a look at some options.

** org-mode phone link
This is a no-brainer approach. We can define an org-mode link that runs the cisco-call function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "phone"
 (lambda (phone-number)
   (cisco-call phone-number)))
#+END_SRC

#+RESULTS:
| lambda | (phone-number) | (cisco-call phone-number) |

This makes simple link that just calls the number in the path of the link.

** Clickable text with button-lock
I have used the button-lock package very often to make clickable text. Here we use it to highlight phone numbers matching a regular expression that seems to match most US numbers. This seems to work great in org-mode buffers.

#+BEGIN_SRC emacs-lisp
(require 'rx)

(defvar highlight-phone-numbers nil
 "Button for `highlight-phone-numbers'")

(defun highlight-phone-numbers ()
  "Make phone numbers of the following types clickable:
  (xxx) xxx-xxxx
  xxx.xxx.xxx
  xxxxxxxxxx
  xxx-xxx-xxxx"
  (interactive)
  (let ((inhibit-read-only t))
    (setq highlight-phone-numbers
	  (button-lock-set-button
	   (rx
	    ;; optional () around area code
	    (optional "(")
	    (= 3 digit)
	    (optional ")")
	    ;; delimiters
	    (or (optional "-")
		(optional ".")
		(optional " "))
	    (= 3 digit)
	    (or (optional "-")
		(optional ".")
		(optional " "))
	    (= 4 digit))
	   (lambda ()
	     (interactive)
	     (cisco-call (get-surrounding-text-with-property 'phone-number)))
	   :face '((:background "Darkolivegreen2")
		   (:underline t))
	   :help-echo "click to call"
	   :keyboard-binding (kbd "RET")
	   :additional-property 'phone-number))))

(add-hook 'text-mode 'highlight-phone-numbers)
#+END_SRC

#+RESULTS:
| highlight-phone-numbers |

** Phone numbers in mu4e messages
For some reason, the button-lock package doesn't seem to work in mu4e message buffers, Maybe it is because . The highlight-regexp package does work though, so for these special buffers we use a new approach. We will just put text properties where we want them, and use those properties to make the text clickable.

The messages are in read-only buffers, but we can inhibit that so we can modify the properties. All we need to do is create a little key map as a copy of the existing map, define some keys on it, then search through the buffer adding properties to every phone number we find. I wrote a function that does that, and put that function in a hook to run each time I open a message. Whammo, now I have clickable phone numbers in email! It works pretty well for me.

#+BEGIN_SRC emacs-lisp
(defface mu4e-phone-face
  '((t (:foreground "SteelBlue4" :background "Darkolivegreen2" :underline t)))
  "Phone number directive face.")

(defun mu4e-highlight-phone-numbers ()
  "Make phone numbers clickable in mu4e-view buffers."
  (interactive)
  (let ((phone-regex (rx
		      ;; optional () around area code
		      (optional "(")
		      (= 3 digit)
		      (optional ")")
		      ;; delimiters
		      (or (optional "-")
			  (optional ".")
			  (optional " "))
		      (= 3 digit)
		      (or (optional "-")
			  (optional ".")
			  (optional " "))
		      (= 4 digit))))
    (save-excursion
      (let ((inhibit-read-only t))
	(goto-char (point-min))
	(while (re-search-forward phone-regex nil t)
	  (let ((map (copy-keymap mu4e-view-mode-map))
		(start (match-beginning 0))
		(end (match-end 0)))

	    ;; set file to be clickable to open the source
	    (define-key map [mouse-1]
	      `(lambda ()
		 (interactive)
		 (cisco-call ,(match-string 0))))

	    ;; let letter c also make the call
	    (define-key map "c"
	       `(lambda ()
		 (interactive)
		 (cisco-call ,(match-string 0))))

	    (set-text-properties
	     start end
	     `(local-map, map
			  face mu4e-phone-face
			  mouse-face highlight
			  help-echo "mouse-1: click to call"))))))))

(add-hook 'mu4e-view-mode-hook 'mu4e-highlight-phone-numbers)
#+END_SRC

** Summary
That works pretty well for me overall. The phone number regex is not perfect, e.g. it makes any 10 digit number clickable, and it doesn't recognize international numbers. I am not sure I can call those through the Jabber client anyway. This is purely convenience for me to easily make calls from emails, or other kinds of documents I might read in Emacs.

I don't use phone calls very often, but an interesting thing might be to open a phone log in org-mode, or open the contact that has that phone number to log that you called them, and provide some notes for them. Alternatively, open a new capture for a phone log that could be refiled later.


* org pre-processor
This would be code that replaces syntax like: @(some sexp) with what ever the sexp evals to.


* indirect buffer

(clone-indirect-buffer-other-window (buffer-name) t)

#+BEGIN_SRC emacs-lisp
(defun edit-in-mode ()
  (interactive)
  (when (org-in-src-block-p)
    (message-box "%s"(org-element-context))
    (let* ((src-block (org-element-context))
	   (begin (org-element-property :begin src-block))
	   (end (org-element-property :end src-block))
	   (language (org-element-property :language src-block)))
      (clone-indirect-buffer-other-window (buffer-name) t)
      (narrow-to-region begin end)
      (funcall (intern (concat language "-mode"))))))
#+END_SRC

#+RESULTS:
: edit-in-mode

#+BEGIN_SRC python
import numpy as np
print np.array([6,7])

#+END_SRC

#+RESULTS:
: [6 7]

* Two-mode-mode
This doesn't exactly work. I gather it is supposed to switch modes by detecting if you are between two markers.


http://emacswiki.org/emacs/MultipleModes

this example is broken
http://www.emacswiki.org/emacs/EmacsLispAndLaTeX

I modified this a little. It seems switching back and forth between org-mode is annoying, the buffer tends to get folded.
#+BEGIN_SRC emacs-lisp :tangle two-mode-mode.el
;;; two-mode-mode.el -- switches between tcl and sgml(html) modes
;; $Id: two-mode-mode.el,v 1.2 1999/10/18 14:29:02 davidw Exp $
;; two-mode-mode.el is Copyright David Welton <davidw@efn.org> 1999
;; two-mode-mode.el is free software under the terms of the GNU GPL

;; As I'm sure is painfully obvious, I don't know much about elisp,
;; but I thought it would be cool to do this mode, for mod_dtcl.  So
;; if you have any comments or suggestions, please email me!

;; These same concepts could be used to do a number of neat 2-mode
;; modes, for things like PHP, or anything else where you have a
;; couple of modes you'd like to use.

;; Use of 'psgml-mode' is highly recommended.  It is, of course, a
;; part of Debian GNU/Linux.

;; configure these:
(defvar two-mode-lmatch "#\\+BEGIN_SRC emacs-lisp")
(defvar two-mode-rmatch "#\\+END_SRC")

(defvar default-mode (list 'org-mode "org"))
(defvar second-mode (list 'emacs-lisp-mode "emacs-lisp"))
;; ----------------

(defun two-mode-mode-setup ()
  (add-hook 'post-command-hook 'two-mode-mode-update-mode nil t)
  (make-local-variable 'minor-mode-alist)
  (or (assq 'two-mode-mode minor-mode-alist)
      (setq minor-mode-alist
            (cons '(two-mode-mode " two-mode") minor-mode-alist))))

(defun two-mode-change-mode (to-mode)
  (if (string= to-mode major-mode)
      t
    (progn
      (if (string= to-mode (cadr second-mode))
          (funcall (car second-mode))
        (funcall (car default-mode)))
      (two-mode-mode-setup)
;      (if (eq font-lock-mode t)
;          (font-lock-fontify-buffer))
;	  (font-lock-fontify-buffer)
	  )))

(defun two-mode-mode-update-mode ()
  (let ((lm -1)
        (rm -1))
    (save-excursion
      (if (search-backward two-mode-lmatch nil t)
          (setq lm (point))
        (setq lm -1)))
    (save-excursion
      (if (search-backward two-mode-rmatch nil t)
          (setq rm (point))
        (setq rm -1)))
    (if (and (= lm -1) (= rm -1))
        (two-mode-change-mode (cadr default-mode))
      (if (>= lm rm)
          (two-mode-change-mode (cadr second-mode))
        (two-mode-change-mode (cadr default-mode))))))

(defun two-mode-mode ()
  (interactive)
  (funcall (car default-mode))
  (setq two-mode-mode t)
  (two-mode-mode-setup))

(provide 'two-mode-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results none
(org-babel-tangle)
(load-file "two-mode-mode.el")
(two-mode-mode)
#+END_SRC
#+RESULTS:
| two-mode-mode                             | two-mode                                                                  |   |   |
| dired-omit-mode                           | (:eval (if (eq major-mode (quote dired-mode))  Omit ))                    |   |   |
| latex-electric-env-pair-mode              | /e                                                                        |   |   |
| helm-mode                                 | helm-completion-mode-string                                               |   |   |
| lispy-transform-mode                      | [transform]                                                               |   |   |
| lispy-other-mode                          | [other]                                                                   |   |   |
| lispy-goto-mode                           | [goto]                                                                    |   |   |
| lispy-mode                                | LY                                                                        |   |   |
| ivy-mode                                  | ivy                                                                       |   |   |
| semantic-minor-modes-format               | semantic-minor-modes-format                                               |   |   |
| semantic-highlight-edits-mode             | /e                                                                        |   |   |
| semantic-show-unmatched-syntax-mode       | /u                                                                        |   |   |
| view-mode                                 | View                                                                      |   |   |
| highlight-indentation-current-column-mode |                                                                           |   |   |
| highlight-indentation-mode                |                                                                           |   |   |
| company-search-mode                       | company-search-lighter                                                    |   |   |
| company-mode                              |                                                                           |   |   |
| elpy-mode                                 | Elpy                                                                      |   |   |
| cider--debug-mode                         | DEBUG                                                                     |   |   |
| cider-mode                                | cider-mode-line                                                           |   |   |
| cider-popup-buffer-mode                   | ( cider-tmp)                                                              |   |   |
| archive-subfile-mode                      | Archive                                                                   |   |   |
| orgtbl-mode                               | OrgTbl                                                                    |   |   |
| org-table-follow-field-mode               | TblFollow                                                                 |   |   |
| xref-etags-mode                           |                                                                           |   |   |
| bmkp-temporary-bookmarking-mode           | bmkp-temporary-bookmarking-mode-lighter                                   |   |   |
| bmkp-auto-idle-bookmark-mode              | bmkp-auto-idle-bookmark-mode-lighter                                      |   |   |
| projectile-mode                           | projectile-mode-line                                                      |   |   |
| 2C-mode                                   | 2C                                                                        |   |   |
| hs-minor-mode                             | hs                                                                        |   |   |
| yas-minor-mode                            |                                                                           |   |   |
| hi-lock-mode                              | (:eval (if (or hi-lock-interactive-patterns hi-lock-file-patterns)  Hi )) |   |   |
| auto-capitalize                           | Cap                                                                       |   |   |
| override-global-mode                      |                                                                           |   |   |
| ace-isearch-mode                          | ace-isearch-mode-lighter                                                  |   |   |
| flycheck-mode                             | flycheck-mode-line                                                        |   |   |
| flymake-mode                              |                                                                           |   |   |
| auto-complete-mode                        | AC                                                                        |   |   |
| flyspell-mode                             | flyspell-mode-line-string                                                 |   |   |
| ispell-minor-mode                         | Spell                                                                     |   |   |
| diff-minor-mode                           | Diff                                                                      |   |   |
| TeX-interactive-mode                      |                                                                           |   |   |
| TeX-PDF-mode                              |                                                                           |   |   |
| global-whitespace-newline-mode            | NL                                                                        |   |   |
| global-whitespace-mode                    | ᗣ                                                                         |   |   |
| whitespace-newline-mode                   | nl                                                                        |   |   |
| whitespace-mode                           | ᗣ                                                                         |   |   |
| linum-mode                                |                                                                           |   |   |
| global-auto-revert-mode                   | global-auto-revert-mode-text                                              |   |   |
| auto-revert-tail-mode                     | auto-revert-tail-mode-text                                                |   |   |
| auto-revert-mode                          | auto-revert-mode-text                                                     |   |   |
| rainbow-mode                              |                                                                           |   |   |
| doc-view-minor-mode                       | DocView                                                                   |   |   |
| image-minor-mode                          | (:eval (if image-type (format  Image[%s] image-type)  Image))             |   |   |
| lab-notebook-mode                         | LN                                                                        |   |   |
| vc-parent-buffer                          | vc-parent-buffer-name                                                     |   |   |
| xkcd-mode                                 | xkcd                                                                      |   |   |
| acronym-mode                              | AM                                                                        |   |   |
| techela-mode                              | techela                                                                   |   |   |
| grade-mode                                | grade                                                                     |   |   |
| button-lock-mode                          | button-lock-mode-lighter                                                  |   |   |
| reftex-mode                               | Ref                                                                       |   |   |
| org-show-mode                             | org-show                                                                  |   |   |
| eimp-mode                                 | eimp-mode-string                                                          |   |   |
| org-capture-mode                          | Rem                                                                       |   |   |
| gnus-dead-summary-mode                    | Dead                                                                      |   |   |
| mml-mode                                  | MML                                                                       |   |   |
| org-beamer-mode                           | Bm                                                                        |   |   |
| org-cdlatex-mode                          | OCDL                                                                      |   |   |
| orgstruct-mode                            | OrgStruct                                                                 |   |   |
| outline-minor-mode                        | Outl                                                                      |   |   |
| edebug-mode                               | *Debugging*                                                               |   |   |
| compilation-minor-mode                    | Compilation                                                               |   |   |
| compilation-shell-minor-mode              | Shell-Compile                                                             |   |   |
| compilation-in-progress                   | Compiling                                                                 |   |   |
| flx-ido-mode                              |                                                                           |   |   |
| undo-tree-visualizer-selection-mode       | Select                                                                    |   |   |
| undo-tree-mode                            |                                                                           |   |   |
| eldoc-mode                                | eldoc-minor-mode-string                                                   |   |   |
| visible-mode                              | Vis                                                                       |   |   |
| visual-line-mode                          |                                                                           |   |   |
| next-error-follow-minor-mode              | Fol                                                                       |   |   |
| abbrev-mode                               | Abrv                                                                      |   |   |
| overwrite-mode                            | overwrite-mode                                                            |   |   |
| auto-fill-function                        | Fill                                                                      |   |   |
| defining-kbd-macro                        | Def                                                                       |   |   |
| isearch-mode                              | isearch-mode                                                              |   |   |
| ace-jump-mode                             | ace-jump-mode                                                             |   |   |
| iedit-mode                                | iedit-mode                                                                |   |   |







* What is next for jmax?


- [ ] Version control/track changes

- [ ] Annotation

- [ ] orgx format

- [ ] Search integration

- [ ] Export to word

- [ ] Non-latex citations

- [ ] collaboration tools

* Merging bibtex files

Add entries of f2 to f1 if they are not already there

#+BEGIN_SRC emacs-lisp


(let (d1 d2)
  (find-file "../../Dropbox/bibliography/references.bib")
  (bibtex-map-entries
   (lambda (key start end)
     (add-to-list 'd1 (cons key (buffer-substring start end)))))

  (find-file "/Users/jkitchin/Dropbox/CMU/proposals/@archive/2015/DOE-alloys/doe-alloys.bib")
  (bibtex-map-entries
   (lambda (key start end)
     (add-to-list 'd2 (cons key (buffer-substring start end)))))

  (pop-to-buffer "new-entries")
  (insert (mapconcat 'identity
		     (loop for new-key in
			   (-difference (mapcar 'car d2) (mapcar  'car d1))
			   collect
			   (cdr (assoc new-key d2)))
		     "\n")))
#+END_SRC

#+RESULTS:
#+begin_example
@article{zhao-2006-comput-approac,
  author =	 {Zhao, J.-C.},
  title =	 {Computational Approaches As Effective Tools in the Study of
                  Phase Diagrams and Composition-Structure-Property
                  Relationships},
  journal =	 {Progress in Materials Science},
  volume =	 51,
  pages =	 {557-631},
  year =	 2006,
  type =	 {Journal Article},
}
#+end_example

* DONE Saving the current restriction and restoring it while following links
  CLOSED: [2015-10-24 Sat 13:41]
  :PROPERTIES:
  :ID:       881AD1B6-E4F3-4860-8734-BFB9BE613ABF
  :categories: emacs,orgmode
  :date:     2015/10/24 13:41:45
  :updated:  2015/10/25 07:09:15
  :END:

On the org-mode mailing list there has been some discussion about following id links. The issue is that if your buffer is narrowed, clicking on the link does not change the restriction to actually take you to the entry. This is debatably desirable. If I click on a link, I want it to go where it points. But, I might also like to go back to my narrowed view. So here consider how to save the state of narrowing, and restore it. We modify the function that opens an id link to save the restriction, and widen the buffer if necessary.

Saving the restriction seems easy, we just save a marker to point, and the point-min and point-max. We save the marker for a convenient way to get the buffer, and perhaps the actual point. We advise the C-c & function to restore the restriction after we leave it. This should fix the restriction in whatever buffer we undid it in.

Here is the code that seems to work for me. Thanks to Rasmus for the idea on saving the restriction data.

#+BEGIN_SRC emacs-lisp
(defvar *saved-restriction* nil
 "A global var containing the current restriction.
Returns (current-buffer point-min point-max")

(defun save-current-restriction ()
  "Save the current restriction at point."
  (setq *saved-restriction*
	(if (buffer-narrowed-p)
	    (list (current-buffer) (point-min) (point-max))
	  nil)))

(defun restore-saved-restriction ()
  "Restore the last saved restriction."
  (when *saved-restriction*
    (set-buffer (car *saved-restriction*))
    (narrow-to-region (nth 1 *saved-restriction*)
		      (nth 2 *saved-restriction*)))
  (setq *saved-restriction* nil))

;' actually modify this function to save the restriction, and widen if needed.
(defun org-id-open (id)
  "Go to the entry with id ID."
  (org-mark-ring-push)
  (let ((m (org-id-find id 'marker))
	cmd)
    (unless m
      (error "Cannot find entry with ID \"%s\"" id))
    ;; Use a buffer-switching command in analogy to finding files
    (setq cmd
	  (or
	   (cdr
	    (assq
	     (cdr (assq 'file org-link-frame-setup))
	     '((find-file . switch-to-buffer)
	       (find-file-other-window . switch-to-buffer-other-window)
	       (find-file-other-frame . switch-to-buffer-other-frame))))
	   'switch-to-buffer-other-window))
    (if (not (equal (current-buffer) (marker-buffer m)))
	(funcall cmd (marker-buffer m)))
    (save-current-restriction)
    (when (> m (point-max))
      (widen))
    (goto-char m)
    (move-marker m nil)
    (org-show-context)))


;; And we advise the function going back to restore the restriction.
(defadvice org-mark-ring-goto (after restore-my-restriction () activate)
  "Restore narrowing."
  (restore-saved-restriction))

#+END_SRC

#+RESULTS:
: org-mark-ring-goto

This seems to preserve restrictions in the current buffer and in other buffers, as long as I use C-c & to invoke org-mark-ring goto. I am not sure how easy it would be to make this work for all links. Each link has its own function for following so I am not sure we can easily get them all to do this unless there is some high level function to advise like org-mouse-down-mouse or something similar. It also has the limitation that the restoration only occurs using org-mark-ring-goto, unless you specifically run the  (restore-saved-restriction) function yourself. That could be made an interactive function for that purpose. Otherwise, this seems like a reasonable approach.


* TODO coupling org-mode and code	    :test:
  DEADLINE: <2015-10-20 Tue>
  :PROPERTIES:
  :TEST:     tree
  :ID:       2FD9A4E4-74F9-43E7-B42F-8DF4F979C668
  :END:

This is a generic idea that I am using org-headlines as containers for data, and frequently want some way to interact with collections, to add new headlines, etc... I find it awkward to use org-entry-get all the time. I am thinking of a generic function that would return a data structure.

Here I work it out for a contact.

#+BEGIN_SRC emacs-lisp
(defclass Contact ()
  ((email :initarg :email
	  :documentation "The email address")
   (birthday :initarg :birthday
	     :documentation "An org-timestamp for the birthdate."))
  "A contact")

(defmethod get-email ((contact Contact))
  (oref contact email))

(let ((c (Contact nil :email "jkitchin@andrew.cmu.edu" :birthday [2015-10-20 Tue])))
  (oref c birthday))
#+END_SRC

#+RESULTS:
: [2015-10-20 Tue]


Here is a struct approach.

#+BEGIN_SRC emacs-lisp
(cl-defstruct Contact name marker properties)

(let ((contacts (org-map-entries
		 (lambda ()
		   (make-Contact
		    :name (org-get-heading t t)
		    :marker (point-marker)
		    :properties (org-entry-properties (point) 'all)))
		 "BIRTHDAY<>\"\"")))
  (mapcar 'Contact-name contacts))
#+END_SRC

#+RESULTS:
| John | Jane |

#+BEGIN_SRC emacs-lisp
(defun org-headline-to-alist ()
  (append
   (list
    (org-get-heading t t)
    (cons "MARKER" (point-marker))

    )
   (org-entry-properties (point) 'all))
  )

(org-headline-to-alist)
#+END_SRC

#+RESULTS:
| coupling org-mode and code | (MARKER . #<marker at 1409 in blog.org>) | (TODO . TODO) | (FILE . /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | (TAGS . :test:) | (ALLTAGS . :test:) | (BLOCKED . ) | (DEADLINE . 2015-10-20 Tue) | (TIMESTAMP_IA . 2015-10-20 Tue) | (TEST . tree) | (CATEGORY . blog) |

** John
   :PROPERTIES:
   :BIRTHDAY: [2012-10-20 Sat]
   :TYPE:    contact
   :END:

** Jane
   :PROPERTIES:
   :BIRTHDAY: [2014-10-20 Mon]
   :TYPE:    contact
   :END:




* Cycling through a list of files      :tets:tree:

#+BEGIN_SRC emacs-lisp
(setq my-files '("a.org" "b.org" "c.org"))

(defun my-next-file ()
 (interactive)
 (let ((f (pop my-files)))
   (add-to-list 'my-files f t)
   (find-file f)))

(defun my-previous-file ()
  (interactive)
  (let* ((r-my-files (reverse my-files))
	 (f (pop r-my-files)))
    (add-to-list 'r-my-files f t)
    (setq my-files (reverse r-my-files))
    (find-file f)))

(global-set-key (kbd "s-<right>") 'my-next-file)
(global-set-key (kbd "s-<left>") 'my-previous-file)
#+END_SRC

#+RESULTS:
: my-previous-file

* Exploring elpy

`M-: (setq elpy-rpc-backend "jedi")` and `M-x (elpy-rpc-restart)` t

#+BEGIN_SRC python
from numpy import array

from pycse import nlinfit

nlinfit(
#+END_SRC
* Using the python ast module to figure out what node a cursor is on

** parser

#+BEGIN_SRC python
import parser

source = '''import numpy as np

def func(x):
    return x

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

print parser.expr(source)
#+END_SRC

#+RESULTS:

** symtable

we can get a list of identifiers and symbols like this.

#+BEGIN_SRC python
import symtable

source = '''import numpy as np

def func(x):
    return x

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

table = symtable.symtable(source, "string", "exec")
print table.get_symbols()
print table.get_identifiers()

print dir(table.get_symbols()[0])
print table.get_symbols()[0].is_imported()
#+END_SRC

#+RESULTS:
: [<symbol 'np'>, <symbol 'a'>, <symbol 'b'>, <symbol 'func'>]
: ['np', 'a', 'b', 'func']
: ['_Symbol__flags', '_Symbol__name', '_Symbol__namespaces', '_Symbol__scope', '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'get_name', 'get_namespace', 'get_namespaces', 'is_assigned', 'is_declared_global', 'is_free', 'is_global', 'is_imported', 'is_local', 'is_namespace', 'is_parameter', 'is_referenced']
: False

** jedi
#+BEGIN_SRC python
import jedi
import pydoc

source = '''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''

script = jedi.Script(source, 6, 13)

print dir(script)
print script.usages()[0]
print script.call_signatures()[0].params
print dir(script.call_signatures()[0])

#+END_SRC

#+RESULTS:
: [<CallSignature: dot index 0>, <CallSignature: dot index 0>]


** ast
I want to connect Emacs, org-mode and python to get help about the symbol a cursor is on. I am not sure this will work, but I am going to explore it here. First, I want to figure out what node of the ast.tree the cursor is on. Statements and expressions in the ast have a lineno and col_offset specified in them.

#+BEGIN_SRC python
import ast

tree = ast.parse('''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))''')

for node in ast.walk(tree):
    if isinstance(node, ast.expr) or isinstance(node, ast.stmt):
        a = (node.lineno, node.col_offset)
    else:
        a = ''

    print str(a) + ast.dump(node) + '\n'
#+END_SRC

#+RESULTS:
#+begin_example
Module(body=[Import(names=[alias(name='numpy', asname='np')]), Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None)), Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None)), Print(dest=None, values=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)], nl=True)])

(1, 0)Import(names=[alias(name='numpy', asname='np')])

(3, 0)Assign(targets=[Name(id='a', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None))

(4, 0)Assign(targets=[Name(id='b', ctx=Store())], value=Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None))

(6, 0)Print(dest=None, values=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)], nl=True)

alias(name='numpy', asname='np')

(3, 0)Name(id='a', ctx=Store())

(3, 4)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None)

(4, 0)Name(id='b', ctx=Store())

(4, 4)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load()), args=[List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())], keywords=[], starargs=None, kwargs=None)

(6, 6)Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)

Store()

(3, 4)Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())

(3, 13)List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())

Store()

(4, 4)Attribute(value=Name(id='np', ctx=Load()), attr='array', ctx=Load())

(4, 13)List(elts=[Num(n=5), Num(n=6), Num(n=7)], ctx=Load())

(6, 6)Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load())

(6, 13)Name(id='a', ctx=Load())

(6, 16)Name(id='b', ctx=Load())

(3, 4)Name(id='np', ctx=Load())

Load()

(3, 14)Num(n=5)

(3, 17)Num(n=6)

(3, 20)Num(n=7)

Load()

(4, 4)Name(id='np', ctx=Load())

Load()

(4, 14)Num(n=5)

(4, 17)Num(n=6)

(4, 20)Num(n=7)

Load()

(6, 6)Name(id='np', ctx=Load())

Load()

Load()

Load()

Load()

Load()

Load()

#+end_example

Now which node covers line 6 column 4
#+BEGIN_SRC python
import ast

tree = ast.parse('''import numpy as np

a=np.array([5, 6, 7])
b=np.array([5,6,7])

print(np.dot(a, b))''')

exprs = [node for node in ast.walk(tree)
         if isinstance(node, ast.expr) or isinstance(node, ast.stmt)]

# nodes in line 6
for x in sorted([x for x in exprs if x.lineno == 6], key=lambda x: x.col_offset):
    print (x.lineno, x.col_offset), ast.dump(x) + '\n'


N = None

for x in sorted([x for x in exprs if x.lineno == 6], key=lambda x: x.col_offset):
    if x.col_offset <= 16:
        N = x
        continue
    else:
        break

print "N = ", (N.lineno, N.col_offset), ast.dump(N)
#+END_SRC

#+RESULTS:
#+begin_example
(6, 0) Print(dest=None, values=[Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)], nl=True)

(6, 6) Call(func=Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load()), args=[Name(id='a', ctx=Load()), Name(id='b', ctx=Load())], keywords=[], starargs=None, kwargs=None)

(6, 6) Attribute(value=Name(id='np', ctx=Load()), attr='dot', ctx=Load())

(6, 6) Name(id='np', ctx=Load())

(6, 13) Name(id='a', ctx=Load())

(6, 16) Name(id='b', ctx=Load())

N =  (6, 16) Name(id='b', ctx=Load())
#+end_example

* A quick example with Racket

#+BEGIN_SRC emacs-lisp
(defun org-babel-execute:racket (body params)
  (let* ((tangle (cdr (assoc :tangle params)))
         (script-file
          (if (string-equal tangle "no")
              (org-babel-temp-file "org-babel-" ".rkt")
            tangle)))
    (with-temp-file script-file
      (insert body))
    (let* ((pn (org-babel-process-file-name script-file))
           (cmd (format "racket -u %s" pn)))
      (message cmd)
      (shell-command-to-string cmd))))
#+END_SRC

#+RESULTS:
: org-babel-execute:racket

#+BEGIN_SRC racket
#lang racket
(printf "Hello world and John!")
#+END_SRC

#+RESULTS:
: Hello world and John!

It works!

Here is the total lispy way to write the code, i.e. without the #lang sugar at the top. The only downside I see is the extra indentation.
#+BEGIN_SRC racket
(module main racket
  (printf "Hello world and John!"))
#+END_SRC

#+RESULTS:
: Hello world and John!

#+BEGIN_SRC racket
#lang racket
;; Finds org-files in all subdirs
(for ([path (in-directory)]
      #:when (regexp-match? #rx"[.]org$" path))
  (printf "source file: ~a\n" path))
#+END_SRC

#+RESULTS:
#+begin_example
source file: acs-cat-data/acs-cat-manuscript.org
source file: acs-cat-manuscript.org
source file: add-new-unique-heading.org
source file: add-properties-to-headings.org
source file: add-subheadings-to-headings.org
source file: an-interesting-article.org
source file: ase-db.org
source file: attaching-code-blocks-to-a-pdf.org
source file: bbdb conversion/import_bbdb.org
source file: blog-2014.org
source file: blog-references.org
source file: blog.org
source file: blog.org.org
source file: blogofile.org
source file: cheat-sheets.org
source file: cmd-line-section-export.org
source file: collect-entries/collect-entries.org
source file: colored-block.org
source file: constrained-fit.org
source file: controlling-latex-export.org
source file: course/syllabus.org
source file: custom-export.org
source file: custom_latex.org
source file: dynamic-menus/dynamic-menus.org
source file: emacs-jasp/emacs-jasp.org
source file: emacs-jasp/using-jasp-el.org
source file: emacs-scripts/emacs-scripts.org
source file: embedded-source.org
source file: estimating-intersections-from-data.org
source file: exam.org
source file: export-csv.org
source file: exporting-accented-characters.org
source file: exporting-with-biblatex.org
source file: file-options.org
source file: file-upload-blog.org
source file: for-else.org
source file: gaussian-fitting.org
source file: gibbs.org
source file: highlights.org
source file: html-citations.org
source file: interactive-qdel.org
source file: jmax-bibtex-doc.org
source file: json-export.org
source file: links.org
source file: lisp-data-structures.org
source file: lisp-link-to-content.org
source file: literate/literate.org
source file: load-lisp-org.org
source file: make-project-dir.org
source file: matlab-org-mode/using-matlab-orgmode.org
source file: memoizing-functions-with-file.org
source file: memos/memos.org
source file: modeling-data-with-splines.org
source file: molecules/molecules.org
source file: multi-exports/multi-exports.org
source file: my-table.org
source file: new-file.org
source file: news.org
source file: odelay-multiple-equations.org
source file: org-contacts/make-contacts.org
source file: org-contacts/referee-contacts.org
source file: org-db.org
source file: org-index/file-1.org
source file: org-index/file-2.org
source file: org-index/org-index.org
source file: org-notebook/f1.org
source file: org-notebook/f2.org
source file: org-outside-emacs.org
source file: org-ref-other-bibliographies.org
source file: org-ref-show.org
source file: org-report/Ellen-Donnte-HW1.org
source file: org-report/Jim-Vicious-HW1.org
source file: org-report/John-Doe-HW1.org
source file: org-report/org-report.org
source file: org-report/Slim-Shady-HW1.org
source file: org-to-docx-export.org
source file: org-to-docx-pandoc.org
source file: org-to-org.org
source file: org-to-word.org
source file: org.org
source file: pdfsync.org
source file: plotting-uncertainty.org
source file: posting-to-citeulike.org
source file: prediction-intervals.org
source file: problem-selection/exam.org
source file: problem-selection/p1.org
source file: problem-selection/p2.org
source file: problem-selection/problem-selection.org
source file: processes/processes.org
source file: publishing/acs-iecr.org
source file: publishing/elsevier.org
source file: publishing/springer.org
source file: python-and-or-tricks.org
source file: python-dates.org
source file: python-sessions.org
source file: read-write-pdf-metadata.org
source file: readding-data-from-figures.org
source file: scripting-git/scripting-git.org
source file: separate-bib-references.org
source file: separate-bib.org
source file: serializing-jasp-as-json.org
source file: sessions.org
source file: set-reftex-formats.org
source file: sin.org
source file: some-filename.org
source file: ss-manuscript.org
source file: stackoverflow.org
source file: super-super-cells.org
source file: supporting-information.org
source file: surface-science-data/manuscript.org
source file: swish-email/index-email.org
source file: swish-org/index-org-as-html.org
source file: sympy-printing.org
source file: test-archive-2015-06-26/test-archive.org
source file: test-archive.org
source file: test-bibtex.org
source file: test.org
source file: tests.org
source file: uncertainties-eos.org
source file: uncertainty-in-ode-solutions.org
source file: unertainty-in-polynomial-roots.org
source file: using-org-ref.org
source file: using-temp-buffers.org
source file: why-org-mode.org
source file: writing-exams-in-orgmode.org
#+end_example


* Working with org-contacts
Rather than dig through org-contacts, here is a different approach to finding contacts. It is surprisingly fast, using org-map-entries with a list of contacts files.

Here I get my email addresses at CMU, with last names starting with K.
#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (org-entry-get (point) "EMAIL"))
 "EMAIL={cmu}+LASTNAME={^K}"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| okonkwo@andrew.cmu.edu | yaesunk@andrew.cmu.edu | jelenak@cmu.edu | Aditya Khair <akhair@andrew.cmu.edu> | jkitchin@andrew.cmu.edu |

Here, I get current phd students. They are tagged with :phd: and a TODO state of "CURRENT".

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (format "%s %s"
	   (org-entry-get (point) "FIRSTNAME")
	   (org-entry-get (point) "LASTNAME")))
 "EMAIL<>\"\"+phd+TODO=\"CURRENT\""
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Jacob Boes | Zhongnan Xu | Alex Hallenbeck |

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (nth 4 (org-heading-components)))
 "EMAIL<>\"\"+GENDER=\"F\""
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Elizabeth Biddinger | Cathy Chin | Maria Curet-Arana | Carrie Farberow | Maria Flytzani-Stephanopoulos | Rachael Getman | Helena Hagelin-Weaver | Preeti Kamakoti | Heather Kulik | Cynthia Lo | Surya Mallapragada | Maria Martinez | Eranda Nikolla | Bihter Padak | Susan Stagg-Williams | Maureen Tang | Judith Yang | Perla B Balbuena | Sumathy Raman | Rachel Getman | Eranda Nikolla | Y-H. Cathy Chin | Aleksandra Vojvodic | Heather Mayes | Maria Curet-Arana | Gabriella Farnham | Susanna Scott | Lashonda Korley | Marianthi Ierapetritou | Heather Kulik | Lydia Contreras | Kathleen Schwarz | Carol Frieze | Ty Walton | Justine Cassell | Amy Burkert | Susan Polansky | Anna Fisher | Alissa Park |

#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (nth 4 (org-heading-components)))
 "EMAIL<>\"\"+cheme+assistant|associate"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| Kris Dahl | Chrysanthos Gounaris | Aditya Khair | Kathryn Whitehead |

** org-contacts
#+BEGIN_SRC emacs-lisp
(assoc "John Kitchin" org-contacts-db)
#+END_SRC

#+RESULTS:
| John Kitchin | #<marker at 9292 in department-contacts.org> | ((FILE . /Users/jkitchin/Dropbox/org-mode/contacts/department-contacts.org) (TAGS . :cheme:faculty:full:hiring:css:teqie:cfs:bias:) (ALLTAGS . :cheme:faculty:full:hiring:css:teqie:cfs:bias:) (BLOCKED . ) (scopus-id . 7004212771) (PHD . 2004) (FIRSTNAME . John) (LASTNAME . Kitchin) (EMAIL . jkitchin@andrew.cmu.edu) (LAST_SENT_EMAIL . [[mu4e:msgid:m2d1wfzpu8.fsf@andrew.cmu.edu][(search) application 623566 review (Thu Oct 15 19:14:57 2015)]]) (LAST-EMAIL-READ . mu4e:msgid:m2h9lrzq1v.fsf@andrew.cmu.edu) (CATEGORY . department-contacts)) |


#+BEGIN_SRC emacs-lisp
(let ((lexical-binding nil)
      (todo-only nil))
  (loop for contact in org-contac
ts-db
	for tags = (cdr (assoc "TAGS" (nth 2 contact)))
	for tags-list = (split-string
			 (substring
			  (or tags "  ")
			  1 -1)
			 ":")
	for tag-expression = (or (org-make-tags-matcher "group-phd") nil)
	if (and
	    ;; A name match
	    (string-match-p "h" (car contact))
	    ;; a property match
	    (string-match-p "cmu\\.edu" (org-contacts-get-property "EMAIL" contact))
	    ;; a tag match.
	    (eval (cdr tag-expression)))
	collect contact))
#+END_SRC

#+RESULTS:
| CURRENT Venkatesh Naik      | #<marker at 11335 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . vnaik@andrew.cmu.edu) (CATEGORY . group-contacts))    |
| CURRENT Siddharth Deshpande | #<marker at 11437 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . siddhard@andrew.cmu.edu) (CATEGORY . group-contacts)) |
| CURRENT Zhaofeng Chen       | #<marker at 11547 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . zhaofenc@andrew.cmu.edu) (CATEGORY . group-contacts)) |
| CURRENT Hari Thirumalai     | #<marker at 11651 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :ms:group:current:) (ALLTAGS . :ms:group:current:) (BLOCKED . ) (EMAIL . hthiruma@andrew.cmu.edu) (CATEGORY . group-contacts)) |

#+BEGIN_SRC emacs-lisp
(defun org-contacts-match-tag-expression-p (contact tag-expression)
  "Test if a CONTACT matches a TAG-EXPRESSION."
  (let* ((lexical-binding nil)
	 (todo-only nil)
	 (tags-list (org-contacts-get-tag-list contact)))
    (eval (cdr (org-make-tags-matcher tag-expression)))))

(org-contacts-match-tag-expression-p
 (assoc "John Kitchin" org-contacts-db)
  "faculty")
#+END_SRC

#+RESULTS:
: t


#+BEGIN_SRC emacs-lisp
(org-contacts-filter-tags "group-phd+undergrad")
#+END_SRC

#+RESULTS:
| CURRENT Matt Palmer | #<marker at 11757 in group-contacts.org> | ((TODO . CURRENT) (FILE . /Users/jkitchin/Dropbox/org-mode/contacts/group-contacts.org) (TAGS . :group:undergrad:) (ALLTAGS . :group:undergrad:) (BLOCKED . ) (EMAIL . Matthew Palmer <mjpalmer@andrew.cmu.edu>) (CATEGORY . group-contacts)) |


#+BEGIN_SRC emacs-lisp
(org-map-entries
 (lambda ()
   (org-entry-get (point) "EMAIL"))
 "EMAIL<>\"\"+group-undergrad"
 org-contacts-files)
#+END_SRC

#+RESULTS:
| mcurnan@andrew.cmu.edu | jboes@cmu.edu | zhongnanxu@cmu.edu | Alexander Hallenbeck <ahallenb@andrew.cmu.edu> | vnaik@andrew.cmu.edu | siddhard@andrew.cmu.edu | zhaofenc@andrew.cmu.edu | hthiruma@andrew.cmu.edu |

* DONE Line numbers in org-mode code blocks
  CLOSED: [2015-10-13 Tue 08:58]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/10/13 08:58:34
  :updated:  2015/10/13 08:58:34
  :END:

Some of my students have wanted to show line numbers in code blocks. This is especially useful for when you run a Python block, and you get an error message with a line number in it. Right now, to figure out which line that is, you have to into the code block, type C-c ' to get into edit mode, and turn line numbers on. We look into how to achieve that here.

You may want to see the video here: https://www.youtube.com/watch?v=kinWijGzXms.

First, we need to get the region that is the code block. We can find some info in the org-element, but, the :begin and :end include lines we don't want, like the header lines, and the results. But, we can get the beginning, and maybe from there search forward to the block. Run this code block to see where the point goes.

#+name: boring-example
#+BEGIN_SRC emacs-lisp
;; a boring comment

(progn
  (+ 40 2))

(goto-char (org-element-property :begin (org-element-context)))
(re-search-forward (regexp-quote (org-element-property :value (org-element-context))))
(goto-char (match-beginning 0))
;; number of lines in block. The last carriage return doesn't count.
(1- (length (s-split "\n" (org-element-property :value (org-element-context)))))
#+END_SRC

#+RESULTS: boring-example
: 9

So, we can get the number of lines, and move the point to the first line. For numbers, we will use overlays. Here is a simple way to put a number at the beginning of a line.

#+BEGIN_SRC emacs-lisp
(let (ov)
  (beginning-of-line)
  (setq ov (make-overlay (point) (point)))
  (overlay-put ov 'before-string "1"))
#+END_SRC

#+RESULTS:
: 1

The next thing to do is make a function that puts a number at the beginning of a line. We might as well store these overlays in a variable, so they are easy to remove later. This is just for exploration of how to do it. Later we combine all these pieces together.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line (N)
 "Put an overlay at the beginning of a line."
  (beginning-of-line)
  (let (ov)
    (setq ov (make-overlay (point) (point)))
    (overlay-put ov 'before-string (format "%3s" (number-to-string N)))
    (add-to-list 'number-line-overlays ov)))

(number-line 4)
#+END_SRC

#+RESULTS:
| #<overlay from 1782 to 1782 in blog.org> |


That looks promising. Let's make a function to clear those overlays. It is so easy it may not even be worth writing.

#+BEGIN_SRC emacs-lisp
(defun number-line-clear ()
  (mapc 'delete-overlay number-line-overlays)
  (setq number-line-overlays '()))

(number-line-clear)
#+END_SRC

#+RESULTS:

Finally, we are ready to hack up the code block numbering code. The numbers will not automatically update, so we will write a function that numbers the block, but only temporarily. Any key press will get rid of the numbers so we can get back to work.  I am going to go ahead and make this a stand-alone function and block.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line-src-block ()
  (interactive)
  (save-excursion
    (let* ((src-block (org-element-context))
	   (nlines (- (length
		       (s-split
			"\n"
			(org-element-property :value src-block)))
		      1)))
      (goto-char (org-element-property :begin src-block))
      (re-search-forward (regexp-quote (org-element-property :value src-block)))
      (goto-char (match-beginning 0))

      (loop for i from 1 to nlines
	    do
	    (beginning-of-line)
	    (let (ov)
	      (setq ov (make-overlay (point) (point)))
	      (overlay-put ov 'before-string (format "%3s" (number-to-string i)))
	      (add-to-list 'number-line-overlays ov))
	    (next-line))))

  ;; now read a char to clear them
  (read-key "Press a key to clear numbers.")
  (mapc 'delete-overlay number-line-overlays)
  (setq number-line-overlays '()))

(number-line-src-block)
#+END_SRC

#+RESULTS:

I am not sure how to get the numbers to automatically update smoothly like they do in linum-mode. That code uses a lot of hooks to make updates work, and embeds them in a minor mode to get rid of them. It also puts them in the fringe I think, but it is not clear how that is done.

We could modify what happens after the numbers are put on, e.g. pressing numbers might jump to a line, or some other kind of functionality. I don't have a critical need for this right now, so I didn't explore it more. Let me know if you have any good ideas for it!


Let's try a variation of that code that allows us to type a number to jump to a line, or quit it.

#+BEGIN_SRC emacs-lisp
(defvar number-line-overlays '()
  "List of overlays for line numbers.")

(make-variable-buffer-local 'number-line-overlays)

(defun number-line-src-block ()
  (interactive)
  (save-excursion
    (let* ((src-block (org-element-context))
	   (nlines (- (length
		       (s-split
			"\n"
			(org-element-property :value src-block)))
		      1)))
      (goto-char (org-element-property :begin src-block))
      (re-search-forward (regexp-quote (org-element-property :value src-block)))
      (goto-char (match-beginning 0))

      (loop for i from 1 to nlines
	    do
	    (beginning-of-line)
	    (let (ov)
	      (setq ov (make-overlay (point) (point)))
	      (overlay-put ov 'before-string (format "%3s" (number-to-string i)))
	      (add-to-list 'number-line-overlays ov))
	    (next-line))))

  (let ((entry (read-string "Jump to line number (enter to quit):")))
    (cond
     ((string-match "[0-9*]" entry)
      (progn
          (goto-char (org-element-property :begin (org-element-context)))
       (forward-line (string-to-number entry)))))
    (mapc 'delete-overlay number-line-overlays)
    (setq number-line-overlays '())))

(number-line-src-block)
#+END_SRC
#+RESULTS:


* Using functions in font lock

If you want to get past simple regular expressions in font-lock, you can use functions for search-based fontification.
#+BEGIN_SRC emacs-lisp
(defun foo-left (old-point new-point)
  (message "in foo-left (%s %s)" old-point new-point))

(defun foo-entered (old-point new-point)
  (message "in foo-entered (%s %s)\n" old-point new-point))

(defface new-face
  '((t (:foreground "OrangeRed1"
		    :point-left 'foo-left
		    :point-entered 'foo-entered)))
  "Font Lock mode face used to highlight format specifiers."
  :group 'font-lock-faces)


(defun match-next-foo (&optional limit)
  (when (re-search-forward "foo" limit t)
    (put-text-property (match-beginning 0) (match-end 0) 'point-left 'foo-left)
    (put-text-property (match-beginning 0) (match-end 0) 'point-entered 'foo-entered)))

(font-lock-add-keywords nil
 '((match-next-foo 0 'new-face)))

#+END_SRC

#+RESULTS:
| t | ((match-next-foo 0 (quote new-face)) (\(?: \(?:Billy Bardin\ | Concetta LaMarca\ | Ma\(?:r\(?:ianthi Ierapetritou\ | k Bendett\)\ | tt Tirrell\)\)\ | A\(?:aron \(?:Deskins\ | P\. Mitchell\ | Reinicker\)\ | bhishek Bagusetty\ | d\(?:am \(?:Feinberg\ | Holewinski\)\ | itya \(?:Bhan\ | Khair\ | Sinha\)\)\ | kshay Tharval\ | l\(?:an Pittler\ | bina Kwak\ | e\(?:ksandra Vojvodic\ | x\(?: \(?:\(?:L\ | Yokoch\)i\)\ | ander (Alex) Davis\)\)\ | i\(?:cia M\. Walsh\ | ssa Park\)\ | len Robinson\)\ | my \(?:Burkert\ | Desalazar\)\ | n\(?:a\(?:nya Chowdhury\ | stasios Angelopoulos\)\ | d\(?:re\(?:a\(?: \(?:Cohen\ | Farinacci\)\ | s \(?:Heyden\ | Waechter (PhD 2002)\)\)\ | w \(?:Adamczyk\ | Gellman\ | Jreissaty\ | M\(?:edford\ | oore\)\ | Peterson\ | \(?:Rapp\ | Ye\)e\)\)\ | y Hrymak\)\ | ita de Waard\ | n\(?:a Fisher\ | ette Jacobson\)\ | thon\(?:ia Raphael-Chieke\ | y Difrancesco\)\ | ushree Kamat\ | vitha Kandiraju\)\ | r\(?:avind Asthagiri\ | p\(?:ad Somogyvari\ | ita Iddya\)\ | up Chakraborty\)\ | sh\(?:faq Shaikh\ | ish Mhadeshwar\ | ok Kumar\ | win Thirumala Kumara\)\ | tharv Bhosekar\)\ | B\(?:e\(?:an Getsoian\ | hnam Bahrami\ | n\(?: and Erin\ | jamin \(?:& Erin Kitchin\ | Hunt\ | Kitchin\)\)\ | thany Nicholson\)\ | ha\(?:gyashree Lele\ | vana Rao\)\ | i\(?:hter Padak\ | ll \(?:Epling\ | Schneider\)\ | n\(?: Liu\ | g\(?:jun Xu\ | yun Li\)\)\)\ | o\(?: Li\ | b \(?:Ofoli (PhD 1994)\ | Tilton\)\ | jun Feng\ | yuan Liu\)\ | r\(?:a\(?:d Olsen\ | ulio Brunaud\)\ | ent Shanks\ | ian\(?: So\ | na Larkin\)\ | uce Mclaren\ | yan Goldsmith\)\ | ur\(?:cu Karagoz\ | ton Hollifield\)\)\ | C\(?:URRENT \(?:Alex Hallenbeck\ | Hari Thirumalai\ | Jacob Boes\ | Matt Palmer\ | Siddharth Deshpande\ | Venkatesh Naik\ | Zh\(?:aofeng Chen\ | ongnan Xu\)\)\ | a\(?:r\(?:l\(?: Laird\ | os Domene\)\ | ol Frieze\ | rie Farberow\ | sten \(?:Dominik\ | Sievers\)\)\ | sey Hetrick\ | thy Chin\)\ | h\(?:a\(?:ng\(?: Kim\ | sheng Su\)\ | o Wang\ | rl\(?:es S\(?:\(?:chroeder (B\.S\. 1999\ | tannier (PhD 2003\))\)\ | ie Sykes\)\ | yanit Choomwattana\)\ | e\(?:mE\(?: Faculty\ | -\(?:freshman\ | \(?:junior\ | s\(?:enior\ | ophomore\)\)s\)\)\ | n Wang\)\ | r\(?:is\(?: \(?:Bettinger\ | Herd\ | Jones\ | P\(?:ark\ | istorious\)\ | Wi\(?:l\(?:liams\ | mer\)\ | rth (PhD 2012)\)\)\ | t\(?:ina Cone\ | o\(?:doulos Floudas (PhD 1986)\ | pher \(?:Hanselman\ | W Jones\)\ | s Maravelias\)\)\)\ | ysanthos Gounaris\)\)\ | indy Vicker\ | liff Amundsen\ | o\(?:rey Leclerc\ | ur\(?:se Instructor\ | tney Bryant\)\)\ | ristiana Lara\ | urt Conner\ | ynthia \(?:\(?:L\ | Monac\)o\)\)\ | D\(?:ONE Matt Tirrell\ | a\(?:d\(?:y Dadyburjor\)?\ | mien Guironnet\ | n\(?: \(?:Hickman\ | Shantz\)\ | iel\(?: \(?:Armanios\ | Chen\ | Ginosar\ | Wu\)\ | le Wetzel\)\ | te Simonetti\)\ | r\(?:ragh Byrne\ | yll Velegol (PhD 1997)\)\ | vid \(?:D\(?:eLo\ | zombak\)\ | Flaherty\ | Graves\ | Hibbitts\ | Kaufer\ | W\. Greve\ | Yao\)\)\ | e\(?:an Ding\ | hao Zhu\ | n\(?:a Tsamitis\ | nis Prieve\)\ | von Walker\)\ | i\(?: Xiao\ | an\(?:\(?:a Marculesc\ | e Ngouno\)u\)\ | mitri Skliar\ | on Vlachos\)\ | o\(?: Heui Kim\ | n\(?: Sechler\ | g\(?:hai Mei\ | xia Liu\)\ | na Blackmond (PhD 1984)\)\ | uglas Sicker\)\ | ragomir Bukur\)\ | E\(?:azen Ren\ | d\(?:\(?:ward S\.\)? Rubin\)\ | lizabeth Biddinger\ | nrique Iglesia\ | r\(?:anda Nikolla\ | i\(?:c \(?:Altman\ | Doskocil\ | Furst (B\.S\. 1995)\ | Stangland\)\ | k Ydstie\)\)\ | velyn Fairman\)\ | F\(?:a\(?:bio Ribeiro\ | n Shi\)\ | e\(?:iyang Geng\ | ngqi You (PhD 2009)\ | rnando Resende\)\ | ikile Brushett\ | r\(?:ank\(?: Abild-Pedersen\ | lin \(?:Goldsmith\ | L\. Moon\)\)\ | ed Gilman\)\ | uat Celik\)\ | G\(?:RADUATED \(?:Anita Lee\ | Ethan Demeter\ | Frank DeCarlo\ | J\(?:ames Landon\ | ohn Michael\)\ | M\(?:atthew Curnan\ | e\(?:hak Chawla\ | iheng Lu\)\)\ | Ni\(?:lay Inoglu\ | tish Govindarajan\)\ | Prateek Mehta\ | Qingqi Fan\ | Rich Alesi\ | S\(?:neha Akhade\ | pencer Miller\ | teve Illes\)\ | Wenqin You\ | Zhizhong Ding\)\ | a\(?:briel\(?:a Cach\ | l\(?:a Farnham\ | e Wong-Parodi\)\)\ | len Fisher\ | ng Wu\)\ | e\(?:orge Huber\ | rry Katilius\)\ | iannis Mpourmpakis\ | ongda Ge\ | reg\(?: Rohrer\ | ory Michel\)\)\ | H\(?:a\(?:i\(?:bo Zhai\ | chao Wu\)\ | k Soo Shin\ | n Shui\ | oran Wen\ | ri \(?:Chandan Mantripragada\ | Nair\ | Thirumalai\)\)\ | e\(?:ather \(?:Depasquale\ | Kulik\ | Mayes\)\ | len\(?: Hong\ | a Hagelin-Weaver\)\)\ | ong\(?:fei Lin\ | liang Xin\ | qing Zhao\)\ | yung J\. Kim\)\ | I\(?: Ming Hsing\ | gnacio Grossmann\ | l Moon (PhD 1992)\ | nstructor account\ | r\(?:em Sen\ | ina Yu\)\ | s\(?:\(?:aac Jone\ | rael Wach\)s\)\)\ | J\(?:a\(?:ck Lyu\ | ewoo Lee (PhD 2000)\ | ke Boes\ | mes \(?:A\. Warren\ | Garrett\ | H\(?:am\ | oe\)\ | Ringer\ | Warren\)\ | n\(?: Lerou\ | a Kainerstorfer\ | et Latini\)\ | son \(?:H\(?:\(?:attrick-Simper\ | ick\)s\)\ | Lohn\)\ | vier Guzman\ | y\(?: \(?:Apt\ | Cheng Cheng\)\ | akiran Rebelli\)\)\ | e\(?:an-\(?:Philippe Tessonnier\ | Sabin McEwen\)\ | ff\(?: \(?:Greeley\ | Pierce (PhD 2008)\ | Rimer\)\ | rey \(?:Greeley\ | Siirola\)\)\ | lena Kovacevic\ | ns Norskov\ | ong Woo Han\ | remy Luterbacher\ | sse \(?:Bond\ | Hensley\)\)\ | i\(?:m\(?: \(?:Antaki\ | Garrett\ | \(?:Mill\ | Pfaendtn\ | Schneid\)er\)\ | my Williams\)\ | n\(?:gguang Chen\ | long Gong\ | soo Kim\)\ | yu Zhu\)\ | o\(?:e \(?:Holles\ | Pekny (PhD 1989)\ | Shaeiwitz\)\ | h\(?:annes Schwank\ | n \(?:Berg (B\.S\. 1960)\ | Caulkins\ | Danaher\ | Falconer\ | K\(?:eith\ | \(?:itchi\ | uh\)n\)\ | M\(?:\. Anderson\ | ichael\)\ | Regalbuto\ | Shabaker\ | V\(?:illarraga\ | olk\)\ | Walz (PhD 1992)\ | Zondlo\ | and Neetha Kitchin\)\)\ | n\(?: Bender\ | athan \(?:Calvello\ | Dordick\)\)\ | r\(?:ge \(?: Gatica\ | Gibson\)\ | is Thybaut\)\ | s\(?:e\(?: Cortes-Concepcion\ | ph Gomes\)\ | h\(?: Stolaroff\ | ua \(?:Ratts\ | Shodeinde\)\)\)\)\ | u\(?:dith Yang\ | lie Jung\ | nhang Dong\ | stin\(?: \(?:Dawber\ | Notestein\)\ | e Cassell\)\)\)\ | K\(?:a\(?:myar Keyvanloo\ | n\(?:g Wu\ | i\(?:ka Suri\ | shka Ghosh\)\)\ | rthikeyan Saravanan\ | shish Tayal\ | t\(?:h\(?:leen Schwarz\ | ryn \(?:Roeder\ | Whitehead\)\)\ | ie Whitefoot\)\ | ushik Dayal\)\ | e\(?:ith \(?:Hohn\ | W\(?:\. Hutchenson\ | ebster\)\)\ | l\(?:ly \(?:McQuoid\ | Rivers\)\ | vin Gregory\)\ | n\(?: Koedinger\ | \(?:ate Kemer\ | ji Shimad\)a\)\ | rry Dooley\ | shav Kasturi Rangan\)\ | halid Hajj\ | i\(?:-Hyouk Choi\ | nshuk Verma\ | shori Deshpande\)\ | ri\(?:s\(?: \(?:Dahl\ | Noel Dahl (B\.S\. 1998)\)\ | hna Kamasamudram\ | tina Wagstrom (Phd 2009)\)\ | thiknath Tirupapuliyur\)\ | yung Yoon\)\ | L\(?:a\(?:r\(?:ry Biegler\ | s Grabow\)\ | shanda Korley\ | ura Espinal\)\ | e\(?:ah Hildebrandt (PhD 2011)\ | \(?:o 'juniboy' Yo\ | vi Thomps\)on\)\ | i\(?:lo Pozzo (PhD 2006)\ | nda \(?:Broadbelt\ | C\. Babcock\)\ | sa \(?:Bullard (PhD 1991)\ | D'Costa\)\ | z Holm\)\ | o\(?:rrie Faith Cranor\ | uis Ayisi\)\ | uke Achenie (PhD 1988)\ | y\(?:dia Contreras\ | nn Walker\)\)\ | M\(?:a\(?:ggie Dang\ | l\(?:avika Thottappillil\ | com Stocks\)\ | nos Mavrikakis\ | r\(?:c \(?:De Graef\ | Garland\)\ | ek Skowronski\ | i\(?:a \(?:Curet-Arana\ | Flytzani-Stephanopoulos\ | Martinez\)\ | e Norman\)\ | k\(?: S\(?:\. Osler\ | aeys\)\ | us Eisenbach\)\ | sha Lovett\ | tin Green\)\ | tt\(?: \(?:C\(?:line\ | urnan\)\ | Kanan\ | Neurock\)\ | hew \(?:E\. Helgeson (B\.S\. 2004)\ | Yung\)\)\ | ureen Tang\(?: (B\.S\. 2007)\)?\ | ysam Chamanzar\)\ | e\(?:a\(?:gan Mauter\ | ve Higgins\)\ | ng\(?:-Ting Tsai\ | jia Qi\ | yuan \(?:Chen\ | Zhu\)\)\ | tin Turkay (PhD 1996)\ | yer, Randall J\)\ | i\(?:ch\(?:a\(?:el \(?:A\. \(?:\(?:(Cummins)\)? Smith\)\ | B\(?:ockstaller\ | ragg\)\ | Das\ | Janik\ | Trick\ | Wong\)\ | il Stamatakis\)\ | el\(?: Bezy\ | le O'Malley (B\.S\. 2004)\)\)\ | ke \(?:Bevan (PhD 1999)\ | Domach\ | Janik\ | McHenry\ | Timko\ | Widom\)\ | llicent Sullivan (PhD 2003)\ | ngkai Zhang\ | sna Sameer\ | tchell Groenenboom\)\ | o\(?:iz Bohra\ | rris Argyle\)\ | yung Jhon\)\ | N\(?:a\(?:ndini Ramachandran\ | than Khosla\ | vneet Singh\)\ | eil Donahue\ | i\(?:c\(?:holas \(?:Brush\ | Lamson\)\ | k \(?:Alvarez (PhD 2011)\ | Brunelli\ | Sahinidis\(?: (PhD 1990)\)?\)\)\ | e\(?: Teng\ | ls Theis Bendtsen\)\ | khil Apte\ | mmy Mathew\ | rmal Surendra Mundhada\ | vedha Seshadri\)\ | orm\(?: Wagner (B\.S\. 1984)\ | an Wilken\)\ | uno Oliveira\)\ | O\(?:l\(?:eg Sapunkov\ | iver Smith\)\ | s\(?:car Marin-Flores\ | man Mamum\)\ | zi Konkwo\)\ | P\(?:a\(?:blo Garcia\ | dmanabha Reddy\ | mela Connelly\ | rag  Kulkarni\ | ul\(?: \(?:Dauenhauer\ | S\(?:alvador\ | ides\)\)\ | a Davis\)\)\ | e\(?:rla B Balbuena\ | ter \(?:\(?:Adam\ | Smirnioti\)s\)\)\ | hil \(?:\(?:Christophe\ | Taylo\)r\)\ | ooja Bhalode\ | reeti Kamakoti\)\ | Qi\(?: Chen\ | n \(?:[GL]u\)\)\ | R\(?:a\(?:ch\(?:a?el Getman\)\ | j \(?:Gounder\ | Vora\)\ | kesh Govind (PhD 1977)\ | ndall \(?:Feenstra\ | \(?:Meye\ | Snur\)r\)\ | y Dagastine (PhD 2002)\)\ | e\(?:e\(?:ja Jayan\ | s Rankin (PhD 2006)\)\ | n\(?:e Bañares (PhD 1986)\ | u Sharma\)\)\ | hea Williams\ | ichard \(?:Scheines\ | West\)\ | o\(?:b\(?: Rioux\ | ert \(?:Grabowski\ | Heard\ | McCabe\ | Perry\ | Rioux\)\)\ | \(?:nald Michalsk\ | ss Swane\)y\)\ | uth Baltus\ | yan Hartman\)\ | S\(?:a\(?:chi Nagada\ | gar Sarsani\ | m\(?:ir Koppolu\ | ji Samira\)\ | njeev Rao\ | rah \(?:Christian\ | Narburgh\)\ | simas Katanyutanon\ | urabh \(?: Chaugule\ | Joshi\)\)\ | cott \(?:Barton\ | G\(?:old\ | uelcher (PhD 1999)\)\ | S\(?:hell (B\.S\. 2000)\ | tevens\)\)\ | e\(?:an \(?:Qian\ | Rommel\)\ | da Keskin (M\.S\. 2008)\ | pideh Faraji\)\ | h\(?:a\(?:nnon Boettcher\ | ran Shetty\ | wn Feist\)\ | elley Anna\(?: (B\.S\. Physics 1995)\)?\ | i\(?:jie Liu\ | rley Pavlischak\)\ | ylesh Pillai\)\ | i\(?:ddharth Deshpande\ | ris Laursen\ | yu Liu\)\ | oham Dutta\ | pyros Pandis\ | reejith Sasidharan\ | t\(?:a\(?:cy Birmingham (PhD 1988)\ | ff - \+dist\+~cc66/dlist/staff\. dl\)\ | e\(?:fano Curtarolo\ | phen Garoff\ | ven \(?:Crossley\ | Iasella\ | McIntosh\ | Saunders\)\)\ | ratos Pistikopoulos\)\ | u\(?: Ha\ | jan Shrestha\ | ljo Linic\ | m\(?:athy Raman\ | edh Beknalkar\)\ | r\(?:endran Assary, Rajeev\ | ya Mallapragada\)\ | san\(?: \(?:Polansky\ | Stagg-Williams\)\ | a C\.  Steppan\)\)\ | warun Kumar\)\ | T\(?:ODO \(?:Bill Schneider\ | Francois Baneyx\ | John Hedengren\ | Lashonda Korley\ | Marianthi Ierapetritou\ | Nasser Abukhdeir\ | Susanna Scott\)\ | a\(?:ejin Kim\ | \(?:mara Am\ | pas Pesh\)in\)\ | eng Ma\ | homas \(?:Bligaard\ | Francisco Jaramillo\ | Jaramillo\ | \(?:Man\ | Schwart\)z\)\ | i\(?:anyu Gao\ | m \(?:Brown  :ece-r:epp:\ | Daly\)\)\ | o\(?:dd Przybycien\ | m \(?:Bohman\ | Degnan\ | Jaramillo\)\ | n\(?:i Bechtel\ | y Rollett\)\)\ | y\(?:\(?: Walt\ | ler Josephs\)on\)\)\ | V\(?:a\(?:idyanathan Subramanian\ | \(?:run Mukthinuthalapat\ | tsal Mod\)i\)\ | enkat\(?: Viswanathan\ | esh Naik\)\ | i\(?:ctor Zavala (PhD 2008)\ | kram Pande\ | ncente Rico (PhD 1998)\)\ | ladimir Pushkarev\)\ | W\(?:ang Yang\ | e\(?:i Fan\ | n\(?:delin Stark\ | yang Lu\)\)\ | il\(?:fred Sieg\ | liam Alba\)\ | onyup Song\)\ | X\(?:i\(?:ang\(?:hong Qian\ | ying Liao\)\ | mena Olivares\ | n\(?:qian Li\ | rui Yu\ | yue Hong\)\)\ | uesong (Pine) Liu\)\ | Y\(?:-H\. Cathy Chin\ | a\(?:n\(?:an Wu\ | g Xiang\)\ | s\(?:\(?:asumi Iwasak\ | een Elkasab\)i\)\)\ | e Xu\ | i\(?: Liu\ | \(?:han Wa\ | mu Ya\ | ngkai So\)ng\)\ | o\(?:gesh Joshi\ | maira Pagan-Torres\ | shi Kawajiri (PhD 2007)\)\ | u\(?: Lei\ | -li Wang\ | long Deng\ | n\(?:-Ru Huang\ | li Han\)\ | peng Zhao\ | riy Roman\ | yu Yao\)\)\ | Z\(?:ach Blonder\ | h\(?:aofeng Chen\ | en\(?:an Bao\ | meng Peng\)\ | i\(?:\(?:qian Hua\ | yuan Che\)ng\)\)\ | i\(?:hao Chen\ | xi Zhao\)\ | o\(?:fia Tillman\ | nglin Yang\)\ | uo Zeng\)\) (0 (quote (face ((:background MistyRose1) (:underline t)) keymap (keymap (13 lambda nil (interactive) (eval (conditional-hydra-actions)) (org-contacts/body)) (mouse-1 lambda nil (interactive) (eval (conditional-hydra-actions)) (org-contacts/body))) button-lock t org-contact t mouse-face button-lock-mouse-face help-echo (lambda (window object position) (save-excursion (goto-char position) (let* ((name (get-surrounding-text-with-property (quote org-contact))) (contact (get-contact-from-name-or-nickname name)) (contact-marker (nth 1 contact)) (content )) (let ((wconfig (current-window-configuration))) (unwind-protect (progn (switch-to-buffer (marker-buffer contact-marker)) (goto-char (marker-position contact-marker)) (setq content (buffer-substring (org-element-property :begin (org-element-at-point)) (org-element-property :end (org-element-at-point))))) (set-window-configuration wconfig))) (format %s (%s)\n%s (cdr (assoc EMAIL (car (cdr (cdr contact))))) (cdr (assoc ALLTAGS (car (cdr (cdr contact))))) (substring content 0 200))))) rear-nonsticky t)) append)) (\(\w*\.\)?\w*@\w*\(\.\w*\)+ (0 (quote (face ((:background gray80 :underline t)) keymap (keymap (13 lambda nil (interactive) (clickable-email-hydra/body)) (mouse-1 lambda nil (interactive) (clickable-email-hydra/body))) button-lock t email-address t mouse-face button-lock-mouse-face help-echo click to send mu4e email rear-nonsticky t)) append)) (\<@\([-a-zA-Z0-9_:]*\)\> (0 (quote (face ((:background SlateGray1) (:underline t)) keymap (keymap (mouse-1 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote twitter)))) (string-match twitter-re s) (put-text-property (match-beginning 1) (match-end 1) (quote twitter-handle) (match-string-no-properties 1 s))) (twitter/body))) button-lock t twitter t mouse-face button-lock-mouse-face help-echo (lambda (window object pos) (interactive) (save-excursion (goto-char pos) (get-most-recent-tweet (substring-no-properties (get-surrounding-text-with-property (quote twitter)) 1)))) rear-nonsticky t)) append)) (org-font-lock-hook) (^\(\**\)\(\* \)\(.*\) (1 (org-get-level-face 1)) (2 (org-get-level-face 2)) (3 (org-get-level-face 3))) (^[ \n]*\(\( | \ | \+-[-+]\).*\S-\) (1 (quote org-table) t)) (^[ \n]* | \(?:.*? | \)? *\(:?=[^ | \n]*\) (1 (quote org-formula) t)) (^[ \n]* | *\([#*]\) * | (1 (quote org-formula) t)) (^[ \n]* | \( *\([$!_^/]\) * | .*\) | (1 (quote org-formula) t)) ( | *\(<[lrc]?[0-9]*>\) (1 (quote org-formula) t)) (^[ \n]*:\(PROPERTIES\ | CLOCK\ | LOGBOOK\ | RESULTS\):[ \n]*$ (0 (quote org-special-keyword) t)) (^[ \n]*:END: (0 (quote org-special-keyword) t)) (^\(?4:[ \n]*\)\(?1::\(?2:.*?\):\)\(?:\(?3:$\)\ | [ \n]+\(?3:.*?\)\)\(?5:[ \n]*\)$ (1 (quote org-special-keyword) t) (3 (quote org-property-value) t)) (org-activate-tags (1 (quote org-tag) prepend)) (org-activate-angle-links (0 (quote org-link) t)) (org-activate-plain-links (0 (quote org-link) t)) (org-activate-bracket-links (0 (quote org-link) t)) (org-activate-target-links (0 (quote org-link) t)) (org-activate-dates (0 (quote org-date) t)) (org-activate-footnote-links) (<<<?\([^<>\n\n]+\)>>>? (0 (quote org-target) t)) (^&?%%(.*\ | <%%([^>\n]*?> (0 (quote org-sexp-date) t)) ({{{.+}}} (0 (quote org-macro) t)) (org-hide-wide-columns (0 nil append)) (^\(\*+\)\(?: +\(TODO\ | DONE\ | CANCELLED\ | NEW\ | TODO\ | INCOMPLETE\ | READY\ | ASSIGNED\ | COMPLETED\ | DONE\ | SHORTLIST\ | NOTSUITABLE\ | SENIOR\)\)\(?: +\(.*?\)\)?[ \n]*$ (2 (org-get-todo-face 2) t)) (org-font-lock-add-priority-faces) (org-font-lock-add-tag-faces) (\<DEADLINE: (0 (quote org-special-keyword) t)) (\<SCHEDULED: (0 (quote org-special-keyword) t)) (\<CLOSED: (0 (quote org-special-keyword) t)) (\<CLOCK: (0 (quote org-special-keyword) t)) (org-do-emphasis-faces) (^[ \n]*\(?:[-+*]\ | [0-9]+[.)]\)[ \n]+\(?:\[@\(?:start:\)?[0-9]+\][ \n]*\)?\(\[[- X]\]\) 1 (quote org-checkbox) prepend) (\[\([0-9]*%\)\]\ | \[\([0-9]*\)/\([0-9]*\)\] (0 (org-get-checkbox-statistics-face) t)) (^[ \n]*[-+*][ \n]+\(.*?[ \n]+::\)\([ \n]+\ | $\) 1 (quote org-list-dt) prepend) (^\*+ \(.*:ARCHIVE:.*\) (1 (quote org-archived) prepend)) (org-do-latex-and-related) (org-fontify-entities) (org-raise-scripts) (org-activate-code (1 (quote org-code) t)) (^\(\*+\)\(?: +\(COMMENT\ | QUOTE\)\)\(?: +\(.*?\)\)?[ \n]*$ (2 (quote org-special-keyword) t)) (org-fontify-meta-lines-and-blocks) (:\(B_[a-z]+\ | BMCOL\): 1 (quote org-beamer-tag) prepend) (whitespace-point--flush-used) (\(\n+\) 1 whitespace-tab t) (whitespace-trailing-regexp 1 whitespace-trailing t) (\( +\)\(\n+\) 1 whitespace-space-before-tab t) (^\n*\(\( \{8\}\)+\)[^\n\n] 1 whitespace-indentation t) (\n+\(\( \{8\}\)+\) 1 whitespace-space-after-tab t) (\*+  0 (` (face org-link mouse-face highlight keymap (, org-mouse-map))) (quote prepend)) (^[ \n]*\([-+*]\ | [0-9]+[.)]\) + (1 (` (face org-link keymap (, org-mouse-map) mouse-face highlight)) (quote prepend))) (^[ \n]*\([-+*]\ | [0-9]+[.)]\) +\(\[[ X]\]\) (2 (` (face bold keymap (, org-mouse-map) mouse-face highlight)) t)) (\(eq\)?ref:\([a-zA-Z0-9-_:]*,?\)* (0 (quote org-ref-ref-face) prepend)) (label:\([a-zA-Z0-9-_:]*,?\)* (0 (quote org-ref-label-face) prepend)) (\(cite\ | nocite\ | citet\ | citet\*\ | citep\ | citep\*\ | citealt\ | citealt\*\ | citealp\ | citealp\*\ | citenum\ | citetext\ | citeauthor\ | citeauthor\*\ | citeyear\ | citeyear\*\ | Citet\ | Citep\ | Citealt\ | Citealp\ | Citeauthor\ | Cite\ | parencite\ | Parencite\ | footcite\ | footcitetext\ | textcite\ | Textcite\ | smartcite\ | Smartcite\ | cite\*\ | parencite\*\ | supercite\ | autocite\ | Autocite\ | autocite\*\ | Autocite\*\ | Citeauthor\*\ | citetitle\ | citetitle\*\ | citedate\ | citedate\*\ | citeurl\ | fullcite\ | footfullcite\ | notecite\ | Notecite\ | pnotecite\ | Pnotecite\ | fnotecite\ | cites\ | Cites\ | parencites\ | Parencites\ | footcites\ | footcitetexts\ | smartcites\ | Smartcites\ | textcites\ | Textcites\ | supercites\ | autocites\ | Autocites\ | bibentry\):\([a-zA-Z0-9-_:\./]*,?\)* (0 (quote org-ref-cite-face) prepend)) (\(\[\[\)?comment:\([^]]\)+\]?\[?\([^]]\)*\(\]\]\) (0 (quote org-comment-face) prepend))) | (match-next-foo (0 (quote new-face))) | (\(?: \(?:Billy Bardin\ | Concetta LaMarca\ | Ma\(?:r\(?:ianthi Ierapetritou\ | k Bendett\)\ | tt Tirrell\)\)\ | A\(?:aron \(?:Deskins\ | P\. Mitchell\ | Reinicker\)\ | bhishek Bagusetty\ | d\(?:am \(?:Feinberg\ | Holewinski\)\ | itya \(?:Bhan\ | Khair\ | Sinha\)\)\ | kshay Tharval\ | l\(?:an Pittler\ | bina Kwak\ | e\(?:ksandra Vojvodic\ | x\(?: \(?:\(?:L\ | Yokoch\)i\)\ | ander (Alex) Davis\)\)\ | i\(?:cia M\. Walsh\ | ssa Park\)\ | len Robinson\)\ | my \(?:Burkert\ | Desalazar\)\ | n\(?:a\(?:nya Chowdhury\ | stasios Angelopoulos\)\ | d\(?:re\(?:a\(?: \(?:Cohen\ | Farinacci\)\ | s \(?:Heyden\ | Waechter (PhD 2002)\)\)\ | w \(?:Adamczyk\ | Gellman\ | Jreissaty\ | M\(?:edford\ | oore\)\ | Peterson\ | \(?:Rapp\ | Ye\)e\)\)\ | y Hrymak\)\ | ita de Waard\ | n\(?:a Fisher\ | ette Jacobson\)\ | thon\(?:ia Raphael-Chieke\ | y Difrancesco\)\ | ushree Kamat\ | vitha Kandiraju\)\ | r\(?:avind Asthagiri\ | p\(?:ad Somogyvari\ | ita Iddya\)\ | up Chakraborty\)\ | sh\(?:faq Shaikh\ | ish Mhadeshwar\ | ok Kumar\ | win Thirumala Kumara\)\ | tharv Bhosekar\)\ | B\(?:e\(?:an Getsoian\ | hnam Bahrami\ | n\(?: and Erin\ | jamin \(?:& Erin Kitchin\ | Hunt\ | Kitchin\)\)\ | thany Nicholson\)\ | ha\(?:gyashree Lele\ | vana Rao\)\ | i\(?:hter Padak\ | ll \(?:Epling\ | Schneider\)\ | n\(?: Liu\ | g\(?:jun Xu\ | yun Li\)\)\)\ | o\(?: Li\ | b \(?:Ofoli (PhD 1994)\ | Tilton\)\ | jun Feng\ | yuan Liu\)\ | r\(?:a\(?:d Olsen\ | ulio Brunaud\)\ | ent Shanks\ | ian\(?: So\ | na Larkin\)\ | uce Mclaren\ | yan Goldsmith\)\ | ur\(?:cu Karagoz\ | ton Hollifield\)\)\ | C\(?:URRENT \(?:Alex Hallenbeck\ | Hari Thirumalai\ | Jacob Boes\ | Matt Palmer\ | Siddharth Deshpande\ | Venkatesh Naik\ | Zh\(?:aofeng Chen\ | ongnan Xu\)\)\ | a\(?:r\(?:l\(?: Laird\ | os Domene\)\ | ol Frieze\ | rie Farberow\ | sten \(?:Dominik\ | Sievers\)\)\ | sey Hetrick\ | thy Chin\)\ | h\(?:a\(?:ng\(?: Kim\ | sheng Su\)\ | o Wang\ | rl\(?:es S\(?:\(?:chroeder (B\.S\. 1999\ | tannier (PhD 2003\))\)\ | ie Sykes\)\ | yanit Choomwattana\)\ | e\(?:mE\(?: Faculty\ | -\(?:freshman\ | \(?:junior\ | s\(?:enior\ | ophomore\)\)s\)\)\ | n Wang\)\ | r\(?:is\(?: \(?:Bettinger\ | Herd\ | Jones\ | P\(?:ark\ | istorious\)\ | Wi\(?:l\(?:liams\ | mer\)\ | rth (PhD 2012)\)\)\ | t\(?:ina Cone\ | o\(?:doulos Floudas (PhD 1986)\ | pher \(?:Hanselman\ | W Jones\)\ | s Maravelias\)\)\)\ | ysanthos Gounaris\)\)\ | indy Vicker\ | liff Amundsen\ | o\(?:rey Leclerc\ | ur\(?:se Instructor\ | tney Bryant\)\)\ | ristiana Lara\ | urt Conner\ | ynthia \(?:\(?:L\ | Monac\)o\)\)\ | D\(?:ONE Matt Tirrell\ | a\(?:d\(?:y Dadyburjor\)?\ | mien Guironnet\ | n\(?: \(?:Hickman\ | Shantz\)\ | iel\(?: \(?:Armanios\ | Chen\ | Ginosar\ | Wu\)\ | le Wetzel\)\ | te Simonetti\)\ | r\(?:ragh Byrne\ | yll Velegol (PhD 1997)\)\ | vid \(?:D\(?:eLo\ | zombak\)\ | Flaherty\ | Graves\ | Hibbitts\ | Kaufer\ | W\. Greve\ | Yao\)\)\ | e\(?:an Ding\ | hao Zhu\ | n\(?:a Tsamitis\ | nis Prieve\)\ | von Walker\)\ | i\(?: Xiao\ | an\(?:\(?:a Marculesc\ | e Ngouno\)u\)\ | mitri Skliar\ | on Vlachos\)\ | o\(?: Heui Kim\ | n\(?: Sechler\ | g\(?:hai Mei\ | xia Liu\)\ | na Blackmond (PhD 1984)\)\ | uglas Sicker\)\ | ragomir Bukur\)\ | E\(?:azen Ren\ | d\(?:\(?:ward S\.\)? Rubin\)\ | lizabeth Biddinger\ | nrique Iglesia\ | r\(?:anda Nikolla\ | i\(?:c \(?:Altman\ | Doskocil\ | Furst (B\.S\. 1995)\ | Stangland\)\ | k Ydstie\)\)\ | velyn Fairman\)\ | F\(?:a\(?:bio Ribeiro\ | n Shi\)\ | e\(?:iyang Geng\ | ngqi You (PhD 2009)\ | rnando Resende\)\ | ikile Brushett\ | r\(?:ank\(?: Abild-Pedersen\ | lin \(?:Goldsmith\ | L\. Moon\)\)\ | ed Gilman\)\ | uat Celik\)\ | G\(?:RADUATED \(?:Anita Lee\ | Ethan Demeter\ | Frank DeCarlo\ | J\(?:ames Landon\ | ohn Michael\)\ | M\(?:atthew Curnan\ | e\(?:hak Chawla\ | iheng Lu\)\)\ | Ni\(?:lay Inoglu\ | tish Govindarajan\)\ | Prateek Mehta\ | Qingqi Fan\ | Rich Alesi\ | S\(?:neha Akhade\ | pencer Miller\ | teve Illes\)\ | Wenqin You\ | Zhizhong Ding\)\ | a\(?:briel\(?:a Cach\ | l\(?:a Farnham\ | e Wong-Parodi\)\)\ | len Fisher\ | ng Wu\)\ | e\(?:orge Huber\ | rry Katilius\)\ | iannis Mpourmpakis\ | ongda Ge\ | reg\(?: Rohrer\ | ory Michel\)\)\ | H\(?:a\(?:i\(?:bo Zhai\ | chao Wu\)\ | k Soo Shin\ | n Shui\ | oran Wen\ | ri \(?:Chandan Mantripragada\ | Nair\ | Thirumalai\)\)\ | e\(?:ather \(?:Depasquale\ | Kulik\ | Mayes\)\ | len\(?: Hong\ | a Hagelin-Weaver\)\)\ | ong\(?:fei Lin\ | liang Xin\ | qing Zhao\)\ | yung J\. Kim\)\ | I\(?: Ming Hsing\ | gnacio Grossmann\ | l Moon (PhD 1992)\ | nstructor account\ | r\(?:em Sen\ | ina Yu\)\ | s\(?:\(?:aac Jone\ | rael Wach\)s\)\)\ | J\(?:a\(?:ck Lyu\ | ewoo Lee (PhD 2000)\ | ke Boes\ | mes \(?:A\. Warren\ | Garrett\ | H\(?:am\ | oe\)\ | Ringer\ | Warren\)\ | n\(?: Lerou\ | a Kainerstorfer\ | et Latini\)\ | son \(?:H\(?:\(?:attrick-Simper\ | ick\)s\)\ | Lohn\)\ | vier Guzman\ | y\(?: \(?:Apt\ | Cheng Cheng\)\ | akiran Rebelli\)\)\ | e\(?:an-\(?:Philippe Tessonnier\ | Sabin McEwen\)\ | ff\(?: \(?:Greeley\ | Pierce (PhD 2008)\ | Rimer\)\ | rey \(?:Greeley\ | Siirola\)\)\ | lena Kovacevic\ | ns Norskov\ | ong Woo Han\ | remy Luterbacher\ | sse \(?:Bond\ | Hensley\)\)\ | i\(?:m\(?: \(?:Antaki\ | Garrett\ | \(?:Mill\ | Pfaendtn\ | Schneid\)er\)\ | my Williams\)\ | n\(?:gguang Chen\ | long Gong\ | soo Kim\)\ | yu Zhu\)\ | o\(?:e \(?:Holles\ | Pekny (PhD 1989)\ | Shaeiwitz\)\ | h\(?:annes Schwank\ | n \(?:Berg (B\.S\. 1960)\ | Caulkins\ | Danaher\ | Falconer\ | K\(?:eith\ | \(?:itchi\ | uh\)n\)\ | M\(?:\. Anderson\ | ichael\)\ | Regalbuto\ | Shabaker\ | V\(?:illarraga\ | olk\)\ | Walz (PhD 1992)\ | Zondlo\ | and Neetha Kitchin\)\)\ | n\(?: Bender\ | athan \(?:Calvello\ | Dordick\)\)\ | r\(?:ge \(?: Gatica\ | Gibson\)\ | is Thybaut\)\ | s\(?:e\(?: Cortes-Concepcion\ | ph Gomes\)\ | h\(?: Stolaroff\ | ua \(?:Ratts\ | Shodeinde\)\)\)\)\ | u\(?:dith Yang\ | lie Jung\ | nhang Dong\ | stin\(?: \(?:Dawber\ | Notestein\)\ | e Cassell\)\)\)\ | K\(?:a\(?:myar Keyvanloo\ | n\(?:g Wu\ | i\(?:ka Suri\ | shka Ghosh\)\)\ | rthikeyan Saravanan\ | shish Tayal\ | t\(?:h\(?:leen Schwarz\ | ryn \(?:Roeder\ | Whitehead\)\)\ | ie Whitefoot\)\ | ushik Dayal\)\ | e\(?:ith \(?:Hohn\ | W\(?:\. Hutchenson\ | ebster\)\)\ | l\(?:ly \(?:McQuoid\ | Rivers\)\ | vin Gregory\)\ | n\(?: Koedinger\ | \(?:ate Kemer\ | ji Shimad\)a\)\ | rry Dooley\ | shav Kasturi Rangan\)\ | halid Hajj\ | i\(?:-Hyouk Choi\ | nshuk Verma\ | shori Deshpande\)\ | ri\(?:s\(?: \(?:Dahl\ | Noel Dahl (B\.S\. 1998)\)\ | hna Kamasamudram\ | tina Wagstrom (Phd 2009)\)\ | thiknath Tirupapuliyur\)\ | yung Yoon\)\ | L\(?:a\(?:r\(?:ry Biegler\ | s Grabow\)\ | shanda Korley\ | ura Espinal\)\ | e\(?:ah Hildebrandt (PhD 2011)\ | \(?:o 'juniboy' Yo\ | vi Thomps\)on\)\ | i\(?:lo Pozzo (PhD 2006)\ | nda \(?:Broadbelt\ | C\. Babcock\)\ | sa \(?:Bullard (PhD 1991)\ | D'Costa\)\ | z Holm\)\ | o\(?:rrie Faith Cranor\ | uis Ayisi\)\ | uke Achenie (PhD 1988)\ | y\(?:dia Contreras\ | nn Walker\)\)\ | M\(?:a\(?:ggie Dang\ | l\(?:avika Thottappillil\ | com Stocks\)\ | nos Mavrikakis\ | r\(?:c \(?:De Graef\ | Garland\)\ | ek Skowronski\ | i\(?:a \(?:Curet-Arana\ | Flytzani-Stephanopoulos\ | Martinez\)\ | e Norman\)\ | k\(?: S\(?:\. Osler\ | aeys\)\ | us Eisenbach\)\ | sha Lovett\ | tin Green\)\ | tt\(?: \(?:C\(?:line\ | urnan\)\ | Kanan\ | Neurock\)\ | hew \(?:E\. Helgeson (B\.S\. 2004)\ | Yung\)\)\ | ureen Tang\(?: (B\.S\. 2007)\)?\ | ysam Chamanzar\)\ | e\(?:a\(?:gan Mauter\ | ve Higgins\)\ | ng\(?:-Ting Tsai\ | jia Qi\ | yuan \(?:Chen\ | Zhu\)\)\ | tin Turkay (PhD 1996)\ | yer, Randall J\)\ | i\(?:ch\(?:a\(?:el \(?:A\. \(?:\(?:(Cummins)\)? Smith\)\ | B\(?:ockstaller\ | ragg\)\ | Das\ | Janik\ | Trick\ | Wong\)\ | il Stamatakis\)\ | el\(?: Bezy\ | le O'Malley (B\.S\. 2004)\)\)\ | ke \(?:Bevan (PhD 1999)\ | Domach\ | Janik\ | McHenry\ | Timko\ | Widom\)\ | llicent Sullivan (PhD 2003)\ | ngkai Zhang\ | sna Sameer\ | tchell Groenenboom\)\ | o\(?:iz Bohra\ | rris Argyle\)\ | yung Jhon\)\ | N\(?:a\(?:ndini Ramachandran\ | than Khosla\ | vneet Singh\)\ | eil Donahue\ | i\(?:c\(?:holas \(?:Brush\ | Lamson\)\ | k \(?:Alvarez (PhD 2011)\ | Brunelli\ | Sahinidis\(?: (PhD 1990)\)?\)\)\ | e\(?: Teng\ | ls Theis Bendtsen\)\ | khil Apte\ | mmy Mathew\ | rmal Surendra Mundhada\ | vedha Seshadri\)\ | orm\(?: Wagner (B\.S\. 1984)\ | an Wilken\)\ | uno Oliveira\)\ | O\(?:l\(?:eg Sapunkov\ | iver Smith\)\ | s\(?:car Marin-Flores\ | man Mamum\)\ | zi Konkwo\)\ | P\(?:a\(?:blo Garcia\ | dmanabha Reddy\ | mela Connelly\ | rag  Kulkarni\ | ul\(?: \(?:Dauenhauer\ | S\(?:alvador\ | ides\)\)\ | a Davis\)\)\ | e\(?:rla B Balbuena\ | ter \(?:\(?:Adam\ | Smirnioti\)s\)\)\ | hil \(?:\(?:Christophe\ | Taylo\)r\)\ | ooja Bhalode\ | reeti Kamakoti\)\ | Qi\(?: Chen\ | n \(?:[GL]u\)\)\ | R\(?:a\(?:ch\(?:a?el Getman\)\ | j \(?:Gounder\ | Vora\)\ | kesh Govind (PhD 1977)\ | ndall \(?:Feenstra\ | \(?:Meye\ | Snur\)r\)\ | y Dagastine (PhD 2002)\)\ | e\(?:e\(?:ja Jayan\ | s Rankin (PhD 2006)\)\ | n\(?:e Bañares (PhD 1986)\ | u Sharma\)\)\ | hea Williams\ | ichard \(?:Scheines\ | West\)\ | o\(?:b\(?: Rioux\ | ert \(?:Grabowski\ | Heard\ | McCabe\ | Perry\ | Rioux\)\)\ | \(?:nald Michalsk\ | ss Swane\)y\)\ | uth Baltus\ | yan Hartman\)\ | S\(?:a\(?:chi Nagada\ | gar Sarsani\ | m\(?:ir Koppolu\ | ji Samira\)\ | njeev Rao\ | rah \(?:Christian\ | Narburgh\)\ | simas Katanyutanon\ | urabh \(?: Chaugule\ | Joshi\)\)\ | cott \(?:Barton\ | G\(?:old\ | uelcher (PhD 1999)\)\ | S\(?:hell (B\.S\. 2000)\ | tevens\)\)\ | e\(?:an \(?:Qian\ | Rommel\)\ | da Keskin (M\.S\. 2008)\ | pideh Faraji\)\ | h\(?:a\(?:nnon Boettcher\ | ran Shetty\ | wn Feist\)\ | elley Anna\(?: (B\.S\. Physics 1995)\)?\ | i\(?:jie Liu\ | rley Pavlischak\)\ | ylesh Pillai\)\ | i\(?:ddharth Deshpande\ | ris Laursen\ | yu Liu\)\ | oham Dutta\ | pyros Pandis\ | reejith Sasidharan\ | t\(?:a\(?:cy Birmingham (PhD 1988)\ | ff - \+dist\+~cc66/dlist/staff\. dl\)\ | e\(?:fano Curtarolo\ | phen Garoff\ | ven \(?:Crossley\ | Iasella\ | McIntosh\ | Saunders\)\)\ | ratos Pistikopoulos\)\ | u\(?: Ha\ | jan Shrestha\ | ljo Linic\ | m\(?:athy Raman\ | edh Beknalkar\)\ | r\(?:endran Assary, Rajeev\ | ya Mallapragada\)\ | san\(?: \(?:Polansky\ | Stagg-Williams\)\ | a C\.  Steppan\)\)\ | warun Kumar\)\ | T\(?:ODO \(?:Bill Schneider\ | Francois Baneyx\ | John Hedengren\ | Lashonda Korley\ | Marianthi Ierapetritou\ | Nasser Abukhdeir\ | Susanna Scott\)\ | a\(?:ejin Kim\ | \(?:mara Am\ | pas Pesh\)in\)\ | eng Ma\ | homas \(?:Bligaard\ | Francisco Jaramillo\ | Jaramillo\ | \(?:Man\ | Schwart\)z\)\ | i\(?:anyu Gao\ | m \(?:Brown  :ece-r:epp:\ | Daly\)\)\ | o\(?:dd Przybycien\ | m \(?:Bohman\ | Degnan\ | Jaramillo\)\ | n\(?:i Bechtel\ | y Rollett\)\)\ | y\(?:\(?: Walt\ | ler Josephs\)on\)\)\ | V\(?:a\(?:idyanathan Subramanian\ | \(?:run Mukthinuthalapat\ | tsal Mod\)i\)\ | enkat\(?: Viswanathan\ | esh Naik\)\ | i\(?:ctor Zavala (PhD 2008)\ | kram Pande\ | ncente Rico (PhD 1998)\)\ | ladimir Pushkarev\)\ | W\(?:ang Yang\ | e\(?:i Fan\ | n\(?:delin Stark\ | yang Lu\)\)\ | il\(?:fred Sieg\ | liam Alba\)\ | onyup Song\)\ | X\(?:i\(?:ang\(?:hong Qian\ | ying Liao\)\ | mena Olivares\ | n\(?:qian Li\ | rui Yu\ | yue Hong\)\)\ | uesong (Pine) Liu\)\ | Y\(?:-H\. Cathy Chin\ | a\(?:n\(?:an Wu\ | g Xiang\)\ | s\(?:\(?:asumi Iwasak\ | een Elkasab\)i\)\)\ | e Xu\ | i\(?: Liu\ | \(?:han Wa\ | mu Ya\ | ngkai So\)ng\)\ | o\(?:gesh Joshi\ | maira Pagan-Torres\ | shi Kawajiri (PhD 2007)\)\ | u\(?: Lei\ | -li Wang\ | long Deng\ | n\(?:-Ru Huang\ | li Han\)\ | peng Zhao\ | riy Roman\ | yu Yao\)\)\ | Z\(?:ach Blonder\ | h\(?:aofeng Chen\ | en\(?:an Bao\ | meng Peng\)\ | i\(?:\(?:qian Hua\ | yuan Che\)ng\)\)\ | i\(?:hao Chen\ | xi Zhao\)\ | o\(?:fia Tillman\ | nglin Yang\)\ | uo Zeng\)\) (0 (quote (face ((:background MistyRose1) (:underline t)) keymap (keymap (13 lambda nil (interactive) (eval (conditional-hydra-actions)) (org-contacts/body)) (mouse-1 lambda nil (interactive) (eval (conditional-hydra-actions)) (org-contacts/body))) button-lock t org-contact t mouse-face button-lock-mouse-face help-echo (lambda (window object position) (save-excursion (goto-char position) (let* ((name (get-surrounding-text-with-property (quote org-contact))) (contact (get-contact-from-name-or-nickname name)) (contact-marker (nth 1 contact)) (content )) (let ((wconfig (current-window-configuration))) (unwind-protect (progn (switch-to-buffer (marker-buffer contact-marker)) (goto-char (marker-position contact-marker)) (setq content (buffer-substring (org-element-property :begin (org-element-at-point)) (org-element-property :end (org-element-at-point))))) (set-window-configuration wconfig))) (format %s (%s)\n%s (cdr (assoc EMAIL (car (cdr (cdr contact))))) (cdr (assoc ALLTAGS (car (cdr (cdr contact))))) (substring content 0 200))))) rear-nonsticky t)) append)) | (\(\w*\.\)?\w*@\w*\(\.\w*\)+ (0 (quote (face ((:background gray80 :underline t)) keymap (keymap (13 lambda nil (interactive) (clickable-email-hydra/body)) (mouse-1 lambda nil (interactive) (clickable-email-hydra/body))) button-lock t email-address t mouse-face button-lock-mouse-face help-echo click to send mu4e email rear-nonsticky t)) append)) | (\<@\([-a-zA-Z0-9_:]*\)\> (0 (quote (face ((:background SlateGray1) (:underline t)) keymap (keymap (mouse-1 lambda nil (interactive) (let ((s (get-surrounding-text-with-property (quote twitter)))) (string-match twitter-re s) (put-text-property (match-beginning 1) (match-end 1) (quote twitter-handle) (match-string-no-properties 1 s))) (twitter/body))) button-lock t twitter t mouse-face button-lock-mouse-face help-echo (lambda (window object pos) (interactive) (save-excursion (goto-char pos) (get-most-recent-tweet (substring-no-properties (get-surrounding-text-with-property (quote twitter)) 1)))) rear-nonsticky t)) append)) | (org-font-lock-hook (0 nil)) | (^\(\**\)\(\* \)\(.*\) (1 (org-get-level-face 1)) (2 (org-get-level-face 2)) (3 (org-get-level-face 3))) | (^[ \n]*\(\( | \ | \+-[-+]\).*\S-\) (1 (quote org-table) t)) | (^[ \n]* | \(?:.*? | \)? *\(:?=[^ | \n]*\) (1 (quote org-formula) t)) | (^[ \n]* | *\([#*]\) * | (1 (quote org-formula) t)) | (^[ \n]* | \( *\([$!_^/]\) * | .*\) | (1 (quote org-formula) t)) | ( | *\(<[lrc]?[0-9]*>\) (1 (quote org-formula) t)) | (^[ \n]*:\(PROPERTIES\ | CLOCK\ | LOGBOOK\ | RESULTS\):[ \n]*$ (0 (quote org-special-keyword) t)) | (^[ \n]*:END: (0 (quote org-special-keyword) t)) | (^\(?4:[ \n]*\)\(?1::\(?2:.*?\):\)\(?:\(?3:$\)\ | [ \n]+\(?3:.*?\)\)\(?5:[ \n]*\)$ (1 (quote org-special-keyword) t) (3 (quote org-property-value) t)) | (org-activate-tags (1 (quote org-tag) prepend)) | (org-activate-angle-links (0 (quote org-link) t)) | (org-activate-plain-links (0 (quote org-link) t)) | (org-activate-bracket-links (0 (quote org-link) t)) | (org-activate-target-links (0 (quote org-link) t)) | (org-activate-dates (0 (quote org-date) t)) | (org-activate-footnote-links (0 nil)) | (<<<?\([^<>\n\n]+\)>>>? (0 (quote org-target) t)) | (^&?%%(.*\ | <%%([^>\n]*?> (0 (quote org-sexp-date) t)) | ({{{.+}}} (0 (quote org-macro) t)) | (org-hide-wide-columns (0 nil append)) | (^\(\*+\)\(?: +\(TODO\ | DONE\ | CANCELLED\ | NEW\ | TODO\ | INCOMPLETE\ | READY\ | ASSIGNED\ | COMPLETED\ | DONE\ | SHORTLIST\ | NOTSUITABLE\ | SENIOR\)\)\(?: +\(.*?\)\)?[ \n]*$ (2 (org-get-todo-face 2) t)) | (org-font-lock-add-priority-faces (0 nil)) | (org-font-lock-add-tag-faces (0 nil)) | (\<DEADLINE: (0 (quote org-special-keyword) t)) | (\<SCHEDULED: (0 (quote org-special-keyword) t)) | (\<CLOSED: (0 (quote org-special-keyword) t)) | (\<CLOCK: (0 (quote org-special-keyword) t)) | (org-do-emphasis-faces (0 nil)) | (^[ \n]*\(?:[-+*]\ | [0-9]+[.)]\)[ \n]+\(?:\[@\(?:start:\)?[0-9]+\][ \n]*\)?\(\[[- X]\]\) (1 (quote org-checkbox) prepend)) | (\[\([0-9]*%\)\]\ | \[\([0-9]*\)/\([0-9]*\)\] (0 (org-get-checkbox-statistics-face) t)) | (^[ \n]*[-+*][ \n]+\(.*?[ \n]+::\)\([ \n]+\ | $\) (1 (quote org-list-dt) prepend)) | (^\*+ \(.*:ARCHIVE:.*\) (1 (quote org-archived) prepend)) | (org-do-latex-and-related (0 nil)) | (org-fontify-entities (0 nil)) | (org-raise-scripts (0 nil)) | (org-activate-code (1 (quote org-code) t)) | (^\(\*+\)\(?: +\(COMMENT\ | QUOTE\)\)\(?: +\(.*?\)\)?[ \n]*$ (2 (quote org-special-keyword) t)) | (org-fontify-meta-lines-and-blocks (0 nil)) | (:\(B_[a-z]+\ | BMCOL\): (1 (quote org-beamer-tag) prepend)) | (whitespace-point--flush-used (0 nil)) | (\(\n+\) (1 whitespace-tab t)) | (whitespace-trailing-regexp (1 whitespace-trailing t)) | (\( +\)\(\n+\) (1 whitespace-space-before-tab t)) | (^\n*\(\( \{8\}\)+\)[^\n\n] (1 whitespace-indentation t)) | (\n+\(\( \{8\}\)+\) (1 whitespace-space-after-tab t)) | (\*+  (0 (` (face org-link mouse-face highlight keymap (, org-mouse-map))) (quote prepend))) | (^[ \n]*\([-+*]\ | [0-9]+[.)]\) + (1 (` (face org-link keymap (, org-mouse-map) mouse-face highlight)) (quote prepend))) | (^[ \n]*\([-+*]\ | [0-9]+[.)]\) +\(\[[ X]\]\) (2 (` (face bold keymap (, org-mouse-map) mouse-face highlight)) t)) | (\(eq\)?ref:\([a-zA-Z0-9-_:]*,?\)* (0 (quote org-ref-ref-face) prepend)) | (label:\([a-zA-Z0-9-_:]*,?\)* (0 (quote org-ref-label-face) prepend)) | (\(cite\ | nocite\ | citet\ | citet\*\ | citep\ | citep\*\ | citealt\ | citealt\*\ | citealp\ | citealp\*\ | citenum\ | citetext\ | citeauthor\ | citeauthor\*\ | citeyear\ | citeyear\*\ | Citet\ | Citep\ | Citealt\ | Citealp\ | Citeauthor\ | Cite\ | parencite\ | Parencite\ | footcite\ | footcitetext\ | textcite\ | Textcite\ | smartcite\ | Smartcite\ | cite\*\ | parencite\*\ | supercite\ | autocite\ | Autocite\ | autocite\*\ | Autocite\*\ | Citeauthor\*\ | citetitle\ | citetitle\*\ | citedate\ | citedate\*\ | citeurl\ | fullcite\ | footfullcite\ | notecite\ | Notecite\ | pnotecite\ | Pnotecite\ | fnotecite\ | cites\ | Cites\ | parencites\ | Parencites\ | footcites\ | footcitetexts\ | smartcites\ | Smartcites\ | textcites\ | Textcites\ | supercites\ | autocites\ | Autocites\ | bibentry\):\([a-zA-Z0-9-_:\./]*,?\)* (0 (quote org-ref-cite-face) prepend)) | (\(\[\[\)?comment:\([^]]\)+\]?\[?\([^]]\)*\(\]\]\) (0 (quote org-comment-face) prepend)) |

foo  foo

foo
here a foo there a foo everywhre a foo foo.
a foo is here. a foo bear.




* Using font-lock for toggling links

http://stackoverflow.com/questions/14668225/context-sensitive-font-locking-in-emacs

org-any-link-re





#+BEGIN_SRC emacs-lisp
(defun org-match-next-link (&optional limit)
(org-next-link)

)

(defun org-link-entered (old-point new-point)
 (message-box "Entered a link %s %s" old-point new-point))

(defun org-link-left (old-point new-point)
 (message-box "Left a link %s %s" old-point new-point))

(defface org-link-entry-face
`((t (:inherit org-link :point-entered org-link-entered)))
"face with point-entered property")


;(font-lock-add-keywords 'org-mode '((org-match-next-link 0 org-link-entry-face)))

(org-match-next-link)
#+END_SRC

#+RESULTS:

file:blog.org



* Get all done headings in a new buffer

By TODO keyword.
#+BEGIN_SRC emacs-lisp
(let ((entries (org-map-entries
		(lambda ()
		  (save-restriction
		    (org-narrow-to-subtree)
		    (buffer-string)))
		"TODO=\"DONE\"")))
  (switch-to-buffer (get-buffer-create "new"))
  (org-mode)
  (mapcar 'insert entries))
#+END_SRC

#+RESULTS:
: (#<marker at 417 in blog.org> #<marker at 437 in blog.org> nil nil nil nil nil nil nil nil nil nil nil nil nil nil #<marker at 417 in blog.org> #<marker at 437 in blog.org> #<marker at 417 in blog.org> #<marker at 421 in blog.org> #<marker at 422 in blog.org> #<marker at 437 in blog.org> #<marker at 436 in blog.org> #<marker at 437 in blog.org>)

* DONE Automatic latex image toggling when cursor is on a fragment
  CLOSED: [2015-10-09 Fri 11:54]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/10/09 11:54:50
  :updated:  2015/10/09 11:54:50
  :END:

There was a recent suggestion on the org-mode mailing list to make it possible to toggle individual equations in org-mode when the cursor is on them, and have them toggle back when the mouse is off. Presumably, this would let you edit the equation and see the result very easily.

The strategy to enable this is to use add a function to the post-command function hook. The function will store the last fragment/environment you were on, and compare it to where you are now.  If they are different the function will put the overlay back on the previous point, and do something appropriate at the current point, e.g. nothing if you are not on a fragment, or remove the overlay of the fragment you are on. The function will get run after every command, so we make sure we are in org-mode first!

Here are some example equations.

Here is a sentence with an equation $f^{2x}=3$ and another form \(e^x = 20\) in it.

Here is a standalone equation environment.

\begin{equation}
a + b \sqrt{5o}
\end{equation}

And now, \[15 + 7 = 12\],

It is easiest to see this in a video here: https://www.youtube.com/watch?v=E0s3PDBqsEc

#+BEGIN_SRC emacs-lisp
(defvar org-latex-fragment-last nil
  "Holds last fragment/environment you were on.")

(defun org-latex-fragment-toggle ()
  "Toggle a latex fragment image "
  (and (eq 'org-mode major-mode)
       (let* ((el (org-element-context))
	      (el-type (car el)))
	 (cond
	  ;; were on a fragment and now on a new fragment
	  ((and
	    ;; fragment we were on
	    org-latex-fragment-last
	    ;; and are on a fragment now
	    (or
	     (eq 'latex-fragment el-type)
	     (eq 'latex-environment el-type))
	    ;; but not on the last one this is a little tricky. as you edit the
	    ;; fragment, it is not equal to the last one. We use the begin
	    ;; property which is less likely to change for the comparison.
	    (not (= (org-element-property :begin el)
		    (org-element-property :begin org-latex-fragment-last))))
	   ;; go back to last one and put image back
	   (save-excursion
	     (goto-char (org-element-property :begin org-latex-fragment-last))
	     (org-preview-latex-fragment))
	   ;; now remove current image
           (goto-char (org-element-property :begin el))
	   (let ((ov (loop for ov in org-latex-fragment-image-overlays
			   if
			   (and
			    (<= (overlay-start ov) (point))
			    (>= (overlay-end ov) (point)))
			   return ov)))
	     (when ov
	       (delete-overlay ov)))
	   ;; and save new fragment
	   (setq org-latex-fragment-last el))

	  ;; were on a fragment and now are not on a fragment
	  ((and
	    ;; not on a fragment now
	    (not (or
		  (eq 'latex-fragment el-type)
		  (eq 'latex-environment el-type)))
	    ;; but we were on one
	    org-latex-fragment-last)
	   ;; put image back on
	   (save-excursion
	     (goto-char (org-element-property :begin org-latex-fragment-last))
	     (org-preview-latex-fragment))
	   ;; unset last fragment
	   (setq org-latex-fragment-last nil))

	  ;; were not on a fragment, and now are
	  ((and
	    ;; we were not one one
	    (not org-latex-fragment-last)
	    ;; but now we are
	    (or
	     (eq 'latex-fragment el-type)
	     (eq 'latex-environment el-type)))
	   (goto-char (org-element-property :begin el))
           ;; remove image
	   (let ((ov (loop for ov in org-latex-fragment-image-overlays
			   if
			   (and
			    (<= (overlay-start ov) (point))
			    (>= (overlay-end ov) (point)))
			   return ov)))
	     (when ov
	       (delete-overlay ov)))
	   (setq org-latex-fragment-last el))))))


(add-hook 'post-command-hook 'org-latex-fragment-toggle)
#+END_SRC

#+RESULTS:
| org-latex-fragment-toggle | matlab-start-block-highlight-timer | eldoc-schedule-timer |


I think there could be another way to do this with text properties, e.g. point-left and point-entered, but that would require those properties to be set on the fragments. I might try that approach another day.


* Exploring the Python AST
[[http://stackoverflow.com/questions/1515357/simple-example-of-how-to-use-ast-nodevisitor][python - Simple example of how to use ast.NodeVisitor? - Stack Overflow]]

#+BEGIN_SRC python
import ast

def str_node(node):
    if isinstance(node, ast.AST):
        fields = [(name, str_node(val)) for name, val in ast.iter_fields(node) if name not in ('left', 'right')]
        rv = '%s(%s' % (node.__class__.__name__, ', '.join('%s=%s' % field for field in fields))
        return rv + ')'
    else:
        return repr(node)

def ast_visit(node, level=0):
    print('  ' * level + str_node(node))
    for field, value in ast.iter_fields(node):
        if isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    ast_visit(item, level=level+1)
        elif isinstance(value, ast.AST):
            ast_visit(value, level=level+1)


# ast_visit(ast.parse('a=5; b=a+1; a+b'))
print
ast_visit(ast.parse('''
def f(a, b):
    return a + b
f(5, 4)'''))
#+END_SRC

#+RESULTS:
#+begin_example

Module(body=[<_ast.FunctionDef object at 0x1004c0f50>, <_ast.Expr object at 0x1004c5190>])
  FunctionDef(name='f', args=arguments(args=[<_ast.Name object at 0x1004c0fd0>, <_ast.Name object at 0x1004c5050>], vararg=None, kwarg=None, defaults=[]), body=[<_ast.Return object at 0x1004c5090>], decorator_list=[])
    arguments(args=[<_ast.Name object at 0x1004c0fd0>, <_ast.Name object at 0x1004c5050>], vararg=None, kwarg=None, defaults=[])
      Name(id='a', ctx=Param())
        Param()
      Name(id='b', ctx=Param())
        Param()
    Return(value=BinOp(op=Add()))
      BinOp(op=Add())
        Name(id='a', ctx=Load())
          Load()
        Add()
        Name(id='b', ctx=Load())
          Load()
  Expr(value=Call(func=Name(id='f', ctx=Load()), args=[<_ast.Num object at 0x1004c5250>, <_ast.Num object at 0x1004c5290>], keywords=[], starargs=None, kwargs=None))
    Call(func=Name(id='f', ctx=Load()), args=[<_ast.Num object at 0x1004c5250>, <_ast.Num object at 0x1004c5290>], keywords=[], starargs=None, kwargs=None)
      Name(id='f', ctx=Load())
        Load()
      Num(n=5)
      Num(n=4)
#+end_example



#+BEGIN_SRC python
import ast

def str_node(node):
    if isinstance(node, ast.AST):
        fields = [(name, str_node(val)) for name, val in ast.iter_fields(node) if name not in ('left', 'right')]
        rv = '%s(%s' % (node.__class__.__name__, ', '.join('%s=%s' % field for field in fields)) + ')'
        if isinstance(node, ast.expr):
            rv += '\nline {0} col {1}'.format(node.lineno, node.col_offset)
        return rv
    else:
        return repr(node)

def ast_visit(node, level=0):
    print('  ' * level + str_node(node))
    for field, value in ast.iter_fields(node):
        if isinstance(value, list):
            for item in value:
                if isinstance(item, ast.AST):
                    ast_visit(item, level=level+1)
        elif isinstance(value, ast.AST):
            ast_visit(value, level=level+1)


# ast_visit(ast.parse('a=5; b=a+1; a+b'))
print
ast_visit(ast.parse('''import numpy as np

a = np.array([5, 6, 7])
b = np.array([5, 6, 7])

print(np.dot(a, b))'''))
#+END_SRC

#+RESULTS:
#+begin_example

Module(body=[<_ast.Import object at 0x1004c0f50>, <_ast.Assign object at 0x1004c0fd0>, <_ast.Assign object at 0x1004c5250>, <_ast.Print object at 0x1004c5490>])
  Import(names=[<_ast.alias object at 0x1004c0f90>])
    alias(name='numpy', asname='np')
  Assign(targets=[<_ast.Name object at 0x1004c5050>], value=Call(func=Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4, args=[<_ast.List object at 0x1004c5150>], keywords=[], starargs=None, kwargs=None)
line 3 col 4)
    Name(id='a', ctx=Store())
line 3 col 0
      Store()
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4, args=[<_ast.List object at 0x1004c5150>], keywords=[], starargs=None, kwargs=None)
line 3 col 4
      Attribute(value=Name(id='np', ctx=Load())
line 3 col 4, attr='array', ctx=Load())
line 3 col 4
        Name(id='np', ctx=Load())
line 3 col 4
          Load()
        Load()
      List(elts=[<_ast.Num object at 0x1004c5190>, <_ast.Num object at 0x1004c51d0>, <_ast.Num object at 0x1004c5210>], ctx=Load())
line 3 col 13
        Num(n=5)
line 3 col 14
        Num(n=6)
line 3 col 17
        Num(n=7)
line 3 col 20
        Load()
  Assign(targets=[<_ast.Name object at 0x1004c5290>], value=Call(func=Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4, args=[<_ast.List object at 0x1004c5390>], keywords=[], starargs=None, kwargs=None)
line 4 col 4)
    Name(id='b', ctx=Store())
line 4 col 0
      Store()
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4, args=[<_ast.List object at 0x1004c5390>], keywords=[], starargs=None, kwargs=None)
line 4 col 4
      Attribute(value=Name(id='np', ctx=Load())
line 4 col 4, attr='array', ctx=Load())
line 4 col 4
        Name(id='np', ctx=Load())
line 4 col 4
          Load()
        Load()
      List(elts=[<_ast.Num object at 0x1004c53d0>, <_ast.Num object at 0x1004c5410>, <_ast.Num object at 0x1004c5450>], ctx=Load())
line 4 col 13
        Num(n=5)
line 4 col 14
        Num(n=6)
line 4 col 17
        Num(n=7)
line 4 col 20
        Load()
  Print(dest=None, values=[<_ast.Call object at 0x1004c54d0>], nl=True)
    Call(func=Attribute(value=Name(id='np', ctx=Load())
line 6 col 6, attr='dot', ctx=Load())
line 6 col 6, args=[<_ast.Name object at 0x1004c5590>, <_ast.Name object at 0x1004c55d0>], keywords=[], starargs=None, kwargs=None)
line 6 col 6
      Attribute(value=Name(id='np', ctx=Load())
line 6 col 6, attr='dot', ctx=Load())
line 6 col 6
        Name(id='np', ctx=Load())
line 6 col 6
          Load()
        Load()
      Name(id='a', ctx=Load())
line 6 col 13
        Load()
      Name(id='b', ctx=Load())
line 6 col 16
        Load()
#+end_example


* DONE COMPLETED A checkbox list in org-mode with one value
  CLOSED: [2015-10-07 Wed 11:56]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/10/05 19:15:25
  :updated:  2015/10/05 19:15:25
  :END:

A while ago I had a need for a checklist in org-mode where only one value would be checked at a time. Like a radio button in a browser form. That isn't as far as I know a feature yet, but it was not hard to achieve thanks to the org-element api.  My simple idea is to make a function that will be added to the org-checkbox-statistics-hook. The function will uncheck all the boxes, and recheck the one you just clicked with a hybrid of manipulating the cursor and inserting characters with org-element code. We will use an attribute on the checklist to indicate it is a "radio" list. This seems like a feature that might already exist, but I couldn't find it.

Here is the code we run. First, we make sure we are on a plain list that has an attr_org property of ":radio", that way this won't apply to all lists, just the radio lists. Then, we loop through each element in the structure, and if it is checked, we replace [X] with [ ]. Then, we reinsert the X and delete a space, which puts [X] where we originally clicked, or used C-c C-c. Finally, we add it to the hook, so it only gets run when a checkbox is changed via clicking with org-mouse, or C-c C-c. Of course, this doesn't work if you type X in the box.

#+BEGIN_SRC emacs-lisp
(require 'dash)
(defun check-hook-fn ()
  (when (-contains? (org-element-property
		     :attr_org
		     (org-element-property :parent (org-element-context)))
		    ":radio")
    (save-excursion
      (loop for el in (org-element-property :structure (org-element-context))
	    do
	    (goto-char (car el))
	    (when (re-search-forward "\\[X\\]" (line-end-position) t)
	      (replace-match "[ ]"))))
    (forward-char)
    (insert "X")
    (delete-char 1)))

(add-hook 'org-checkbox-statistics-hook 'check-hook-fn)
#+END_SRC

#+RESULTS:
| check-hook-fn |

Here is a regular checklist. You can check as many as you want.
- [X] one
- [X] two
- [ ] three

Now, here is a radio checklist. Only one item at a time can be checked. Nice!

#+attr_org: :radio
#+name: test
: hello world
: Fri Nov 20 06:14:45 2015

It is worth noting here that if we put a name on the list, it becomes an addressable data source. First we need this convenient function to get the data associated with a named list.

#+BEGIN_SRC emacs-lisp
(defun org-get-plain-list (name)
  "Get the org-element representation of a plain-list with NAME."
  (catch 'found
    (org-element-map
	(org-element-parse-buffer)
	'plain-list
      (lambda (plain-list)
	(when
	    (string= name (org-element-property :name plain-list))
	  (throw 'found plain-list))))))
#+END_SRC

#+RESULTS:
: org-get-plain-list

Now, let's use that to get the value of the checked item in the "test" list. We define the item as everything after the [X] and get it from a regular expression match.

#+BEGIN_SRC emacs-lisp
(defun get-radio-list-value (list-name)
  "Return the value of the checked item in a radio list."
  (save-excursion
    (loop for el in (org-element-property
		     :structure
		     (org-jump-to-plain-list list-name))
	  if (string= (nth 4 el) "[X]")
	  return (progn
		   (let ((item (buffer-substring (car el) (car (last el)))))
		     (string-match "\\[X\\]\\(.*\\)$" item)
		     (match-string 1 item))))))

(get-radio-list-value "test")
#+END_SRC

#+RESULTS:
:  c

Perfect. This has lots of potential applications. Data collection and quizzes come to mind, with associated ability to autograde and aggregate the data!


* DONE A framework for automated feedback with Python and org-mode
  CLOSED: [2015-10-03 Sat 20:23]
  :PROPERTIES:
  :categories: emacs,python
  :date:     2015/10/03 20:23:29
  :updated:  2015/10/03 20:29:00
  :END:

[[http://docs.autolab.cs.cmu.edu][Autolab]] is an autograding service that automatically grades code assignments. It uses a program to evaluate a program on a secure virtual system. Using this requires you to run a server, and run code from students. I have never liked that because it is hard to sandbox code well enough to prevent malicious code from doing bad things. Autolab does it well, but it is a heavy solution. Here we explore a local version, one that is used to test for correctness, and not for grading. Here, if you are malicious, you reap what you sow...

The basic idea I am working towards is that Emacs will provide content to be learned (through org-mode) with active exercises. The exercises will involve a code block, and the user will run a command on their code (or an advised C-c C-c) that checks the solution for correctness. A user will be able to see the solution, and maybe get hints.

Suppose we have a problem to solve $e^x = 3$. This is a simple problem to solve, and here is a solution.

#+BEGIN_SRC python
from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)

print solve()
#+END_SRC

#+RESULTS:
: [ 1.09861229]

We would like to test this for correctness. We code this in a function-based form because we will later use the function =solve= to test for correctness. Let's see how we could test it with a test function. We will use exec on a string representing our code to get it into our namespace. I don't see a security issue here. You are writing the code! Eventually, we will be passing code to the test framework this way from an org-mode source block.

#+BEGIN_SRC python
import unittest
TOLERANCE = 1e-5

s = '''from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()'''

def test_solve(s):
    exec s in globals()
    if (abs(np.log(3) - solve()) <= TOLERANCE):
        print('Correct')
    else:
        print('incorrect')

test_solve(s)
#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct

Next, we need to think about how we could generate an import statement from a code block name, import in python, and run a test function. We can assume that the test code will be in a file called "test_%s.py" on your python path. Here are the contents of test_solve.py.

#+BEGIN_SRC python :tangle test_solve.py
import numpy as np
TOLERANCE = 1e-5

def solve_solution():
    from scipy. optimize import fsolve
    import numpy as np

    def objective(x):
        return np.exp(x) - 3

    return fsolve(objective, 3)[0]


def test_solve(s):
    exec s in globals()
    if (abs(solve_solution() - solve()) <= TOLERANCE):
        print('Correct!')
    else:
        print('Incorrect')
#+END_SRC

#+RESULTS:

Now, we can import that, and use the functions. Here is the Python script we need to run to test it.

#+BEGIN_SRC python
import test_solve
test_solve.test_solve('''
from scipy. optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()''')
#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct!

Now, an elisp block to do that. One way to do this is to just run a shell command passing the string to a python interpreter. This is a short way away from an Emacs command now.

#+BEGIN_SRC emacs-lisp
(let* ((string "import test_solve
test_solve.test_solve('''
from scipy. optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)[0]

print solve()''')"))
  (shell-command-to-string (format "python -c \"%s\"" string)))

#+END_SRC

#+RESULTS:
: 1.09861228867
: Correct!

Ok, now to wrap it all up in a function we can run from Emacs in a code block to test it. With the cursor in a code block, we get the name, and build the python code, and run it. The function is more complex than I anticipated because I end up  running the code block essentially twice, once to get a results block and once to get the test results. For short problems this is not an issue. I also add the test results in a way that is compatible with the current results.

#+BEGIN_SRC emacs-lisp
(defun check ()
  (interactive)
  (let* ((src-block (org-element-context))
	 (name (org-element-property :name src-block))
	 (code (org-element-property :value src-block))
         (end (org-element-property :end src-block))
	 (results)
	 (template (format "import test_%s
test_%s.test_%s('''%s''')" name name name code))
	 (output (format
		  "\n%s\n"
		  (s-join
		   "\n"
		   (mapcar
		    (lambda (s)
		      (if (s-starts-with? ":" s)
			  s
			(concat ": " s)))
		    (s-split
		     "\n"
		     (shell-command-to-string
		      (format "python -c \"%s\"" template))))))))
    ;; execute block as normal
    (org-babel-execute-src-block)
    ;; and add some output to the Results block
    (if (org-babel-where-is-src-block-result)
	(progn
	  (goto-char (org-babel-where-is-src-block-result))
	  (setq results (org-element-context))
	  ;; delete results line
          (kill-line)
	  ;;  delete the results
	  (setf (buffer-substring (org-element-property :begin results)
				  (org-element-property :post-affiliated results))
		"")
	  ;; paste results line back
          (yank)
	  ;; and the output from your code
          (insert output))
      (message "%s" output))))
#+END_SRC

#+RESULTS:
: check

Now, we use a named src-block so we can call M-x check in it, and check the answer.

#+name: solve
#+BEGIN_SRC python :results output
from scipy.optimize import fsolve
import numpy as np

def objective(x):
    return np.exp(x) - 3

def solve():
    return fsolve(objective, 3)

print solve()
#+END_SRC

#+RESULTS: solve
: [ 1.09861229]
: Correct!
:

I would like to be able to provide a solution function that would show a user my solution they were tested against. Python provides the =inspect= module that can do this. Here is how we get the code in Python.

#+BEGIN_SRC python
import inspect
import test_solve

print inspect.getsource(test_solve.solve_solution)
#+END_SRC

#+RESULTS:
: def solve_solution():
:     from scipy. optimize import fsolve
:     import numpy as np
:
:     def objective(x):
:         return np.exp(x) - 3
:
:     return fsolve(objective, 3)[0]
:

This makes it easy to wrap up a function in emacs that will show this from at src block. We just get the block name, and build the python code and execute it here.

#+BEGIN_SRC emacs-lisp
(defun show-solution ()
  (interactive)
  (let* ((src-block (org-element-context))
	 (name (org-element-property :name src-block))
	 (template (format  "import inspect
import test_%s

print inspect.getsource(test_%s.%s_solution)" name name name)))
    (switch-to-buffer-other-window (get-buffer-create "solution"))
    (erase-buffer)
    (insert (shell-command-to-string
	     (format "python -c \"%s\"" template)))
    (python-mode)))
#+END_SRC

#+RESULTS:
: show-solution

That summarizes the main features. It allows me to write a test module that has some name conventions to define a solution function, and a test function. Emacs can generate some boilerplate code for different problem names, and run the test to give the user some feedback. Most of the code in this post would not be directly visible to a user, it would be buried in a python module somewhere on the path, and in elisp files providing the glue. I am not sure how much obfuscation you can put in the python files, e.g. just providing byte-compiled code, so it is less easy to just read it. That is not as big a deal when it is just a study guide/feedback system.

From an authoring point of view, this seems pretty good to me. It is feasible I think to write an org-source document like this with tangling for the test modules, and an export to org that does not have the solutions in it. The only subtle point might be needing to alter Python paths to find the test modules if they aren't installed via something like pip.


I think this is pretty flexible, and could handle problems that take arguments, e.g. write a function that sorts a list. Here is a simple example of that. First we write the test_sort.py file with a solution, and some tests.

#+BEGIN_SRC python :tangle test_sort.py
def sort_solution(LIST):
    return LIST.sort()

def test_sort(s):
    exec s in globals()
    if sort([3, 4, 2]) == [2, 3, 4]:
        print('passed test 1')
    if sort(['z', 'b']) == ['b', 'z']:
        print('passed test 2')
#+END_SRC


#+name: sort
#+BEGIN_SRC python
def sort(LIST):
    s = sorted(LIST)
    return s
#+END_SRC
#+RESULTS: sort
: passed test 1
: passed test 2
:

Maybe it would make sense to use unittests, or nose or some other testing framework if it makes writing the tests easier. Another day.

* Save all open bibtex files


#+BEGIN_SRC emacs-lisp
(loop for buffer in (buffer-list)
  do
  (set-buffer buffer)
  (when (and (buffer-file-name) (f-ext? (buffer-file-name) "bib"))
    (save-buffer)))
#+END_SRC

#+RESULTS:

* Scopus author report
This is an example of using my scopus api to get tabular data about authors. It is time consuming to run because each document has to be downloaded.

#+BEGIN_SRC python :results value
from scopus.scopus_author import *

authors = [('Lars Grabow', '7005942402'),
           ('John Kitchin', '7004212771'),
           ('Eranda Nikolla', '14422415600'),
           ('Aaron Deskins', '8338495100'),
           ('Andreas Heyden', '56230635600'),
           ('Cynthia Lo', '36786289800'),
           ('Rachel Getman', '16028471000'),
           ('Elizabeth Biddinger', '14832345100'),
           ('Jessie Bond', '36011452800'),
           ('Liney Arnadottir', '6505601647'),
           ('Heather Kulik', '14421161700'),
           ('Bihter Padak', '15521044000'),
           ('Yuriy Roman', '14028938700'),
           ('Mike Janik', '7005984190'),
           ('Jeff Greeley', '56268000500'),
           ('Suljo Linic', '6602543828'),
           ('Rohan Mishra', '36876559500')]


return ([['Name', 'h-index', 'aif', '#first', '#last', 'N', 'cites', 'created'], None]
        + [[au.name,
            au.hindex,
            round(au.author_impact_factor(), 1),
            au.n_first_author_papers(),
            au.n_last_author_papers(),
            au.n_journal_articles(),
            au.ncitations,
            au.date_created]
           for au in [ScopusAuthor(sid) for name, sid in authors]])
#+END_SRC

#+RESULTS:
| Name                                  | h-index |  aif | #first | #last |   N | cites | created      |
|---------------------------------------+---------+------+--------+-------+-----+-------+--------------|
| Lars C. Grabow                        |      17 | 15.7 |     10 |     2 |  32 |  1084 | (2005 11 28) |
| John R. Kitchin                       |      18 | 19.7 |     10 |    35 |  56 |  3428 | (2005 12 3)  |
| Eranda Nikolla                        |      10 | 36.3 |      7 |     6 |  19 |   696 | (2006 9 14)  |
| Nathaniel Aaron Deskins               |      14 | 14.6 |      8 |     2 |  29 |   853 | (2005 11 28) |
| Andreas Heyden                        |      15 | 12.0 |      6 |    26 |  46 |  2349 | (2014 7 8)   |
| Cynthia Lo                            |       8 |  5.9 |      0 |    16 |  24 |   216 | (2011 6 5)   |
| Rachel B. Getman                      |       9 | 75.8 |      7 |     3 |  14 |   719 | (2007 3 18)  |
| Elizabeth J. Biddinger                |      12 | 12.4 |      6 |     2 |  21 |   639 | (2006 10 22) |
| Jesse Q. Bond                         |      11 | 52.0 |      4 |     3 |  14 |  1249 | (2010 5 21)  |
| Líney Árnadõttir |       6 |  5.0 |      3 |     0 |  12 |   119 | (2005 12 1)  |
| Heather J. Kulik                      |      10 | 12.3 |     13 |     3 |  18 |   344 | (2006 9 14)  |
| Bihter Padak                          |       3 |  0.0 |      1 |     1 |   3 |    93 | (2006 12 27) |
| Yuriy Román-Leshkov            |      17 | 32.6 |      7 |    26 |  40 |  3265 | (2006 8 9)   |
| Michael J. Janik                      |      24 |  9.3 |     11 |    33 |  88 |  1729 | (2005 12 4)  |
| Jeffrey P. Greeley                    |      36 | 23.6 |     14 |    22 | 108 |  5473 | (2014 7 26)  |
| Suljo Linic                           |      29 | 33.1 |     13 |    28 |  47 |  3246 | (2005 11 28) |
| Rohan Mishra                          |       6 |  7.4 |      6 |     0 |  20 |   106 | (2011 2 10)  |


None of Cynthia Lo's first author papers are showing up.
#+BEGIN_SRC python
from scopus.scopus_author import *
au = ScopusAuthor('36786289800')
au.n_first_author_papers()

scopus_abstracts = [ScopusAbstract(eid)
                    for eid in au.get_document_eids()
                    if ScopusAbstract(eid).aggregationType == 'Journal']

first_authors = [1 for ab in scopus_abstracts
                 if ab.authors[0].scopusid == au.author_id]
print first_authors
print [ab.authors[0].scopusid for ab in scopus_abstracts]
print [ab.authors[0].indexed_name for ab in scopus_abstracts]

#+END_SRC

#+RESULTS:
: []
: ['56416508500', '55581066000', '36967806600', '56416508500', '55923852900', '36967806600', '6507412549', '56405307200', '55372258500', '55581066000', '36727879000', '55006113200', '6507412549', '55006113200', '55372258500', '55581066000', '55006113200', '55006113200', '39961627300', '36727879000', '25651125000', '21741173000', '16314196200', '24072097500']
: ['Faghaninia A.', 'Jiang J.', 'Bricker W.P.', 'Faghaninia A.', 'Cheng Z.', 'Bricker W.P.', 'Niedzwiedzki D.M.', 'Mueller V.H.', 'Stoica M.', 'Jiang J.', 'Kovacs S.A.', 'Cheng Z.', 'Niedzwiedzki D.M.', 'Cheng Z.', 'Stoica M.', 'Jiang J.', 'Cheng Z.', 'Cheng Z.', 'Havran V.', 'Kovacs S.A.', 'Zheng X.', 'Unrau C.J.', 'Rycenga M.', 'Thimsen E.']




#+BEGIN_SRC python :results raw
from scopus.scopus_author import *
print ScopusAuthor('36786289800')
#+END_SRC

#+RESULTS:
** Cynthia Lo (updated on Tue Sep 29 15:57:43 2015)
http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=36786289800&origin=inward
36 documents cited 216 times by 206 people (44 coauthors)
#first author papers 0
#last author papers 16
h-index: 8        AIF(2014) = 5.88
Scopus ID created on (2011, 6, 5)

Current affiliation according to Scopus:
  Washington University in St. Louis, Department of Energy, Environmental and Chemical Engineering

Subject areas
  Chemical Engineering (all) (16), Chemistry (all) (12), Physical and
  Theoretical Chemistry (10), Surfaces, Coatings and Films (8),
  Catalysis (7), Biochemistry (6), Cell Biology (6), Industrial and
  Manufacturing Engineering (6), Electronic, Optical and Magnetic
  Materials (5), Materials Chemistry (5), Condensed Matter Physics
  (4), Biophysics (3), Energy (all) (3), Plant Science (3), Chemical
  Engineering (miscellaneous) (3), Medicine (all) (2), Physics and
  Astronomy (all) (2), Materials Science (all) (2), Biotechnology (1),
  Genetics (1), Molecular Biology (1), Structural Biology (1), Safety,
  Risk, Reliability and Quality (1), Information Systems (1), Modeling
  and Simulation (1), Bioengineering (1), Process Chemistry and
  Technology (1)

Publishes in:
  FEBS Lett., Conf. Proc. - AIChE Annu. Mtg., 09AIChE, AIChE - AIChE
  Annu. Meet., Conf. Proc., AIChE - AIChE Annu. Meet., Conf. Proc.,
  Top. Catal., New J. Phys., ACS Natl. Meet. Book Abstr., Catal.,
  Biochim. Biophys. Acta Bioenerg., J Phys Chem B, J Phys Chem B,
  Phys. Rev. B Condens. Matter Mater. Phys., J. Phys. Chem. B, Mol
  Simul, ACS Catal., AIChE - AIChE Annu. Meet., Conf. Proc., J Phys
  Condens Matter, Appl. Catal. A Gen., Photosynth. Res., Angew. Chem.
  Int. Ed., J Chem Phys, J. Phys. Chem. C, Phys. Rev. B Condens.
  Matter Mater. Phys., Biochim. Biophys. Acta Bioenerg., Photosyn.
  Res., J Phys Chem B, Ind. Eng. Chem. Res.

Affiliation history:
37 of 37 documents
 1. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=61649126491&origin=inward][2-s2.0-61649126491]]  E. Thimsen, S. Biswas, C.S. Lo and P. Biswas, Predicting the band structure of mixed transition metal oxides: Theory and experiment, Journal of Physical Chemistry C, 113(5), p. 2014-2021, (2009). http://dx.doi.org/10.1021/jp807579h, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=61649126491&origin=inward, cited 71 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 2. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=72449177429&origin=inward][2-s2.0-72449177429]]  M. Rycenga, Z. Wang, E. Gordon, C.M. Cobley, A.G. Schwartz, C.S. Lo and Y. Xia, Probing the photothermal effect of gold-based nanocages with surface-enhanced Raman scattering (SERS), Angewandte Chemie - International Edition, 48(52), (no pages found) (2009). http://dx.doi.org/10.1002/anie.200904382, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=72449177429&origin=inward, cited 43 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 3. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79958827846&origin=inward][2-s2.0-79958827846]]  V. Havran, M.P. Duduković and C.S. Lo, Conversion of methane and carbon dioxide to higher value products, Industrial and Engineering Chemistry Research, 50(12), p. 7089-7100, (2011). http://dx.doi.org/10.1021/ie2000192, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79958827846&origin=inward, cited 32 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 4. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872066774&origin=inward][2-s2.0-84872066774]]  Z. Cheng, B.J. Sherman and C.S. Lo, Carbon dioxide activation and dissociation on ceria (110): A density functional theory study, Journal of Chemical Physics, 138(1), Art. No. 014702 (2013). http://dx.doi.org/10.1063/1.4773248, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872066774&origin=inward, cited 16 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 5. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84860994429&origin=inward][2-s2.0-84860994429]]  J. Jiang, H. Zhang, Y. Kang, D. Bina, C.S. Lo and R.E. Blankenship, Characterization of the peridinin-chlorophyll a-protein complex in the dinoflagellate Symbiodinium, Biochimica et Biophysica Acta - Bioenergetics, 1817(7), p. 983-989, (2012). http://dx.doi.org/10.1016/j.bbabio.2012.03.027, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84860994429&origin=inward, cited 10 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 6. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78049401297&origin=inward][2-s2.0-78049401297]]  X. Zheng, G.M. Veith, E. Redekop, C.S. Lo, G.S. Yablonsky and J.T. Gleaves, Oxygen and CO adsorption on Au/SiO2 catalysts prepared by magnetron sputtering: The role of oxygen storage, Industrial and Engineering Chemistry Research, 49(21), p. 10428-10437, (2010). http://dx.doi.org/10.1021/ie100547f, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78049401297&origin=inward, cited 10 times (Scopus).
Affiliations:
   id:60028590 St. Louis University
   id:60010261 Washington University in St. Louis
   id:60024266 Oak Ridge National Laboratory

 7. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84858056670&origin=inward][2-s2.0-84858056670]]  Z. Cheng and C.S. Lo, Formation of active sites on WO 3 catalysts: A density functionaltheory study of olefin metathesis, ACS Catalysis, 2(3), p. 341-349, (2012). http://dx.doi.org/10.1021/cs2005778, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84858056670&origin=inward, cited 9 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 8. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84898831441&origin=inward][2-s2.0-84898831441]]  D.M. Niedzwiedzki, J. Jiang, C.S. Lo and R.E. Blankenship, Spectroscopic properties of the Chlorophyll a-Chlorophyll c 2-Peridinin-Protein-Complex (acpPC) from the coral symbiotic dinoflagellate Symbiodinium, Photosynthesis Research, 120(1-2), p. 125-139, (2014). http://dx.doi.org/10.1007/s11120-013-9794-5, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84898831441&origin=inward, cited 8 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

 9. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84884926529&origin=inward][2-s2.0-84884926529]]  D.M. Niedzwiedzki, J. Jiang, C.S. Lo and R.E. Blankenship, Low-temperature spectroscopic properties of the peridinin-chlorophyll a-protein (PCP) complex from the coral symbiotic dinoflagellate symbiodinium, Journal of Physical Chemistry B, 117(38), p. 11091-11099, (2013). http://dx.doi.org/10.1021/jp401022u, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84884926529&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

10. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142336&origin=inward][2-s2.0-84866142336]]  Z. Cheng, N.A. Fine and C.S. Lo, Platinum nanoclusters exhibit enhanced catalytic activity for methane dehydrogenation, Topics in Catalysis, 55(5-6), p. 345-352, (2012). http://dx.doi.org/10.1007/s11244-012-9803-5, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142336&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

11. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78650413591&origin=inward][2-s2.0-78650413591]]  S.A. Kovács and C.S. Lo, Electronic structure and charge ordering in magnetite: Implications for the Fe3O4 (001)-water interface, Molecular Simulation, 36(15), p. 1289-1296, (2010). http://dx.doi.org/10.1080/08927022.2010.517735, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=78650413591&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

12. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77953502784&origin=inward][2-s2.0-77953502784]]  C.J. Unrau, R.L. Axelbaum and C.S. Lo, High-yield growth of carbon nanotubes on composite Fe/Si/O nanoparticle catalysts: A car-parrinello molecular dynamics and experimental study, Journal of Physical Chemistry C, 114(23), p. 10430-10435, (2010). http://dx.doi.org/10.1021/jp909255r, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77953502784&origin=inward, cited 3 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

13. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84905728423&origin=inward][2-s2.0-84905728423]]  W.P. Bricker and C.S. Lo, Excitation energy transfer in the peridinin-chlorophyll a-protein complex modeled using configuration interaction, Journal of Physical Chemistry B, 118(31), p. 9141-9154, (2014). http://dx.doi.org/10.1021/jp5017054, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84905728423&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

14. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84907261562&origin=inward][2-s2.0-84907261562]]  J. Jiang, H. Zhang, G.S. Orf, Y. Lu, W. Xu, L.B. Harrington, H. Liu, C.S. Lo and R.E. Blankenship, Evidence of functional trimeric chlorophyll a/c2-peridinin proteins in the dinoflagellate Symbiodinium, Biochimica et Biophysica Acta - Bioenergetics, 1837(11), p. 1904-1912, (2014). http://dx.doi.org/10.1016/j.bbabio.2014.07.023, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84907261562&origin=inward, cited 2 times (Scopus).
Affiliations:


15. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84892731712&origin=inward][2-s2.0-84892731712]]  S.Á. Kovács, W.P. Bricker, D.M. Niedzwiedzki, P.F. Colletti and C.S. Lo, Computational determination of the pigment binding motif in the chlorosome protein a of green sulfur bacteria, Photosynthesis Research, 118(3), p. 231-247, (2013). http://dx.doi.org/10.1007/s11120-013-9920-4, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84892731712&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

16. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84887593491&origin=inward][2-s2.0-84887593491]]  Z. Cheng and C.S. Lo, Effect of support structure and composition on the catalytic activity of Pt nanoclusters for methane dehydrogenation, Industrial and Engineering Chemistry Research, 52(44), p. 15447-15454, (2013). http://dx.doi.org/10.1021/ie400776n, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84887593491&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

17. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867025683&origin=inward][2-s2.0-84867025683]]  M. Stoica and C.S. Lo, Electrical transport properties of Co-based skutterudites filled with Ag and Au, Physical Review B - Condensed Matter and Materials Physics, 86(11), Art. No. 115211 (2012). http://dx.doi.org/10.1103/PhysRevB.86.115211, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867025683&origin=inward, cited 2 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

18. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84908620507&origin=inward][2-s2.0-84908620507]]  V.H. Mueller, M.P. Duduković and C.S. Lo, The role of metal-support interaction on catalytic methane activation, Applied Catalysis A: General, 488, p. 138-147, (2014). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84908620507&origin=inward, cited 1 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

19. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901709620&origin=inward][2-s2.0-84901709620]]  M. Stoica and C.S. Lo, P-type zinc oxide spinels: Application to transparent conductors and spintronics, New Journal of Physics, 16, Art. No. 055011 (2014). http://dx.doi.org/10.1088/1367-2630/16/5/055011, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901709620&origin=inward, cited 1 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

20. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84935043479&origin=inward][2-s2.0-84935043479]]  A. Faghaninia, J.W. Ager and C.S. Lo, Ab initio electronic transport model with explicit solution to the linearized Boltzmann transport equation, Physical Review B - Condensed Matter and Materials Physics, 91(23), Art. No. 235123 (2015). http://dx.doi.org/10.1103/PhysRevB.91.235123, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84935043479&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis
   id:60007174 Lawrence Berkeley National Laboratory

21. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84941426406&origin=inward][2-s2.0-84941426406]]  J. Jiang, H. Zhang, X. Lu, Y. Lu, M.J. Cuneo, H.M. O'Neill, V. Urban, C.S. Lo and R.E. Blankenship, Oligomerization state and pigment binding strength of the peridinin-Chl a-protein, FEBS Letters, 589(19), p. 2713-2719, (2015). http://dx.doi.org/10.1016/j.febslet.2015.07.039, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84941426406&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis
   id:60024266 Oak Ridge National Laboratory

22. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84928995456&origin=inward][2-s2.0-84928995456]]  W.P. Bricker and C.S. Lo, Efficient pathways of excitation energy transfer from delocalized S <inf>2</inf> excitons in the peridinin-chlorophyll a -protein complex, Journal of Physical Chemistry B, 119(18), p. 5755-5764, (2015). http://dx.doi.org/10.1021/jp511766j, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84928995456&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

23. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924411864&origin=inward][2-s2.0-84924411864]]  A. Faghaninia and C.S. Lo, First principles study of defect formation in thermoelectric zinc antimonide, β-Zn4Sb3
, Journal of Physics Condensed Matter, 27(12), Art. No. 125502 (2015). http://dx.doi.org/10.1088/0953-8984/27/12/125502, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924411864&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

24. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84927721858&origin=inward][2-s2.0-84927721858]]  Z. Cheng and C.S. Lo, Propagation of Olefin Metathesis to Propene on WO<inf>3</inf> Catalysts: A Mechanistic and Kinetic Study, ACS Catalysis, 5(1), p. 59-72, (2015). http://dx.doi.org/10.1021/cs500531b, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84927721858&origin=inward, cited 0 times (Scopus).
Affiliations:


25. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84937414302&origin=inward][2-s2.0-84937414302]]  E. Lee, Z. Cheng and C.S. Lo, Present and future prospects in heterogeneous catalysts for C<inf>1</inf> chemistry, Catalysis, 27, p. 187-208, (2015). http://dx.doi.org/10.1039/9781782622697-00187, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84937414302&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

26. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872855145&origin=inward][2-s2.0-84872855145]]  S.A. Kovács, W.P. Bricker, J. Jiang and C.S. Lo, Evaluating photosynthetic antenna complex assemblies for efficient solar energy utilization, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872855145&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

27. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872835453&origin=inward][2-s2.0-84872835453]]  Z. Cheng and C.S. Lo, Computational study on olefin metathesis of ethene and 2-butene on WO3 surfaces, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872835453&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

28. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872856541&origin=inward][2-s2.0-84872856541]]  Z. Cheng, V. Havran, N.A. Fine, B. Sherman and C.S. Lo, A first-principles study on carbon dioxide reforming of methane over supported Pt catalysts, AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2012). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84872856541&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60013372 University of Texas at Austin
   id:60010261 Washington University in St. Louis

29. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857217577&origin=inward][2-s2.0-84857217577]]  S. Kovcs and C.S. Lo, Modeling protein-surface interactions for biohybrid solar energy utilization, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857217577&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

30. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857226857&origin=inward][2-s2.0-84857226857]]  V. Havran, M.P. Dudukovic and C.S. Lo, Catalytic conversion of methane and carbon dioxide to higher value products, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857226857&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

31. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857214814&origin=inward][2-s2.0-84857214814]]  Z. Cheng and C.S. Lo, Computational study on dry reforming reactions over Pt/TiO
                    2 catalysts, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857214814&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

32. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857209688&origin=inward][2-s2.0-84857209688]]  Z. Cheng and C.S. Lo, Active sites for olefin metathesis on WO
                    3 catalysts: A density functional theory study, 11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2011). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84857209688&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

33. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79251501995&origin=inward][2-s2.0-79251501995]]  N.A. Fine and C.S. Lo, Methane dehydrogenation on platinum-based nanocluster catalysts, 10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings, None, (no pages found) (2010). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79251501995&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

34. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951482671&origin=inward][2-s2.0-79951482671]]  B.J. Sherman, N.A. Fine and C.S. Lo, Computational design of multifunctional catalysts for efficient carbon dioxide and methane utilization, ACS National Meeting Book of Abstracts, None, (no pages found) (2010). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951482671&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

35. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951481223&origin=inward][2-s2.0-79951481223]]  S.Á. Kovács, W.P. Bricker, K.W. Leung and C.S. Lo, Structure and organization of photosynthetic antenna complexes for efficient excitation energy transfer, ACS National Meeting Book of Abstracts, None, (no pages found) (2010). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=79951481223&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

36. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77952256378&origin=inward][2-s2.0-77952256378]]  N.A. Fine and C.S. Lo, Density functional theory analysis of methane dehydrogenation on platinum nanoclusters for liquid fuels production, Conference Proceedings - 2009 AIChE Annual Meeting, 09AIChE, None, (no pages found) (2009). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77952256378&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis

37. [[http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77955601322&origin=inward][2-s2.0-77955601322]]  E. Thimsen, C.S. Lo and P. Biswas, Nanostructured TiO2 thin films co-doped with transition metals for enhanced visible light absorption: Experiments and first-principles calculations, ACS National Meeting Book of Abstracts, None, (no pages found) (2008). http://dx.doi.org/None, http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=77955601322&origin=inward, cited 0 times (Scopus).
Affiliations:
   id:60010261 Washington University in St. Louis



* DONE Upping my Emacs navigation game
  CLOSED: [2015-09-27 Sun 21:21]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/09/27 21:21:51
  :updated:  2015/09/27 21:21:51
  :END:

I have been trying to up my navigation game in Emacs, by which I mean I want to get my cursor where I want it with a minimal number of keystrokes, and preferrably no mouse actions. There are lots of little and big navigations I do a lot:
1. forward/backward by a character
2. forward/backward by a word/subword
3. forward/backward by a sentence
4. forward/backward by a line
5. to the beginning and end of a line
6. to the beginning and end of a sentence
7. to the beginning and end of a paragraph
8. to the beginning and end of a page
9. to the beginning and end of a buffer
10. scrolling up/down
11. into another window
12. back and forth to buffers

Occasionally, I want to save a location so I can easily get back to it. Not all of these are strictly speaking navigation in the usual sense, but they are things I do often enough. There are Emacs commands for all these, and keyboard shortcuts for many of them, but I don't use them often, and as a result I don't remember them either.

Here I develop a [[https://github.com/abo-abo/hydra][hydra]] that will provide these features. Hydra is a super amazing, menu prompting system that provides hints to remind you of what can be done, and to access it from a character. It is possible to pass numeric and universal arguments to the commands by typing -, a number, or C-u before pressing the character.

I want some commands to be repeatable, which we get with a "red" hydra, and some commands to exit on running, which we get with a "blue" head. So, here is an over-the-top hydra for navigation.

#+BEGIN_SRC emacs-lisp
(defhydra hydra-navigate (:color red
                          :hint nil)
  "
_f_: forward-char       _w_: forward-word       _n_: next-line
_b_: backward-char      _W_: backward-word      _p_: previous-line
^ ^                     _o_: subword-right      _,_: beginning-of-line
^ ^                     _O_: subword-left       _._: end-of-line

_s_: forward sentence   _a_: forward paragraph  _g_: forward page
_S_: backward sentence  _A_: backward paragraph _G_: backward page

_h_: helm mini _B_: buffer list _i_: window
_<left>_: previous buffer   _<right>_: next buffer
_<up>_: scroll-up           _<down>_: scroll-down

_[_: backward-sexp _]_: forward-sexp
_<_ beginning of buffer _>_ end of buffer _m_: set mark _/_: jump to mark
"
  ("f" forward-char)
  ("b" backward-char)
  ("w" forward-word)
  ("W" backward-word)
  ("n" next-line)
  ("p" previous-line)
  ("o" subword-right)
  ("O" subword-left)
  ("s" forward-sentence)
  ("S" backward-sentence)
  ("a" forward-paragraph)
  ("A" backward-paragraph)
  ("g" forward-page)
  ("G" backward-page)
  ("<right>" next-buffer)
  ("<left>" previous-buffer)
  ("h" helm-mini :color blue)
  ("i" ace-window :color blue)
  ("m" org-mark-ring-push)
  ("/" org-mark-ring-goto :color blue)
  ("B" helm-buffers-list)
  ("<up>" scroll-up)
  ("<down>" scroll-down)
  ("<" beginning-of-buffer)
  (">" end-of-buffer)
  ("." end-of-line)
  ("[" backward-sexp)
  ("]" forward-sexp)
  ("," beginning-of-line)
  ("q" nil "quit" :color blue))

(global-set-key (kbd "s-n") 'hydra-navigate/body)
#+END_SRC

#+RESULTS:
: hydra-navigate/body

I basically like it. The menu is a little on the large side, but it makes for easy modal navigation in a buffer, to other windows, and other buffers. On the whole for moderate cursor movements, this results in basically equal keystrokes. For example, to move 3 characters forward, we have C-f C-f C-f or C-u 3 C-f, or s-n 3 f. The advantage (I think) is a single interface to all these navigation commands with hints on what to do.

There is still another level of navigation, which is related to navigation by searching. That is a whole different level of navigation I will work on another day!


* DONE COMPLETED A cursor goto hydra for emacs
  CLOSED: [2015-09-28 Mon 19:20]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/09/28 16:38:11
  :updated:  2015/09/28 16:38:11
  :END:

In the spirit of upping my navigation game, here we examine navigation by search like methods. You probably know about C-s with will search forward for a word, and C-r which will search backwards. This will get you to the start of a word pretty easily. It won't get you into a word though, you have to navigate to that, and it isn't too handy to get to a line, or window, or headline in an org-file. Each of these is an emacs command, which as with navigation I don't always remember. Today, we build a hydra to make this easy too.

We will use features from [[https://github.com/abo-abo/avy][avy]], and [[https://github.com/emacs-helm/helm][helm]], and some standard emacs features. =avy= is pretty neat. It provides an interface to jump to characters, words and subwords by pressing keys. To jump to a character that is visible on the screen, you invoke avy-goto-char and press the character you want to jump to. =avy= will overlay a sequence of keys you then type to jump to that character. It might be more convenient to jump to a pair of characters, which you do by invoking avy-goto-char-2. Similarly, there are commands to jump to the beginning of a word, and a subword, both with variations that allow you to specify the beginning letter of the word, or to get overlays on every word.

I spend most of my days in org-files, so I frequently want to jump to an org headline in the current buffer, or some headline in an org-file in my agenda. Helm provides a nice set of functions for this in helm-org-headlines and helm-org-agenda-files-headings. We can also use helm-multi-swoop-org to use the swoop search function in all open org-buffers with helm selection. Within a buffer, you might also use the search forward and backward capabilities, or the more advanced helm-occur or swiper-helm features.
Finally, I may want my cursor to go to another recent file, or open buffer.

The hydra we will develop here puts all of these commands a few keystrokes away, with a hint system to remind you what is possible. In addition to these "goto" commands, I add a character to switch to the navigation hydra we developed in the last [[http://kitchingroup.cheme.cmu.edu/blog/2015/09/27/Upping-my-Emacs-navigation-game/][post]] so I can switch to navigation if I change my mind. I also put two commands to store the current position before the goto command, and to return to that stored position conveniently. I bind this hydra to super-g, because the super key isn't used much on my Mac, and g reminds of "goto". So, here is my hydra code:

#+BEGIN_SRC emacs-lisp
(defhydra goto (:color blue :hint nil)
  "
Goto:
^Char^              ^Word^                ^org^                    ^search^
^^^^^^^^---------------------------------------------------------------------------
_c_: 2 chars        _w_: word by char     _h_: headline in buffer  _o_: helm-occur
_C_: char           _W_: some word        _a_: heading in agenda   _p_: helm-swiper
_L_: char in line   _s_: subword by char  _q_: swoop org buffers   _f_: search forward
^  ^                _S_: some subword     ^ ^                      _b_: search backward
-----------------------------------------------------------------------------------
_B_: helm-buffers       _l_: avy-goto-line
_m_: helm-mini          _i_: ace-window
_R_: helm-recentf

_n_: Navigate           _._: mark position _/_: jump to mark
"
  ("c" avy-goto-char-2)
  ("C" avy-goto-char)
  ("L" avy-goto-char-in-line)
  ("w" avy-goto-word-1)
  ;; jump to beginning of some word
  ("W" avy-goto-word-0)
  ;; jump to subword starting with a char
  ("s" avy-goto-subword-1)
  ;; jump to some subword
  ("S" avy-goto-subword-0)

  ("l" avy-goto-line)
  ("i" ace-window)

  ("h" helm-org-headlines)
  ("a" helm-org-agenda-files-headings)
  ("q" helm-multi-swoop-org)

  ("o" helm-occur)
  ("p" swiper-helm)

  ("f" isearch-forward)
  ("b" isearch-backward)

  ("." org-mark-ring-push :color red)
  ("/" org-mark-ring-goto :color blue)
  ("B" helm-buffers-list)
  ("m" helm-mini)
  ("R" helm-recentf)
  ("n" hydra-navigate/body))

(global-set-key (kbd "s-g") 'goto/body)
#+END_SRC

As with the last navigation hydra, this is a pretty massive set of options and takes up some decent screen space at the bottom om my emacs. They are mostly here to remind me that there are better navigation options, and with practice I suspect muscle memory will provide fast navigation tools with more precision and fewer keystrokes than simple navigation.

* time stamp in code block

#+name: update-timestamp
#+BEGIN_SRC emacs-lisp :var data=""

 (re-search-forward "#\\+END_SRC")
 (kill-line)
 (insert (concat " #Last run: "  (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time))))

data
#+END_SRC #Last run: [2015-09-21 Mon 15:19:10]



#+BEGIN_SRC python :post update-timestamp(data=*this*)
print('hello')
#+END_SRC

#+RESULTS:
: hello

#+BEGIN_SRC emacs-lisp :time-stamp
(defun j-add-ts ()
  (save-excursion
    ; this is a little hacky, but it works.
    (when (string= ":time-stamp" (plist-get (cadr (org-element-context)) :parameters))

      (re-search-forward "#\\+END_SRC")
      (forward-line)
      (beginning-of-line)
      (when (looking-at "# Last run:")
	(kill-line))
      (insert (concat
	       "# Last run: "
	       (format-time-string "[%Y-%m-%d %a %H:%M:%S]" (current-time)))))))


(add-hook 'org-babel-after-execute-hook 'j-add-ts)

;(remove-hook 'org-babel-after-execute-hook  'j-add-ts)
#+END_SRC
# Last run: [2015-09-21 Mon 22:01:15]

#+RESULTS:
| j-add-ts | org-babel-python-strip-session-chars | (lambda nil (org-refresh-images)) |

#+BEGIN_SRC python
print 'hello'
#+END_SRC
# Last run: [2015-09-21 Mon 21:58:51]
#+RESULTS:
: hello


* DONE YAT - yet another template strategy
  CLOSED: [2015-11-01 Sun 14:12]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/11/01 14:12:34
  :updated:  2015/11/01 14:12:34
  :END:

I have another need for a template that is dynamically evaluated. I previously wrote about this [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Another-alternative-to-string-templates/][here]], and today I am going to do a variation of the theme. We will still use a syntax of $(expression), but a new approach to evaluating the expression. I saw this interesting function to evaluate and replace an s-expression in a buffer [[http://emacsredux.com/blog/2013/06/21/eval-and-replace/][Eval and Replace - Emacs Redux]]. I am going use that to replace a template expression in a string, with a little variation to avoid replacing non-sexp variations, e.g. $(. Here we go.

#+BEGIN_SRC emacs-lisp
(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (princ (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (concat "$" (current-kill 0))))))

(defun j-format (s)
  "Replace all instances of $(expression) in S with the evaluated
expression."
  (with-temp-buffer
    (insert s)
    (goto-char (point-min))
    (while (re-search-forward "$(" nil t)
      (backward-char)
      (when (sexp-at-point)
	;; get rid of the $
	(delete-char -1)
	;; go to the end of the sexp and then eval-and-replace it.
	(end-of-sexp)
	(eval-and-replace)))
    ;; return the formatted text.
    (buffer-string)))


(let ((some-var "You got me"))
  (j-format "Test of 4 + 5 = $(+ 4 5). $(  $(foobar). $(progn (setq x 5) \"\")
and then we have 2x=$(prin1 (* 2 x)).

some-var = $(print some-var)"))
#+END_SRC

#+RESULTS:
: Test of 4 + 5 = 9. $(  $(foobar).
: and then we have 2x=10.
:
: some-var = You got me

That seems pretty ok. I obviously have not tested it extensively, but it looks pretty promising.

* A more flexible s-format
s-format can take an arbitrary function

This is tough logic to get right in one conditional
#+BEGIN_SRC emacs-lisp :results output
(defun j-replacer (name &optional extra)
  "Find the replacement for NAME, possibly using EXTRA.
If EXTRA is a list, and NAME a number, then NAME refers to positions in EXTRA.
If EXTRA is a hash-table, and NAME is a key in it, it returns the value.
If EXTRA is a list, we try to get the value from assoc, then as a plist.
If NAME is a sexp, we return the evaluated form.
If NAME is a bound variable, we return its value."
  (let (result)
    (catch 'result
      ;; a numeric argument
      (when (and extra
		 (listp extra)
		 (string-match "^[0-9]+$" name))
	(throw 'result (format "%s" (elt extra (string-to-int name)))))

      ;; check hash table
      (when (and
	     extra
	     (hash-table-p extra))
	(when (setq result (gethash name extra))
	  (throw 'result result)))

      ;; try alist
      (when
	  (and extra
	       (listp extra)
	       (setq result (assoc name extra)))
	(throw 'result (cdr  result)))

      ;; try plist
      (when (and extra
		 (listp extra)
		 (setq result (plist-get extra (intern (concat ":" name)))))
	(throw 'result result))

      ;; maybe a sexp?
      (when (with-temp-buffer
	      (insert name)
	      (goto-char (point-min))
	      (and
	       (thing-at-point 'sexp)
	       (s-starts-with? "(" (buffer-string))
	       (s-ends-with? ")" (buffer-string))))
	(throw 'result (format "%s" (eval (read name)))))

      ;; Check for bound variables
      (when (intern-soft name)
	(when (-contains? '("name" "extra") name)
	  (error "You cannot expand \"%s\". Please change it to some other variable name." name))
	(throw 'result (symbol-value (intern-soft name))))

      ;; nothing found
      (error "\"%s\" was not found" name))))


(defun j-format (j-template &optional data)
  "Use `j-replacer' with `s-format' as a templating system."
  (s-format j-template 'j-replacer data))

(print (j-format "1. ${name} and ${(+ 4 5)}" '(("name" . "John"))))
(print (j-format "2. ${name} and ${(+ 4 5)}" '(:name "John")))

(setq data (make-hash-table :test 'equal))
(puthash "name" "Jimmy" data)
(print (j-format "3. ${name} and ${(+ 4 5)}"  data))

(setq name "untill")
(setq this-name "till")
(print  (j-format "4. ${this-name} ${user-full-name} and ${(+ 4 5)} or ${1}"  '(a b c)))
#+END_SRC

#+RESULTS:
:
: "1. John and 9"
:
: "2. John and 9"
:
: "3. Jimmy and 9"
:
: "4. till John Kitchin and 9 or b"


#+BEGIN_SRC emacs-lisp
(let ((name-it "bill"))
(boundp 'name-it))
#+END_SRC

#+RESULTS:
: t

* getting data from a named checklist


#+name: research-impact
- test
  - [ ] (4) a
  - [ ] (3) b
  - [X] (2) c
  - [X] (1) d

#+attr_org: :single-value
#+name: teaching
- [X] (4) a
- [ ] (3) b
- [ ] (2) c
- [ ] (1) d



#+BEGIN_SRC emacs-lisp
(defun element-explorer ()
  (interactive)
  (message "%s" (org-element-context)))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp :results none
(defun org-jump-to-plain-list (name)
  (catch 'found
    (org-element-map
	(org-element-parse-buffer)
	'plain-list
      (lambda (plain-list)
	(when
	    (string= name (org-element-property :name plain-list))
	  (goto-char (org-element-property :begin plain-list))
	  (throw 'found plain-list))))))

(org-jump-to-plain-list "research-impact")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun happ-get-first-checked-item (plain-list-name)
  "Go to the list named PLAIN-LIST-NAME and get the value of the first checked item.
The value is stored in () in the list, and it will be 1,2,3,4 or y/n."

  (save-excursion
    (loop for el in (org-element-property
		     :structure
		     (org-jump-to-plain-list plain-list-name))
	  if (string= (nth 4 el) "[X]")
	  return (progn
		   (string-match "(\\([1234yn]\\))" (buffer-substring (car el) (car (last el))))
		   (match-string 1 (buffer-substring (car el) (car (last el))))))))

(org-get-checked-items "research-impact")
#+END_SRC
#+RESULTS:
: 2

(buffer-substring 68 80)
* Customizing mu4e
[[http://www.djcbsoftware.nl/code/mu/mu4e/HV-Custom-headers.html#HV-Custom-headers][mu4e 0.9.12 user manual: HV Custom headers]]

#+BEGIN_SRC emacs-lisp
(add-to-list 'mu4e-header-info-custom
  '(:recipnum .
    ( :name "Number of recipients"  ;; long name, as seen in the message-view
      :shortname "Recip#"           ;; short name, as seen in the headers view
      :help "Number of recipients for this message" ;; tooltip
      :function
      (lambda (msg)
	(format "%d"
	  (+ (length (mu4e-message-field msg :to))
	    (length (mu4e-message-field msg :cc))))))))

(add-to-list 'mu4e-headers-fields (cons :recipnum nil) t)
(setq mu4e-headers-fields (-remove-item '(:recipnum) mu4e-headers-fields))
#+END_SRC

#+RESULTS:
| :recipnum | :name | Number of recipients | :shortname | Recip# | :help | Number of recipients for this message | :function | (lambda (msg) (format %d (+ (length (mu4e-message-field msg :to)) (length (mu4e-message-field msg :cc))))) |

mu4e:msgid:m2egi9np93.fsf@andrew.cmu.edu


Message-ID: <BLUPR0401MB177812963CF71FD54C291D93AB530@BLUPR0401MB1778.namprd04.prod.outlook.com>
References: <m2a8syxu48.fsf@andrew.cmu.edu>
 <BLUPR0401MB1778F500DA3CBA3C3B1B0B29AB530@BLUPR0401MB1778.namprd04.prod.outlook.com>
 <m2egi9np93.fsf@andrew.cmu.edu>
In-Reply-To: <m2egi9np93.fsf@andrew.cmu.edu>


#+BEGIN_SRC emacs-lisp
(defun open-msgid ()
  "get msg-id at point and open it."
  (interactive)
  (save-excursion
    (re-search-backward "<")
    (re-search-forward "<\\([^>]*\\)>")
    (org-open-link-from-string (format "[[mu4e:msgid:%s]]" (match-string 1)))))
#+END_SRC

#+RESULTS:
: open-msgid

** custom view header to org-headings
mu4e-view-fields

#+BEGIN_SRC emacs-lisp
(defun org-ref-ids (msg)
  (let ((matches '()))
    (when (mu4e-message-field msg :body-txt)
      (with-temp-buffer
	(insert (mu4e-message-field msg :body-txt))
	(goto-char (point-min))
	(while (re-search-forward
		"\\[\\[id:\\(.*\\)\\]\\]"
		nil t)
	  (add-to-list 'matches
		       (match-string 0)))
	(when matches
	  (mapconcat 'identity matches "\n"))))))

(setq mu4e-org-refs
      '(:orgrefs . (:name "Org references"
			   :shortname "orgrefs"
			   :help "List of links to org headings by ID"
			   :function org-ref-ids)))
(setq mu4e-header-info-custom '())
(add-to-list 'mu4e-header-info-custom mu4e-org-refs)
(add-to-list 'mu4e-view-fields :orgrefs t)
#+END_SRC

#+RESULTS:
| :from | :to | :cc | :subject | :flags | :date | :maildir | :mailing-list | :tags | :attachments | :signature | :decryption | :orgrefs |

** Custom view header with links to in reply to and references

#+BEGIN_SRC emacs-lisp
(defun mu4e-get-subject-from-msgid (msgid)
  (car
   (s-split
    "\n"
    (shell-command-to-string
     (format  "mu find msgid:%s -f s" msgid)))))

(defun mu4e-reference-links (msg)
  (interactive)
  (let ((references (mu4e-message-field msg :references)))
    (when references
	 (mapconcat
	  'identity
	  (loop for i from 1
		for reference in references
		collect (format "%s. [[mu4e:msgid:%s]]" i reference))
	  "\n"))))

(defun mu4e-reply-to-links (msg)
  (interactive)
  (let ((reply-to (mu4e-message-field msg :in-reply-to)))
    (when (not (string= "" reply-to))
     (format
      "[[mu4e:msgid:%s]]"
      (replace-regexp-in-string "<\\|>" "" reply-to)))))

(setq mu4e-message-refs
      '(:mrefs . (:name "References:"
			   :shortname "mrefs"
			   :help "List of links to messages by ID"
			   :function mu4e-reference-links)))

(setq mu4e-reply-to-refs
      '(:repref . (:name "In-Reply-To:"
			   :shortname "rrefs"
			   :help "Link to reply to message"
			   :function mu4e-reply-to-links)))

(add-to-list 'mu4e-header-info-custom mu4e-message-refs)
(add-to-list 'mu4e-view-fields :mrefs t)

(add-to-list 'mu4e-header-info-custom mu4e-reply-to-refs)
(add-to-list 'mu4e-view-fields :repref t)

(setq mu4e-view-fields (-remove-item :reprefs mu4e-view-fields))

(button-lock-set-button
 "\\[\\[mu4e:msgid:.*\\]\\]"
 (lambda ()
   (org-open-link-from-string
    (get-surrounding-text-with-property 'mu4e-msgid)))
 :face '((:foreground "Blue")
	 (:underline t))
 :additional-property 'mu4e-msgid)

#+END_SRC

#+RESULTS:
| \[\[mu4e:msgid:.*\]\] | (0 (quote (face ((:foreground Blue) (:underline t)) keymap (keymap (mouse-1 lambda nil (org-open-link-from-string (get-surrounding-text-with-property (quote mu4e-msgid))))) button-lock t mu4e-msgid t mouse-face button-lock-mouse-face rear-nonsticky t)) append) |

** Add note to headline from a message

I want to scan the current message for an id link, open the headline, and put a link in it.

#+BEGIN_SRC emacs-lisp
(defun activate-on-id ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\[\\[id:\\(.*\\)\\]\\]" nil t)
      (let ((cb (current-buffer))
	    (msgid (mu4e-message-field (mu4e-message-at-point) :message-id))
	    (subject (mu4e-message-field (mu4e-message-at-point) :subject))
	    (id (match-string 1))
	    file
	    values)
	(setq file (org-id-find id))
        (find-file (car file))
        (goto-char (cdr file))
	(if (org-entry-get (point) "Message-IDs")
	    (setq values (read (org-entry-get (point) "Message-IDs")))
	  (setq values '()))
	(add-to-list 'values (format "[[mu4e:msgid:%s][%s]]" msgid subject))
	(org-entry-put (point) "Message-IDs" (format "%S" values))
        (save-buffer)
	(switch-to-buffer cb)))))

(add-hook 'mu4e-view-mode-hook 'activate-on-id)
#+END_SRC

#+RESULTS:
| activate-on-id | email-fontify | on-view | #[nil \301\300!\210\302\211\207 [bookmark-make-record-function make-local-variable mu4e-view-bookmark-make-record] 2] |

* test fortune


#+BEGIN_SRC emacs-lisp :exports results :results org
(format "#+BEGIN_QUOTE:
%s
,#+END_QUOTE
" (shell-command-to-string "fortune"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :exports none
(let ((org-export-babel-evaluate t))
  (browse-url (org-html-export-to-html nil t)))
#+END_SRC
#+RESULTS:
: #<process open ./blog.html>


* a tblfm

| Student | Assgn Points | Points Earned | Possible | Achieved | Percentage |
|---------+--------------+---------------+----------+----------+------------|
| Barney  |           40 |           35. |       16 |       14 |       87.5 |
| Barney  |           40 |           35. |       16 |       14 |       87.5 |
| Betty   |           40 |           30. |       16 |       12 |        75. |
| Fred    |           40 |           25. |       16 |       10 |       62.5 |
| Wilma   |           40 |          17.5 |       16 |        7 |      43.75 |
#+TBLFM: $6 = ($5 / $4) * 100 ::  $3 = ($6 / 100) * $2

#+BEGIN_SRC emacs-lisp
(/ 14.0 16.0)
#+END_SRC

#+RESULTS:
: 0.875

* Using functions in font-lock
I am still looking at ways to add functionality to text dynamically in Emacs. Here I examine functions in font-lock mode. This puts an overlay on the text.
#+BEGIN_SRC emacs-lisp
(require 'ov)
(setq font-lock-extra-managed-props (delq 'help-echo font-lock-extra-managed-props))

(defun fn-match (bound)
  (when
      (re-search-forward "crazy fox" bound t)
    (ov (match-beginning 0)
	(match-end 0)
	'face '(:background "Darkolivegreen1")
        'mouse-face 'highlight
        'help-echo (lambda (a b c) (message-box "Aw yeah. That's what I'm talkin about"))
	'highlighted t)
    t))

(defun my-action (x) (message-box "%s\ndone" x))

(defun fn-match (bound)
  (when
      (re-search-forward "crazy fox" bound t)
    (make-button
     (match-beginning 0)
     (match-end 0)
     'face '(:background "Darkolivegreen1")
     'action (lambda (x) (message-box "%s" x))
     'follow-link t
     'help-echo (lambda (a b c) (format "On %s in %s at %s" a b c))
     )))

;;(font-lock-add-keywords nil '((fn-match 0 'font-lock-warning-face prepend)))
;;(font-lock-remove-keywords nil '((fn-match 0 'font-lock-warning-face prepend)))

(font-lock-add-keywords nil '(fn-match))
;; (font-lock-remove-keywords nil '(fn-match))

;; (ov-clear)
#+END_SRC

The crazy fox crazy fox  and the tree but not the graph

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords nil
  '(("\\<\\(FIXME\\):" 1 'font-lock-warning-face prepend)
    ("\\<\\(and\\|or\\|not\\)\\>" . 'font-lock-keyword-face)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(require 'button)
(re-search-forward "foo")
(make-button
 (match-beginning 0)
 (match-end 0)
 'follow-link t  ;; make mouse-1 work
 'action (lambda (x) (find-file user-init-file)))
#+END_SRC

#+RESULTS:
: #<overlay from 1461 to 1464 in blog.org>

foo



* Asynchronous functions to modify buffers

I wrote some code to make clickable org-contacts in org-mode buffers. The code works by generating a regular expression for every name in your contact, and using button-lock to add properties to matches. I discovered that if you have a few thousand contacts though, the regular expression is "too big" for Emacs! I could try to figure out how to breakup the contacts into reasonable sized groups, say 100 names at a time, but I want to try something else today. Today I want to explore an alternative approach to font-lock. The idea is to write a function that will scan through the buffer for names, and fontify them when they are found. This will usually block Emacs while running, so I want to see if I can run it asynchronously.

It does not appear possible. I cannot figure out how to pass the buffer to the asynchronous function.

#+BEGIN_SRC emacs-lisp
(require 'ov)
(defun hl-phrases ()
  (let ((phrases '("tree" "crazy fox" "animal")))
    (loop for phrase in phrases
	  do
	  (sleep-for 2)
	  (save-excursion
	    (goto-char (point-min))
	    (while (re-search-forward phrase nil t)
	      (ov (match-beginning 0)
		  (match-end 0)
		  'face '(:background "Darkolivegreen1")
		  'highlighted t)))))
  0)

(setq *hl-buffer* (current-buffer))
(async-start
 (lambda ()
   (require 'cl)
   (let ((phrases '("tree" "crazy fox" "animal"))
	 (found '()))
     (loop for phrase in phrases
	   do
	   (sleep-for 2)
	   (save-excursion
	     (goto-char (point-min))
	     (while (re-search-forward phrase nil t)
	       (add-to-list
		'found
		(list (match-beginning 0) (match-end 0))))))
     found))
 (lambda (result)
   (message-box "Done in %s" result)))
#+END_SRC

#+RESULTS:
: #<overlay from 1648 to 1651 in blog.org>


#+BEGIN_SRC emacs-lisp
(ov-clear 'highlighted t)
#+END_SRC

#+RESULTS:


The crazy fox jumped over the tree because it is an animal.


* DONE Checking for email attachments before you send email
  CLOSED: [2015-09-04 Fri 19:03]
  :PROPERTIES:
  :categories: emacs,email
  :date:     2015/09/04 19:03:53
  :updated:  2015/09/04 19:04:15
  :END:
Does this comic (http://www.phdcomics.com/comics/archive.php?comicid=1817) apply to you? Do you miss the Gmail feature that will alert you that it seems like you mention an attachment but there isn't one attached before it lets you send it? Let's make Emacs help us here. We will scan our emails for the word "attach", and if we see it, scan the email for evidence of an attachment. Then create a hook function that will prompt us if it appears we mention an attachment, but don't have one.

An attachment looks like this in my messages:
#+BEGIN_EXAMPLE
<#part type="image/png" filename="~/Desktop/wordcloud.png" disposition=attachment>
<#/part>
#+END_EXAMPLE

So, probably finding "<#part" in the buffer means I probably have an attachment. We will use the message-send-hook to run this function. Here is the code. Some brief testing from me seems to work fine! It is pretty simple, but probably good enough to save me from sending messages with no attachment, and not too intrusive for when no attachment is actually needed, e.g. in replies. Let me know if you have ideas for improvements.

#+BEGIN_SRC emacs-lisp
(defun email-says-attach-p ()
  "Return t if email suggests there could be an attachment."
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "attach" nil t)))

(defun email-has-attachment-p ()
  "Return t if the currently open email has an attachment"
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "<#part" nil t)))

(defun email-pre-send-check-attachment ()
  (when (and (email-says-attach-p)
	     (not (email-has-attachment-p)))
    (unless
	(y-or-n-p "Your email suggests you need an attachment, but no attachment was found. Send anyway?")
      (error "It seems an attachment is needed, but none was found. Aborting send."))))

(add-hook 'message-send-hook 'email-pre-send-check-attachment)
#+END_SRC

* dynamic yasnippet
  :PROPERTIES:
  :ID:       393D5FC5-90EB-48E2-B804-20FA735C6402
  :END:
#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : my-fortune
# key: myf
# expand-env: ((yas-indent-line nil)
# --

#+BEGIN_QUOTE:
${1:`(shell-command-to-string \"fortune\")`}
#END_QUOTE

$0
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# -*- mode: snippet -*-
# key: sc
# name: Source Block
# group: HELP
# contributor: gcr@wisdomandwonder.com
# --
,#+NAME: ${1:`(org-id-new)`}
,#+BEGIN_SRC ${2:$$(yas-choose-value '(\"emacs-lisp\" \"python\" \"org\"))}${2:$(when (-contains? '(\"ditaa\" \"dot\"
\"plantuml\") yas-text) (concat \" :file \\\"./image/\" (yas-field-value 1)
\".png\\\"\"))} $3
$0
,#+END_SRC")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+NAME: 77C740DF-C6E6-4A99-885E-9C7D0E3B145A
#+BEGIN_SRC emacs-lisp
(+ 2 4)
#+END_SRC

#+RESULTS: 77C740DF-C6E6-4A99-885E-9C7D0E3B145A
: 6

#+BEGIN_SRC emacs-lisp
(defun org-src-block-store-link ()
  (let* ((object (org-element-context)))
    (when (equal (org-element-type object) 'src-block)
      (org-store-link-props
       :type "src-block"
       :link (concat "src-block:" (org-element-property :name object))))))

(add-hook 'org-store-link-functions 'org-src-block-store-link)

(org-add-link-type
 "src-block"
 (lambda (label)
   (org-mark-ring-push)
   (widen)
   (goto-char (point-min))
   (re-search-forward (regexp-quote (format "#+NAME: %s" label)))
   (beginning-of-line)))
#+END_SRC

#+RESULTS:
| lambda | (label) | (org-mark-ring-push) | (widen) | (goto-char (point-min)) | (re-search-forward (regexp-quote (format #+NAME: %s label))) | (beginning-of-line) |

[[src-block:77C740DF-C6E6-4A99-885E-9C7D0E3B145A]]

* Dates in headers and sorting


** [2013-09-02 Mon]
** [2014-09-02 Tue]
** [2015-09-02 Wed]

* Python tutor
  :PROPERTIES:
  :ID:       198C4A99-8C35-4AC5-A487-6A82334603CC
  :END:

** Example requests to get hints.
This is code to explore using the Python tutor That Kelly Rivers has developed. Below is an example that shows how to do it in Python.
#+BEGIN_SRC python
import json

payload = {'needsReturn': True,
           'code': '''def canDrinkAlcohol(age, isDriving):
    return age >= 21 and not isDrivin
''',
           'userId': 'jkitchin',
           'problemId': 'canDrinkAlcohol'}

url = 'http://www.krivers.net/feedback/gethint.php'
headers = {'Content-type': 'application/json'}

import requests

print requests.post(url, data=json.dumps(payload)).json()
#+END_SRC

#+RESULTS:
: {u'hint': u"In line 2 replace <b>isDrivin</b> with something in the value of the unary operation.<br>If you're still stuck, ask for the next level of hint!"}


Here is the equivalent code In Emacs Lisp


#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((url-request-method "POST")
      (url "http://www.krivers.net/feedback/gethint.php")
      (url-request-data (json-encode-alist `((needsReturn . t)
					     (userId . "jkitchin")
					     (problemId . "canDrinkAlcohol")
					     (code . "def canDrinkAlcohol(age, isDriving):
    return age >= 21 and not isDriving")))))
    (with-current-buffer  (url-retrieve-synchronously url)
      (message-box
       (buffer-substring url-http-end-of-headers (point-max)))))
#+END_SRC

#+RESULTS:
:
: {"hint":"Your solution is already correct! Press 'Submit' to get credit for solving the problem."}

** Get hint for a code block
Function to get a hint from a code block:

#+BEGIN_SRC emacs-lisp
(require 'json)

(defvar cloudcoder-userid "jkitchin")

(defun cloudcoder-check-answer (&optional debug)
  "With your cursor in a Python source block, send code to the
hint server to get a hint. Use a prefix arg for DEBUG."
  (interactive "P")
  ;;  first get code block
  (let* ((src-block (org-element-context))
	 (url-request-method "POST")
	 (url "http://www.krivers.net/feedback/gethint.php")
	 (url-request-data
	  (json-encode-alist `((needsReturn . t)
			       (userId . cloudcoder-userid)
			       (problemId . ,(org-element-property :name src-block))
			       (code . ,(org-element-property :value src-block)))))
	 json-response)
    (when debug
      (message "%s" url-request-data))
    (with-current-buffer  (url-retrieve-synchronously url)
      (let ((response (s-trim
		       (buffer-substring url-http-end-of-headers (point-max)))))
	(when debug
	  (message response))
	(setq json-response
	      (json-read-from-string
	       response))
	(message "%S"
		 (replace-regexp-in-string
		  "<br>" "\n" (cdr (assoc 'hint json-response))))))))
#+END_SRC

#+RESULTS:
: cloudcoder-check-answer

Here are some example code blocks.

It looks like for this to work, you need use a function the server can evaluate, and the function has to have a name the server knows. There needs to be a userID stored in a variable for this. The org src-block needs a name that is the problemID.

It might be nice to show model solutions and pep8 style feedback. I can get the hints, but I am not sure about submitting this.

For engineering, if we can use Enthought or Continuum we can get numpy, scipy, and matplotlib. I would also want some other packages installed. Synchronization between local installations and the server could be a challenge.

*** canDrinkAlcohol
#+name: canDrinkAlcohol
#+BEGIN_SRC python
def canDrinkAlcohol(age, isDriving):
    return age == 21 and not isDriving

print canDrinkAlcohol(20, True)
#+END_SRC

#+RESULTS: canDrinkAlcohol
: False

*** overNineThousand
#+name: overNineThousand
#+BEGIN_SRC python
def overNineThousand(N):
    return N > 9000
#+END_SRC


*** findRoot
there seems to be some security manager issue.

#+name: findRoot
#+BEGIN_SRC python
import math
def findRoot(a, b, c):
    return max([(-b + math.sqrt(b**2 - 4 * a * c)) / (2 * a), (-b - math.sqrt(b**2 - 4 * a * c)) / (2 * a)])

print findRoot(1, -7, 12)
#+END_SRC

#+RESULTS:
: 4.0


#+name: findRoot
#+BEGIN_SRC python
def findRoot(a, b, c):
    s1 = (-b + (b**2 - 4 * a * c)**0.5) / (2 * a)
    s2 = (-b - (b**2 - 4 * a * c)**0.5) / (2 * a)
    if s1 > s2:
        return s1
    else:
        return s2
#+END_SRC

*** kthDigit
Given two integers, x and k, return the kth digit of x, counting from the right. So:
kthDigit(789, 0) returns 9
kthDigit(789, 1) returns 8
kthDigit(789, 2) returns 7
kthDigit(789, 3) returns 0
Negative numbers should work, too, so:
kthDigit(-789, 0) returns 9

#+name: kthDigit
#+BEGIN_SRC python
def kthDigit(x, k):
    s = str(abs(x))[::-1]
    return int(s[k]) if k < len(s) else 0
#+END_SRC

*** isEvenPositiveInt

Given an arbitrary value x, return True if it is an integer, and it is positive, and it is even (all 3 must be True), or False otherwise. Do not crash if the value is not an integer. So, isEvenPositiveInt("yikes!") returns False (rather than crashing), and isEvenPositiveInt(123456) returns True.

#+name: isEvenPositiveInt
#+BEGIN_SRC python
def isEvenPositiveInt(x):
    return isinstance(x, int) and x > 0 and (x % 2 == 0)

print isEvenPositiveInt('yikes')
print isEvenPositiveInt(1)
print isEvenPositiveInt(-1)
print isEvenPositiveInt(1.0)
#+END_SRC

#+RESULTS: isEvenPositiveInt
: False
: False
: False
: False

*** nearestBusStop
Write a function that takes a non-negative street number, and returns the nearest bus stop to the given street, where buses stop every 8th street, including street 0, and ties go to the lower street, so the nearest bus stop to 12th street is 8th street, and the nearest bus stop to 13 street is 16th street.

#+name: nearestBusStop
#+BEGIN_SRC python
def nearestBusStop(street):
    a = street % 8
    if a <= 4:
        return street - a
    else:
        return street + (8 - a)

print nearestBusStop(12)
print nearestBusStop(13)
#+END_SRC

#+RESULTS: nearestBusStop
: 4
: 5


*** circleArea
This seems to have some security issues. failed_by_security_manager

Given the radius of a circle, calculate its area (pi r^2). Note that you'll need to get the built-in value of pi from the math module.

#+name: circleArea
#+BEGIN_SRC python
import math
def circleArea(radius):
    return math.pi * radius**2
#+END_SRC


This example seems to return no hint
#+BEGIN_SRC python
def circleArea(radius):
    return 3.141 / radius**2

print circleArea(1.00)
#+END_SRC

#+RESULTS:
: 3.141


* transposed table

#+name: my-data
| 1 | 2 | 3 | 4 |
| a | b | c | d |

#+BEGIN_SRC emacs-lisp
(defun get-transposed-table (tblname)
  (save-excursion
    (org-open-link-from-string (format  "[[%s]]" tblname))
    (while (not (org-table-p))
      (forward-line))
    (let* ((table (delete 'hline (org-table-to-lisp)))
	   (contents (mapcar (lambda (p)
			       (let ((tp table))
				 (mapcar
				  (lambda (rown)
				    (prog1
					(pop (car tp))
				      (setq tp (cdr tp))))
				  table)))
			     (car table))))
      (mapconcat (lambda(x) (concat "| " (mapconcat 'identity x " | " ) "  |\n" ))
		 contents ""))))
#+END_SRC

#+RESULTS:
: get-transposed-table

#+BEGIN_SRC python :var data=(get-transposed-table "my-data")
print data
#+END_SRC

#+RESULTS:
: | 1 | a  |
: | 2 | b  |
: | 3 | c  |
: | 4 | d  |
:

[[my-data]]
* AIF

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ns, ScopusAbstract
from scopus.my_scopus import MY_API_KEY
import requests
import xml.etree.ElementTree as ET

import matplotlib.pyplot as plt
plt.xkcd()

QUERY = 'au-id(7004212771) and ((pubyear is {0}) or (pubyear is {1}))'

YEARS = [2008, 2009, 2010, 2011, 2012, 2013, 2014]
AIF = []
Hind = []
for YEAR in YEARS:

    s = ScopusSearch(query=QUERY.format(YEAR - 2, YEAR - 1),
                     fields='dc:identifier')

    abstracts = [ScopusAbstract(eid) for eid in s.EIDS
                 if ScopusAbstract(eid).aggregationType == 'Journal']


    TOTAL = 0 # citation count

    for ab in abstracts:
        xml = requests.get(ab.cite_link,
                           headers={'Accept': 'application/xml',
                                    'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

        results = ET.fromstring(xml)
        N = int(get_encoded_text(results, 'opensearch:totalResults'))

        start = 0
        count = 25

        while N > 0:
            xml = requests.get(ab.cite_link,
                               headers={'Accept': 'application/xml',
                                        'X-ELS-APIKey': MY_API_KEY},
                               params={'count': count,
                                       'start': start}).text.encode('utf-8')
            results = ET.fromstring(xml)

            start += count
            N -= count

            for el in results.findall('atom:entry/prism:coverDate', ns):
                year = int(el.text.split('-')[0])
                if year <= YEAR:
                    TOTAL += 1

    AIF.append(float(TOTAL) / len(abstracts))

    print Hind, AIF

    s = 'Author Impact Factor ({1}) = {0:1.3f} ({2} papers, {3} citations)\n'
    print(s.format(float(TOTAL) / len(abstracts),
                   YEAR,
                   len(abstracts),
                   TOTAL))

plt.figure()
plt.plot(YEARS, AIF, 'ro')
plt.xlabel('Year')
plt.ylabel('AIF_{2,3}')
plt.savefig('aif23.png')

plt.show()
#+END_SRC

#+RESULTS:

* DOI to org-bibtex entry
I can use this function to enter publications for our students in org-bibtex format. this will make them searchable in the future.

#+BEGIN_SRC emacs-lisp
(defun doi-to-org-bibtex (doi)
  (interactive "sDOI: ")
  (with-temp-buffer
    (insert (doi-utils-doi-to-bibtex-string doi))
    (bibtex-clean-entry)
    (kill-region (point-min) (point-max)))
   (org-bibtex-yank)
   (org-metaright)
   (org-metaright)
   (org-set-tags-to ":publication:"))
#+END_SRC
*** Alkaline Electrolyte and Fe Impurity Effects on the Performance and Active-Phase Structure of NiOOH Thin Films for OER Catalysis Applications :publication:
    :PROPERTIES:
    :TITLE:    Alkaline Electrolyte and Fe Impurity Effects on the Performance and Active-Phase Structure of NiOOH Thin Films for OER Catalysis Applications
    :BTYPE:    article
    :CUSTOM_ID: michael-2015-alkal-elect
    :AUTHOR:   John D. Michael and Ethan L. Demeter and Steven M. Illes and Qingqi Fan and Jacob R. Boes and John R. Kitchin
    :JOURNAL:  J. Phys. Chem. C
    :YEAR:     2015
    :VOLUME:   119
    :NUMBER:   21
    :PAGES:    11475-11481
    :DOI:      10.1021/acs.jpcc.5b02458
    :URL:      http://dx.doi.org/10.1021/acs.jpcc.5b02458
    :END:




#+BEGIN_HTML
tel:%28412%29%20268-7803
<a href="tel:18475555555">1-847-555-5555</a>
<a href="tel:+14123610357">1-412-361-0357</a>
#+END_HTML

* DONE Author impact factors
  CLOSED: [2015-08-11 Tue 09:12]
  :PROPERTIES:
  :categories: bibliometrics
  :date:     2015/08/11 09:12:19
  :updated:  2015/08/11 09:12:19
  :END:

In this new letter http://pubs.acs.org/doi/pdf/10.1021/acs.jpclett.5b01527, the editors suggest a new "Author Impact Factor" as a way to measure the productivity and impact of an author independently of the journals they publish in. The AIF is defined for a year like this: take the paper published in two consecutive years, get the citations for those papers in the following year, and compute:

\(AIF = \frac{Y3 citations for papers_{Y1,Y2}}{Number of papers in Y1, Y2}\).

Here I do this for myself, using Scopus as the source of papers and citations. My Scopus ID is
scopusid:7004212771. First, we need to get the articles published in 2012 and 2013. Here is the query, and the results.

#+BEGIN_SRC python :results html
from scopus import *
from scopus.scopus_api import ScopusAbstract

s = ScopusSearch(query='au-id(7004212771) and (pubyear is 2012 or pubyear is 2013)',
                 fields='dc:identifier')

abstracts = [ScopusAbstract(eid) for eid in s.EIDS
             if ScopusAbstract(eid).aggregationType == 'Journal']

print('<ol>')
for ab in abstracts:
    print('<li>' + ab.html + '</li>')
print('</ol>')
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<ol>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35603120700">John C. Eslick</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55772901000">David C. Miller</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84880986072&origin=inward">Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=6200180161">International Journal of Greenhouse Gas Control</a>, <b>18</b>, p. 68-74, (2013-10-01). <a href="http://dx.doi.org/10.1016/j.ijggc.2013.06.020">doi:10.1016/j.ijggc.2013.06.020</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569145100">Alexander P. Hallenbeck</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84881394200&origin=inward">Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>52(31)</b>, p. 10788-10794, (2013-08-07). <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55373026900">James X. Mao</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Hunaid B. Nulwala</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">David R. Luebke</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Krishnan Damodaran</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84873706643&origin=inward">Interactions in 1-ethyl-3-methyl imidazolium tetracyanoborate ion pair: Spectroscopic and density functional study</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=24642">Journal of Molecular Structure</a>, <b>1038</b>, p. 12-18, (2013-04-24). <a href="http://dx.doi.org/10.1016/j.molstruc.2013.01.046">doi:10.1016/j.molstruc.2013.01.046</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=26433085700">Federico Calle-Vallejo</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23479647900">Nilay G. Inoglu</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=25224517700">Hai-Yan Su</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=27667815700">José I. Martínez</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35491189200">Isabela C. Man</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7006205398">Marc T. M. Koper</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=9742604300">Jan Rossmeisl</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84876703352&origin=inward">Number of outer electrons as descriptor for adsorption processes on transition metals and their oxides</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=19700200838">Chemical Science</a>, <b>4(3)</b>, p. 1245-1249, (2013-03-01). <a href="http://dx.doi.org/10.1039/c2sc21601a">doi:10.1039/c2sc21601a</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Anita S. Lee</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84867809683&origin=inward">Chemical and molecular descriptors for the reactivity of amines with CO
                    2 </a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>51(42)</b>, p. 13609-13618, (2012-10-24). <a href="http://dx.doi.org/10.1021/ie301419q">doi:10.1021/ie301419q</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7201763336">Edward S. Rubin</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=27467500000">Hari Mantripragada</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55210428500">Aaron Marks</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=37081979100">Peter Versteeg</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84864914806&origin=inward">The outlook for improved carbon capture technology</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=27538">Progress in Energy and Combustion Science</a>, <b>38(5)</b>, p. 630-671, (2012-10-01). <a href="http://dx.doi.org/10.1016/j.pecs.2012.03.003">doi:10.1016/j.pecs.2012.03.003</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=52463103500">Sneha A. Akhade</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84865730756&origin=inward">Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=28134">Journal of Chemical Physics</a>, <b>137(8)</b>, Art. No. 084703, , (2012-08-28). <a href="http://dx.doi.org/10.1063/1.4746117">doi:10.1063/1.4746117</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=35787409400">James Landon</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55328415000">Ethan Demeter</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23479647900">Nilay Inoǧlu</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=47962378000">Chris Keturakis</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7006804734">Israel E. Wachs</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8238710700">Relja Vasić</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24404182600">Anatoly I. Frenkel</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84864592302&origin=inward">Spectroscopic characterization of mixed Fe-Ni oxide electrocatalysts for the oxygen evolution reaction in alkaline electrolytes</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=19700188320">ACS Catalysis</a>, <b>2(8)</b>, p. 1793-1801, (2012-08-03). <a href="http://dx.doi.org/10.1021/cs3002644">doi:10.1021/cs3002644</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=54973276000">Robin Chao</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55308251800">Ratiporn Munprom</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=56347288000">Rumyana Petrova</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=12803603300">Kirk Gerdes</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004541416">Paul A. Salvador</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84863684845&origin=inward">Structure and relative thermal stability of mesoporous (La, Sr) MnO 3powders prepared using evaporation-induced self-assembly methods</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=20982">Journal of the American Ceramic Society</a>, <b>95(7)</b>, p. 2339-2346, (2012-07-01). <a href="http://dx.doi.org/10.1111/j.1551-2916.2012.05236.x">doi:10.1111/j.1551-2916.2012.05236.x</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84866142469&origin=inward">Preface: Trends in computational catalysis</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=21971">Topics in Catalysis</a>, <b>55(5-6)</b>, p. 227-228, (2012-06-01). <a href="http://dx.doi.org/10.1007/s11244-012-9808-0">doi:10.1007/s11244-012-9808-0</a>.</li>
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=36472906200">W. Richard Alesi</a> and <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">John R. Kitchin</a>, <a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84861127526&origin=inward">Evaluation of a primary amine-functionalized ion-exchange resin for CO
                    2 capture</a>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=13057">Industrial and Engineering Chemistry Research</a>, <b>51(19)</b>, p. 6907-6915, (2012-05-16). <a href="http://dx.doi.org/10.1021/ie300452c">doi:10.1021/ie300452c</a>.</li>
</ol>
#+END_HTML

Now, we need to get the citing articles for each one of these, and only count them if they were published in 2014 or earlier. Each abstract has a cite_link in it, which points to the API url to get the articles citing it. Let's see what we are up against here. First, we see how many citations there are in total.

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ScopusAbstract
from scopus.my_scopus import MY_API_KEY

s = ScopusSearch(query='au-id(7004212771) and (pubyear is 2012 or pubyear is 2013)',
                 fields='dc:identifier')

abstracts = [ScopusAbstract(eid) for eid in s.EIDS
             if ScopusAbstract(eid).aggregationType == 'Journal']

import requests
import xml.etree.ElementTree as ET

TOTAL = 0
for ab in abstracts:
    xml = requests.get(ab.cite_link,
                       headers={'Accept': 'application/xml',
                                'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

    results = ET.fromstring(xml)
    N = int(get_encoded_text(results, 'opensearch:totalResults'))
    TOTAL += N
    print N

print '{} total citations'.format(TOTAL)
print TOTAL / float(11)
#+END_SRC

#+RESULTS:
#+begin_example
4
9
5
18
5
98
10
50
4
0
16
219 total citations
19.9090909091
#+end_example

Not bad looking, but some of those citations might be from 2015, and some of them might be self-citations.  Let's see about removing those. Usually, there are just 25 results per query, and some of the ones above have more than 25 results, so we will have to run a loop to get them all. For now, we just remove the citations from papers newer than the desired year It is a little tougher to remove the self-citations; that would require another request to Scopus to get authors and look for matches.

Here is some code that calculates my AIF for 2012, 2013 and 2014. The only issue I currently have with this code is the use of the abstract coverDate to get the publication year. I don't have a better way to do this, but I have seen a lot of cover dates that start on Jan 1 of a year, and that seems improbable to me. On the other hand, that might reflect a lot of submissions near the end of a year that just make it into the next one.

#+BEGIN_SRC python
from scopus import *
from scopus.scopus_api import get_encoded_text, ns, ScopusAbstract
from scopus.my_scopus import MY_API_KEY
import requests
import xml.etree.ElementTree as ET


QUERY = 'au-id(7004212771) and ((pubyear is {0}) or (pubyear is {1}))'

for YEAR in [2012, 2013, 2014]:

    print(QUERY.format(YEAR - 2, YEAR - 1))
    s = ScopusSearch(query=QUERY.format(YEAR - 2, YEAR - 1),
                     fields='dc:identifier')

    abstracts = [ScopusAbstract(eid) for eid in s.EIDS
                 if ScopusAbstract(eid).aggregationType == 'Journal']
    print '{0}-{1} papers'.format(YEAR - 2, YEAR - 1)
    print ' '.join(['doi:{}'.format(ab.doi) for ab in abstracts])
    TOTAL = 0 # citation count

    for ab in abstracts:
        xml = requests.get(ab.cite_link,
                           headers={'Accept': 'application/xml',
                                    'X-ELS-APIKey': MY_API_KEY}).text.encode('utf-8')

        results = ET.fromstring(xml)
        N = int(get_encoded_text(results, 'opensearch:totalResults'))

        start = 0
        count = 25

        while N > 0:
            xml = requests.get(ab.cite_link,
                               headers={'Accept': 'application/xml',
                                        'X-ELS-APIKey': MY_API_KEY},
                               params={'count': count,
                                       'start': start}).text.encode('utf-8')
            results = ET.fromstring(xml)

            start += count
            N -= count

            for el in results.findall('atom:entry/prism:coverDate', ns):
                year = int(el.text.split('-')[0])
                if year <= YEAR:
                    TOTAL += 1

    s = 'Author Impact Factor ({1}) = {0:1.3f} ({2} papers, {3} citations)\n'
    print(s.format(float(TOTAL) / len(abstracts),
                   YEAR,
                   len(abstracts),
                   TOTAL))
#+END_SRC

#+RESULTS:
#+begin_example
au-id(7004212771) and ((pubyear is 2010) or (pubyear is 2011))
2010-2011 papers
doi:10.1063/1.3631948 doi:10.1002/cctc.201000397 doi:10.1021/cs200039t doi:10.1063/1.3561287 doi:10.1002/cssc.201000056 doi:10.1149/1.3432440 doi:10.1103/PhysRevB.82.045414 doi:10.1016/j.fuel.2009.11.036 doi:10.1080/08927022.2010.481794
Author Impact Factor (2012) = 9.667 (9 papers, 87 citations)

au-id(7004212771) and ((pubyear is 2011) or (pubyear is 2012))
2011-2012 papers
doi:10.1021/ie301419q doi:10.1016/j.pecs.2012.03.003 doi:10.1063/1.4746117 doi:10.1021/cs3002644 doi:10.1111/j.1551-2916.2012.05236.x doi:10.1007/s11244-012-9808-0 doi:10.1021/ie300452c doi:10.1063/1.3631948 doi:10.1002/cctc.201000397 doi:10.1021/cs200039t doi:10.1063/1.3561287
Author Impact Factor (2013) = 14.000 (11 papers, 154 citations)

au-id(7004212771) and ((pubyear is 2012) or (pubyear is 2013))
2012-2013 papers
doi:10.1016/j.ijggc.2013.06.020 doi:10.1021/ie400582a doi:10.1016/j.molstruc.2013.01.046 doi:10.1039/c2sc21601a doi:10.1021/ie301419q doi:10.1016/j.pecs.2012.03.003 doi:10.1063/1.4746117 doi:10.1021/cs3002644 doi:10.1111/j.1551-2916.2012.05236.x doi:10.1007/s11244-012-9808-0 doi:10.1021/ie300452c
Author Impact Factor (2014) = 14.000 (11 papers, 154 citations)
#+end_example

Just a reminder of what these AIFs are. It is the ratio of the number of citations papers from two consecutive years (Y1 and Y2) have received in the next year Y3. These numbers suggest that on average my recent papers are getting 14 citations a year. I printed the DOIs above because I was skeptical that my AIF in 2013 and 2014 were identical, but it seems clear the papers are different, and it must be a coincidence that the number of citations is the same (I am still a bit skeptical though ;).

Is this a useful measure of author impact? That would take some study. The way this is defined it is a short-term impact which might be biased to some fields that have more than a three year time-frame before citations build up. That is fixed easily enough by increasing the window of publications, and/or counting citations two years out, for example. It is interesting this decouples the impact from the journals the articles are published in. I think this says I should be submitting my papers to higher impact journals though! My AIF exceeds the JIF of the journals I usually publish in.





* Radio targets

You can see this (id) and here (id-2), but you might prefer a link like [[some target][this one]].

a

a

a

a

a

a

a

a

a

a

a
a
a

a

a

a

























<<<id>>> http://example.com/ "Optional Title Here"

<<<id-2>>> Some other tidbit.

<<some target>> A note about something.
* Using format-spec

#+BEGIN_SRC emacs-lisp
(format-spec "A %s is good for %g" '((?s . "Tree") (?g . "wood")))
#+END_SRC

#+RESULTS:
: A Tree is good for wood

* Run shell command asynchronously

#+BEGIN_SRC sh :tangle some_cmd.sh :tangle-mode (identity #o755) :shebang #!/bin/bash
sleep 10
touch async-file
echo "done"
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(require 'async)

(org-babel-tangle)

(async-start
 (lambda ()
   (shell-command (expand-file-name "some_cmd.sh")))
 (lambda (result)
   (message-box "%s" result)))

#+END_SRC

#+RESULTS:
: #<process emacs>

#+BEGIN_SRC sh
ls async-file
#+END_SRC

#+RESULTS:
: async-file

#+BEGIN_SRC emacs-lisp
(require 'async)

(async-start
 (lambda ()
   (shell-command "xterm"))
 (lambda (result)
   (message-box "%s" result)))
#+END_SRC
#+RESULTS:
: #<process emacs>


* Tag clouds

** this works!
#+BEGIN_SRC python

with open('pg2852.txt') as f:
    text = f.read()

from os import path
import matplotlib.pyplot as plt
from wordcloud import WordCloud

wordcloud = WordCloud(font_path='/Users/jkitchin/Library/Fonts/Inconsolata-g.ttf').generate(text)
# Open a plot of the generated image.
plt.imshow(wordcloud)
plt.axis("off")
plt.show()
#+END_SRC

#+RESULTS:
==

** pygame doesn't quite work for large tag clouds
[[http://blog.matt-swain.com/post/87112978897/fixing-matplotlib-png-output-on-mac-os-x][Fixing matplotlib png output on Mac OS X | Matt Swain]]
[[https://bitbucket.org/pygame/pygame/issues/82/homebrew-on-leopard-fails-to-install][pygame / pygame / issues / #82 - homebrew on Leopard fails to install —
Bitbucket]]

[[https://github.com/atizo/PyTagCloud/blob/master/pytagcloud/test/tests.py][PyTagCloud/tests.py at master · atizo/PyTagCloud]]

#+BEGIN_SRC python
from pytagcloud import create_tag_image, make_tags
from pytagcloud.lang.counter import get_tag_counts

YOUR_TEXT = "A tag cloud is a visual representation for text data, typically\
used to depict keyword metadata on websites, or to visualize visualize visualize free form text."

with open('pg2852.txt') as f:
    YOUR_TEXT = f.read()

tags = make_tags(get_tag_counts(YOUR_TEXT), maxsize=120)
#create_tag_image(tags, 'cloud_large.png', size=(900, 600))
#+END_SRC

#+RESULTS:


[[./cloud_large.png]]


* not breaking index			 :ARCHIVE:
this was an effort to try getting emacs not to break at spaces in the index. it did not work.
#+BEGIN_SRC emacs-lisp
(defun nobreak-p ()
  (interactive)
  (let ((result (if (and (looking-at " ")
			 (save-excursion
			   (re-search-forward "[^{]*}" (line-end-position) 'end))
			 (save-excursion
			   (re-search-backward "[^}]*\\\\index{" (line-beginning-position) 'end)))
		    t
		  nil)))
    (message "%s" result)
    result))

(add-hook 'fill-nobreak-predicate #'nobreak-p)
#+END_SRC

#+RESULTS:
| nobreak-p | org-fill-line-break-nobreak-p | org-fill-paragraph-with-timestamp-nobreak-p |


like this fjkd;lsa fiosg hgjkr ae jfk;las fdsjakl; fdjskal; fjdskla; fjkdsla;
fjdskla; fjdskla; fjdskal; fjdskal;f jdsakl;f ajkl;sd fjklas;
fjdksla;fjkdsjfkd;lsjfkdls;jfkldsa  jfkld;s fjkdlas; fjdkl; fjdkl;sa fjkdsl;
fjdskl; fjdskl;

jfdjkla; fjkdsla \index{this is an index} and then some text \index{and then
another index} what  else can we do to get wrapping to work?   something fjdklsa fjdklasjfkdsla kl; jfklda jkl; jfkdlsa jkl;a jfkldsjierwoqjr kl;as l; j lkjkl;as jkl; jklfewaj jkl;ewjk l; jfdkajkf jkfl;dsa jkl; jk ;fjkl;w jfdl jkfldas jkl j lk; jklfdsa jkfldsa jkl jkl fjdkl;sa

what djkf;a fkdls; fjdksal; fjdklsa; fjdklsa;



* Using python in formulas in an org-mode spreadsheet
You can use emacs lisp in an org-mode spreadsheet as a formula. We will hack that to let us use Python. We will do that by making a lisp function that evaluates a python string and returns the results.

| x | y |    |
|---+---+----|
| 1 | 2 |  3 |
| 2 | 4 |  6 |
| 3 | 6 | 18 |
|---+---+----|
|   |   |    |
#+TBLFM: @2$3=@2$1 + @2$2
#+TBLFM: @3$3='(+ @3$1 @3$2);N
#+TBLFM: @4$3='(python "@4$1 * @4$2");N

#+BEGIN_SRC emacs-lisp
(defun python (string)
  "Send string to a python interpreter and return result."
  (python-shell-send-string-no-output
    string
    (or (python-shell-get-process)
	(run-python))))
#+END_SRC


* Replacement for insert paths using helm

You just type C-x C-f select the file, and then use the new actions. Note, there is already a way to insert an org link from helm: C-c @ but it will always be an absolute path.

#+BEGIN_SRC emacs-lisp
(defun helm-insert-path (candidate)
 (insert candidate))

(defun helm-insert-relative-path (candidate)
 (insert (file-relative-name candidate)))

(defun helm-attach-to-email (candidate)
 (mml-attach-file candidate))

(helm-add-action-to-source "Insert path"
			   'helm-insert-path helm-source-find-files)
(helm-add-action-to-source "Insert relative path"
			   'helm-insert-relative-path helm-source-find-files)

(helm-add-action-to-source "Attach file to email"
                           'helm-attach-to-email helm-source-find-files)
#+END_SRC

* org src blocks hydra
[[https://github.com/abo-abo/hydra/wiki/Org-mode-block-templates][Org mode block templates · abo-abo/hydra Wiki]]



* Updating a timestamp in a heading
  :PROPERTIES:
  :LAST-EDITED: [2015-08-01 Sat 12:01:27]
  :END:
Here is the function to update a timestamp when you run it.
#+BEGIN_SRC emacs-lisp
(defun update-last-edited (beg end length)
  (when
      (and
       (not (org-before-first-heading-p))
       (org-get-heading))
    (org-entry-put nil "LAST-EDITED" (format-time-string "[%Y-%m-%d %a %H:%M:%S]"))))

(add-to-list 'after-change-functions 'update-last-edited)
#+END_SRC

#+RESULTS:
| update-last-edited |

** test
   :PROPERTIES:
   :LAST-EDITED: [2015-08-01 Sat 12:01:30]
   :END:

* Displaying image overlays on image filenames
  :PROPERTIES:
  :LAST-EDITED: [2015-08-01 Sat 12:00:23]
  :END:
It has always bothered me a little that I have to add a file image after code blocks in org-mode to see the results. That extra work... I also don't like having to explicitly print the figure in the code, since that is the extra work, just in a different place. Today I look into just putting overlays of image files right on the file name. The plus side of this is no extra work. The downside is they won't export; that will still take the extra work, but you needed that for the caption anyway ;)

Here is a test.
#+BEGIN_SRC python
import matplotlib.pyplot as plt
plt.plot([-0, 1, 2, 4, 16])
plt.savefig("test-fig.png")
#+END_SRC

#+RESULTS:

We make this so it only works for png files.

#+BEGIN_SRC emacs-lisp
(save-excursion
 (save-restriction
  (goto-char (point-min))
  (let ((re (concat  "\\(?:'\\|\"\\)\\(.*\\."
		     (regexp-opt '("png" "PNG" "JPG" "jpeg"
				   "jpg" "JPEG" "eps" "EPS"))
		     "\\)\\(?:'\\|\"\\)"))
	beg end imgfile img)
    (while (re-search-forward re nil t)
      (setq beg (match-beginning 0)
	    end (match-end 0)
	    imgfile (match-string 1))
      (when (file-exists-p imgfile)
	(setq img (create-image (expand-file-name imgfile) 'imagemagick nil :width 300))
	(setq ov (make-overlay beg end))
	(overlay-put ov 'display img)
	(overlay-put ov 'face 'default)
	(overlay-put ov 'org-image-overlay t)
	(overlay-put ov 'modification-hooks
		     (list 'org-display-inline-remove-overlay)))))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(ov-clear)
#+END_SRC
#+RESULTS:


* Parsing sexps in plain text and putting overlays on them

I am exploring a kind of richer markup here to put context into plain text using sexp notation instead of [[http://www.w3.org/TR/rdfa-lite/][RDF]] notation. RDF notation is just heavy for an author to write. Sexp notation, on the other hand, is lighter in my opinion. You can even imagine this relatively readable markup being code in addition to data (see this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/][post]] on a sexp notation for bibtex for example).

I will use Emacs overlays to hide the sexp and display the contents. For example, say we markup a "person" like this @(:person "John Kitchin" :email "jkitchin@andrew.cmu.edu"). It seems in this approach it is necessary to put strings in quotes because we eventually read these sexps into lisp. I want Emacs to find these, and replace it with an overlay of a more human readable content, and some contextual tooltip about the real content.

For fun, let us see if we can nest a sexp in the sexp, here to have some code that constructs an email address. For example, (:person "John" :email (concat "jkitchin" "@cmu.edu")) has code to build the email address. This works, but the code is not actually executed anywhere. You would have to do that somewhere else.

Ok, here is a little code block that "renders" our buffer to show the person entries with an overlay. This is kind of like what a browser would do with html tags, but with my lispy markup. Here we rely on a particular data structure that we know in advance. We could probably be smarter about it, and check that there is a :person in the sexp, but for now we keep it simple, and make that be the car of the sexp. We will make an overlay of the name in angle brackets with an underline to indicate it is not the original text, and make a tooltip of the contents.

#+BEGIN_SRC emacs-lisp
(require 'ov)

(save-excursion
  (goto-char (point-min))
  (while (and  (re-search-forward "@(" nil t)
	       (sexp-at-point))
    (let ((beg)
	  (end)
	  (sexp))
      (backward-char)
      (setq beg (point))
      (setq sexp (read (current-buffer)))
      (when (and (listp sexp)
		 (eq :person (car (sexp-at-point))))
	(scan-sexps (point) 1)
		(setq end (point))
	(ov beg end 'help-echo (format "%S" sexp)
	    'face '(:underline t)
	    'display (concat "<" (plist-get sexp :person) ">")
	    'person t)))))
#+END_SRC

#+RESULTS:

That seems to work nicely. We can remove the overlays like this we can see the plain text.

#+BEGIN_SRC emacs-lisp
(ov-clear 'person)
#+END_SRC

#+RESULTS:

One reason for doing this, is the possibility of machine reading documents to extract data. Let's get the "people" out of this document. Here we go.

#+BEGIN_SRC emacs-lisp
(save-excursion
  (goto-char (point-min))
  (let ((beg)
	(end)
	(sexp)
	(people '()))
    (while (and  (re-search-forward "(" nil t)
		 (sexp-at-point))
      (backward-char)
      (setq beg (point))
      (setq sexp (read (current-buffer)))
      (when (and (listp sexp)
		 (eq :person (car (sexp-at-point))))
	(add-to-list 'people sexp)))
    people))
#+END_SRC

#+RESULTS:
| :person | John         | :email | (concat jkitchin @cmu.edu) |
| :person | John Kitchin | :email | jkitchin@andrew.cmu.edu    |

Now, we have a nice list of "persons" we can do something with, e.g. add them to an org-contacts database, send a mail merge, etc... For sufficiently complex data structures, there might be some functions to help insert them. Let us do show a simple example to insert a "person" from a name in my org-contacts database.

#+BEGIN_SRC emacs-lisp
(defun insert-person (name)
  "Insert a person sexp for the NAME entry in `org-contacts-db'."
  (interactive "sName: ")
  (let ((contact (assoc name (org-contacts-db)))
	(p '()))
    (when contact
      (setq p (plist-put p :person (substring-no-properties(car contact))))
      (setq p (plist-put p :email (cdr (assoc "EMAIL" (nth 2 contact)))))
      (insert (format "%S" p)))))
#+END_SRC

#+RESULTS:
: insert-person


No doubt there are potential security issues with this. You would not want to do this with untrusted documents. But, with trusted documents, what an amazing opportunity to do something that is just not possible otherwise! This is like the best of both worlds in text, where you get easy authoring of some parts, the text part, and machine-readability in the data parts, which also look pretty readable, especially after the overlays.

Now, obviously you would need some kind of way to know how to render any things marked up this way. These are usually called [[http://www.w3schools.com/schema/][schemas]], and somewhere in the document you would put some kind of information about that. This could range from code that loads the overlay library, e.g. (:schema 'person), or some kind of url that defines the schema, e.g. (:schema "http://kitchingroup.cheme.cmu/person"). I have not thought too much about this point yet.

There are some related ideas around, e.g. [[http://racket-lang.org][racket]]. [[http://www.dexy.it][dexy]] is a project that lets you embed code in documents that can be rendered in different outputs. Over on oremacs there is a project called [[http://oremacs.com/2015/01/23/eltex/][eltex]] where a LaTeX document is written totally in emacs-lisp. We previously  wrote about [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/05/Extending-the-org-mode-link-syntax-with-attributes/][org-mode links with attributes]]. There is also the linked text library [[http://www.emacswiki.org/emacs/linkd.el][linkd.el]] that provides a syntax for making sexps in text clickable. That package is especially interesting because, among many other things, it ties sexps into font-lock to automatically recognize them, and it provides some export support to other formats, making it possible to do some preprocessing to handle the sexps, and then to have an org-mode export. This package definitely needs more study!


Why not use html/xml for this kind of markup? There are some strong opinions out there, including http://c2.com/cgi/wiki?LispVsXml and https://rwmj.wordpress.com/2009/10/30/xml-or-s-expressions/. Here the bottom line is we can integrate the sexp notation pretty well with the editor we are using; it natively speaks them.

* Record audio and put link to it in org-mode

#+BEGIN_SRC emacs-lisp
(defun insert-voice-memo ()
  "Record voice memo and insert an org-mode link to it.
memos are stored by time-stamp in the current directory."
  (interactive)

  (let ((memo-name (replace-regexp-in-string "\\( \\|:\\)" "-"
					     (concat (current-time-string)
						     ".m4a"))))
    (do-applescript
     (format "tell application \"Finder\"
        set savePath to \"%s\"
        set savePath to POSIX file \"%s\" as text
	tell application \"QuickTime Player\"
		activate
		set doku to new audio recording
		start doku
		set yn to (display dialog \"Press Stop to quit and save.\" buttons {\"Stop\"} giving up after 600)
		stop doku
		set newDoc to last item of (documents whose name contains \"Untitled\")
		export newDoc in file savePath using settings preset \"Audio Only\"
		quit saving no
	end tell
end tell" (expand-file-name memo-name ".") (expand-file-name memo-name ".")))
 (insert (format
	     "[[./%s][%s]]"
	     memo-name (read-input "Description: " "voice memo")))))
#+END_SRC

#+RESULTS:
: insert-voice-memo

[[./Sun-Jul-26-08-45-09-2015.m4a]]   [[./Sun-Jul-26-09-00-55-2015.m4a][voice memo]]

* DONE Altmetrics meet my publications
  CLOSED: [2015-08-08 Sat 15:56]
  :PROPERTIES:
  :categories: publication,bibliometric
  :date:     2015/08/08 15:56:57
  :updated:  2015/08/08 15:56:57
  :END:
Altmetrics is an alternative to simple citation counts of articles. Altmetrics looks at how your papers are mentioned in Tweets, google+, blog posts, news, how many Mendeley users have the article, etc... They are partnering with publishers to provide additional metrics on your papers.

You can put some Altmetric badges on your papers so you can see how they are doing. In this post, we scrape out my papers from my orcid page, and add Altmetric badges to them. This is basically just a little snippet of html code that will put the Altmetric donut in the citation, which has some information about the number of times each paper is tweeted, etc...

#+BEGIN_HTML
<script type='text/javascript' src='https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js'></script>
#+END_HTML

So, here is a python script that will print some html results. We print each title with the Altmetric donut, and we add a Scopus Cited by count for each paper.

#+BEGIN_SRC python :results html
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})
results = resp.json()

data = []
TITLES, DOIs = [], []

badge = "<div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='{doi}'></div>"
scopus_cite = "<img src=\"http://api.elsevier.com/content/abstract/citation-count?doi={doi}&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c\">"
html = '<a href="http://dx.doi.org/{doi}">{title}</a>'

print '<ol>'
for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    title = str(result['work-title']['title']['value'].encode('utf-8'))
    doi = 'None'

    for x in result.get('work-external-identifiers', []):
        for eid in result['work-external-identifiers']['work-external-identifier']:
            if eid['work-external-identifier-type'] == 'DOI':
                doi = str(eid['work-external-identifier-id']['value'].encode('utf-8'))

    # AIP journals tend to have a \n in the DOI, and the doi is the second line. we get
    # that here.
    if len(doi.split('\n')) == 2:
        doi = doi.split('\n')[1]

    pub_date = result.get('publication-date', None)
    if pub_date:
        year = pub_date.get('year', None).get('value').encode('utf-8')
    else:
        year = 'Unknown'

    # Try to minimize duplicate entries that are found
    dup = False
    if title.lower() in TITLES:
        dup = True
    if (doi != 'None'
        and doi.lower() in DOIs):
        dup = True

    if not dup and doi != 'None':
        # truncate title to first 50 characters
        print('<li>' + html.format(doi=doi, title=title)
              + badge.format(doi=doi) + scopus_cite.format(doi=doi)
              + '</li>\n')

    TITLES.append(title.lower())
    DOIs.append(doi.lower())

print '</ol>'
#+END_SRC

It is a little humbling to see these results! The Altmetric data shows a very different dimension than the citation metrics. It is hard to tell what impact these will have, but they give you another view of who is talking about your work.

#+RESULTS:
#+BEGIN_HTML
<ol>
<li><a href="http://dx.doi.org/10.1021/jp511426q">A Linear Response DFT+ U Study of Trends in the Oxygen Evolution Activity of Transition Metal Rutile Dioxides</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp511426q'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp511426q&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.4914093">Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.4914093'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4914093&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2015.02.011">Core level shifts in Cu–Pd alloys as a function of bulk composition and structure</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2015.02.011'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2015.02.011&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs501585k">Estimating bulk-composition-dependent H2 adsorption energies on CuxPd1- x alloy (111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs501585k'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs501585k&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp508805h">Probing the Coverage Dependence of Site and Adsorbate Configurational Correlations on (111) Surfaces of Late Transition Metals</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp508805h'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp508805h&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.catcom.2013.10.028'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ja5015986">Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ja5015986'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ja5015986&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/am4059149">Identifying Potential BO 2 Oxide Polymorphs for Epitaxial Growth Candidates</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/am4059149'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/am4059149&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1007/s11244-013-0166-3">Simulating temperature programmed desorption of oxygen on Pt(111) using DFT derived coverage dependent desorption barriers</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1007/s11244-013-0166-3'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1007/s11244-013-0166-3&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/c3ra47097k">Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/c3ra47097k'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/c3ra47097k&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp507957n">Effects of concentration, crystal structure, magnetism, and electronic structure method on first-principles oxygen vacancy formation energy trends in perovskites</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp507957n'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp507957n&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie400582a">Effects of O 2 and SO 2 on the Capture Capacity of a Primary-Amine Based Polymeric CO 2 Sorbent</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie400582a'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie400582a&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/http://dx.doi.org/10.1016/j.molstruc.2013.01.046">Interactions in 1-ethyl-3-methyl imidazolium tetracyanoborate ion pair: Spectroscopic and density functional study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='http://dx.doi.org/10.1016/j.molstruc.2013.01.046'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=http://dx.doi.org/10.1016/j.molstruc.2013.01.046&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/http://dx.doi.org/10.1016/j.ijggc.2013.06.020">Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='http://dx.doi.org/10.1016/j.ijggc.2013.06.020'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=http://dx.doi.org/10.1016/j.ijggc.2013.06.020&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie301419q">Chemical and Molecular Descriptors for the Reactivity of Amines with CO 2</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie301419q'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie301419q&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs3002644">Spectroscopic Characterization of Mixed Fe–Ni Oxide Electrocatalysts for the Oxygen Evolution Reaction in Alkaline Electrolytes</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs3002644'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs3002644&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.2172/1149701">Modeling Coverage Dependence in Surface Reaction Networks</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.2172/1149701'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.2172/1149701&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.pecs.2012.03.003">The outlook for improved carbon capture technology</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.pecs.2012.03.003'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.pecs.2012.03.003&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1111/j.1551-2916.2012.05236.x">Structure and Relative Thermal Stability of Mesoporous (La,Sr)MnO3 Powders Prepared Using Evaporation-Induced Self-Assembly Methods</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1111/j.1551-2916.2012.05236.x'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1111/j.1551-2916.2012.05236.x&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1007/s11244-012-9808-0">Preface: Trends in computational catalysis</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1007/s11244-012-9808-0'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1007/s11244-012-9808-0&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/ie300452c">Evaluation of a Primary Amine-Functionalized Ion-Exchange Resin for CO2 Capture</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/ie300452c'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/ie300452c&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.4746117">Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.4746117'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4746117&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/9781849734776-00083">Coverage dependent adsorption properties of atomic adsorbates on late transition metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/9781849734776-00083'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/9781849734776-00083&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1002/cctc.201000397">Universality in Oxygen Evolution Electrocatalysis on Oxide Surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1002/cctc.201000397'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1002/cctc.201000397&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.3570235">Preparation of Mesoporous La 0.8Sr 0.2MnO 3 infiltrated coatings in porous SOFC cathodes using evaporation-induced self-assembly methods</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.3570235'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.3570235&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/cs200039t">Identification of sulfur-tolerant bimetallic surfaces using dft parametrized models and atomistic thermodynamics</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/cs200039t'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/cs200039t&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3631948">Effects of strain, d-band filling, and oxidation state on the bulk electronic structure of cubic 3d perovskites</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3631948'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3631948&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3561287">Configurational correlations in the coverage dependent adsorption energies of oxygen atoms on late transition metal fcc(111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3561287'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3561287&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1002/cssc.201000056">CO2 Adsorption on Supported Molecular Amidine Systems on Activated Carbon</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1002/cssc.201000056'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1002/cssc.201000056&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.fuel.2009.11.036">Separation of CO2 from flue gas using electrochemical cells</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.fuel.2009.11.036'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.fuel.2009.11.036&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927022.2010.481794">New solid-state table: estimating d-band characteristics for transition metal atoms</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927022.2010.481794'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927022.2010.481794&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.82.045414">Simple model explaining and predicting coverage-dependent atomic adsorption energies on transition metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.82.045414'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.82.045414&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.3432440">Electrochemical concentration of carbon dioxide from an oxygen/carbon dioxide containing gas stream</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.3432440'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.3432440&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927020902833137">Uncertainty and figure selection for DFT based cluster expansions for oxygen adsorption on Au and Pt (111) surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927020902833137'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927020902833137&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1080/08927020902833129">Sulphur poisoning of water-gas shift catalysts: Site blocking and electronic structure modification</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1080/08927020902833129'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1080/08927020902833129&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.3096964">Step decoration of chiral metal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.3096964'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.3096964&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2009.01.021">Relating the coverage dependence of oxygen adsorption on Au and Pt fcc(111) surfaces through adsorbate-induced surface electronic structure effects</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2009.01.021'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2009.01.021&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevLett.103.246102">Hydrogen Dissociation and Spillover on Individual Isolated Palladium Atoms</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevLett.103.246102'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevLett.103.246102&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.79.205412">Correlations in coverage-dependent atomic adsorption energies on Pd(111)</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.79.205412'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.79.205412&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.jcat.2008.11.020">Atomistic thermodynamics study of the adsorption and the effects of water-gas shift reactants on Cu catalysts under reaction conditions</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.jcat.2008.11.020'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.jcat.2008.11.020&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1117/12.776303">Rotational isomeric state theory applied to the stiffness prediction of an anion polymer electrolyte membrane</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1117/12.776303'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1117/12.776303&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1039/b608782p">Density functional theory studies of alloys in heterogeneous catalysis</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1039/b608782p'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/b608782p&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevB.77.075437">Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag3Pd(111) in oxygen atmospheres</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevB.77.075437'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevB.77.075437&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.2358292">Response to &quot;comment on 'Trends in the exchange current for hydrogen evolution' J. Electrochem. Soc., 152, J23 (2005) &quot;</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.2358292'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.2358292&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1149/1.1856988">Trends in the exchange current for hydrogen evolution</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1149/1.1856988'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1149/1.1856988&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.cattod.2005.04.008">Trends in the chemical properties of early transition metal carbide surfaces: A density functional study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.cattod.2005.04.008'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.cattod.2005.04.008&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1103/PhysRevLett.93.156801">Role of strain and ligand effects in the modification of the electronic and chemical properties of bimetallic surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1103/PhysRevLett.93.156801'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1103/PhysRevLett.93.156801&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jp047349j">Origin of the overpotential for oxygen reduction at a fuel-cell cathode</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jp047349j'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jp047349j&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1063/1.1737365">Modification of the surface electronic and chemical properties of Pt(111) by subsurface 3d transition metals</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1063/1.1737365'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.1737365&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2003.09.007">Elucidation of the active surface and origin of the weak metal-hydrogen bond on Ni/Pt(111) bimetallic surfaces: a surface science and density functional theory study</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2003.09.007'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2003.09.007&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/j.susc.2003.08.041">A four-point probe correlation of oxygen sensitivity to changes in surface resistivity of TiO2(001) and Pd-modified TiO2(001)</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/j.susc.2003.08.041'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.susc.2003.08.041&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1016/s0039-6028(02)02679-1">A comparison of gold and molybdenum nanoparticles on TiO2(110) 1 x 2 reconstructed single crystal surfaces</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1016/s0039-6028(02)02679-1'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/s0039-6028(02)02679-1&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1073/pnas.072514399">H3PW12O40-functionalized tip for scanning tunneling microscopy</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1073/pnas.072514399'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1073/pnas.072514399&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

<li><a href="http://dx.doi.org/10.1021/jo00117a004">Preparation and Characterization of a Bis-Semiquinone: a Bidentate Dianion Biradical</a><div data-badge-type='medium-donut' class='altmetric-embed' data-badge-details='right' data-doi='10.1021/jo00117a004'></div><img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1021/jo00117a004&amp;httpAccept=image/jpeg&amp;apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></li>

</ol>
#+END_HTML


* getting altmetric by doi

#+BEGIN_SRC emacs-lisp
(defun doi-altmetrics (doi)
  (interactive "sDOI: ")
  (let ((url-request-method "GET")
	(url (concat "http://api.altmetric.com/v1/doi/" doi))
	(json-object-type 'plist)
	(json-data))
    (setq json-data
	  (with-current-buffer
	      (url-retrieve-synchronously url)

	    (json-read-from-string
	     (buffer-substring
	      url-http-end-of-headers (point-max)))))
    (browse-url
     (plist-get json-data :details_url))))

(doi-altmetrics "10.1021/jp511426q")
#+END_SRC

#+RESULTS:
: #<process open http://www.altmetric.com/details.php?citation_id=3863449>

* DONE Running scientific instruments in Emacs and recording the results
  CLOSED: [2015-07-25 Sat 10:04]
  :PROPERTIES:
  :categories: emacs,orgmode,notebook
  :date:     2015/07/25 10:04:01
  :updated:  2015/07/25 10:04:01
  :END:

Today we look at running a scientific instrument via http requests from Emacs and org-mode. We will use a Gamry Ref600 potentiostat because Gamry has very nicely provide a COM interface we can access via Python. This will be only a proof of concept to see what it is like. We will not consider any issues of security, etc..., only what is it like to do it.

The setup will look like this: we will run a flask web app that uses python to control the instrument via http requests. Why? Because I want to run the instrument from my Mac ;) and so far there are only Windows drivers for the instrument. So, we run the flask app on the Windows machine, and I run it from here on my Mac by sending requests. Flask takes care of converting requests to action using Python. You can see the [[id:5EB72A19-B9D3-4ABA-975F-61ACE16E0D87][Flask app here]].

Let's see what is online:
#+BEGIN_SRC sh
curl jkitchin-win.cheme.cmu.edu:5000/pstats
#+END_SRC

#+RESULTS:
: (u'REF600-13089',)

We have one potentiostat online with serial number 13089. I have a dummy cell connected to it which has a little resistor on it. So we can run a cyclic voltammogram and it should be a straight line. We have to know a bit about what is returned. We will get a json file back, and it will have the data in it. The data will be a list of lists. The data we want is in columns 1 and 3 (python indexing). Obviously you need some prior knowledge of what data comes back to use this. That would come from reading some documentation.

#+BEGIN_SRC python
import requests
import numpy as np
import matplotlib.pyplot as plt

resp = requests.get('http://jkitchin-win.cheme.cmu.edu:5000/cv?endv=0.25&startv=-0.25')

dj = resp.json()
data = np.array(dj['data'])

plt.plot(data[:, 1], data[:, 3])
plt.xlabel('Voltage (V)')
plt.ylabel('Current (A)')
plt.tight_layout()
plt.savefig('cv-1.png')
#+END_SRC

#+RESULTS:


[[./cv-1.png]]
Well, there you have it. Possibly the first Gamry Ref600 to ever have been driven from a Mac ;) Let me be more explicit about that; I could /also/ run this from Linux, an iPad, etc... You could do this in a browser, or in an IPython notebook, or in Matlab, among many other possibilities. You could write a script in perl, shell, ruby, emacs-lisp, or any other language that supports http requests.

I am not sure why the graph is not perfectly linear, maybe there is some capacitive charging that starts out. The resistance based on the current at 0.2V is about 2000 ohms, which is in good agreement with what is listed on the board the dummy cell is on.

** Summary thoughts
There are a host of interesting issues one eventually has to consider here including security, but also error management and debugging. I hacked something like an http api here by running flask on the windows machine running the instrument. That is a layer of abstraction on an abstraction to start with. I think later instruments are likely to run these webservers themselves on small dedicated computers, e.g. via a Raspberry pi or Arduino chipset. It is not obvious how sophisticated you can make this with respect to triggering different instruments, etc...

In running this, my "notebook" was blocked while the experiment ran. It is possible to run things asynchronously, and sometimes that would make sense. In the example here, we have provided a very limited set of functions to "run" the potentiostat. It was only a proof of concept to get a sense for what it is like. In practice a fuller set of functions would be implemented. Another point to consider is how the data comes back from the potentiostat. We used json here because it is convenient, but we could just as well send files, and other sorts of data too.

This lays out the possibility to walk up to an instrument with an electronic notebook, setup and run the experiment, capture the results in the notebook and take it back to the office for analysis. Pretty cool.

** Flask app
   :PROPERTIES:
   :ID:       5EB72A19-B9D3-4ABA-975F-61ACE16E0D87
   :END:

So, here is my flask app. We setup a few routes using get requests to do things like get a list of the potentiostats online, and to run a cyclic voltamogram. As a side note, after this post is over, I am turning off the app, so you won't be able to repeat the codes ;) This is not a beautiful, secure or error tolerant code. It works enough for a proof of concept of simple experiments.

#+BEGIN_SRC python :tangle ~/Dropbox/python/gamry/gamry_flask.py
from flask import Flask, request, jsonify
import time

app = Flask(__name__)

@app.route('/')
def hello_world():
    return 'Hello World!'

@app.route('/pstats')
def get_pstats():
    import win32com.client as client
    devices = client.Dispatch('GamryCOM.GamryDeviceList')
    result = str(devices.EnumSections())
    return result

@app.route('/close_pstat')
def close():
    import win32com.client as client
    devicelist = client.Dispatch('GamryCOM.GamryDeviceList')

    x = devicelist.EnumSections()[0]
    pstat = client.Dispatch('GamryCOM.GamryPstat')
    pstat.Init(x)

    pstat.Close()


def run_ramp(Sinit,  # start value
             Sfinal, # end value
             ScanRate=1,
             SampleRate=0.01,
             CtrlMode=1,  # GamryCOM.PstatMode
             fname=None):
    '''We assume the first device is the one you want.
    '''
    import win32com.client as client
    import numpy as np
    devicelist = client.Dispatch('GamryCOM.GamryDeviceList')

    x = devicelist.EnumSections()[0]

    pstat = client.Dispatch('GamryCOM.GamryPstat')
    pstat.Init(x)

    pstat.Open()

    dtaqcpiv=client.Dispatch('GamryCOM.GamryDtaqCpiv')
    dtaqcpiv.Init(pstat)

    sigramp=client.Dispatch('GamryCOM.GamrySignalRamp')
    sigramp.Init(pstat, Sinit, Sfinal, ScanRate, SampleRate, CtrlMode)

    pstat.SetSignal(sigramp)
    pstat.SetCell(1) # 1 == GamryCOM.CellOn

    try:
        dtaqcpiv.Run(True)
    except Exception as e:
        pstat.Close()
        raise

    # NOTE:  The comtypes example in this same directory illustrates the use of com
    # notification events.  The comtypes package is recommended as an alternative
    # to win32com.
    time.sleep(2) # just wait sufficiently long for the acquisition to complete.

    acquired_points = []
    count = 1
    while count > 0:
        count, points = dtaqcpiv.Cook(10)
        # The columns exposed by GamryDtaq.Cook vary by dtaq and are
        # documented in the Toolkit Reference Manual.
        acquired_points.extend(zip(*points))

    acquired_points = np.array(acquired_points)
    if fname is not None:
        np.savetxt(fname, acquired_points)

    pstat.Close()
    return jsonify({'data': acquired_points.tolist()})

@app.route('/cv')
def run_cv():
    result = str(request.values)
    startv = float(request.values.get('startv', -0.1))
    endv = float(request.values.get('endv', 0.1))
    scanrate = float(request.values.get('scanrate', 1.0))
    samplerate = float(request.values.get('samplerate', 0.01))

    data = run_ramp(startv, endv, scanrate, samplerate)
    return data


if __name__ == '__main__':
    app.run(host='jkitchin-win.cheme.cmu.edu', port=5000, debug=True)
#+END_SRC

#+RESULTS:
* DONE Indexing text in screenshots so they are searchable
  CLOSED: [2015-07-24 Fri 07:43]
  :PROPERTIES:
  :ID:       E08BF332-B853-4EE5-9C1B-B70EA6D69F89
  :categories: search,image
  :date:     2015/07/24 07:43:08
  :updated:  2015/07/24 07:43:08
  :END:

I had an interesting conversation with someone yesterday about using screenshots to document a process. This has an appeal of simplicity, since it is agnostic to the process, but I wondered about the long-term utility. If the documentation is valuable, you would like to search it in the future, and we so far have limited capability to search images. But, if there is important text in the image, we might be able to recognize the text, and use it to index the images. Then they would become searchable at least for the text in the image. Don't get me wrong, it would be better if we could store that text directly, but suppose that just isn't possible, maybe because it is all stored in some kind of gui, or it is locked up in proprietary software. Here we explore the potential utility of this. We only explore getting text out of images here, not the actual indexing part. See this [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/06/Indexing-headlines-in-org-files-with-swish-e-with-laser-sharp-results/][post]] for how we could integrate this into an actual index and search tool.

First we need an OCR engine. Tesseract[[https://github.com/tesseract-ocr/tesseract][ (tesseract-ocr/tesseract)]] is supposed to be pretty good, and it easily installs via brew:
#+BEGIN_SRC sh
brew install tesseract
#+END_SRC

#+BEGIN_SRC emacs-lisp
(shell-command-to-string "tesseract -v")
#+END_SRC

#+RESULTS:
: tesseract 3.02.02
:  leptonica-1.72
:   libjpeg 8d : libpng 1.6.17 : libtiff 4.0.3 : zlib 1.2.5
:

We will test it on some screenshots taken with the default settings on my Mac. Here is an example. This example has text in color boxes, and some shadowing on the left side because another window was near it and that is some OS effect.

#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-19-56-52.png]]

And here is the simplest text extraction.

#+BEGIN_SRC sh
tesseract ./screenshots/date-23-07-2015-time-19-56-52.png test
cat test.txt
rm test.txt
#+END_SRC

#+RESULTS:
#+begin_example
M. ~ an an. -.2... nuIunIrv- I.nd=d¢wn, a.....=.-p. u|u.=u_x. van" bar imam-

smm-ry ~ nu... ma, Camilla man Qu-In lui. Sdlwnu u._-. /-x/mu



master node q)l9amesh.chemc.cmn.edn up 9: days, mas, n nsersv

cutﬂmltc nude: men): :1

bpxoc node sum 17 dmln , o.1s,u.:n up
cuxque node state: n17 dawn

tuxqng jobs: 207 max, m2 nmmnq. as queued
aggregate laud: 799.55

#+end_example

That is not too good. I am skeptical it would be useful for anything. This [[http://vbridge.co.uk/2012/11/05/how-we-tuned-tesseract-to-perform-as-well-as-a-commercial-ocr-package/][page]] suggests improvements can be made with image clean up, but that image is pretty clear to me. There is a little shadow on the left side, but otherwise it is very readable to me. Let us try doubling the size of the image. Maybe that will help. Imagemagick lets us resize the image pretty easily.

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-19-56-52.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
#+begin_example
- 2D Node status summary. Rnd=down, Groun=up, BIu¢=boot. Vdlow bur indium --



Summlry - Hnﬂnr Mods, Compuh Nodu, Quuue, Land, Soﬁwan Ric:-as, /dzc/maul

master node gilqnmesh.cheme.cmu.edu up 91 days, 10:45, 11 users, .'

compute nodes total: 31

bproc node state: 17 down , 0-16,18-30 up
torque node state: n17 down

torque jobs: 207 total, 102 running, 88 queued
aggregate load: 799.55

#+end_example


That is a very remarkable improvement! This looks very useful, and could even be used for indexing. Interestingly, the white text on colored backgrounds does not do as well. That could be important to remember in designing the GUI front end if you have any say in it.  Let's try a few others.


#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-20-01-43.png]]

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-20-01-43.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
: Fllbn V Q I-"Ind a repository...
:
: tesseract
: Tesseract Open Source OCR Enghe (main repository)
: Updated 43 minutes ago
:

That is also pretty good. Again, the text on colored backgrounds is less good than that on a white background. And one more from Twitter.

#+attr_org: :width 300
[[./screenshots/date-23-07-2015-time-20-05-59.png]]

#+BEGIN_SRC sh
convert -resize 200% ./screenshots/date-23-07-2015-time-20-05-59.png ./screenshots/doubled.png

tesseract ./screenshots/doubled.png test
cat test.txt
rm test.txt ./screenshots/doubled.png
#+END_SRC

#+RESULTS:
: chEnected AIchE .-.ChEnected - 5h
: C h E AlChE Academy: Take AlChE‘s Pneumatic Conveying 0! Bulk Solids Course and
: learn practical design principles. r1m.ag/|IJcN
:

Overall pretty good. I am pretty convinced that the right screenshots could be an easy way to document some processes conveniently and that they could be searched in the future. Some testing would need to be done on how to do the OCR, and it does not appear that one recipe will work for all images.

Nevertheless, a program could pretty easily be developed to index a directory of screenshots, do the OCR on each image, and index the resulting text so it can be searched. It is even conceivable that several indexes could be made using different OCR methods that might work better for different types of images. Another improvement would be if some metadata could be associated with the screenshot including what instrument it is a shot of, who took it, etc... This starts to move in a direction that requires dedicated screenshot tools, and away from the simplicity of the PrintScreen button, but it adds value to the data that makes it easier to find later.

The beauty of the screenshot is that it is what you saw at the time, and it captures things as they were. It doesn't capture anything "behind the scenes" or off-screen of course, so there is certainly room to lose information this way. A careful analysis of what information is captured and what is lost would be important to assess the long-term value of capturing the process this way as opposed to any other way. There certainly is a balance of how much effort it takes to capture it and the value of the information in the future, and cost to rerun it if it isn't found in the future.

* Get bibtex entries from a PDF		 :ARCHIVE:

Some reference managers like Zotero, Mendeley and Endnote can take a pdf and build a reference entry from it. There is a python project here: https://github.com/venthur/gscholar/blob/master/gscholar/gscholar.py that builds a google scholar query to get bibtex entries. We will build on this here, using emacs-lisp. The first step we need is to build the query. In gscholar.py they use [[http://www.foolabs.com/xpdf/download.html][pdftotext]] to get the pdf text and then select 20 words. The first 20 don't seem like the right choice to me since many pdfs have cover pages with nothing of substance on them. A really sophisticated tool would try to find the most relevant text, e.g. something that is clearly a title or doi, but there is so little structure in pdfs across the literature this does not seem worthwhile right now. So, we will take the last 20 words from the second page.

#+BEGIN_SRC emacs-lisp
(defun gscholar-pdf-words (pdf)
  (s-join
   " "
   (last
    (s-split
     " "
     (replace-regexp-in-string
      "\\W" " "
      (shell-command-to-string
       (format "pdftotext -f 2 -l 2 %s - | less" pdf))))
    20)))

(gscholar-pdf-words "~/Dropbox/bibliography/bibtex-pdfs/alcock-1964-therm.pdf")
#+END_SRC

#+RESULTS:
: electrolyte  its flat base resting on a tablet of a mixture of metal A and its


[[https://github.com/cute-jumper/gscholar-bibtex/blob/master/gscholar-bibtex.el][gscholar-bibtex/gscholar-bibtex.el at master · cute-jumper/gscholar-bibtex]]


#+BEGIN_SRC emacs-lisp
;;; gscholar-bibtex.el --- Retrieve BibTeX from Google Scholar and other online sources(ACM, IEEE, DBLP)

;; Copyright (C) 2014  Junpeng Qiu

;; Author: Junpeng Qiu <qjpchmail@gmail.com>
;; Keywords: extensions
;; Version: 0.2

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; * gscholar bibtex

;;   Retrieve BibTeX entries from Google Scholar, ACM Digital Library, IEEE Xplore
;;   and DBLP by your query. All in Emacs Lisp!

;;   *UPDATE*: ACM Digital Library, IEEE Xplore, and DBLP are now supported though
;;    the package name doesn't suggest that.
;; ** Basic usage
;;    Without package.el:
;;        (add-to-list 'load-path "/path/to/gscholar-bibtex.el")
;;        (require 'gscholar-bibtex)

;;    With package.el: install via melpa!

;;    To use, simply call
;;         M-x gscholar-bibtex

;;   Choose a source, then enter your query and select the results.

;;   Available commands in `gscholar-bibtex-mode', i.e., in the window of search
;;   results:
;;   - n/p: next/previous
;;   - TAB: show BibTeX entry for current search result
;;   - A/W: append/write to `gscholar-bibtex-database-file' (see later)
;;   - a/w: append/write to a file
;;   - c: close BibTeX entry window
;;   - q: quit

;; ** Sources
;;   By default, I enable all sources(Google Scholar, ACM Digital Library, IEEE
;;   Xplore and DBLP). If you don't want to enable some of them, you could call
;;       M-x gscholar-bibtex-turn-off-sources

;;   Similarly, if you want to enable some of them, you could call
;;       M-x gscholar-bibtex-turn-on-sources

;;   To keep the configuration in your init file, you could use the following
;;   format(*NOT* real code):
;;       (gscholar-bibtex-source-on-off action source-name)

;;   Possible values:
;;   - action: :on or :off
;;   - source-name: "Google Scholar", "ACM Digital Library" or "IEEE Xplore"

;;   Say if you want to disable "IEEE Xplore", use the following code:
;;       (gscholar-bibtex-source-on-off :off "IEEE Xplore")

;; ** Default source
;;   If you have a preferred source, you can set it as default so you don't have to
;;   type the name to select the source every time you call `gscholar-bibtex'. Say
;;   if you want to set "Google Scholar" as default:
;;       (setq gscholar-bibtex-default-source "Google Scholar")

;;   Note that in order to make it work, you have to make sure the source name is
;;   correct and you don't disable the source that you set as default, otherwise
;;   the default source setting has no effect. Besides, if you only have one source
;;   enabled, then the enabled source automatically becomes the default, regardless
;;   of the value of `gscholar-bibtex-default-source'.

;; ** Configuring `gscholar-bibtex-database-file'
;;    If you have a master BibTeX file, say refs.bib, as database, and want to
;;    append/write the BibTeX entry to refs.bib without being asked for a
;;    filename to be written every time, you can set
;;    `gscholar-bibtex-database-file':
;;        (setq gscholar-bibtex-database-file "/path/to/refs.bib")

;;    Then use "A" or "W" to append or write to refs.bib, respectively.

;; ** Adding more sources
;;    Currently these three sources cover nearly all my needs, and it is possible
;;    if you need to add more sources.

;;    Basically, you need to implement following five functions(if you're willing,
;;    I think looking the source code is better. The implementation is easy!):
;; #+BEGIN_SRC elisp
;; (defun gscholar-bibtex-SourceName-search-results (query)
;; "In the body, call `gscholar-bibtex--url-retrieve-as-string' to return a string
;; containing query results"
;;   body)

;; (defun gscholar-bibtex-SourceName-titles (buffer-content)
;; "Given the string `buffer-content', return the list of titles"
;;   body)

;; (defun gscholar-bibtex-SourceName-subtitles (buffer-content)
;; "Given the string `buffer-content', return the list of subtitles"
;;   body)

;; (defun gscholar-bibtex-SourceName-bibtex-urls (buffer-content)
;; "Given the string `buffer-content', return the list of urls(or maybe other
;;  feature) of the BibTeX entries, which would be fed to the next function"
;;   body)

;; (defun gscholar-bibtex-SourceName-bibtex-content (arg)
;; "Given the url(or other feature) of a BibTeX entry, return the entry as string.
;; Also call `gscholar-bibtex--url-retrieve-as-string' for convenience"
;;   body)
;; #+END_SRC

;;    Then you need to add a line:
;;        (gscholar-bibtex-install-source "Source Name" 'SourceName)

;;    You should put this line somewhere near the end of `gscholar-bibtex.el',
;;    where you could find several `gscholar-bibtex-install-source' lines.

;;    That's all. Enjoy hacking^_^

;;; Code:

(require 'bibtex)
(require 'xml)

(defgroup gscholar-bibtex nil
  "Retrieve BibTeX from Google Scholar and other online sources(ACM, IEEE, DBLP)."
  :group 'bibtex)

(defconst gscholar-bibtex-version "0.2"
  "gscholar-bibtex version number")

(defvar gscholar-bibtex-caller-buffer nil
  "Buffer that calls gscholar-bibtex")

(defvar gscholar-bibtex-urls-cache nil
  "Cache for all the urls of BibTeX entries")

(defvar gscholar-bibtex-entries-cache nil
  "Cache for the retrieved BibTeX entries")

(defvar gscholar-bibtex-database-file nil
  "Default BibTeX database file")

(defconst gscholar-bibtex-item-height 3
  "The height for each item")

(defvar gscholar-bibtex-available-sources nil
  "Avaiable sources for query")

(defvar gscholar-bibtex-enabled-sources nil
  "List of enabled sources")

(defvar gscholar-bibtex-disabled-sources nil
  "List of disabled sources")

(defvar gscholar-bibtex-selected-source nil
  "Currently selected source")

(defvar gscholar-bibtex-default-source nil
  "Default source name")

(defconst gscholar-bibtex-result-buffer-name "*gscholar-bibtex Search Results*"
  "Buffer name for Google Scholar search results")

(defconst gscholar-bibtex-entry-buffer-name "*BibTeX entry*"
  "Buffer name for BibTeX entry")

(defconst gscholar-bibtex-function-suffixes-alist
  '((:search-results . "search-results")
    (:titles . "titles")
    (:subtitles . "subtitles")
    (:bibtex-urls . "bibtex-urls")
    (:bibtex-content . "bibtex-content")))

(defconst gscholar-bibtex-help
  "[n/p] next/previous; [TAB] show BibTeX entry; [A/W] append/write to database;\
 [a/w] append/write to file; [c] close BibTeX entry window; [q] quit;"
  "Help string for gscholar-bibtex")

;; Face related
(defface gscholar-bibtex-title
  '((t (:height 1.4 :foreground "light sea green")))
  "Face for title"
  :group 'gscholar-bibtex)

(defface gscholar-bibtex-subtitle
  '((t (:height 1.0)))
  "Face for subtitle"
  :group 'gscholar-bibtex)

(defconst gcholar-bibtex-highlight-item-overlay
  (let ((ov (make-overlay 1 1)))
    (overlay-put ov 'face 'highlight)
    ov)
  "Overlay for item highlight")

(defun gscholar-bibtex--move-to-line (N)
  (goto-char (point-min))
  (forward-line (1- N)))

(defun gscholar-bibtex-prettify-title (s)
  (propertize s 'face 'gscholar-bibtex-title))

(defun gscholar-bibtex-prettify-subtitle (s)
  (propertize s 'face 'gscholar-bibtex-subtitle))

(defun gscholar-bibtex-highlight-current-item-hook ()
  (save-excursion
    (let* ((line (gscholar-bibtex--current-beginning-line))
           (beg (progn (gscholar-bibtex--move-to-line line) (point)))
           (end (progn (gscholar-bibtex--move-to-line (+ line 3)) (point))))
      (move-overlay gcholar-bibtex-highlight-item-overlay beg end
                    (current-buffer)))))

;; Major mode
(defvar gscholar-bibtex-mode-map
  (let ((map (make-sparse-keymap)))
    (define-key map "n" 'gscholar-bibtex-next-item)
    (define-key map "p" 'gscholar-bibtex-previous-item)
    (define-key map (kbd "<tab>") 'gscholar-bibtex-retrieve-and-show-bibtex)
    (define-key map "A" 'gscholar-bibtex-append-bibtex-to-database)
    (define-key map "W" 'gscholar-bibtex-write-bibtex-to-database)
    (define-key map "a" 'gscholar-bibtex-append-bibtex-to-file)
    (define-key map "w" 'gscholar-bibtex-write-bibtex-to-file)
    (define-key map "c" 'gscholar-bibtex-quit-entry-window)
    (define-key map "q" 'gscholar-bibtex-quit-gscholar-window)
    map))

(define-derived-mode gscholar-bibtex-mode fundamental-mode "gscholar-bibtex"
  (setq buffer-read-only t)
  (add-hook 'pre-command-hook 'gscholar-bibtex-show-help nil t)
  (add-hook 'post-command-hook 'gscholar-bibtex-highlight-current-item-hook
            nil t))

(defun gscholar-bibtex-show-help ()
  (message gscholar-bibtex-help))

(defun gscholar-bibtex-guard ()
  (unless (eq major-mode 'gscholar-bibtex-mode)
    (error "Error: you are not in `gscholar-bibtex-mode'!")))

(defun gscholar-bibtex--string-cleanup (str)
  (while (string-match "\\`^\n+\\|^\\s-+\\|\\s-+$\\|\n+\\|\r+\\|^\r\\'" str)
    (setq str (replace-match "" t t str)))
  (replace-regexp-in-string "[\r\n\t ]+" " " str))

(defun gscholar-bibtex--current-beginning-line ()
  (1+ (* (gscholar-bibtex--current-index) gscholar-bibtex-item-height)))

(defun gscholar-bibtex--current-index ()
  (let ((line-number (+ (line-number-at-pos)
                        (if (= (point) (point-max))
                            -1 0))))
    (/ (1- line-number) gscholar-bibtex-item-height)))

(defun gscholar-bibtex--delete-response-header ()
  (ignore-errors
    (save-match-data
      (goto-char (point-min))
      (delete-region (point-min)
                     (1+ (re-search-forward "^$" nil t)))
      (goto-char (point-min)))))

(defun gscholar-bibtex--replace-html-entities (str)
  (let ((retval str)
        (pair-list
         '(("&amp;" . "&")
           ("&hellip;" . "...")
           ("&quot;" . "\"")
           ("&#[0-9]*;" .
            (lambda (match)
              (format "%c" (string-to-number (substring match 2 -1))))))))
    (dolist (elt pair-list retval)
      (setq retval (replace-regexp-in-string (car elt) (cdr elt) retval)))))

(defun gscholar-bibtex--html-value-cleanup (s)
  (gscholar-bibtex--string-cleanup
   (gscholar-bibtex--replace-html-entities
    (replace-regexp-in-string "<.*?>" "" s))))

(defun gscholar-bibtex--xml-child (children)
  (pcase-let ((`(,child) children)) child))

(defun gscholar-bibtex--xml-node-child (node)
  (gscholar-bibtex--xml-child
   (xml-node-children node)))

(defun gscholar-bibtex--xml-get-child (node child-name)
  (gscholar-bibtex--xml-child
   (xml-get-children node child-name)))

(defun gscholar-bibtex--url-retrieve-as-buffer (url)
  (let ((response-buffer (url-retrieve-synchronously url)))
    (with-current-buffer response-buffer
      (gscholar-bibtex--delete-response-header))
    response-buffer))

(defun gscholar-bibtex--url-retrieve-as-string (url)
  (let ((response-buffer (gscholar-bibtex--url-retrieve-as-buffer url))
        retval)
    (with-current-buffer response-buffer
      (setq retval (buffer-string)))
    (kill-buffer response-buffer)
    retval))

(defun gscholar-bibtex-re-search (buffer-content surrounding-regexp subexp-count)
  (save-match-data
    (with-temp-buffer
      (insert buffer-content)
      (let (retval)
        (goto-char (point-min))
        (while (re-search-forward surrounding-regexp nil t)
          (push (gscholar-bibtex--html-value-cleanup
                 (match-string-no-properties subexp-count)) retval))
        (nreverse retval)))))

(defun gscholar-bibtex-next-item ()
  (interactive)
  (gscholar-bibtex-guard)
  (gscholar-bibtex--move-to-line (+ (gscholar-bibtex--current-beginning-line)
                                    gscholar-bibtex-item-height)))

(defun gscholar-bibtex-previous-item ()
  (interactive)
  (gscholar-bibtex-guard)
  (gscholar-bibtex--move-to-line (- (gscholar-bibtex--current-beginning-line)
                                    gscholar-bibtex-item-height)))

(defun gscholar-bibtex-retrieve-and-show-bibtex ()
  (interactive)
  (gscholar-bibtex-guard)
  (let* ((index (gscholar-bibtex--current-index))
         (bibtex-entry
          (progn (when (string= "" (elt gscholar-bibtex-entries-cache index))
                   (aset gscholar-bibtex-entries-cache index
                         (gscholar-bibtex-dispatcher
                          :bibtex-content
                          (nth index gscholar-bibtex-urls-cache))))
                 (elt gscholar-bibtex-entries-cache index)))
         (entry-buffer (get-buffer-create gscholar-bibtex-entry-buffer-name))
         (entry-window (get-buffer-window entry-buffer))
         (gscholar-window (selected-window)))
    (with-current-buffer entry-buffer
      (erase-buffer)
      (insert bibtex-entry)
      (bibtex-mode)
      ;; Have to manually call this to set `bibtex-entry-head', otherwise
      ;; `bibtex-parse-buffers-stealthily' will throw some errors since the our
      ;; BibTeX buffer is not associated with an existing file:-(
      (bibtex-set-dialect)
      (goto-char (point-min)))
    (unless entry-window
      (select-window (split-window-below))
      (switch-to-buffer entry-buffer)
      (select-window gscholar-window))))

(defun gscholar-bibtex--write-bibtex-to-database-impl (&optional append)
  (gscholar-bibtex-guard)
  (gscholar-bibtex-retrieve-and-show-bibtex)
  (unless gscholar-bibtex-database-file
    (setq gscholar-bibtex-database-file
          (read-file-name "gscholar-bibtex database file:")))
  (if gscholar-bibtex-database-file
      (progn
        (with-current-buffer (get-buffer gscholar-bibtex-entry-buffer-name)
          (write-region nil nil gscholar-bibtex-database-file append))
        (message "%s BibTeX entry to %s" (if append "Append" "Write")
                 gscholar-bibtex-database-file))
    (error "Please set `gscholar-bibtex-database-file' first.")))

(defun gscholar-bibtex-append-bibtex-to-database ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-database-impl t))

(defun gscholar-bibtex-write-bibtex-to-database ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-database-impl))

(defun gscholar-bibtex--write-bibtex-to-file-impl (prompt &optional append)
  (gscholar-bibtex-guard)
  (gscholar-bibtex-retrieve-and-show-bibtex)
  (let ((filename (read-file-name prompt)))
    (with-current-buffer (get-buffer gscholar-bibtex-entry-buffer-name)
      (write-region nil nil filename append))
    (message "%s BibTeX entry to %s" (if append "Append" "Write") filename)))

(defun gscholar-bibtex-append-bibtex-to-file ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-file-impl "Append BibTeX entry to file: " t))

(defun gscholar-bibtex-write-bibtex-to-file ()
  (interactive)
  (gscholar-bibtex--write-bibtex-to-file-impl "Write BibTeX entry to file: "))

(defun gscholar-bibtex-quit-entry-window ()
  (interactive)
  (gscholar-bibtex-guard)
  (let ((gscholar-window (selected-window))
        (entry-window (get-buffer-window gscholar-bibtex-entry-buffer-name)))
    (when entry-window
      (select-window entry-window)
      (delete-window)
      (select-window gscholar-window))))

(defun gscholar-bibtex-quit-gscholar-window ()
  (interactive)
  (gscholar-bibtex-guard)
  (let ((gscholar-window (selected-window))
        (entry-window (get-buffer-window gscholar-bibtex-entry-buffer-name))
        (caller-window (get-buffer-window gscholar-bibtex-caller-buffer)))
    (gscholar-bibtex-quit-entry-window)
    (if (or (eq caller-window gscholar-window)
            (eq caller-window entry-window)
            (not (buffer-live-p gscholar-bibtex-caller-buffer)))
        (next-buffer)
      (if caller-window
          (progn (delete-window) (select-window caller-window))
        (switch-to-buffer gscholar-bibtex-caller-buffer))))
  (message ""))

(defun gscholar-bibtex-install-source (source-name source-symbol)
  (let ((retval t))
    (dolist (pair gscholar-bibtex-function-suffixes-alist retval)
      (unless
          (fboundp
           (gscholar-bibtex--get-dispatch-func-name (car pair) source-symbol))
        (setq retval nil)))
    (unless retval
      (error
       "Installation failed! You need to define all necessary functions!"))
    (push `(,source-name . ,source-symbol) gscholar-bibtex-available-sources)))

(defun gscholar-bibtex--get-dispatch-func-name (kind source-symbol)
  (intern
   (concat
    "gscholar-bibtex-"
    (symbol-name source-symbol)
    "-"
    (assoc-default kind gscholar-bibtex-function-suffixes-alist))))

;;; dispatcher
(defun gscholar-bibtex-dispatcher (kind arg)
  (funcall
   (gscholar-bibtex--get-dispatch-func-name
    kind
    (assoc-default gscholar-bibtex-selected-source
                   gscholar-bibtex-enabled-sources))
   arg))

(defun gscholar-bibtex--get-list-symbol-pair (action)
  (let* ((alist '((:on . ("disabled" . "enabled"))
                  (:off . ("enabled" . "disabled"))))
         (names (assoc-default action alist))
         (build-name (lambda (s)
                       (intern (concat "gscholar-bibtex-" s "-sources")))))
    `(,(funcall build-name (car names)) . ,(funcall build-name (cdr names)))))

(defun gscholar-bibtex-source-on-off (action source-name)
  (let* ((prompt (if (eq action :on) "available" "enabled"))
         (symbol-pair (gscholar-bibtex--get-list-symbol-pair action))
         (source-list (car symbol-pair))
         (dest-list (cdr symbol-pair))
         (source-pair (assoc source-name (symbol-value source-list))))
    (if source-pair
        (progn
          (set source-list
               (remove source-pair (symbol-value source-list)))
          (push source-pair (symbol-value dest-list)))
      (message
       (concat "Please choose from the " prompt " sources!")))))

(defun gscholar-bibtex--source-on-off-interactive-impl (action)
  (let ((source-list (car (gscholar-bibtex--get-list-symbol-pair action)))
        source-name)
    (while (and (symbol-value source-list)
                (not
                 (string= "" (setq source-name
                                   (completing-read
                                    "Source[empty to exit]:"
                                    (symbol-value source-list))))))
      (gscholar-bibtex-source-on-off action source-name))))

;;; acm
(defun gscholar-bibtex-acm-search-results (query)
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          '(("Content-Type" . "application/x-www-form-urlencoded")))
         (url-request-data
          (mapconcat (lambda (arg)
                       (concat (url-hexify-string (car arg))
                               "="
                               (url-hexify-string (cdr arg))))
                     `(("query" . ,(replace-regexp-in-string " " "\+" query)))
                     "&")))
    (gscholar-bibtex--url-retrieve-as-string
     "http://dl.acm.org/results.cfm?h=1")))
(defun gscholar-bibtex-acm-titles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<A HREF=\"citation.cfm[^>]*?>\\(.*?\\)</A>" 1))

(defun gscholar-bibtex-acm-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<div class=\"authors\">\\([[:print:][:space:]]*?\\)</div>" 1))

(defun gscholar-bibtex-acm-bibtex-urls (buffer-content)
  (mapcar
   (lambda (href)
     (let ((retval href)
           (case-fold-search t)
           (pair-list '(("coll=DL" . "expformat=bibtex")
                        ("id" . "parent_id")
                        ("\\." . "&id=")
                        ("cfm" . "downformats.cfm"))))
       (dolist (pair pair-list retval)
         (setq retval
               (replace-regexp-in-string (car pair) (cdr pair) retval)))))
   (gscholar-bibtex-re-search
    buffer-content
    "<A HREF=\"citation\.\\(.*?\\)\"" 1)))

(defun gscholar-bibtex-acm-bibtex-content (bibtex-url)
  (gscholar-bibtex--url-retrieve-as-string
   (concat "http://dl.acm.org/" bibtex-url)))

;;; ieee
(defun gscholar-bibtex-ieee-search-results (query)
  (let* ((url-request-method "GET"))
    (gscholar-bibtex--url-retrieve-as-string
     (concat
      "http://ieeexplore.ieee.org/search/searchresult.jsp?queryText="
      (url-hexify-string query)))))

(defun gscholar-bibtex-ieee-titles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "Select this article: \\(.*\\) type" 1))

(defun gscholar-bibtex-ieee-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<a.*?class=\"authorPreferredName[^>]*?>\\([[:space:][:print:]]*?\\)<a href='.." 1))

(defun gscholar-bibtex-ieee-bibtex-urls (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<input.*id=\'\\(.*\\)\'" 1))

(defun gscholar-bibtex-ieee-bibtex-content (bibtex-id)
  (let* ((url-request-method "POST")
         (url-request-extra-headers
          '(("Content-Type" . "application/x-www-form-urlencoded")))
         (url-request-data
          (mapconcat (lambda (arg)
                       (concat (url-hexify-string (car arg))
                               "="
                               (url-hexify-string (cdr arg))))
                     `(("recordIds" . ,bibtex-id)
                       ("citations-format" . "citation-only")
                       ("download-format" . "download-bibtex"))
                     "&"))
         (pair-list '(("<br>\\|\r" . "")
                      ("\n\n+" . "\n")
                      ("\n *" . "\n  ")))
         (retval (gscholar-bibtex--url-retrieve-as-string
                  "http://ieeexplore.ieee.org/xpl/downloadCitations")))
    (dolist (pair pair-list retval)
      (setq retval (replace-regexp-in-string (car pair) (cdr pair) retval)))))

;;; Google Scholar
(defun gscholar-bibtex-google-scholar-search-results (query)
  (let* ((url-request-method "GET")
         (random-id (format "%016x" (random (expt 16 16))))
         (url-request-extra-headers
          `(("Cookie" . ,(concat "GSP=ID=" random-id ":CF=4")))))
    (gscholar-bibtex--url-retrieve-as-string
     (concat  "http://scholar.google.com/scholar?q="
              (url-hexify-string
               (replace-regexp-in-string " " "\+" query))))))

(defun gscholar-bibtex-google-scholar-bibtex-urls (buffer-content)
  (gscholar-bibtex-re-search buffer-content "\\(/scholar\.bib.*?\\)\"" 1))

(defun gscholar-bibtex-google-scholar-titles (buffer-content)
  (gscholar-bibtex-re-search buffer-content "<h3.*?>\\(.*?\\)</h3>" 1))

(defun gscholar-bibtex-google-scholar-subtitles (buffer-content)
  (gscholar-bibtex-re-search
   buffer-content
   "<div class=\"gs_a\">\\(.*?\\)</div>" 1))

(defun gscholar-bibtex-google-scholar-bibtex-content (bibtex-url)
  (gscholar-bibtex--url-retrieve-as-string
   (concat "http://scholar.google.com" bibtex-url)))

;;; DBLP
(defun gscholar-bibtex-dblp-search-results (query)
  (let* ((url-request-method "GET")
         (response-buffer (gscholar-bibtex--url-retrieve-as-buffer
                           (concat "http://dblp.uni-trier.de/search/publ/api?"
                                   (url-build-query-string
                                    `((q ,query)
                                      (format xml)))))))
    (with-current-buffer response-buffer
      (set-buffer-multibyte t))
    (prog1
        (pcase-let ((`(,(and result `(result . ,_))) (xml-parse-region nil nil response-buffer)))
          (mapcar (lambda (hit)
                    (gscholar-bibtex--xml-get-child hit 'info))
                  (xml-get-children (gscholar-bibtex--xml-get-child result 'hits) 'hit)))
      (kill-buffer response-buffer))))

(defun gscholar-bibtex-dblp-titles (search-results)
  (mapcar (lambda (info)
            (gscholar-bibtex--xml-node-child
             (gscholar-bibtex--xml-get-child info 'title)))
          search-results))

(defun gscholar-bibtex-dblp-subtitles (search-results)
  (mapcar (lambda (info)
            (mapconcat #'gscholar-bibtex--xml-node-child
                       (xml-get-children (gscholar-bibtex--xml-get-child info 'authors) 'author)
                       ", "))
          search-results))

(defun gscholar-bibtex-dblp-bibtex-urls (search-results)
  (mapcar (lambda (info)
            (gscholar-bibtex--xml-node-child
             (gscholar-bibtex--xml-get-child info 'url)))
          search-results))

(defun gscholar-bibtex-dblp-bibtex-content (html-url)
  (string-match "/rec/" html-url)
  (gscholar-bibtex--url-retrieve-as-string
   (replace-match "/rec/bib2/" t t html-url)))

;;;###autoload
(defun gscholar-bibtex-turn-on-sources ()
  (interactive)
  (gscholar-bibtex--source-on-off-interactive-impl :on))

;;;###autoload
(defun gscholar-bibtex-turn-off-sources ()
  (interactive)
  (gscholar-bibtex--source-on-off-interactive-impl :off))

;;;###autoload
(defun gscholar-bibtex ()
  (interactive)
  (if (= 1 (length gscholar-bibtex-enabled-sources))
      (setq gscholar-bibtex-selected-source
            (caar gscholar-bibtex-enabled-sources))
    (let* ((default-source (assoc
                            gscholar-bibtex-default-source
                            gscholar-bibtex-enabled-sources))
           (source-prompt (if default-source
                              (concat "Select a source[default "
                                      gscholar-bibtex-default-source
                                      "]: ")
                            "Select a source: "))
           (selected-source
            (completing-read source-prompt
                             gscholar-bibtex-enabled-sources)))
      (setq gscholar-bibtex-selected-source
            (if (string= "" selected-source)
                gscholar-bibtex-default-source
              selected-source))))
  (unless (assoc gscholar-bibtex-selected-source
                 gscholar-bibtex-enabled-sources)
    (error "Please select an installed source!"))
  (let* ((query (read-string
                 (concat "Query[" gscholar-bibtex-selected-source "]: ")))
         (search-results (gscholar-bibtex-dispatcher :search-results query))
         (titles (gscholar-bibtex-dispatcher :titles search-results))
         (subtitles (gscholar-bibtex-dispatcher :subtitles search-results))
         (gscholar-buffer
          (get-buffer-create gscholar-bibtex-result-buffer-name)))
    (setq gscholar-bibtex-caller-buffer (current-buffer))
    (setq gscholar-bibtex-urls-cache
          (gscholar-bibtex-dispatcher :bibtex-urls search-results))
    (setq gscholar-bibtex-entries-cache
          (make-vector (length gscholar-bibtex-urls-cache) ""))
    (unless (get-buffer-window gscholar-buffer)
      (switch-to-buffer-other-window gscholar-buffer))
    (setq buffer-read-only nil)
    (erase-buffer)
    (goto-char (point-min))
    (dotimes (i (length titles))
      (insert "* " (gscholar-bibtex-prettify-title (nth i titles)))
      (newline-and-indent)
      (insert "  "
              (gscholar-bibtex-prettify-subtitle (nth i subtitles)) "\n\n"))
    (goto-char (point-min))
    (gscholar-bibtex-mode)
    (gscholar-bibtex-show-help)))

;; install sources
(gscholar-bibtex-install-source "DBLP" 'dblp)
(gscholar-bibtex-install-source "IEEE Xplore" 'ieee)
(gscholar-bibtex-install-source "ACM Digital Library" 'acm)
(gscholar-bibtex-install-source "Google Scholar" 'google-scholar)
;; initalize
(setq gscholar-bibtex-disabled-sources gscholar-bibtex-available-sources)
;; enable all
(gscholar-bibtex-source-on-off :on "DBLP")
(gscholar-bibtex-source-on-off :on "IEEE Xplore")
(gscholar-bibtex-source-on-off :on "ACM Digital Library")
(gscholar-bibtex-source-on-off :on "Google Scholar")

;; Remove byte compilation warnings
(defvar evil-emacs-state-modes)
(eval-after-load "evil"
  '(add-to-list 'evil-emacs-state-modes 'gscholar-bibtex-mode))

(provide 'gscholar-bibtex)
;;; gscholar-bibtex.el ends here
#+END_SRC

#+BEGIN_SRC emacs-lisp


(gscholar-bibtex-google-scholar-search-results " electrolyte  its flat base resting on a tablet of a mixture of metal A and its")
#+END_SRC

This sort of worked. I got blocked from google at one point, and I found it difficult to figure out how to get the bibtex entries from the code above (although it does do it). My doi-utils package seems better.








* A highlight annotation mode with overlays :ARCHIVE:
One of my students asked about highlighting text in emacs for note-taking. For temporary use, this is pretty easy, you put an overlay on a region that modifies the face, and any other properties you choose. One downside of overlays, as opposed to font-lock properties, is they do not "follow" text when you cut and paste them. On the other hand, they are easier to work with. So, we will work through doing this with overlays, and another day try it out with font-lock properties.

Here is a simple function to put a highlight on a region.

#+BEGIN_SRC emacs-lisp
(require 'ov)

(defun highlight-region (beg end)
 (interactive "r")
 (ov beg end 'face '(:background "Light Salmon") 'help-echo "highlighted" 'highlighted t))

(global-set-key (kbd "s-h") 'highlight-region)
#+END_SRC

#+RESULTS:
: highlight-region

The trouble is these are temporary, and disappear when you close the file. So, we need to save them. It is easy to get the overlays in the buffer, and we only want ones that have the 'highlighted property. So we just get those, and then save the information we need to recreate them.

#+BEGIN_SRC emacs-lisp
(ov-in 'highlighted t)
#+END_SRC

#+RESULTS:
| #<overlay from 1041 to 1062 in blog.org> | #<overlay from 536 to 552 in blog.org> |

Here is the code we use to save the overlay data in an external file. We use a hidden dotfile for this so we don't clutter our directory up. Then, we will save the start, end and properties of each overlay so we can reconstruct them later. We add this to a save hook, so it updates our file each time we save the buffer.

#+BEGIN_SRC emacs-lisp :results silent
(defun highlight-save-filename ()
  "Return name of file to save overlays in."
  (concat "." (file-name-nondirectory (buffer-file-name)) ".highlights"))

(defun highlight-save ()
  "Save highlight overlays in an external file"
  (interactive)
  (when (buffer-file-name)
    (save-buffer)
    (let ((fname (highlight-save-filename))
	  (ovs (ov-in 'highlighted t)))
      (if ovs
	  (with-temp-file fname
	    (prin1
	     (mapcar
	      (lambda (ov)
		(list (overlay-start ov)
		      (overlay-end ov)
		      (overlay-properties ov)))
	      ovs)
	     (current-buffer)))
	;; Delete file if no ovs
	(and (file-exists-p fname)
	     (delete-file fname))))))

(add-hook 'after-save-hook 'highlight-save)
#+END_SRC

#+RESULTS:
: highlight-save

#+BEGIN_SRC emacs-lisp
(highlight-save)
#+END_SRC

#+RESULTS:
| 1041 | 1062 | (highlighted t help-echo highlighted face (:background Light Salmon)) |
|  536 |  552 | (highlighted t help-echo highlighted face (:background Light Salmon)) |

#+BEGIN_SRC sh
cat .blog.org.highlights
#+END_SRC

#+RESULTS:
: ((4288 4296 (highlighted t help-echo "Some note to yourself about the tip" face (:background "Yellow1"))) (4184 4188 (highlighted t help-echo "highlighted" face (:background "Darkolivegreen1"))) (4178 4182 (highlighted t help-echo "highlighted" face (:background "Coral"))) (3496 3508 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))) (1041 1062 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))) (536 552 (highlighted t help-echo "highlighted" face (:background "Light Salmon"))))


Now, we also need to be able to load the overlays. We set this in a hook too, so the overlays get created when we open the file.

#+BEGIN_SRC emacs-lisp :results silent
(defun highlight-load ()
  "Load and apply overlays"
  (interactive)
  (let ((fname (highlight-save-filename)))
    (when (file-exists-p fname)
      (mapc
       (lambda (entry)
	 (ov (nth 0 entry)		; beg
	     (nth 1 entry)		; end
	     (nth 2 entry)))		; properties

      (with-temp-buffer
	(insert-file-contents fname)
	(read (current-buffer)))))))

(add-hook 'find-file-hook 'highlight-load)
#+END_SRC

So far so good. Let's raise the bar on ridiculosity and use helm-colors to select the highlight color. You will be able to highlight  with crazy color resolution. We will up the ante and also allow this function to update an existing highlight.

#+BEGIN_SRC emacs-lisp
(defun highlight (beg end &optional color)
  "Put a highlight overlay on the region. If on an overlay, change the color"
  (interactive "r")
  (unless color
    (setq color (s-trim (helm-colors))))
  (if (ov-at)
      (ov-set (ov-at) 'face `(:background ,color))
    (unless (region-active-p)
      (error "No region selected."))
    (ov beg end 'face `(:background ,color) 'help-echo "highlighted" 'highlighted t)))
#+END_SRC

#+RESULTS:
: highlight

What  else can we do? Let's make a special highlight note where you can put your own text as a tooltip, and a function to edit the text.

#+BEGIN_SRC emacs-lisp
(defun highlight-note (beg end &optional color note)
  (interactive "r")
  (unless (region-active-p)
    (error "No region selected."))
  (unless color
    (setq color (s-trim (helm-colors))))
  (unless note
    (setq note (read-input "Note: ")))
  (ov beg end 'face `(:background ,color) 'help-echo note 'highlighted t))

;; We need to edit a note too
(defun highlight-note-edit (new-note)
  (interactive (list (read-input "New note: " (overlay-get (ov-at) 'help-echo))))
  (ov-set (ov-at) 'help-echo new-note))
#+END_SRC

#+RESULTS:
: highlight-note-edit

After a while you may want to list your notes. This function is a little clumsy in window management. Basically we make a new buffer with the highlighted text and a link to get back to it.

#+BEGIN_SRC emacs-lisp
(defun highlight-list ()
  (interactive)
  (let* ((ovs (ov-in 'highlighted t))
	 (cb (current-buffer))
	 (links (mapcar
		 (lambda (ov)
		   (format "[[%s][link]]%s\n"
			   (format
			    "elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))"
			    cb (overlay-start ov))
			   (buffer-substring
			    (overlay-start ov)
			    (overlay-end ov))))
		 ovs)))
    (split-window-right)
    (switch-to-buffer-other-window "*highlights*") (erase-buffer)
    (org-mode)
    (mapc
     (lambda (s)
       (insert s))
     links)))
#+END_SRC

#+RESULTS:
: highlight-list

At some point you will want to clear all your highlights. After you do this, if you save the buffer, they will be gone forever.

#+BEGIN_SRC emacs-lisp
(defun highlight-clear ()
  (interactive)
  (ov-clear 'highlighted t)
  (when (get-buffer "*highlights*") (kill-buffer "*highlights*")))
#+END_SRC

#+RESULTS:
: highlight-clear


Finally, a few convenience functions and a menu. We define some standard highlight colors for convenience, an menu in the "Org" menu, a hydra, and a final key binding to the hydra.

#+BEGIN_SRC emacs-lisp
(defun highlight-yellow ()
  (interactive)
  (highlight (region-beginning) (region-end) "Yellow"))

(defun highlight-blue ()
  (interactive)
  (highlight (region-beginning) (region-end) "LightBlue"))

(defun highlight-pink ()
  (interactive)
  (highlight (region-beginning) (region-end) "Pink"))

(defun highlight-green ()
  (interactive)
  (highlight (region-beginning) (region-end) "Darkolivegreen1"))

(easy-menu-change
 '("Org") "highlighter"
 '(["Highlight" highlight]
   ["Highlight (B)" highlight-blue]
   ["Highlight (G)" highlight-green]
   ["Highlight (P)" highlight-pink]
   ["Highlight (Y)" highlight-yellow]
   ["List highlights" highlight-list]
   ["Clear highlights" highlight-clear])
 "Show/Hide")

(defhydra highlight (:color blue) "highlighter"
  ("b" highlight-blue "blue")
  ("g" highlight-green "Green")
  ("p" highlight-pink "Pink")
  ("s" (highlight (region-beginning) (region-end) "Lightsalmon1") "Salmon")
  ("y" highlight-yellow "yellow")
  ("c" highlight "Choose color")
  ("n" (highlight-note (region-beginning) (region-end) "Thistle") "Thistle Note")
  ("N" highlight-note "Note")
  ("m" highlight-mouse-on "Mouse highlight")
  ("M" highlight-mouse-off "Mouse off")
  ("e" highlight-note-edit "Edit note")
  ("l" highlight-list "List highlights")
  ("r" highlight-load "Reload")
  ("s" highlight-save "Save")
  ("C" highlight-clear "Clear"))

(global-set-key (kbd "s-h") 'highlight/body)
#+END_SRC

#+RESULTS:
: highlight/body

There  are some limitations here. Overlays are not attached to text, so you cannot cut and paste them. Boo... You have to use the hook functions to keep the external file synchronized with the buffer. If these ever get out of sync, good luck resynchronizing them.

* overlay notes				 :ARCHIVE:

(overlay-start (ov-next 'highlighted t))
(overlay-end (ov-next 'highlighted t))
(overlay-properties (ov-next 'highlighted t))
(overlay-get (ov-next 'highlighted t) 'help-echo)
(overlay-get (ov-next 'highlighted t) 'face)

(ov-in 'highlighted t)

(ov-spec (ov-prev 'highlighted t))
clear all
(ov-clear 'highlighted t)

tree tree


(ov-goto-next 'highlighted t)

* highlight notes			 :ARCHIVE:


#+BEGIN_SRC emacs-lisp
(remove-hook 'activate-mark-hook 'highlight-yellow)
(remove-hook 'deactivate-mark-hook 'highlight-yellow)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(defadvice handle-shift-selection (after my-show-point-and-mark () activate)
  "Show point and mark."
  (message "[%s %s]" (mark) (point)))

(defadvice mouse-set-region (after my-highlight () activate)
  "Highlight"
  (highlight-green))
#+END_SRC

#+RESULTS:
: mouse-set-region

(setq org-support-shift-select t)


what else can we  can we do? Let's make a new highlight /note/.

#+BEGIN_SRC emacs-lisp
(defun highlight-note (beg end note)
  (interactive (list (region-beginning) (region-end) (read-input "Note: ")))
  (unless (region-active-p)
    (error "No region selected."))
  (add-text-properties
   beg end
   `(help-echo ,note font-lock-face (:background "Thistle")
		    highlighted t)))

;; You might want to edit your note
(defun highlight-note-edit (new-note)
  (interactive (list (read-input "Note: " (get-text-property (point) 'help-echo))))
  (let* ((region (button-lock-find-extent (point) 'highlighted))
	 (beg (car region))
	 (end (cdr region)))
    (put-text-property beg end 'help-echo new-note)))
#+END_SRC

#+RESULTS:
: highlight-note-edit

f   dsaf   das    fds (ov-all)


#+BEGIN_SRC emacs-lisp
(require 'ov)

(defun highlight-note (beg end note)
  (interactive (list (region-beginning) (region-end) (read-input "Note: ")))
  (unless (region-active-p)
    (error "No region selected."))
  (ov beg end 'help-echo note 'face '(:background "Thistle")))

;; You might want to edit your note
(defun highlight-note-edit (new-note)
  (interactive (list (read-input "Note: " (get-text-property (point) 'help-echo))))
  (let* ((region (button-lock-find-extent (point) 'highlighted))
	 (beg (car region))
	 (end (cdr region)))
    (put-text-property beg end 'help-echo new-note)))
#+END_SRC


* Insert images from image-dired
[[http://stackoverflow.com/questions/31311833/copy-links-from-image-dired-to-org-mode][emacs - Copy links from image-dired to org-mode - Stack Overflow]]


#+BEGIN_SRC emacs-lisp
(defun my-insert-current-image-path ()
  (interactive)
  (insert
   (concat
    "[["
    (save-excursion
      (with-current-buffer "*image-dired*"
        (image-dired-original-file-name)))
    "]]")
(org-display-inline-images t t)))
#+END_SRC

#+RESULTS:
| 2576 | 2580 | #FFFFFF      |
| 2567 | 2574 | #FFFFFF      |
| 1742 | 1746 | Light Salmon |
|  479 |  509 | Light Salmon |
|  160 |  179 | Light Salmon |


* DONE Drag images and files onto org-mode and insert a link to them
  CLOSED: [2015-07-10 Fri 16:11]
  :PROPERTIES:
  :categories: emacs,video
  :date:     2015/07/10 16:11:43
  :updated:  2015/07/10 16:11:43
  :END:
I want to drag and drop an image onto an org mode file and get a link to that file. This would be used for finding images in Finder, and then dragging them to the Emacs buffer. There is [[http://orgmode.org/cgit.cgi/org-mode.git/plain/contrib/lisp/org-download.el][org-download.el]] which looks like it should do something like this too, but it did not work out of the box for me, and I want to add a few wrinkles to it. For a simple drag-n-drop, I just want the link to appear. With ctrl-drag-n-drop I want to add an attr_org line to set the image size, add a caption line, insert the image at the beginning of the line where the mouse cursor is, put the cursor on the caption line and then refresh the inline images in org-mode so the image is immediately visible.

While we are at let us also make it possible to drag file links onto org-files, instead of having the files open. Again, for a simple drag-n-drop, I want a link inserted. For ctrl-drag-n-drop we open the file, and for Meta (alt) drag-n-drop, we insert an attachfile link. You can also define s-drag-n-drop (Super/command) and C-s and M-s drag-n-drop if you can think of things to do with that.

Here is the code to make those things happen. Or watch the video: https://www.youtube.com/watch?v=ahqKXbBVjpQ

#+BEGIN_SRC emacs-lisp
(defun my-dnd-func (event)
  (interactive "e")
  (goto-char (nth 1 (event-start event)))
  (x-focus-frame nil)
  (let* ((payload (car (last event)))
	 (type (car payload))
	 (fname (cadr payload))
	 (img-regexp "\\(png\\|jp[e]?g\\)\\>"))
    (cond
     ;; insert image link
     ((and  (eq 'drag-n-drop (car event))
	    (eq 'file type)
	    (string-match img-regexp fname))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; insert image link with caption
     ((and  (eq 'C-drag-n-drop (car event))
	    (eq 'file type)
	    (string-match img-regexp fname))
      (insert "#+ATTR_ORG: :width 300\n")
      (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
      (insert (format "[[%s]]" fname))
      (org-display-inline-images t t))
     ;; C-drag-n-drop to open a file
     ((and  (eq 'C-drag-n-drop (car event))
	    (eq 'file type))
      (find-file fname))
     ((and (eq 'M-drag-n-drop (car event))
	   (eq 'file type))
      (insert (format "[[attachfile:%s]]" fname)))
     ;; regular drag and drop on file
     ((eq 'file type)
      (insert (format "[[%s]]\n" fname)))
     (t
      (error "I am not equipped for dnd on %s" payload)))))


(define-key org-mode-map (kbd "<drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<C-drag-n-drop>") 'my-dnd-func)
(define-key org-mode-map (kbd "<M-drag-n-drop>") 'my-dnd-func)
#+END_SRC

#+RESULTS:
: my-dnd-func

[[/Users/jkitchin/blogofile-jkitchin.github.com/_blog/jkitchin.json]]
[[attachfile:/Users/jkitchin/blogofile-jkitchin.github.com/_blog/jkitchin.json]]

[[file:///Users/jkitchin/blogofile-jkitchin.github.com/_blog/Au-icosahedron-3.png][Au-icosahedron-3.png]]
* old dnd code


#+BEGIN_SRC emacs-lisp
(defun org-image-dnd (uri action)
  "Insert org link to an image file at beginning of the line where the mouse is."
  (goto-char (nth 1 (event-start last-input-event)))
  (x-focus-frame nil)
  (cond
   ((eq 'C-drag-n-drop (car last-input-event))
    (insert "#+ATTR_ORG: :width 300\n")
    (insert (concat  "#+CAPTION: " (read-input "Caption: ") "\n"))
    (insert (format "[[%s]]\n" uri)))
   (t
    (insert (format "[[%s]]\n" uri))))
  (org-display-inline-images t t))


(defun org-file-dnd (uri action)
  "Insert org-link to file with drag-n-drop. For C-drag-n-drop
open file. See `org-file-M-dnd' for inserting attachfile links."
  (interactive)
  (x-focus-frame nil)
  (goto-char (nth 1 (event-start last-input-event)))
  (insert (format "[[%s]]" uri)))

; The order of addition is important. We need the most specific pattern first.
; each addition pushes into the first position.
(add-to-list 'dnd-protocol-alist '("^file:/" . org-file-dnd))
(add-to-list 'dnd-protocol-alist '("^file:/.*\\.\\(png\\|jp[e]?g\\)" . org-image-dnd))

(defun org-file-M-dnd (event)
  "Insert attachfile link on M-drag-n-drop."
  (interactive "e")
  (goto-char (nth 1 (event-start event)))
  (let ((payload (car (last last-input-event))))
    (when (eq 'file (car payload))
      (insert (format  "[[attachfile:%s]]" (cadr payload))))))

(kbd "<drag-n-drop>")
(kbd "<s-drag-n-drop>")
(kbd "<M-drag-n-drop>")
(kbd "<C-drag-n-drop>")
(kbd "<C-s-drag-n-drop>")
(kbd "<M-drag-n-drop>")
(kbd "<M-s-drag-n-drop>")

(global-set-key (kbd "<M-drag-n-drop>") 'org-file-M-dnd)
#+END_SRC
* Don't put headline in the email body	 :ARCHIVE:
  :PROPERTIES:
  :SENT-ON:  Tue Jul  7 13:34:58 2015
  :TO:       dixit@aya.yale.edu
#+ATTR_ORG: :width 300
#+CAPTION:
[[file:/Users/jkitchin/Desktop/scopus/nauthors-vs-ranking.png]]
  :END:

With the email.el in github it is not possible to not repeat the headline in the body of the message because it uses the whole subtree. Here is a modified version that fixes that issue and only puts the body of the current headline (including sub-headings).

** modified email-heading function
   :PROPERTIES:
   :SENT-ON:  Tue Jul  7 14:30:46 2015
   :TO:       dixit@aya.yale.edu
   :END:
(require 'org-mime)

It looks like you need to put those into the body of the email-heading function. I am not too sure why. Also, I have to pass nil as an arg to org-mime-htmlize.

#+BEGIN_SRC emacs-lisp
(defun email-heading ()
  "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
CC
BCC
OTHER-HEADERS is an alist specifying additional
header fields.  Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

Save when it was sent as a SENT property. this is overwritten on
subsequent sends."
  (interactive)
  ; store location.
  (setq *email-heading-point* (set-marker (make-marker) (point)))
  (save-excursion
    (let ((content (progn
		     (unless (org-on-heading-p) (outline-previous-heading))
		     (let ((headline (org-element-at-point)))
		       (buffer-substring
			(org-element-property :contents-begin headline)
			(org-element-property :contents-end headline)))))
	  (TO (org-entry-get (point) "TO" t))
	  (CC (org-entry-get (point) "CC" t))
	  (BCC (org-entry-get (point) "BCC" t))
	  (SUBJECT (nth 4 (org-heading-components)))
	  (OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
	  (continue nil)
	  (switch-function nil)
	  (yank-action nil)
	  (send-actions '((email-send-action . nil)))
	  (return-action '(email-heading-return)))

      (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
      (message-goto-body)
      (insert content)
      (when CC
	(message-goto-cc)
	(insert CC))
      (when BCC
	(message-goto-bcc)
	(insert BCC))
      (if TO
	  (message-goto-body)
	(message-goto-to))

      (end-of-buffer)
      (insert "Warm regards,\nJay Dixit\n\n---\nJay Dixit
(646) 355-8001
[[http://jaydixit.com/][jaydixit.com]]
\n"))
(org-mime-htmlize nil)))
#+END_SRC

#+RESULTS:
: email-heading
* Extracting content in MS Word and Powerpoint files for indexing in swish-e

Here is my swish-e code to index docx and pptx files. I have previously done this with FileFilters ([[id:2444338F-B4A1-4F87-B98C-867F344EFDA8][Indexing MS Office documents with swish-e]]) on the xml files inside these documents, but it is a little slow. I don't index excel files here, I am not sure how to extract meaningful text from them.

#+BEGIN_SRC python :tangle ~/.swish-e/msx/msx-swish.py :shebang #!/usr/bin/env python :tangle-mode (identity #o755)
from __future__ import print_function
from docx import Document
from pptx import Presentation

from xml.sax.saxutils import escape, quoteattr
import os
from os.path import join, getsize

def printtag(name,closing=False):
    if closing:
        return '</{}>'.format(name)
    else:
        return '<{}>'.format(name)


def tag(name, *content):
    return '{0}{1}{2}'.format(printtag(name),
                             ''.join(content),
                             printtag(name, closing=True))

template = '''Path-Name: {0}
Content-Length: {1}
Document-Type: XML*

{2}'''

def docx2swishxml(fdocx):
    doc = Document(fdocx)
    content = ''.join([paragraph.text.encode('utf-8')
                       for paragraph in doc.paragraphs])
    content = ''.join([i if ord(i) < 128 else ' ' for i in content])
    xml = tag('swishdefault', escape(content))

    return template.format(fdocx, len(xml), xml)

def pptx2swishxml(pptx):
    prs = Presentation(pptx)
    content = ''
    for slide in prs.slides:
        for shape in slide.shapes:
            if hasattr(shape, 'text'):
                content += shape.text.encode('utf-8')

    content = ''.join([i if ord(i) < 128 else ' ' for i in content])
    xml = tag('swishdefault', escape(content))

    return template.format(pptx, len(xml), xml)

index_dirs = ['/Users/jkitchin/Dropbox', '/Users/jkitchin/Box Sync']

for idir in index_dirs:
    for root, dirs, files in os.walk(idir):
        for f in files:
            try:
                # use end arg to avoid an extra space and carriage return
                fname = os.path.join(root, f)
                if fname.endswith('.docx'):
                    print(docx2swishxml(fname), end='')
                elif fname.endswith('.pptx'):
                    print(pptx2swishxml(fname), end='')
            except:
                pass
#+END_SRC

#+BEGIN_SRC text :tangle ~/.swish-e/msx/swish-msx-archive.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/.swish-e/msx/index-msx-archive.swish-e

# Save descriptions for context on search results.
StoreDescription XML <desc> 500
StoreDescription XML* <desc> 500

MetaNames swishtitle swishdocpath keywords description
MetaNameAlias swishtitle title
MetaNameAlias swishdocpath path
#+END_SRC



#+BEGIN_SRC text :tangle ~/.swish-e/swish-pdf.conf
# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox/bibliography/bibtex-pdfs

# where to save the index
IndexFile /Users/jkitchin/.swish-e/pdf-index.swish-e

# What to index
IndexOnly .pdf

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .pdf

FileFilter  .pdf /Users/jkitchin/Library/Enthought/Canopy_64bit/User/bin/pdf2txt.py %p

MetaNames swishtitle swishdocpath keywords description
MetaNameAlias swishtitle title
MetaNameAlias swishdocpath path

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
#+END_SRC



#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish-pdf.conf
#+END_SRC

* The ultimate org indexer


#+BEGIN_SRC emacs-lisp :tangle ~/bin/swish-org-documents.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 "$@"

(require 'org)
(require 'xml)
(require 'cl)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/f-20140828.716")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/s-20140910.334")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/dash-20141201.2206")
(require 'f)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/helm-20150701.117")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/helm-bibtex-20150301.1221")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/parsebib-20150205.1305")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/org-ref")
(require 'org-ref)


(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))


(defmacro tag (name attributes &rest body)
  "macro to create an xml tag with NAME, ATTRIBUTES. BODY is executed in the tag."
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	    ,@body)
	   (print-tag ,name nil t)))


(defun swish-e-get-buffer-lines (n)
  "Get N lines from point from buffer. Return as string with no properties."
  (beginning-of-line)
  (let ((p (point)))
    (forward-line n)
    (buffer-substring-no-properties
     p (point))))


(defun document (fname char content)
  "Return string for a swish-e document to be indexed.
FNAME is path to file.
CHAR is a position in FNAME of the CONTENT."
  (let ((stripped-content (replace-regexp-in-string
			   "[^[:ascii:]]" "" (string-as-unibyte content))))
    (when stripped-content
      (format "Path-Name: [[elisp:(progn (find-file \"%s\") (goto-char %s) (show-subtree))][link]]
Content-Length: %s
Document-Type: XML*

%s" fname
char
(length stripped-content)
stripped-content))))


;; * Document - for broadest of searching
(defun document-xml ()
  "Return xml string for the open document. Provides indexing on
content, and file-keywords."
  (let ((keywords (org-element-map
		      (org-element-parse-buffer 'element)
		      'keyword
		    (lambda (keyword)
		      (tag (xml-escape-string
			    (format
			     "%s" (org-element-property :key keyword)))
			   ()
			   (xml-escape-string
			    (format
			     "%s"
			     (org-element-property :value keyword))))))))

    (tag 'document ()
	 (tag 'file-name () (buffer-file-name))
	 (tag 'last-modified ()
	      (format-time-string "%F %A %B" (visited-file-modtime)))
	 (tag 'last-accessed ()
	      (format-time-string
	       "%F %A %B"
	       (nth 4 (file-attributes (buffer-file-name)))))
	 (tag 'desc () (xml-escape-string
			(progn
			  (goto-char (point-min))
			  (swish-e-get-buffer-lines 4))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (tag 'swish-position () (int-to-string 1))
	 ;; this is the content. saved in swishdefault for simple searching
	 (tag 'swishdefault () (xml-escape-string (or (buffer-string) "")))
	 (when keywords
	   (tag 'file-keywords ()
		(mapconcat
		 'identity
		 keywords
		 ""))))))


;; special case for documents
(defun document-document ()
  (let ((stripped-content (replace-regexp-in-string
			   "[^[:ascii:]]" ""
			   (string-as-unibyte (document-xml)))))
    (when stripped-content
      (format "Path-Name: [[file:%s]]
Content-Length: %s
Document-Type: XML

%s" fname (length stripped-content) stripped-content))))


;; * Headlines
(defun headline-xml (headline)
  "Return xml representation of an element HEADLINE.
Provides indexing on headline title, tags, and properties."
  (let ((title (org-element-property :title headline))
	(tags (org-element-property :tags headline))
	(properties  (org-element-map headline 'node-property
		       (lambda (p)
			 (cons (org-element-property :key p)
			       (org-element-property :value p))))))
    (tag 'headline ()
	 (tag 'title () (xml-escape-string (format "%s" (car title))))
	 (tag 'desc () (xml-escape-string (progn
					    (goto-char
					     (org-element-property :begin headline))
					    (swish-e-get-buffer-lines 1))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (when tags
	   (tag 'tags () (xml-escape-string (mapconcat 'identity tags " "))))
	 (when (org-element-property :todo-keyword headline)
	   (tag 'todo-keyword ()
		(xml-escape-string
		 (format
		  "%s"
		  (org-element-property :todo-keyword headline)))))
	 (when (org-element-property :todo-type headline)
	   (tag 'todo-type ()
		(xml-escape-string
		 (format
		  "%s"
		  (org-element-property :todo-type headline)))))
	 (when (org-element-property :priority headline)
	   (tag 'priority ()
		(cond
		 ((symbolp (org-element-property :priority headline))
		  (format "%s" (org-element-property :priority headline)))
		 ((char-valid-p (org-element-property :priority headline))
		  (char-to-string (org-element-property :priority headline))))))
	 (when (org-element-property :archivedp headline)
	   (tag 'archivedp ()
		(format
		 "%s"
		 (org-element-property :archivedp headline))))
	 (when (org-element-property :commentedp headline)
	   (tag 'commentedp ()
		(format
		 "%s"
		 (org-element-property :commentedp headline))))
	 (when (org-element-property :quotedp headline)
	   (tag 'quotedp ()
		(format
		 "%s"
		 (org-element-property :quotedp headline))))
	 (when properties
	   (tag 'properties ()
		(mapconcat
		 'identity
		 (loop for (p . v) in properties
		       collect (tag p () (xml-escape-string (format "%s" v))))
		 ""))))))

(defun headline-document (headline)
  "Return the headline \"document\" for swish-e to index."
  (document (buffer-file-name)
	    (org-element-property :begin headline)
	    (headline-xml headline)))

;; * Links
(defun link-xml (link)
  (tag 'link
       `((type . ,(xml-escape-string (org-element-property :type link)))
	 (path . ,(xml-escape-string (org-element-property :path link)))
	 (raw-link . ,(xml-escape-string
		       (org-element-property :raw-link link))))
       (tag 'desc () (xml-escape-string (progn
					  (goto-char
					   (org-element-property :begin link))
					  (swish-e-get-buffer-lines 1))))
       (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
       ;; captions are in the parent paragraph. Captions can contain other stuff
       ;; like latex fragments and links.
       (when (org-element-property
	      :caption
	      (org-element-property :parent link))
	 (tag 'caption ()
	      (xml-escape-string
	       (mapconcat
		(lambda (x)
		  (mapconcat
		   (lambda (y)
		     (format "%s" (car y)))
		   x
		   " "))
		(org-element-property
		 :caption
		 (org-element-property :parent link))
		" "))))
       (when (org-element-property :contents-begin link)
	 (buffer-substring (org-element-property :contents-begin link)
			   (org-element-property :contents-end link)))))

(defun link-document (link)
  (document (buffer-file-name)
	    (org-element-property :begin link)
	    (link-xml link)))


;; * Tables
(defun table-xml (table)
  (tag 'table ()
       (let* ((caption (mapconcat
			(lambda (x)
			  (mapconcat 'car x " "))
			(org-element-property :caption table) ""))
	      (begin (org-element-property :begin table))
	      (end (org-element-property :end table))
	      (contents (buffer-substring begin end)))
	 (tag 'desc () (xml-escape-string (progn
					    (goto-char
					     (org-element-property :begin table))
					    (swish-e-get-buffer-lines 4))))
	 (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
	 (tag 'caption () (xml-escape-string (format "%s" caption)))
	 (tag 'table-contents () (xml-escape-string (format "%s" contents))))))


(defun table-document (table)
  (document (buffer-file-name)
	    (org-element-property :begin table)
	    (table-xml table)))


;; * src-blocks
(defun src-block-xml (src-block)
  (tag
   'src-block
   `((language . ,(xml-escape-string
		   (org-element-property :language src-block)))
     (switches . ,(xml-escape-string
		   (format
		    "%s"
		    (org-element-property :switches src-block))))
     (parameters . ,(xml-escape-string
		     (format
		      "%s"
		      (org-element-property :parameters src-block)))))
   (tag 'desc () (xml-escape-string (progn
				      (goto-char
				       (org-element-property :begin src-block))
				      (swish-e-get-buffer-lines 4))))
   (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
   (when (org-element-property :name src-block)
     (tag 'name () (xml-escape-string
		    (org-element-property :name src-block))))
   (when (org-element-property :caption src-block)
     (tag 'caption ()
	  (mapconcat
	   (lambda (x)
	     (mapconcat 'car x " "))
	   (org-element-property :caption src-block) "")))
   (tag 'code ()
	(xml-escape-string
	 (org-element-property :value src-block)))))


(defun src-block-document (src-block)
  (document (buffer-file-name)
	    (org-element-property :begin src-block)
	    (src-block-xml src-block)))


;; * paragraphs
(defun paragraph-xml (paragraph)
  (tag 'paragraph ()
       (tag 'swish-position ()
	    (format "%s" (org-element-property :begin paragraph)))
       (tag 'desc () (xml-escape-string (progn
					  (goto-char
					   (org-element-property :begin paragraph))
					  (swish-e-get-buffer-lines 4))))
       (tag 'swishtitle () (xml-escape-string (buffer-file-name)))
       (xml-escape-string (buffer-substring-no-properties
			   (org-element-property :begin paragraph)
			   (org-element-property :end paragraph)))))


(defun paragraph-document (paragraph)
   (document (buffer-file-name)
	     (org-element-property :begin paragraph)
	     (paragraph-xml paragraph)))


(defun process-file (fname)
  "Print the `headline-document' for each headline in FNAME."
  (find-file fname)
  ;; one file had a local variable that switched the mode, so we make sure we
  ;; are in org-mode here
  (org-mode)
  (princ (document-document))

  (org-element-map (org-element-parse-buffer)
      'headline
    (lambda (headline)
      (princ (headline-document headline))))

  (org-element-map (org-element-parse-buffer)
      'link
    (lambda (link)
      (princ (link-document link))))

  (org-element-map (org-element-parse-buffer)
      'table
    (lambda (table)
      (princ (table-document table))))

  (org-element-map (org-element-parse-buffer)
      'src-block
    (lambda (src-block)
      (princ (src-block-document src-block))))

  (org-element-map (org-element-parse-buffer)
      'paragraph
    (lambda (paragraph)
      (princ (paragraph-document paragraph))))
  (kill-buffer))

;; Here is the main work in the script.
(loop for dir in '("/Users/jkitchin/Dropbox"
		   "/Users/jkitchin/Box Sync"
		   "/Users/jkitchin/dft-book"
		   "/Users/jkitchin/research"
		   "/Users/jkitchin/techela"
		   "/Users/jkitchin/blogofile-jkitchin.github.com/_blog"
)
      do
      (loop for fname in (f-entries
			  dir
			  (lambda (x)
			    (string=  "org"  (file-name-extension x)))
			  t)
            ;; I do not like to ignore errors here, but if you don't then any
            ;; error will stop the indexing.
	    do (ignore-errors (process-file fname))))
#+END_SRC

A configuration

#+BEGIN_SRC text :tangle ~/.swish-e/swish-org.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index-org.swish-e

PropertyNames swish-position

# Save descriptions for context on search results.
StoreDescription XML <desc> 500
StoreDescription XML* <desc> 500

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC

And run it.

#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish-org.conf -S prog -i ~/bin/swish-org-documents.el
#+END_SRC

The following metanames are supported (actually there are more, these are just the ones created above).
- document
  - file-keywords
  - last-modified
  - last-accessed
  - content

- headline
  - title
  - properties
  - categories
  - tags
  - todo-keyword
  - priority

- link
 - link.type
 - link.path
 - link.raw-link
 - caption

- table
 - table-contents
 - caption

- src-block
 - src-block.language
 - src-block.switches
 - src-block.parameters
 - code

- author

- paragraph

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -x '<swishrank>\t<swishdocpath>\t<swish-position>\t<swishtitle>\t<swishdescription>\n' -w dft
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: dft
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	[[file:/Users/jkitchin/dft-book/dft.org]]	1	/Users/jkitchin/dft-book/dft.org	#+TITLE:     Modeling materials using density functional theory #+AUTHOR:    John Kitchin #+DRAWERS: HIDDEN HINT SOLUTION #+EMAIL:     jkitchin@cmu.edu
498	[[file:/Users/jkitchin/dft-book/README.org]]	1	/Users/jkitchin/dft-book/README.org	This is a project to compile a pretty comprehensive set of notes and examples on using density functional theory to model properties of materials. Check out the new blog at http://jkitchin.github.com/dft-book.
299	[[file:/Users/jkitchin/dft-book/index.org]]	1	/Users/jkitchin/dft-book/index.org	#+TITLE: Welcome to dft-book - [[./dft.pdf][PDF]]
149	[[file:/Users/jkitchin/dft-book/header.org]]	1	/Users/jkitchin/dft-book/header.org	#+DRAWERS: HIDDEN HINT SOLUTION #+EMAIL:     jkitchin@cmu.edu #+DATE:      2012-07-11 Wed #+DESCRIPTION: A book on using density functional theory to model materials.
.
#+end_example


#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -x '<swishrank>\t<swishdocpath>\t<swish-position>\t<swishtitle>\t<swishdescription>\n' -w paragraph=solvation
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: paragraph=solvation
# Removed stopwords:
# Number of hits: 4
# Search time: 0.000 seconds
# Run time: 0.007 seconds
1000	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 419791) (show-subtree))][link]]	419791	/Users/jkitchin/dft-book/dft.org	Here is the evidence that we actually ran a calculation with solvation: #+BEGIN_SRC sh grep -A 5 Solvation molecules/CO-solvated/OUTCAR
789	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 418900) (show-subtree))][link]]	418900	/Users/jkitchin/dft-book/dft.org	Next, we do the solvation calculation. We use the default solvent dielectric constant of water, which is 80. #+BEGIN_SRC python from jasp import *
499	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 419513) (show-subtree))][link]]	419513	/Users/jkitchin/dft-book/dft.org	Note these take quite a bit longer to calculate (e.g. 10 times longer)! The energies here are a little different than the vacuum result. To use this energy in an energy difference, you need to make sure the other energies were run with lsol=True also, and the same parameters. Here is the evidence that we actually ran a calculation with solvation:
499	[[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 418822) (show-subtree))][link]]	418822	/Users/jkitchin/dft-book/dft.org	The forces are high because nsw was set to 0, so only one iteration was run. Next, we do the solvation calculation. We use the default solvent dielectric constant of water, which is 80.
.
#+end_example

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index-org.swish-e -w todo-keyword=TODO
#+END_SRC
#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: todo-keyword=TODO
# Removed stopwords:
# Number of hits: 42
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 21919) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 218
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 289
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 885779) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 256
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 884088) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 282
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 876922) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 226
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 871680) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 342
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 862511) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 310
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 860365) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 859209) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 333
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 858167) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 258
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 857251) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 228
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 848373) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 312
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 762835) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 238
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 717870) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 334
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 614118) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 614082) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 225
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 603103) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 227
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 115554) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 385
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 101644) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org" 385
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 2044) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org" 247
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1989) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org" 243
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/README.org") (goto-char 1279) (show-subtree))][link]] "/Users/jkitchin/dft-book/README.org" 239
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 556337) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 247
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 462462) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 202
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 424294) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 242
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 417778) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 193
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410212) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 227
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410105) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 410069) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 398549) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 372769) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 217
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 370890) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 255
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 370836) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 263
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 304068) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 205
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 304020) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 189
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 303969) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 258
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 252305) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 238
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 85024) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 295
1000 [[elisp:(progn (find-file "/Users/jkitchin/dft-book/dft.org") (goto-char 26371) (show-subtree))][link]] "/Users/jkitchin/dft-book/dft.org" 213
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-subtree))][link]] "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org" 233
.
#+end_example

* Worldcat
This returns an atom XML feed of entry items
#+BEGIN_SRC emacs-lisp :results output
;; (let* ((xml (with-current-buffer
;;		(url-retrieve-synchronously "http://www.worldcat.org/webservices/catalog/search/opensearch?q=civil%20war&wskey=Z65ynvQVhbmmxq07PX3IN1n71Z91pjUXYSSCCP9p2n8gD241P46jMyMHDuAvqRejIX1g8YbrwOAbobBM")
;;	      (xml-parse-region url-http-end-of-headers (point-max))))
;;        (entries (xml-get-children (car xml) 'entry))
;;        (formatted-entries (mapcar
;;			   (lambda (entry)
;;			     (format " - %s. %s\n  %s\n%s\n\n"
;;				     (car (xml-node-children
;;					   (car (xml-get-children  entry 'title))))
;;				     (car (xml-node-children
;;					   (car (xml-get-children
;;						 (car (xml-get-children entry 'author))
;;						 'name))))
;;				     (car (xml-node-children (car (xml-get-children entry 'summary))))
;;				     (car (xml-node-children (car (xml-get-children entry 'id))))))
;;			   entries)))
;;   (loop for s in formatted-entries
;;	do (princ s)))
#+END_SRC

#+RESULTS:
#+begin_example
 - The Civil War. Burns, Ken, 1953- Ward, Geoffrey C. Burns, Ric. McCullough, David G. Dewhurst, Colleen. Fishburne, Laurence, 1961- Freeman, Morgan. Irons, Jeremy, 1948- Jacobi, Derek. Robards, Jason. Waterston, Sam. Axton, Hoyt. Shaw, Bruce.
  An epic documentary bringing life to America's most destructive - and defining - conflict. Here is the saga of celebrated generals and the ordinary soldiers. A heroic and transcendent president and a country that had to divide itself in two in order to become one again.
http://worldcat.org/oclc/57408580

 - Pharsalia (aka "The civil war"). Lucan, 39-65.
  nil
http://worldcat.org/oclc/49294459

 - The Civil War.. Jordan, Robert Paul.
  Personalized portrait and pictorial chronicle of the men and events, campaigns and battlefields of the American Civil War.
http://worldcat.org/oclc/1034667

 - The Spanish Civil War. Thomas, Hugh, 1931-
  nil
http://worldcat.org/oclc/395987

 - Civil War. Stanchak, John E.
  Examines many aspects of the Civil War, including the issue of slavery, secession, the raising of armies, individual battles, the commanders, Northern life, Confederate culture, the surrender of the South, and the aftermath.
http://worldcat.org/oclc/43487214

 - The red badge of courage : an episode of the American Civil War. Crane, Stephen, 1871-1900.
  This stirring tale of action in the American Civil War captures the immediacies and experiences of actual battle and army life.
http://worldcat.org/oclc/8114241

 - The Civil War. Simpson, Brooks D., editor. Sears, Stephen W., editor. Sheehan-Dean, Aaron Charles, editor.
  Drawn from letters, diaries, speeches, articles, poems, songs, military reports, legal opinions, and memoirs, this collection brings together over 120 pieces by more than 60 men and women to create a firsthand narrative of the first year of the Civil War. Beginning on the eve of Lincoln's election in 1860 and ending in January 1862 with the appointment of Edwin M. Stanton as Secretary of War, the selections provide a sense of the immediacy, uncertainty, and urgency of events as the nation was torn asunder. Includes headnotes, a chronology of events, and biographical and explanatory endnotes.--Adapted from publisher description.
http://worldcat.org/oclc/642844029

 - The Civil War. Catton, Bruce, 1899-1978.
  nil
http://worldcat.org/oclc/197955

 - Observations on the nature of civil liberty, the principles of government, and the justice and policy of the war with America to which is added an appendix, containing a state of the national debt, an estimate of the money drawn from the public by the taxes, and an account of the national income and expenditure since the last war. Price, Richard, 1723-1791.
  nil
http://worldcat.org/oclc/65353752

 - The war was you and me : civilians in the American Civil War. Cashin, Joan E.
  Though civilians constituted the majority of the nation's population and were intimately involved with almost every aspect of the war, we know little about the civilian experience of the Civil War. Southerners lived through the breakup of basic social and economic institutions, including slavery. Northerners witnessed the reorganization of society to fight the war. And citizens of the border regions grappled with elemental questions of loyalty that reached into the family itself. These original essays recover the stories of civilians from Natchez to New England. They address the experiences of men, women, and children of whites, slaves, and free blacks and of civilians from numerous classes. Not least of these stories are the on-the-ground experiences of slaves seeking emancipation and the actions of white Northerners who resisted the draft. Many of the authors present brand new material, such as the war's effect on the sounds of daily life and on reading culture. Others examine the war's premiere events, including the battle of Gettysburg and the Lincoln assassination, from fresh perspectives. Several consider the passionate debate that broke out over how to remember the war, a debate that has persisted into our own time.
http://worldcat.org/oclc/47785571

#+end_example

* Looking up chemicals by CAS number

Benzene has a [[https://en.wikipedia.org/wiki/CAS_Registry_Number][CAS]] number of 71-43-2. That number can be used to retrieve information about benzene, e.g.

http://www.commonchemistry.org/ChemicalDetail.aspx?ref=71-43-2

Aldrich: http://www.sigmaaldrich.com/catalog/search?term=71-43-2&interface=CAS%20No.&N=0&mode=partialmax

What? Of course that looks like an opportunity for an org-link ;) Here is a bare bones link to open a website and export to html.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "cas"
 (lambda (cas-number)
   (browse-url
    (format "http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s" cas-number)))
 (lambda (cas-number desc backend)
   (format "<a href=\"http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s\">CAS:%s</a>" cas-number (or desc cas-number))))
#+END_SRC

And here is the link in action: cas:71-43-2. The link syntax is pretty rigid (but has the advantage of exporting in a fixed format), and you might prefer some flexibility, say CAS: 71-43-2 or CAS 71-43-2. Maybe because you want to apply this to text that is not org-mode formatted. button-lock to the rescue (again).

We can build a regexp that defines a CAS number (https://en.wikipedia.org/wiki/CAS_Registry_Number), and use it to make clickable text. A wrinkle on past examples here is we need a regexp that provides some context around the number, but ultimately we want to extract a piece of the regexp (the number). We do this by saving the regexp as a variable so that we can match to it later. We use a lot of shy groups in the regexp and explicitly number the group we want. We will make the clickable text open a website to the search results on the CAS number.

#+BEGIN_SRC emacs-lisp
(setq cas-re  "\\(?:CAS\\|cas\\)\\(?::?\\)\\s-*\\(?1:[0-9]\\{2,7\\}-[0-9]\\{2\\}-[0-9]\\)")

(button-lock-set-button
 cas-re
 (lambda ()
   (interactive)
   (save-match-data
     (let ((s  (let ((result (button-lock-find-extent (point))))
		 (buffer-substring (car result) (cdr result)))))
       (string-match cas-re s)
       (browse-url
	(format
	 "http://www.commonchemistry.org/ChemicalDetail.aspx?ref=%s"
	 (match-string 1 s))))))
 :face '((:underline t))
 :help-echo "A Chemical Abstracts Service number. Click to search"
 :additional-property 'cas)
#+END_SRC

This is an example where we use some context to identify the relevant text to make functional (e.g. 71-43-2 by itself is not highlighted).

* Using lisp to enable data reuse from a program
  :PROPERTIES:
  :LAST-EDITED: [2015-08-01 Sat]
  :END:

Here is some code in a file.
#+name: code
#+BEGIN_SRC emacs-lisp :tangle code.el
(-max '(8 3 2 4 5))
#+END_SRC

#+RESULTS: code
: 8

We can read it in like this.
#+BEGIN_SRC emacs-lisp
(read (with-temp-buffer
	(insert-file-contents "code.el")
	(buffer-string)))
#+END_SRC

#+RESULTS:
| -max | (quote (8 3 2 4 5)) |

#+BEGIN_SRC emacs-lisp
(nth 1 (nth 1 (read (with-temp-buffer
			   (insert-file-contents "code.el")
			   (buffer-string)))))
#+END_SRC

#+RESULTS:
| 8 | 3 | 2 | 4 | 5 |

Now, we reuse the data /from the code/. We read the code in as data,
#+BEGIN_SRC emacs-lisp
(-min (nth 1 (nth 1 (read (with-temp-buffer
			   (insert-file-contents "code.el")
			   (buffer-string))))))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp
(eval '(2 3 4))
#+END_SRC
That is a little awkward but illustrates the idea.
* python extract html
libextract

Wow...

#+BEGIN_SRC python
from requests import get
from lxml import html

req = get('http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract')
parsed_doc = html.fromstring(req.content)

print parsed_doc.xpath('head/meta[@name="citation_pdf_url"]')[0].attrib['content']
#+END_SRC

#+RESULTS:
: http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/pdf

[[http://rodricios.github.io/posts/solving_the_data_extraction_problem.html][How to Solve Data Extraction]]


#+BEGIN_SRC emacs-lisp
(let* ((html (with-current-buffer (url-retrieve-synchronously "http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract")
	       (libxml-parse-html-region url-http-end-of-headers (point-max))))
       (head (car (xml-get-children html 'head)))
       (metas (xml-get-children head 'meta)))
  (loop for meta in metas
	if (eq 'citation_pdf_url  (xml-get-attribute meta 'name))
	return meta
	)
  )
#+END_SRC

#+RESULTS:

Double wow. In emacs-lisp.
#+BEGIN_SRC emacs-lisp :results value code
(let* ((html (with-current-buffer (url-retrieve-synchronously "http://onlinelibrary.wiley.com/doi/10.1002/ange.201002301/abstract")
	       (libxml-parse-html-region url-http-end-of-headers (point-max))))
       (head (car (xml-get-children html 'head)))
       (metas (xml-get-children head 'meta)))
  (loop for meta in metas
	when (string= "citation_pdf_url" (xml-get-attribute meta 'name))
        return (xml-get-attribute meta 'content)))
#+END_SRC

* Getting VASP output from vasprun.xml in Python and Emacs
  :PROPERTIES:
  :categories: python,vasp,lisp
  :END:

[[https://www.vasp.at][VASP]] outputs a lot of its data in XML. Here we examine that output in Python and emacs-lisp to see how easy it is to use it. Where feasible, this is probably better than trying to parse the text-based OUTCAR file.

The XML is organized in "sections". Here, we look at the top level sections in the [[./vasprun.xml]] file. This particular file is from a CuPd alloy calculation I ran a long time ago.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

for el in xml:
    print el

#+END_SRC

#+RESULTS:
: <Element 'generator' at 0x102931050>
: <Element 'incar' at 0x102931210>
: <Element 'kpoints' at 0x102931410>
: <Element 'parameters' at 0x10294d950>
: <Element 'atominfo' at 0x10295f7d0>
: <Element 'structure' at 0x102963210>
: <Element 'calculation' at 0x102963610>
: <Element 'structure' at 0x103c64510>

Now, let us look at the elements in the generator element. We are just exploring for now.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

def pr(el, indent=0):
    print ' ' * indent, el.tag, el.attrib
    for child in el:
        pr(child, indent + 2)

pr(xml.find('generator'))
#+END_SRC

#+RESULTS:
:  generator {}
:    i {'type': 'string', 'name': 'program'}
:    i {'type': 'string', 'name': 'version'}
:    i {'type': 'string', 'name': 'subversion'}
:    i {'type': 'string', 'name': 'platform'}
:    i {'type': 'string', 'name': 'date'}
:    i {'type': 'string', 'name': 'time'}

The generator element contains information about the VASP executable, version and computer platform the calculation was run on. We can extract this information in the next section. We "find" an element with an [[https://en.wikipedia.org/wiki/XPath][xpath]] which allows you to write something like a path to the node containing the information, including specifying the attributes of a node. Pretty sweet.

#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

print xml.find('generator/i[@name="program"]').text
print xml.find('generator/i[@name="version"]').text
print xml.find('generator/i[@name="subversion"]').text
#+END_SRC
#+RESULTS:
: vasp
: 5.2.12
: 11Nov11 complex                                                      serial

Next, we see about the incar element. This contains the entries you used in the INCAR.
#+BEGIN_SRC python :session
import xml.etree.ElementTree as ET

with open('vasprun.xml') as f:
    vasprun_xml = f.read()

xml = ET.fromstring(vasprun_xml)

def pr(el, indent=0):
    print ' ' * indent, el.tag, el.attrib
    for child in el:
        pr(child, indent + 2)

pr(xml.find('incar'))
#+END_SRC

#+RESULTS:
:  incar {}
:    i {'type': 'string', 'name': 'PREC'}
:    i {'type': 'int', 'name': 'IBRION'}
:    i {'type': 'int', 'name': 'ISIF'}
:    i {'name': 'ENCUT'}
:    i {'type': 'int', 'name': 'NBANDS'}
:    i {'type': 'int', 'name': 'ISMEAR'}
:    i {'name': 'SIGMA'}

Let us print them in the form that could be used as an INCAR file. Note we can iterate over the incar element here.

#+BEGIN_SRC python :session
for el in xml.find('incar'):
    print '{0} = {1}'.format(el.attrib['name'],
                             el.text)
#+END_SRC
#+RESULTS:
: PREC = high
: IBRION =     -1
: ISIF =      2
: ENCUT =     350.00000000
: NBANDS =     34
: ISMEAR =     -5
: SIGMA =       0.10000000

Here we look at the kpoints/generation element.

#+BEGIN_SRC python :session
for el in xml.find('kpoints/generation'):
    print '{0} = {1}'.format(el.attrib['name'], el.text)
#+END_SRC
#+RESULTS:
: divisions =        8        8        8
: usershift =       0.00000000       0.00000000       0.00000000
: genvec1 =       0.12500000       0.00000000       0.00000000
: genvec2 =       0.00000000       0.12500000       0.00000000
: genvec3 =       0.00000000       0.00000000       0.12500000
: shift =       0.00000000       0.00000000       0.00000000


There are a whole bunch of things in the parameters element. Most of these are either default values or properties of the calculation. Here we look at the number of electrons, and the value of the [[http://cms.mpi.univie.ac.at/wiki/index.php/AMIX][AMIX]] parameter in the electronic mixer.
#+BEGIN_SRC python :session
print xml.find('parameters/separator[@name="electronic"]/i[@name="NELECT"]').text
print xml.find('parameters/separator[@name="electronic"]/separator[@name="electronic mixer"]/i[@name="AMIX"]').text
#+END_SRC

#+RESULTS:
: 43.00000000
: 0.40000000

The structure element contains two elements: the initialpos and the finalpos.

#+BEGIN_SRC python :session
for el in xml.findall('structure'):  print el.attrib['name']
#+END_SRC
#+RESULTS:
: initialpos
: finalpos

Get final structure:
#+BEGIN_SRC python :session
positions = [[float(x) for x in el.text.split()]
             for  el in xml.findall('structure[@name="finalpos"]/varray[@name="positions"]/v')]

unit_cell = [[float(x) for x in el.text.split()]
             for el in xml.findall('structure[@name="finalpos"]/crystal/varray[@name="basis"]/v')]

symbols = [el.text for el in xml.findall('atominfo/array[@name="atoms"]/set/rc/c[1]')]

for sym, pos in zip(symbols, positions):
    print '{0}: {1}'.format(sym, pos)

print 'UC = {0}'.format(unit_cell)
#+END_SRC

#+RESULTS:
: Cu: [0.25334331, 0.25334331, 0.25334331]
: Cu: [0.0, 0.0, 0.0]
: Cu: [0.74665669, 0.74665669, 0.74665669]
: Pd: [0.5, 0.5, 0.5]
: UC = [[-5.46362047, 3.5654701, 5.46362047], [-3.5654701, 5.46362047, 5.46362047], [-5.46362047, 5.46362047, 3.5654701]]

The calculation element contains the energies for the self-consistent iterations performed.
#+BEGIN_SRC python :session
for el in xml.findall('calculation/scstep/energy/i[@name="e_0_energy"]'):
    print float(el.text)
#+END_SRC
#+RESULTS:
: -16.49261096
: -16.50499056
: -16.48925155
: -16.48985986
: -16.48973695
: -16.48985835
: -16.48981957

There is a lot more information in the vasprun.xml file. It takes some exploration to figure out what is there, and how to get it. I am not aware of any documentation on this file anywhere. But, it seems a lot easier to extract data from this than to parse the OUTCAR file.

** Lisp version
Here is a lisp script that extracts some data.
#+BEGIN_SRC emacs-lisp
(let* ((xml (car  (xml-parse-file "vasprun.xml")))
       (generator (car (xml-get-children xml 'generator)))
       (i-nodes (xml-get-children generator 'i)))
  (list
   (loop for i-node in i-nodes
	 when (string= "program" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))
   (loop for i-node in i-nodes
	 when (string= "version" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))
   (loop for i-node in i-nodes
	 when (string= "subversion" (xml-get-attribute i-node 'name))
	 return (car (xml-node-children i-node)))))
#+END_SRC

#+RESULTS:
| vasp | 5.2.12 | 11Nov11 complex                                                      serial |

That is definitely a bit more verbose than the Python code, but I suspect that is because it uses lower level functions. The main thing missing here is the use of xpath in emacs-lisp.

Let's see if we can get a little closer to the Python syntax. First, we break down the parsed xml a bit. The returned value of xml-parse-file is a list of elements, in this case, it is one element named modeling. That element contains everything else.

#+BEGIN_SRC emacs-lisp :results code
(loop for element in  (xml-parse-file "vasprun.xml")
      collect (xml-node-name element))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(modeling)
#+END_SRC

Now, lets see what is in modeling. The modeling element is nested in the output of xml-parse-file, and I guess it is conceivable there could be more than one of them. Let us be general and allow for that. We create a lambda function that takes a node, and then collects the name of any children nodes. It is possible the child node is a string, in which case it is the "text" of the element. We only want to collect container nodes here, which are lists. We use our lambda function to loop over each element in the output of xml-parse-file, and on that element, examine the child nodes.

#+BEGIN_SRC emacs-lisp :results code
(mapcar
 (lambda (node)
   (loop for element in  (xml-node-children node)
	 when (listp element)
	 collect (xml-node-name element)))
 (xml-parse-file "vasprun.xml"))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((generator incar kpoints parameters atominfo structure calculation structure))
#+END_SRC

Here I just wrap a function to make it a little cleaner.

#+BEGIN_SRC emacs-lisp :results value raw
(defun collect-children-names (parent)
  (loop for element in  (xml-node-children parent)
	   when (listp element)
	   collect (xml-node-name element)))

(mapcar
 'collect-children-names
 (xml-parse-file "vasprun.xml"))
#+END_SRC

#+RESULTS:
((generator incar kpoints parameters atominfo structure calculation structure))

Ok, that gives us an idea of the secondary structure.  The returned structure is a list containing a list of symbols. One more example. Let's now consider what is in the generator. Let us refresh our mental model of the data. We start with a list containing one modeling element, which is itself a list. The modeling element contains a generator element, which is a list containing other elements.

((modeling (generator (node1) (node2))))

So, when we work on the parent xml, we will get an outer list containing a list of a list of generators for each modeling element in the file. Sounds confusing! We can just flatten our list to level two!

#+BEGIN_SRC emacs-lisp
(defun collect-children-names (parent)
  (loop for element in  (xml-node-children parent)
	   when (listp element)
	   collect (cons (xml-node-name element) (cdr element))))

(collect-children-names
 (-flatten-n 2(loop for modeling in (xml-parse-file "vasprun.xml")
		    collect (loop for generator in (xml-get-children modeling 'generator)
				  collect (xml-node-children generator)))))
#+END_SRC

#+RESULTS:
| i | ((name . version) (type . string))    | 5.2.12                                                                      |
| i | ((name . subversion) (type . string)) | 11Nov11 complex                                                      serial |
| i | ((name . platform) (type . string))   | LinuxIFC                                                                    |
| i | ((name . date) (type . string))       | 2012 04 19                                                                  |
| i | ((name . time) (type . string))       | 03:40:00                                                                    |

#+BEGIN_SRC emacs-lisp
(car (mapcar
 (lambda (generator)
   (-filter (lambda (node) (when (listp node) (eq (car node) 'i)))
	    (xml-node-children generator)))
 (xml-get-children (car (xml-parse-file "vasprun.xml")) 'generator)))

#+END_SRC

#+RESULTS:
| i | ((name . program) (type . string))    | vasp                                                                        |
| i | ((name . version) (type . string))    | 5.2.12                                                                      |
| i | ((name . subversion) (type . string)) | 11Nov11 complex                                                      serial |
| i | ((name . platform) (type . string))   | LinuxIFC                                                                    |
| i | ((name . date) (type . string))       | 2012 04 19                                                                  |
| i | ((name . time) (type . string))       | 03:40:00                                                                    |


I am working towards:

#+BEGIN_SRC emacs-lisp
(findall xml '((generator) (i . '((name . "program")))))
#+END_SRC


#+RESULTS:

* rx


#+BEGIN_SRC emacs-lisp
(rx (group bow (one-or-more (or "C" "H" "Cu") (zero-or-more digit)) eow))
#+END_SRC

#+RESULTS:
: \(\<\(?:\(?:Cu\|[CH]\)[[:digit:]]*\)+\>\)

* rdp a recursive descent parser in emacs
Example from [[https://github.com/skeeto/rdp][skeeto/rdp]]

#+BEGIN_SRC emacs-lisp
(require 'rdp)

(defvar arith-tokens
  '((sum       prod  [([+ -] sum)  no-sum])
    (prod      value [([* /] prod) no-prod])
    (num     . "-?[0-9]+\\(\\.[0-9]*\\)?")
    (+       . "\\+")
    (-       . "-")
    (*       . "\\*")
    (/       . "/")
    (pexpr     "(" [sum prod num pexpr] ")")
    (value   . [pexpr num])
    (no-prod . "")
    (no-sum  . "")))

(defun arith-op (expr)
  (destructuring-bind (a (op b)) expr
    (funcall op a b)))

(defvar arith-funcs
  `((sum     . ,#'arith-op)
    (prod    . ,#'arith-op)
    (num     . ,#'string-to-number)
    (+       . ,#'intern)
    (-       . ,#'intern)
    (*       . ,#'intern)
    (/       . ,#'intern)
    (pexpr   . ,#'cadr)
    (value   . ,#'identity)
    (no-prod . ,(lambda (e) '(* 1)))
    (no-sum  . ,(lambda (e) '(+ 0)))))

(defun arith (string)
  (rdp-parse-string string arith-tokens arith-funcs))

(arith "(1 + 2 + 3 * 4)*-3/4.0")
#+END_SRC

#+RESULTS:
: -11.25

this doesn't work as I expect.
#+BEGIN_SRC emacs-lisp
(require 'rdp)

(setq tokens
 '((email  name at address)
   (address  (word "." word "." word))
   (at . "@")
   (word . "[a-z]*")
   (name . "[a-z]*")))

(setq funcs
 `((email . ,(lambda (e) (message-box "email: %s" e)))
   (address . ,(lambda (e) (message-box "address: %s" e)))
   (name . ,(lambda (e) (message-box "name: %s" e)))
   (at . ,(lambda (e) (message-box "at: %s" e)))
   (word . ,(lambda (e) (message-box "word: %s" e)))))

(defun parse-email (string)
 (rdp-parse-string string tokens funcs))

;(email "jkitchin@andrew.cmu.edu")

(parse-email "jkitchin@andrew.cmu")
#+END_SRC

#+RESULTS:
: address: ((word: jkitchin @ word: andrew . word: cmu))


** peg
I cannot figure out how to get the parsed results here.
#+BEGIN_SRC emacs-lisp
(require 'peg)
(peg-parse-string ((number   sign digit)
                    (sign     (or "+" "-" ""))
                    (digit    [0-9]))
 "9a")
#+END_SRC
#+RESULTS:

#+BEGIN_SRC emacs-lisp
(defun peg-ex-recognize-int ()
  (peg-parse (number   sign digit (* digit))
	     (sign     (or "+" "-" ""))
	     (digit    [0-9])))

(peg-ex-recognize-int)
#+END_SRC
* DONE A sudo org-link and sh block
  CLOSED: [2015-07-17 Fri 12:42]
  :PROPERTIES:
  :categories: emacs,babel,orgmode
  :date:     2015/07/17 12:42:34
  :updated:  2015/07/17 12:42:34
  :END:
Shell blocks in org-mode are pretty useful, but they are a little limited in that it is not obvious how to run a sudo command in them.

So for example, this gives me a permission denied error.
#+BEGIN_SRC sh
ls /var/audit
#+END_SRC

One way to get around this is to create an org-mode link like this one:

#+BEGIN_SRC emacs-lisp :results silent
;http://stackoverflow.com/questions/2472273/how-do-i-run-a-sudo-command-in-emacs
(org-add-link-type
 "sudo"
 (lambda (cmd)
   "Run CMD with sudo."
   (shell-command
    (concat "echo " (shell-quote-argument (read-passwd "Password? "))
	    " | sudo -S " cmd))))
#+END_SRC

Now you can create a link like [[sudo:ls /var/audit]], and when you click on it you will be prompted for a password, and then you will see a buffer containing the output. To get an actual sudo code block, you need a new org babel library. Here is an example of what it might look like. Tangle this file to generate the library. Note: This is a lightly modified version of ob-emacs-lisp.el, and I have not tested it very thoroughly.


#+BEGIN_SRC emacs-lisp :tangle ob-sudo.el
;;; ob-sudo.el --- An org-mode source block to run shell commands as sudo

;;; Commentary:
;; Runs the block of code as a shell command with sudo.

;;; Code:

(defun org-babel-execute:sudo (body params)
  "Run BODY as a shell command using sudo."
  (let* ((passwd (shell-quote-argument (read-passwd "Password? ")))
	 (result (shell-command-to-string
		  (concat "echo " passwd
			  " | sudo -S " body))))
    ;; this is verbatim from ob-emacs-lisp
    (org-babel-result-cond (cdr (assoc :result-params params))
      (let ((print-level nil)
	    (print-length nil))
	(if (or (member "scalar" (cdr (assoc :result-params params)))
		(member "verbatim" (cdr (assoc :result-params params))))
	    (format "%S" result)
	  (format "%s" result)))
      (org-babel-reassemble-table
       result
       (org-babel-pick-name (cdr (assoc :colname-names params))
			    (cdr (assoc :colnames params)))
       (org-babel-pick-name (cdr (assoc :rowname-names params))
			    (cdr (assoc :rownames params)))))))

(provide 'ob-sudo)
;;; ob-sudo.el ends here

#+END_SRC

Let us add the current dir to our path so we can load it. If you use this a lot, you should put the library on your permanent path.

#+BEGIN_SRC emacs-lisp :results silent
(add-to-list 'load-path (expand-file-name "."))
#+END_SRC

Now, add the sudo "language" to org-babel-load-languages.

#+BEGIN_SRC emacs-lisp :results silent
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)
   (sh . t)
   (matlab . t)
   (sqlite . t)
   (ruby . t)
   (perl . t)
   (org . t)
   (dot . t)
   (plantuml . t)
   (R . t)
   (sudo . t)))
#+END_SRC

#+RESULTS:

And, here it is in action. Hopefully I am not giving away some important information here!

#+BEGIN_SRC sudo
ls /var/audit
#+END_SRC

#+RESULTS:
#+begin_example
20141106003522.20141110021519
20141110021548.crash_recovery
20141112154126.crash_recovery
20141119201541.20141122145259
20141122145317.20141124214930
20141124215000.crash_recovery
20141126062011.20141202192451
20141202192507.crash_recovery
20141210133306.crash_recovery
20141225181819.20150106015256
20150106015325.20150111010018
20150111010121.crash_recovery
20150115195518.20150115200101
20150115200110.crash_recovery
20150123061227.20150215123411
20150215123454.crash_recovery
20150225004740.20150310201600
20150310201633.20150314214730
20150314214807.crash_recovery
20150323145600.20150329170647
20150329170721.crash_recovery
20150407215846.20150413000423
20150413000438.20150421122044
20150421122104.20150518122545
20150518122616.20150518124432
20150518124432.20150518124513
20150518124513.20150518125437
20150518125437.20150518125935
20150518125935.20150518132111
20150518132111.20150531202621
20150531202719.20150601123612
20150601123612.20150601124932
20150601124932.20150601125151
20150601125151.20150601125555
20150601125555.20150601131947
20150601131947.20150601132421
20150601132421.20150601133735
20150601133735.20150601140740
20150601140740.20150601154012
20150601154012.20150601155125
20150601155125.20150601155215
20150601155215.20150601160937
20150601160937.crash_recovery
20150613061543.20150614054541
20150614054541.20150625165357
20150625165432.20150625200623
20150625200623.20150628042242
20150628042242.20150628103628
20150628103628.20150630052100
20150630052100.20150701232519
20150702005345.20150710203212
20150710203226.not_terminated
current
#+end_example

Summary thoughts: I will reiterate again I have not tested this a lot, I was mostly interested in trying to make a new sh block with sudo support. Let me know if it has issues for you, and make sure you have backups of things it could mess up!
* DONE Acronym minor mode for Emacs
  CLOSED: [2015-07-09 Thu 08:04]
  :PROPERTIES:
  :categories: emacs,tooltip, video
  :date:     2015/07/09 08:04:40
  :updated:  2015/07/09 08:04:40
  :END:

Three letter acronyms (TLA) are pretty common, as are other kinds of acronyms, e.g. ferromagnetic (FM), anti-ferromagnetic (AFM), National Security Agency (NSA), even [[https://www.gnu.org/fun/jokes/gnuemacs.acro.exp.html][Escape-Meta-Alt-Control-Shift]] (EMACS) etc... in technical documents. As you get away from the definition, it can get hard to remember what they are, so here we develop a minor mode that will put a tooltip over acronyms that hopefully shows what they mean.

You can see this in action here: https://www.youtube.com/watch?v=2G2isMO6E2c

When we turn the mode on, it will scan the buffer looking for an acronym pattern, deduce its likely meaning, and put tooltips on every subsequent use of the acronym. The pattern we will look for is a sequence of uppercase letters surrounded by parentheses. We will assume that if we find N uppercase letters, that the previous N words contain the definition of the acronym. This is pretty approximate, but it is not likely to be that wrong. Then, we will use button-lock to put the tooltips on all subsequent instances of acronyms. We don't want flyspell interfering with the tooltips, so we remove the overlays if they are there.

Unlike previous examples where we just use button-lock, here we wrap the feature into a minor mode that you can turn on and off. Note, you cannot add new acronyms and have them have tooltips. You have to refresh the buttons.

Here is the minor mode code. We use the interesting rx package to build the regular expression. It is more verbose, but a little easier to read than a straight regexp like (concat "\\<" (match-string 1) "\\>") in my opinion.




#+BEGIN_SRC emacs-lisp
(make-variable-buffer-local
 (defvar *acronym-buttons* '() "list of acronym buttons"))

(require 'rx)

(defun highlight-acronyms ()
  (save-excursion
    (let ((case-fold-search nil))
      (goto-char (point-min))
      (while (re-search-forward "(\\([A-Z]+\\))" nil t)
	(when flyspell-mode
	  (flyspell-delete-region-overlays (match-beginning 1)
					   (match-end 1)))
	(let* ((acronym (match-string 1))
	       (p (point))
	       (definition (save-excursion
			     (goto-char (match-beginning 1))
			     (backward-word (length acronym))
			     (buffer-substring (point) p))))
	  (add-to-list '*acronym-buttons*
		       (button-lock-set-button
			;; (rx word-start acronym word-end)
			(concat "\\<" acronym "\\>")
			nil
			:help-echo definition)))))
    ;; now highlight undefined acronyms, which are two or more capital letters.
    (goto-char (point-min))
    (let ((case-fold-search nil)
	  (m) (b) (e))
      (while (re-search-forward "[^(]\\<\\([A-Z]\\{2,\\}+\\)\\>[^)]" nil t)
	(setq m (match-string 1)
	      b (match-beginning 1)
	      e (match-end 1))
	(unless (string-match
		 (concat
		  ;; some org capitalized non-acronyms
		  "DONE\\|TODO\\|RESULTS\\|END\\|BEGIN\\|SRC\\|"
		  "CAPTION\\|"
		  (s-join
		   "\\|"
		   (mapcar 'button-lock-button-pattern *acronym-buttons*)))
		 m)

	  (when flyspell-mode
	    (flyspell-delete-region-overlays b e))
	  (add-text-properties
	   b e
	   '(help-echo "Undefined acronym"
		       font-lock-face '(:foreground "red")
		       undefined-acronym t)))))))


(defun remove-acronym-buttons ()
  "Remove buttons and undefined acronyms."
  ;; this is a littly clumsy to just get rid of all properties, but it is pretty
  ;; easy.
  (save-excursion
    (goto-char (point-min))
    (let ((b) (e))
      (while (setq b (next-single-property-change
		      (point) 'undefined-acronym))
	(goto-char b)
	(setq
	 e
	 (goto-char
	  (next-single-property-change
	   (point) 'undefined-acronym)))
	(set-text-properties b e nil))))
  (dolist (button *acronym-buttons*)
    (button-lock-unset-button button))
  (setq *acronym-buttons* '()))


(defun refresh-acronyms ()
  "Refresh acronym tooltips in buffer."
  (interactive)
  (remove-acronym-buttons)
  (highlight-acronyms))


;;;###autoload
(define-minor-mode acronym-mode
  "Put definitions on acronyms."
  :lighter " AM"
  (if acronym-mode
      (highlight-acronyms)
    (remove-acronym-buttons)))


(provide 'acronym-mode)

#+END_SRC

#+RESULTS:
: acronym-mode

(remove-acronym-buttons)
There it is. Now any time we have an acronym like EMACS we can mouse over it, or type C-h . on the acronym to see how it was previously defined. If you don't like it, you can turn it off!

For some reason, undefined acronyms UA are made red, and have the undefined-acronym property, but the tooltips do not appear there. DFT
* DONE Indexing headlines in org files with swish-e with laser-sharp results
  CLOSED: [2015-07-06 Mon 11:04]
  :PROPERTIES:
  :categories: emacs,swishe,orgmode
  :date:     2015/07/06 11:04:43
  :updated:  2015/07/06 11:04:43
  :END:

So far, it looks like swish-e is able to do some pretty focused searches on specific content types. However, the return results are not actually that sharp; in the way we have been using swish-e, it can only tell us the document path that matches, not where in the document the match is. To fix that, we need a new approach to what a "document" is, and a new approach to indexing. We will finally use the "-s prog" option in swish-e which runs an external program that prints stuff to stdout for swish-e to index. We will treat each headline in an org file as a "document" but rather than have the path to the file, we will put an org-mode link there that will take us right to the point of interest.

You can see this in action here: https://www.youtube.com/watch?v=bTwXtEb5Ng8

Basically, we need a program to output chunks like this for each headline in an org-file:
#+BEGIN_EXAMPLE
Path-Name: [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org") (goto-char 1))]]
Content-Length: 247
Document-Type: XML*

<headline><title>Using the ase database module</title><properties><FILE>/Users/jkitchin/blogofile-jkitchin.github.com/_blog/ase-db.org</FILE><BLOCKED></BLOCKED><categories>python, ase</categories><CATEGORY>ase-db</CATEGORY></properties></headline>
#+END_EXAMPLE

Then we need to tell swish-e to run the program and index its output. Here is the program to do that.

#+BEGIN_SRC emacs-lisp :tangle swish-org-headlines.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 "$@"
(require 'org)
(require 'xml)
(require 'cl)

(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/f-20140828.716")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/s-20140910.334")
(add-to-list 'load-path "~/Dropbox/kitchingroup/jmax/elpa/dash-20141201.2206")
(require 'f)

(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))

(defmacro tag (name attributes &rest body)
  "macro to create an xml tag with NAME, ATTRIBUTES. BODY is executed in the tag."
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	    ,@body)
	   (print-tag ,name nil t)))

(defun headline-xml (headline)
  "Return xml representation of an element HEADLINE."
  (let ((title (org-element-property :title headline))
	(properties (save-excursion
		      (goto-char
		       (org-element-property :begin headline))
		      (org-entry-properties))))
    (tag 'headline ()
	 (tag 'title () (xml-escape-string (mapconcat 'identity title " ")))
	 (when properties
	   (tag 'properties ()
		(mapconcat
		 'identity
		 (loop for (p . v) in properties
		       collect (tag p () (xml-escape-string v)))
		 ""))))))

(defun headline-document (headline)
  "Return the headline \"document\" for swish-e to index."
  (let ((xml (replace-regexp-in-string
	      "[^[:ascii:]]" ""
	      (headline-xml headline))))
    (format "Path-Name: [[elisp:(progn (find-file \"%s\") (goto-char %s) (show-children))][link]]
Content-Length: %s
Document-Type: XML*

%s" (buffer-file-name)
(org-element-property :begin headline)
(length xml)
xml)))

(defun process-file (fname)
  "Print the `headline-document' for each headline in FNAME."
  (with-current-buffer (find-file-noselect fname)
    (mapconcat 'identity
	       (org-element-map (org-element-parse-buffer)
		   'headline
		 (lambda (headline)
		   (princ (headline-document headline))))
	       "")))

;; Here is the main work in the script.
(loop for dir in '("/Users/jkitchin/blogofile-jkitchin.github.com/_blog")
      do
      (loop for fname in (f-entries
			  dir
			  (lambda (x)
			    (string=  "org"  (file-name-extension x)))
			  t)
	    do (ignore-errors
		 (princ (process-file fname)))))
#+END_SRC

Now we need a configuration file:

#+BEGIN_SRC text :tangle swish-org-headlines.conf
# Example configuration file

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org-headlines.swish-e

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC


And we run the indexer, I did this in an actual shell. For some reason, it was not possible to run here. The output is pretty useful though, as it tells you what MetaNames are searchable.

#+BEGIN_SRC sh
swish-e -c swish-org-headlines.conf -S prog -i ./swish-org-headlines.el
#+END_SRC

#+BEGIN_EXAMPLE
10:17 $ swish-e -c swish-org-headlines.conf -S prog -i ./swish-org-headlines.el
Indexing Data Source: "External-Program"
Indexing "./swish-org-headlines.el"
External Program found: ./swish-org-headlines.el
**Adding automatic MetaName 'headline' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'title' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'properties' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'file' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'blocked' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'categories' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'date' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'updated' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'category' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 18) (show-children))][link]]'
**Adding automatic MetaName 'points' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/writing-exams-in-orgmode.org") (goto-char 1391) (show-children))][link]]'
**Adding automatic MetaName 'tags' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 25) (show-children))][link]]'
**Adding automatic MetaName 'alltags' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 25) (show-children))][link]]'
**Adding automatic MetaName 'todo' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1733) (show-children))][link]]'
**Adding automatic MetaName 'closed' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/why-org-mode.org") (goto-char 1733) (show-children))][link]]'
**Adding automatic MetaName 'timestamp_ia' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/pdfsync.org") (goto-char 28) (show-children))][link]]'
**Adding automatic MetaName 'id' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-to-docx-pandoc.org") (goto-char 5056) (show-children))][link]]'
**Adding automatic MetaName 'custom_id' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'calculation' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'volume' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'total_energy' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'stress' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 1311) (show-children))][link]]'
**Adding automatic MetaName 'priority' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 15327) (show-children))][link]]'
**Adding automatic MetaName 'export_title' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_author' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_file_name' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'export_date' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 506769) (show-children))][link]]'
**Adding automatic MetaName 'scheduled' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 516502) (show-children))][link]]'
**Adding automatic MetaName 'deadline' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 516502) (show-children))][link]]'
**Adding automatic MetaName 'votes' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 532031) (show-children))][link]]'
**Adding automatic MetaName 'timestamp' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 571125) (show-children))][link]]'
**Adding automatic MetaName 'clock' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 21059) (show-children))][link]]'
**Adding automatic MetaName 'level' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 46582) (show-children))][link]]'
**Adding automatic MetaName 'correct' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 46582) (show-children))][link]]'
**Adding automatic MetaName 'permalink' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61814) (show-children))][link]]'
**Adding automatic MetaName 'hint' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 340534) (show-children))][link]]'
**Adding automatic MetaName 'answer' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 355206) (show-children))][link]]'
**Adding automatic MetaName 'correct-answer' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 377210) (show-children))][link]]'
**Adding automatic MetaName 'post_filename' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 415454) (show-children))][link]]'
**Adding automatic MetaName 'ordered' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 423900) (show-children))][link]]'
**Adding automatic MetaName 'grade' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/add-subheadings-to-headings.org") (goto-char 2822) (show-children))][link]]'
**Adding automatic MetaName ':export_file_name:' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/add-properties-to-headings.org") (goto-char 2) (show-children))][link]]'
**Adding automatic MetaName 'firstname' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'lastname' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'email' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'affiliation' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-contacts/referee-contacts.org") (goto-char 155) (show-children))][link]]'
**Adding automatic MetaName 'lettergrade' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-report/Slim-Shady-HW1.org") (goto-char 29) (show-children))][link]]'
**Adding automatic MetaName 'difficulty' found in file '[[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/problem-selection/problem-selection.org") (goto-char 1) (show-children))][link]]'
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 6,044 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: Complete
  Writing word hash: Complete
  Writing word data: Complete
6,044 unique words indexed.
4 properties sorted.
5,084 files indexed.  1,760,249 total bytes.  368,569 total words.
Elapsed time: 00:00:37 CPU time: 00:00:01
Indexing done!
#+END_EXAMPLE


Ok, now for the proof in the approach!

#+BEGIN_SRC sh :results raw
swish-e -f index-org-headlines.swish-e -w headline=generating
#+END_SRC

#+RESULTS:
# SWISH format: 2.4.7
# Search words: headline=generating
# Removed stopwords:
# Number of hits: 9
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))][link]] "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))][link]] "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))][link]] "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 158456) (show-children))][link]] "blog-2014.org") (goto-char 158456) (show-children))][link]]" 229
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 448965) (show-children))][link]] "blog.org") (goto-char 448965) (show-children))][link]]" 389
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))][link]] "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/org-db.org") (goto-char 575) (show-children))][link]] "org-db.org") (goto-char 575) (show-children))][link]]" 204
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/separate-bib.org") (goto-char 1) (show-children))][link]] "separate-bib.org") (goto-char 1) (show-children))][link]]" 393
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 272383) (show-children))][link]] "blog-2014.org") (goto-char 272383) (show-children))][link]]" 400
.


#+BEGIN_SRC sh :results org raw
swish-e -f index-org-headlines.swish-e -w todo=TODO
#+END_SRC

#+RESULTS:
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 14
# Search time: 0.000 seconds
# Run time: 0.010 seconds
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 16933) (show-children))][link]] "blog.org") (goto-char 16933) (show-children))][link]]" 342
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))][link]] "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))][link]] "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))][link]] "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))][link]] "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61231) (show-children))][link]] "blog-2014.org") (goto-char 61231) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60802) (show-children))][link]] "blog-2014.org") (goto-char 60802) (show-children))][link]]" 274
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 60289) (show-children))][link]] "blog-2014.org") (goto-char 60289) (show-children))][link]]" 207
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 632875) (show-children))][link]] "blog.org") (goto-char 632875) (show-children))][link]]" 266
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529123) (show-children))][link]] "blog.org") (goto-char 529123) (show-children))][link]]" 202
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 529087) (show-children))][link]] "blog.org") (goto-char 529087) (show-children))][link]]" 206
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 518108) (show-children))][link]] "blog.org") (goto-char 518108) (show-children))][link]]" 280
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org") (goto-char 30559) (show-children))][link]] "blog.org") (goto-char 30559) (show-children))][link]]" 337
1000 [[elisp:(progn (find-file "/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog-2014.org") (goto-char 61568) (show-children))][link]] "blog-2014.org") (goto-char 61568) (show-children))][link]]" 246
.


** Summary thoughts
This could be super useful for a lot of different elements: headlines, src-blocks, links, tables, paragraphs are the main ones that come to mind. You could have pretty focused searches that go straight to the matches!

* DONE An xml representation of an org document for indexing with swish-e
  CLOSED: [2015-07-04 Sat 11:49]
  :PROPERTIES:
  :categories: emacs,search
  :date:     2015/07/04 11:49:23
  :updated:  2015/07/04 19:34:22
  :END:

Swish-e can index xml data, and enable searching by tag. Here we push our org-mode indexing idea a little further. Initially we indexed org files as text. Then, we exported it to html, and indexed the html. That enabled some richer searching. Now, we will create an xml representation of the org file for indexing. This will enable us to use a custom tag system and search for specific text in tables, or src-blocks, or in headlines, or for headlines with certain tags, todo state or properties.

Incidentally, this is a general strategy for indexing arbitrary files. You just make an xml representation of the file containing the data to be indexed, and use swish-e to index that xml.

Let us start with code to generate xml. I adapted this from some code in [[http://landoflisp.com][Land Of Lisp]]. First, a function that simply prints a tag with attributes.

#+BEGIN_SRC emacs-lisp
(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\""
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 " "))
     "")))

(print-tag 'html '((color . "blue") (label . "test")))
#+END_SRC

#+RESULTS:
: <html color="blue" label="test">

XML tags almost always come in pairs. We define a macro to make this happen here. The macro prints the opening tag, evaluates the body, and prints the closing body. Note that the body may contain other tags, or a string. The string should be escaped to avoid illegal xml characters.

#+BEGIN_SRC emacs-lisp
(defmacro tag (name attributes &rest body)
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

;; example usage
(tag "xml" '((test . "id"))
     (tag "body" nil
	  (tag "p" nil (xml-escape-string "paragraph & < 1"))
	  (tag "p" nil "paragraph 2")))
#+END_SRC

#+RESULTS:
: <xml test="id"><body><p>paragraph &amp; &lt; 1</p><p>paragraph 2</p></body></xml>

Now, we can use this to get an xml representation of the source blocks, e.g.

#+BEGIN_SRC emacs-lisp
(mapconcat 'identity
	   (org-element-map
	       (org-element-parse-buffer)
	       'src-block
	     (lambda (element)
	       (tag
		'src-block
		`((language . ,(org-element-property :language element)))
		(tag 'contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   "")
#+END_SRC

#+RESULTS:
#+begin_example
<src-block language="emacs-lisp"><contents>(defun print-tag (name attrs &amp;optional closingp)
  &quot;Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.&quot;
  (format
   &quot;&lt;%s%s%s&gt;&quot;
   (if closingp &quot;/&quot; &quot;&quot;)
   name
   (if (and attrs (not closingp))
       (concat
	&quot; &quot;
	(mapconcat
	 (lambda (x)
	   (format &quot;%s=\&quot;%s\&quot;&quot;
		   (car x)
		   (xml-escape-string (cdr x))))
	 attrs
	 &quot; &quot;))
     &quot;&quot;)))

(print-tag &apos;html &apos;((color . &quot;blue&quot;) (label . &quot;test&quot;)))
</contents></src-block><src-block language="emacs-lisp"><contents>(defmacro tag (name attributes &amp;rest body)
  `(format &quot;%s%s%s&quot;
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(tag &quot;xml&quot; &apos;((test . &quot;id&quot;))
     (tag &quot;body&quot; nil
	  (tag &quot;p&quot; nil (xml-escape-string &quot;paragraph &amp; &lt; 1&quot;))
	  (tag &quot;p&quot; nil &quot;paragraph 2&quot;)))
</contents></src-block><src-block language="emacs-lisp"><contents>(mapconcat &apos;identity
	   (org-element-map
	       (org-element-parse-buffer)
	       &apos;src-block
	     (lambda (element)
	       (tag
		&apos;src-block
		`((language . ,(org-element-property :language element)))
		(tag &apos;contents ()
		     (xml-escape-string
		      (org-element-property :value element))))))
	   &quot;&quot;)
</contents></src-block><src-block language="emacs-lisp"><contents>(let ((xml (tag &apos;root `((filename . ,(buffer-file-name))
			(indexed-on . ,(current-time-string)))
		;; map the headlines
		(mapconcat
		 &apos;identity
		 (org-map-entries
		  (lambda ()
		    (let* ((tags (org-get-tags))
			   (heading-components (org-heading-components))
			   (title (nth 4 heading-components))
			   (level (nth 0 heading-components))
			   (properties (org-entry-properties))
			   (elem (org-element-at-point))
			   (bp (org-element-property :contents-begin elem))
			   (ep (org-element-property :contents-end elem))
			   (content (buffer-substring bp ep)))
		      (tag &apos;heading `((level . ,level))
			   (tag &apos;title () (xml-escape-string title))
			   (tag &apos;tags () (mapconcat &apos;identity tags &quot; &quot;))
			   (tag &apos;properties ()
				(mapconcat
				 (lambda (x)
				   (tag &apos;property `((label . (car ,x))) (cdr x)))
				 properties
				 &quot;&quot;))
			   (tag &apos;content ()
				(format &quot;%s&quot; (xml-escape-string content)))))))
		 &quot;&quot;)

		;; map specific element types
		(tag &apos;source-blocks ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;src-block
			(lambda (element)
			  (tag &apos;src-block
			       `((language .
					   ,(org-element-property
					     :language element)))
			       (tag &apos;contents ()
				    (xml-escape-string
				     (org-element-property :value element)))))) &quot;&quot;))

		(tag &apos;tables ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;table
			(lambda (element)
			  (tag &apos;table ()
			       (when (org-element-property :caption element)
				 (tag &apos;caption ()
				(caaar (org-element-property :caption element))))
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &quot;&quot;))

		(tag &apos;paragraphs ()
		     (mapconcat
		      &apos;identity
		      (org-element-map
			  (org-element-parse-buffer)
			  &apos;paragraph
			(lambda (element)
			  (tag &apos;paragraph ()
			       (xml-escape-string
				(buffer-substring
				 (org-element-property :contents-begin element)
				 (org-element-property :contents-end element))))))
		      &quot;&quot;
		      ))
		)))
  (with-temp-file &quot;org2xml.xml&quot;
    (insert xml)))
</contents></src-block><src-block language="emacs-lisp"><contents>(xml-parse-file &quot;org2xml.xml&quot;)
</contents></src-block>
#+end_example

So, finally we can map the entries to get some information about them, e.g. the tags, properties, todo state, etc... Then we create xml representing all that information so we can have a more precise search. Instead of looking for a word, we can specify that the word be in a property for example. Then, we make xml representations of the tables, src-blocks and paragraphs.

I am going to follow the example [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/03/Using-swish-e-to-index-org-files-as-html/][here]] that we worked out before on html and create a filter function that takes an org-file and spits out xml at the command line.
#+BEGIN_SRC emacs-lisp :tangle org2xml.el :tangle-mode (identity #o755)
:;exec emacs -batch -l $0 -f main "$@"
(require 'org)
(require 'xml)

(defun print-tag (name attrs &optional closingp)
  "Print an xml tag with symbol NAME and ATTRS (a cons list of (attribute . value)).
if CLOSINGP print the closing tag instead.
You should use `xml-escape-string' on text going into the attributes to avoid errors."
  (format
   "<%s%s%s>"
   (if closingp "/" "")
   name
   (if (and attrs (not closingp))
       (concat
	" "
	(mapconcat
	 (lambda (x)
	   (format "%s=\"%s\"" (car x) (cdr x)))
	   attrs
	   " "))
     "")))

(defmacro tag (name attributes &rest body)
  `(format "%s%s%s"
	   (print-tag ,name ,attributes nil)
           (concat
	   ,@body)
	   (print-tag ,name nil t)))

(defun main ()
  (find-file (car command-line-args-left))
  (princ (tag 'root `((filename . ,(buffer-file-name))
		      (indexed-on . ,(current-time-string)))
	      ;; map the headlines
	      (mapconcat
	       'identity
	       (org-map-entries
		(lambda ()
		  (let* ((tags (org-get-tags))
			 (heading-components (org-heading-components))
			 (todo (nth 2 heading-components))
			 (headline (nth 4 heading-components))
			 (thislevel (nth 0 heading-components))
			 (properties (org-entry-properties)))
		    (tag 'heading `((level . ,thislevel))
			 (tag 'headline () (xml-escape-string headline))
			 (tag 'tags () (mapconcat 'identity tags " "))
			 (when todo
			   (tag 'todo () todo))
			 (tag 'properties ()
			      (mapconcat
			       (lambda (x)
				 (tag 'property `((name . ,(xml-escape-string (car x))))
				      (xml-escape-string (cdr x))))
			       properties
			       ""))))))
	       "")

	      ;; get file keywords, TITLE, authors, etc...
	      (tag 'file-keywords ()
		   (mapconcat 'identity
			      (org-element-map (org-element-parse-buffer 'element) 'keyword
				(lambda (keyword)
				  (tag (xml-escape-string (org-element-property :key keyword)) ()
				       (xml-escape-string (org-element-property :value keyword)))))
			      ""))

	      ;; map specific element types
	      (tag 'source-blocks ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'src-block
		      (lambda (element)
			(tag 'src-block
			     `((language .
					 ,(org-element-property
					   :language element)))
			     (tag 'contents ()
				  (xml-escape-string
				   (org-element-property :value element)))))) ""))

	      (tag 'tables ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'table
		      (lambda (element)
			(tag 'table ()
			     (when (org-element-property :caption element)
			       (tag 'caption ()
				    (format
				     "%s"
				     (org-element-property
				      :caption element))))
			     (xml-escape-string
			      (buffer-substring
			       (org-element-property :contents-begin element)
			       (org-element-property :contents-end element))))))
		    ""))

	      (tag 'paragraphs ()
		   (mapconcat
		    'identity
		    (org-element-map
			(org-element-parse-buffer)
			'paragraph
		      (lambda (element)
			(tag 'paragraph ()
			     (xml-escape-string
			      (buffer-substring
			       (org-element-property :contents-begin element)
			       (org-element-property :contents-end element))))))
		    ""
		    )))))
#+END_SRC

We could do more, e.g. links, or images, but this is pretty good for now. Now, let's configure a swish indexer. We instruct swish-e to use some metanames, and attributes so we can search on them later.

#+BEGIN_SRC text :tangle swish-org2xml.conf
# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com/_site

# where to save the index
IndexFile /Users/jkitchin/blogofile-jkitchin.github.com/_blog/index-org2xml.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the HTML parser.
IndexContents XML* .org

FileFilter .org /Users/jkitchin/blogofile-jkitchin.github.com/_blog/org2xml.el

# index all tags for searching
UndefinedMetaTags auto
UndefinedXMLAttributes auto
#+END_SRC

And now, run the index command. I did this at the command line. There might be some problems with the script as there were some warnings about non-zero exits, but there was only a few so we ignore them for now.

#+BEGIN_SRC sh
swish-e -c swish-org2xml.conf
#+END_SRC


** Examples of searching for org-files
*** Files with words in the filename
Here we look for filenames with the word "Extracting" in them.

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w root.filename=Extracting
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: root.filename=Extracting
: # Removed stopwords:
: # Number of hits: 2
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/19/Extracting-bibtex-file-from-an-org-buffer.org "Extracting-bibtex-file-from-an-org-buffer.org" 6094
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
: .

Or, thanks to the date being in the path, we can find by year, How about July of 2012?
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w root.filename="(2012/07)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: root.filename=(2012/07)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2012/07/15/Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org "Professor-Kitchin-was-awarded-the-Presidential-Early-Career-Award-for-Scientists-and-Engineers-(PECASE).org" 311
: .

Interesting we have to use the parentheses here.

*** DONE Files with headlines containing a word
    CLOSED: [2015-07-04 Sat 16:39]
    :PROPERTIES:
    :date:     2015/07/04 16:39:02
    :updated:  2015/07/04 16:39:02
    :END:
Now, lets find documents with "Compiled" in a heading title with level=2
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w heading.level=2 title=Compiled -m5
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: heading.level=2 title=Compiled
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
: .

*** Headlines marked TODO
We can find documents with headlines marked TODO:
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e  -w "todo=TODO" -m 5
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: todo=TODO
# Removed stopwords:
# Number of hits: 12
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-01-27-Clocking-your-time-in-org-mode/blog.org "blog.org" 134160
624 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now.org "A-dynamic-snippet-for-a-task-due-7-days-from-now.org" 2587
425 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/02/16/END.org "END.org" 1531
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/02/01/Handling-multiple-selections-in-helm.org "Handling-multiple-selections-in-helm.org" 3290
269 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2015/01/30/More-adventures-in-helm---more-than-one-action.org "More-adventures-in-helm---more-than-one-action.org" 3236
.
#+end_example

*** For a table
so2-capacity-1

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w table="energy"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: table=energy
: # Removed stopwords:
: # Number of hits: 2
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
: 633 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/07/04/Estimating-uncertainties-in-equations-of-state.org "Estimating-uncertainties-in-equations-of-state.org" 3117
: .

*** Tagged headlines
Find entries with a "slide" tag.
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w "tags=slide"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: tags=slide
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.009 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-07-12-Org-mode-is-awesome/why-org-mode.org "why-org-mode.org" 13522
: .

Evidently there is one file where I talk about slides in org-show.

*** Headlines with a property
Here I find documents with headlines that have thermodynamics in the property "categories".
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w "property.label=categories property=thermodynamics"
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: property.label=categories property=thermodynamics
# Removed stopwords:
# Number of hits: 10
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook.org "Water-gas-shift-equilibria-via-the-NIST-Webbook.org" 10789
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org "Gibbs-energy-minimization-and-the-NIST-webbook.org" 5441
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org "Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org" 6155
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/27/Reading-parameter-database-text-files-in-python.org "Reading-parameter-database-text-files-in-python.org" 3947
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org "The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org" 8230
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org "Calculating-a-bubble-point-pressure-of-a-mixture.org" 3203
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation.org "The-equal-area-method-for-the-van-der-Waals-equation.org" 5737
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/12/Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org "Using-constrained-optimization-to-find-the-amount-of-each-phase-present.org" 5210
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org "Constrained-minimization-to-find-equilibrium-compositions.org" 5666
1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/09/23/Generating-an-atomic-stoichiometric-matrix.org "Generating-an-atomic-stoichiometric-matrix.org" 3487
.
#+end_example

That seems about right, according to http://kitchingroup.cheme.cmu.edu/categories.html there are 9 documents. I am not sure why they don't totally agree, but I can live with it.

Here are documents containing headlines with the property "TOTAL_ENERGY"
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w property.label=TOTAL_ENERGY
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property.label=TOTAL_ENERGY
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.008 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/08/21/Using-org-entries-like-a-database.org "Using-org-entries-like-a-database.org" 53035
: .

*** Documents with a Python source block containing a word
Find org files with diffusion in a python source block.
#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w src-block.language=python -w src-block=diffusion
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: src-block.language=python src-block=diffusion
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.011 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2013/04/02/Transient-diffusion---partial-differential-equations.org "Transient-diffusion---partial-differential-equations.org" 3660
: .

*** An org-file with a UUID

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w  property="(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property=(38FCCF3D-7FC5-49BF-BB77-486BBAA17CD9)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.007 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/org/2014/11/23/Machine-gradable-quizzes-in-emacs+org-modex.org "Machine-gradable-quizzes-in-emacs+org-modex.org" 5743
: .

Interesting, again the parentheses are necessary to find a match. I think because of the dashes. The next example is similar, but finds an entry with that bibtex key in a CUSTOM_ID property.

#+BEGIN_SRC sh
swish-e -f index-org2xml.swish-e -w  property="(mantina-2008-first-princ)"
#+END_SRC

#+RESULTS:
: # SWISH format: 2.4.7
: # Search words: property=(mantina-2008-first-princ)
: # Removed stopwords:
: # Number of hits: 1
: # Search time: 0.000 seconds
: # Run time: 0.010 seconds
: 1000 /Users/jkitchin/blogofile-jkitchin.github.com/_site/media/2014-02-19-Extracting-bibtex-file-from-an-org-buffer/notes.org "notes.org" 195515
: .

** Summary
This is pretty cool. There are still some bugs to work out in the indexing filter I think, but this demonstrates you can index org-files, and have pretty refined searches to find your files. There is still some thinking to do on how to schedule an incremental indexing, and whether we need more or better metanames. The indexing is not fast, but that is probably because I am running this through a FileFilter, rather than the -s prog option in swish-e. This is super promising to me though. Imagine building an agenda from files found with TODO headlines in them; a global todo list! Or, grabbing contacts from wherever they are.  No more losing files you have not used in a while. Find all documents containing a citation. With some extra work, you could index links, citations, [[http://kitchingroup.cheme.cmu.edu/blog/2015/07/02/Pyparsing-meets-Emacs-to-find-chemical-formulas/][chemical formulas]], or other types of identifiable content.

The logical conclusion of this work might be an ox-swish-e-xml export engine to render the org-file into xml, rather than the script I used here. It would be really great to get some refined output, e.g. rather than just get matching documents, get location information so you could open the document to the matching element. That might be out of reach for swish-e, but could be in reach for other programs like Sphinx that are more integrated with a database. There is a very interesting project here: https://github.com/wvxvw/sphinx-mode to integrate org-mode with the Sphinx search (http://sphinxsearch.com) engine.
* DONE Pyparsing meets Emacs to find chemical formulas
  CLOSED: [2015-07-02 Thu 12:22]
  :PROPERTIES:
  :categories: python,emacs
  :date:     2015/07/02 12:22:57
  :updated:  2015/07/02 12:38:04
  :END:

see the video: https://www.youtube.com/watch?v=sjxS9m8QCoo

Today we expand the concepts of clickable text and merge an idea from Python with Emacs. Here we will use Python to find chemical formulas in the buffer, and then highlight them with Emacs.  We will use pyparsing to find the chemical formulas and then use them to create a pattern for button-lock. I chose this approach because regular expressions are hard to use on the most general kinds of chemical formulas, and a (possibly recursive) parser should be better equipped to handle this. I adapted an [[https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py][example]] grammar to match simple chemical formulas, i.e. ones that do not have any parentheses, or charges different than + or -. I think something like this could be done in Emacs, but I am not as familiar with this kind of parsing in Emacs.

Basically, we treat a formula as a group of one or more Elements that have an optional number following them. Spoiler alert: This mostly works, but in the end I conclude there is a clear benefit to a markup language for chemical formulas. Here is an example usage of a parser:

#+BEGIN_SRC python
# adapted from [[https://pyparsing.wikispaces.com/file/view/chemicalFormulas.py/31041705/chemicalFormulas.py]]

from pyparsing import *

element = oneOf( """H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No""" )

integer = Word(nums)
elementRef = Group(element + Optional(integer))
chemicalFormula = (WordStart(alphas.upper())
                   + OneOrMore(elementRef).leaveWhitespace()
                   + Optional(Or([Literal("-"),
                                  Literal("+")]))
                   + WordEnd(alphas + nums + "-+"))


s = '''Water is  H2O or OH2  not h2O, methane is CH4 and of course there is PtCl4.
What about H+ and OH-? and carbon or Carbon or H2SO4?

Is this C6H6? or C2H5OH?

and a lot of elements:
H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No'''

matches = []
for match, start, stop in chemicalFormula.scanString(s):
   matches.append(s[start:stop])

print sorted(matches, key=lambda x: len(x), reverse=True)
#+END_SRC
#+RESULTS:
: ['C2H5OH', 'PtCl4', 'H2SO4', 'C6H6', 'H2O', 'OH2', 'CH4', 'OH-', 'Uub', 'Uut', 'Uuq', 'Uup', 'Uuh', 'Uus', 'Uuo', 'H+', 'He', 'Li', 'Be', 'Ne', 'Na', 'Mg', 'Al', 'Si', 'Cl', 'Ar', 'Ca', 'Sc', 'Ti', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', 'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Zr', 'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', 'Sb', 'Te', 'Xe', 'Cs', 'Ba', 'Lu', 'Hf', 'Ta', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', 'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', 'Rg', 'La', 'Ce', 'Pr', 'Nd', 'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', 'Ac', 'Th', 'Pa', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', 'Md', 'No', 'O', 'H', 'B', 'C', 'N', 'O', 'F', 'P', 'S', 'K', 'V', 'Y', 'I', 'W', 'U']

That is pretty good. If the string was actually our buffer, we could use those to create a regexp to put text-properties on them. The trick is how to get the buffer string to the Python function, and then get back usable information in lisp. We actually explored this [[http://kitchingroup.cheme.cmu.edu/blog/2015/05/16/Python-data-structures-to-lisp/][before]]! Rather than use that, we will just create the lisp output manually since this is a simple list of strings.

The first thing we should do is work out a Python script that will output the lisp results we want, which are the found formulas (I tried getting the start and stop positions, but I don't think they map onto the buffer positions very well). Here it is. We set it up as a command line tool that takes a string. We use set to get a unique list, then sort the list by length so we try matching the longest patterns first. There are a few subtle differences in this script and the example above because of some odd false hits I unsuccessfully tried to get rid of.

#+BEGIN_SRC python :tangle parse_chemical_formulas.py :tangle-mode (identity #o755) :shebang #!/usr/bin/env python
import sys
from pyparsing import *

element_string =  """H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No"""
element = oneOf([x for x in element_string.split()])

integer = Word(nums)
elementRef = Group(element + Optional(integer))
chemicalFormula = (WordStart(alphas.upper()).leaveWhitespace()
                   + OneOrMore(elementRef).leaveWhitespace()
                   + Optional(Or([Literal("-"),
                                  Literal("+")])).leaveWhitespace()
                   + WordEnd(alphas + alphas.lower() + nums + "-+").leaveWhitespace())

s = sys.stdin.read().strip()

matches = []
for match, start, stop in chemicalFormula.scanString(s):
   matches.append(s[start:stop])
matches = list(set(matches))
matches.sort(key=lambda x: len(x), reverse=True)

print "'(" + ' '.join(["\"{}\"".format(m) for m in matches]) + ')'
#+END_SRC

#+RESULTS:

Now we can test this:

#+BEGIN_SRC sh
echo "Water is H2O, methane is CH4 and of course PtCl4, what about H+ and OH-? and carbon or Carbon. Water is H2O not h2o or mH2o, methane is CH4 and of course PtCl4, what about H+ and OH-? carbon, Carbon and SRC, or H2SO4? Is this C6H6? Ethanol is C2H5OH in a sentence.

 C2H5OH firs con

This is CH3OH

H He Li Be B C N O F Ne Na Mg Al Si P S Cl
            Ar K Ca Sc Ti V Cr Mn Fe Co Ni Cu Zn Ga Ge
            As Se Br Kr Rb Sr Y Zr Nb Mo Tc Ru Rh Pd Ag
            Cd In Sn Sb Te I Xe Cs Ba Lu Hf Ta W Re Os
            Ir Pt Au Hg Tl Pb Bi Po At Rn Fr Ra Lr Rf
            Db Sg Bh Hs Mt Ds Rg Uub Uut Uuq Uup Uuh Uus
            Uuo La Ce Pr Nd Pm Sm Eu Gd Tb Dy Ho Er Tm
            Yb Ac Th Pa U Np Pu Am Cm Bk Cf Es Fm Md No
" | ./parse_chemical_formulas.py
#+END_SRC
#+RESULTS:
: '("C2H5OH" "CH3OH" "PtCl4" "H2SO4" "C6H6" "CH4" "OH-" "Uub" "Uuq" "Uup" "Uus" "Uuo" "Uuh" "H2O" "Uut" "Ru" "Re" "Rf" "Rg" "Ra" "Rb" "Rn" "Rh" "Be" "Ba" "Bh" "Bi" "Bk" "Br" "Ho" "Os" "Es" "Hg" "Ge" "Gd" "Ga" "Pr" "Pt" "Pu" "Pb" "Pa" "Pd" "Cd" "Po" "Pm" "Hs" "Hf" "He" "Md" "Mg" "Mo" "Mn" "Mt" "Zn" "H+" "Eu" "Zr" "Er" "Ni" "No" "Na" "Nb" "Nd" "Ne" "Np" "Fr" "Fe" "Fm" "Sr" "Kr" "Si" "Sn" "Sm" "Sc" "Sb" "Sg" "Se" "Co" "Cm" "Cl" "Ca" "Cf" "Ce" "Xe" "Tm" "Cs" "Cr" "Cu" "La" "Li" "Tl" "Lu" "Lr" "Th" "Ti" "Te" "Tb" "Tc" "Ta" "Yb" "Db" "Dy" "Ds" "Ac" "Ag" "Ir" "Am" "Al" "As" "Ar" "Au" "At" "In" "H" "P" "C" "K" "O" "S" "W" "B" "F" "N" "V" "I" "U" "Y")

That seems to work great. Now, we have a list of chemical formulas. Now, the Emacs side to call that function. We do not use regexp-opt here because I found it optimizes too much, and doesn't always match the formulas. We want explicit matches on each formula.

#+BEGIN_SRC emacs-lisp
(defun shell-command-on-region-to-string (start end command)
  (with-output-to-string
    (shell-command-on-region start end command standard-output)))

(read (shell-command-on-region-to-string
        (point-min) (point-max)
        "./parse_chemical_formulas.py"))
#+END_SRC

#+RESULTS:
| quote | (C2H5OH ext; t CH3OH PtCl4 H2SO4 the   fir C6H6 CH4 OH- OH2 Uub  co Uuq Uup Uus Uuo Uuh ord H2O Uut Ru Re Rf Rg Ra Rb Rn Rh Be Ba Bh Bi Bk Br Ho Os Es Hg Ge Gd Ga Pr  t Pt Pu Pb Pa Pd Cd Po Pm Hs Hf He Md Mg Mo Mn Mt Zn H+ Eu Zr Er Ni No Na Nb Nd Ne Np Fr Fe Fm Sr Kr Si Sn Sm Sc Sb Sg Se Co Cm Cl Ca Cf Ce Xe Tm Cs Cr Cu La Li Tl Lu Lr Th Ti Te Tb Tc as Ta Yb Db Dy Ds In Ac Ag Ir Am Al As Ar Au At n H P l t C r K O S W w B F N V   I U Y e i) |


That is certainly less than perfect, you can see a few false hits that are not too easy to understand, e.g. why is "fir" or "the " or "as"  in the list? They don't even start with an uppercase letter. One day maybe I will figure it out. I assume it is a logic flaw in my parser. Until then, let's go ahead and make the text functional, so it looks up the formula in the NIST webbook. The regexp is a little funny, we have to add word-boundaries to each formula to avoid some funny, bad matches.

#+BEGIN_SRC emacs-lisp :results silent
(defvar chemical-formula-button nil "store button for removal later.")

(require 'nist-webbook)
(setq chemical-formula-button
      (button-lock-set-button
       (mapconcat
	(lambda (formula)
	  (concat "\\<" (regexp-quote formula) "\\>"))
	(eval (read (shell-command-on-region-to-string
		     (point-min) (point-max)
		     "./parse_chemical_formulas.py")))
	"\\|")
       (lambda () (interactive)
	 (nist-webbook-formula
	  (get-surrounding-text-with-property
	   'chemical-formula)))
       :face '((:underline t) (:background "gray80"))
       :help-echo "A chemical formula"
       :additional-property 'chemical-formula))
#+END_SRC

Here are a few tests: CH4, C2H5OH, C6H6. C(CH3)4. C6H6 is benzene. As you can see our pattern lacks context; the first word of the sentence is "as" not the symbol for arsenic. Also, our parser does not consider formulas with parentheses in them. Whenever I refer to myself, I mean myself, and not the element iodine. There are a few weird matchs I just don't understand, like firs d t x rn lac? These do not seem to match anything, and I wonder how they are getting in the list. I think this really shows that it would be useful to use some light markup for chemical formulas which would a) provide context, and b) enhance parsing accuracy. In LaTeX you would use \ce{I} to indicate that is iodine, and not a reference to myself. That is more clear than saying I use I in chemical reactions ;) And it also clarifies sentences like the letter W is used to represent tungsten as the symbol \ce{W}.

Nevertheless, we can click on the formulas, and get something to happen that is potentially useful. Is this actually useful? Conceptually yes, I think it could be, but clearly the parsing is not recognizing formulas perfectly. Sending the buffer to a dedicated program that can return a list of matches to highlight in Emacs is a good idea, especially if it is not easy to build in Emacs, or if a proven solution already exists.


Finally, we can remove the highlighted text like this. That was the reason for saving the button earlier!

#+BEGIN_SRC emacs-lisp
(when chemical-formula-button
  (button-lock-unset-button chemical-formula-button)
  (setq chemical-formula-button nil))
#+END_SRC

#+RESULTS:

* DONE Getting Emacs to read to me
  CLOSED: [2015-06-29 Mon 14:56]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/29 14:56:16
  :updated:  2015/06/29 14:56:16
  :END:

I thought it would be interesting to have Emacs read text on the screen. Why? Sometimes I get tired of reading ;) Seriously though, this has applications in accessibility, learning to read, translation, taking a break from looking at the screen, reading emails out loud, fun and games, etc... Seems like a worthwhile endeavor!

You may want to see this video: https://www.youtube.com/watch?v=8bgS8yDSkXw to hear how it works.

On a Mac, it turns out to be easy to get a voice with a little applescript:

#+BEGIN_SRC emacs-lisp
(do-applescript "say \"Hello John\" using \"Victoria\"")
#+END_SRC

#+RESULTS:

Interesting idea to integrate some feedback into Emacs-lisp functions! at least if you are on a Mac. All we need are some interactive functions that grab text, and pass them to the applescript with an appropriate amount of escaping any quotes and backslashes.

Here is a function to speak the word at point, or selected region, or the text passed to the function:

#+BEGIN_SRC emacs-lisp
(defvar words-voice "Vicki"
  "Mac voice to use for speaking.")

(defun words-speak (&optional text)
  "Speak word at point or region. Mac only."
  (interactive)
  (unless text
    (setq text (if (use-region-p)
		   (buffer-substring
		    (region-beginning) (region-end))
		 (thing-at-point 'word))))
  ;; escape some special applescript chars
  (setq text (replace-regexp-in-string "\\\\" "\\\\\\\\" text))
  (setq text (replace-regexp-in-string "\"" "\\\\\"" text))
  (do-applescript
   (format
    "say \"%s\" using \"%s\""
    text
    words-voice)))
#+END_SRC

#+RESULTS:
: words-speak

Now we can write:

#+BEGIN_SRC emacs-lisp
(words-speak "Hello John")
#+END_SRC

#+RESULTS:

One reason I wrote this is to read org-files to me. So, now we write some functions to read words, sentences and paragraphs. These are all syntactic units in Emacs. We write code to enable us to read the next or previous units with the prefix args. Finally,  we bind the commands to some keys and a hydra for fun.

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)

(defun mac-say-word (&optional arg)
  "Speak word at point. With ARG, go forward ARG words."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-word newarg))
    (when (thing-at-point 'word)
      (words-speak (thing-at-point 'word)))))

(defun mac-say-sentence (&optional arg)
  "Speak sentence at point. With ARG, go forward ARG sentences."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-sentence newarg)
      (when (< 0 newarg) (forward-word)))
    (when (thing-at-point 'sentence)
      (words-speak (thing-at-point 'sentence)))))

(defun mac-say-paragraph (&optional arg)
  "Speak paragraph at point. With ARG, go forward ARG paragraphs."
  (interactive "P")
  ;; arg can be (4), 4, "-", or -1. we handle these like this.
  (let ((newarg))
    (when arg
      (setq newarg (cond
		    ((listp arg)
		     (round (log (car arg) 4)))
		    ((and (stringp arg) (string= "-" arg))
		     ((< 0 arg) arg)
		     -1)
		    (t arg)))
      (forward-paragraph newarg)
      (when (< 0 newarg) (forward-word)))
    (when (thing-at-point 'paragraph)
      (words-speak (thing-at-point 'paragraph)))))
#+END_SRC

#+RESULTS:
: mac-say-paragraph

Now for some key-bindings. I will make a hydra that allows repeating commands, and a keymap for more direct function calls.

#+BEGIN_SRC emacs-lisp

(defhydra mac-speak (:color red)
  "word speak"
  ("w" (progn (mac-say-word) (forward-word)) "Next word")
  ("W" (mac-say-word -1) "Previous word")
  ("s" (progn (mac-say-sentence) (forward-sentence)(forward-word)) "Next sentence")
  ("S" (mac-say-sentence -1) "Previous sentence")
  ("p" (progn (mac-say-paragraph) (forward-paragraph)) "Next paragraph")
  ("P" (mac-say-paragraph -1) "Previous paragraph"))

(define-prefix-command 'mac-speak-keymap)
(define-key mac-speak-keymap (vector ?w) 'mac-say-word)
(define-key mac-speak-keymap (vector ?s) 'mac-say-sentence)
(define-key mac-speak-keymap (vector ?p) 'mac-say-paragraph)
(define-key mac-speak-keymap (vector ?h) 'mac-speak/body)
(global-set-key (kbd "\C-xr") 'mac-speak-keymap)
#+END_SRC

#+RESULTS:
: mac-speak-keymap

Now, I can navigate text and have my Mac read it to me. It isn't quite like hearing a real person read it, but it is not too bad either. When you need a break from reading, this might be a nice tool!

* DONE Get spoken definitions from the Meriam dictionary
  CLOSED: [2015-06-30 Tue 11:26]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/30 11:26:41
  :updated:  2015/06/30 11:26:41
  :END:
Now that I can get [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/][Emacs to speak words]], here is a new application of the idea. We use it to speak the definition of the word at point. We look up the definition here:
http://www.dictionaryapi.com/account/index.htm

You may want to head straight to the video to see how this works here: https://www.youtube.com/watch?v=m529gXMrXZA


I had to get an API key for this. I suppose this key should be secret, but it could only be secure by obscurity in any kind of webapp and I don't anticipate using this much so here are the keys I got for the dictionary and thesaurus.

Key (Dictionary): 64f0950a-03b9-4315-9ba5-a73a964251ed
Key (Thesaurus): ff0e39e2-b31f-4f17-833c-24e2875aad5d

#+BEGIN_SRC emacs-lisp
(with-current-buffer
    (url-retrieve-synchronously
     (format
      "http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"
      "synchronous"
      "64f0950a-03b9-4315-9ba5-a73a964251ed"))
  (buffer-substring url-http-end-of-headers (point-max)))
#+END_SRC

#+RESULTS:
:
: <?xml version="1.0" encoding="utf-8" ?>
: <entry_list version="1.0">
:	<entry id="synchronous"><ew>synchronous</ew><subj>AE-4b#CP-5#TL-5</subj><hw>syn*chro*nous</hw><sound><wav>synchr14.wav</wav><wpr>!siN-kru-nus</wpr></sound><pr>ˈsiŋ-krə-nəs, ˈsin-</pr><fl>adjective</fl><et>Late Latin <it>synchronos,</it> from Greek, from <it>syn-</it> + <it>chronos</it> time</et><def><date>1669</date> <sn>1</sn> <dt>:happening, existing, or arising at precisely the same time</dt> <sn>2</sn> <dt>:recurring or operating at exactly the same periods</dt> <sn>3</sn> <dt>:involving or indicating <fw>synchronism</fw></dt> <sn>4 a</sn> <dt>:having the same period</dt> <sd>also</sd> <dt>:having the same period and phase</dt>  <sn>b</sn> <dt>:<sx>geostationary</sx></dt> <sn>5</sn> <dt>:of, used in, or being digital communication (as between computers) in which a common timing signal is established that dictates when individual bits can be transmitted and which allows for very high rates of data transfer</dt><ss>contemporary</ss></def><uro><ure>syn*chro*nous*ly</ure> <fl>adverb</fl></uro><uro><ure>syn*chro*nous*ness</ure> <fl>noun</fl></uro></entry>
:	<entry id="synchronous motor"><ew>synchronous motor</ew><subj>ME#EE</subj><hw>synchronous motor</hw><fl>noun</fl><def><date>1897</date><dt>:an electric motor having a speed strictly proportional to the frequency of the operating current</dt></def></entry>
: </entry_list>

The idea is to query the url, get some xml back, and collect the definitions from it. Then, construct a string of the word, the number of definitions, then the definitions, and say it.

#+BEGIN_SRC emacs-lisp
(defun speak-definition ()
  (interactive)
  (let* ((keyword (thing-at-point 'word))
	 (api-key "64f0950a-03b9-4315-9ba5-a73a964251ed")
	 (xml (with-current-buffer
		  (url-retrieve-synchronously
		   (format
		    "http://www.dictionaryapi.com/api/v1/references/collegiate/xml/%s?key=%s"
		    keyword
		    api-key))
		(xml-parse-region url-http-end-of-headers (point-max))))
	 (entries (xml-get-children (car xml) 'entry))
	 (nentries (length entries))
	 (defs (loop for entry in entries
		     collect (car (xml-get-children entry 'def))))
	 (definition (format
		      "%s"
		      (concat
		       (format "%s has %s definition%s. "
			       keyword
			       nentries
			       (if (or (= 0 nentries)
				       (> nentries 1))
				   "s"
				 ""))
		       (mapconcat
			'identity
			(loop for element in
			      (loop for def in defs
				    collect (car (xml-get-children def 'dt)))
			      for i from 1
			      collect (format "%s %s" i (car (xml-node-children element))))
			" ")))))
    (message definition)
    (do-applescript
     (format
      "say \"%s\"" definition))))
#+END_SRC

#+RESULTS:
: speak-definition

Let us try this out on a few words: asynchronous  synchronous  flibbity

I guess this would be helpful sometimes ;)

* DONE Spoken translations in Emacs
  CLOSED: [2015-07-01 Wed 11:42]
  :PROPERTIES:
  :categories: emacs,speech
  :date:     2015/07/01 11:42:28
  :updated:  2015/07/01 11:42:28
  :END:

Finally, continuing our experiments with computer speech for fun, let us try a translation of text to another language that is then spoken. Here is a free translator that has the courtesy to reply with json with the translated text in it. http://mymemory.translated.net/api/get?q=Hello%20World!&langpair=en|de I had to download a German voice called Anna, then get some translated text.

As with previous posts, there is a video: https://www.youtube.com/watch?v=8CBKnahE0ak. I am trying ScreenFlow for these (instead of Camtasia), and I still have not quite mastered the aspect ratio, so the videos still look a little odd.

As a reminder, we have this easy way to speak text in applescript. If you are on Linux, check out [[https://wiki.archlinux.org/index.php/Festival][Festival]] and on windows you may find some inspiration [[http://stackoverflow.com/questions/1040655/ms-speech-from-command-line][here]].

#+BEGIN_SRC emacs-lisp
(do-applescript "say \"Hello. My name is John. I am glad to meet you.\"")
#+END_SRC

#+RESULTS:

You can retrieve json data of the translated text, and then we can use it in our [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/29/Getting-Emacs-to-read-to-me/][word-speak]] function we previously developed. Here is an example in in German.
#+BEGIN_SRC emacs-lisp :results code
(let* ((words-voice "Anna")
       (text "Hello. My name is John. I am glad to meet you.")
       (url (format "http://mymemory.translated.net/api/get?q=%s!&langpair=en|de"
		    text))
       (json (with-current-buffer
		 (url-retrieve-synchronously url)
	       (json-read-from-string
		(buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
"Hallo. Mein Name ist John. Ich freue mich, Sie kennen zu lernen.!"
#+END_SRC


How about Chinese? Again, I downloaded a Chinese voice called "Ting-Ting".
#+BEGIN_SRC emacs-lisp :results code
(let* ((words-voice "Ting-Ting")
       (text "Hello. My name is John. I am glad to meet you.")
       (url (format "http://mymemory.translated.net/api/get?q=%s!&langpair=en|zh"
		    text))
       (json (with-current-buffer
		 (url-retrieve-synchronously url)
	       (json-read-from-string
		(buffer-substring url-http-end-of-headers (point-max)))))
       (translated-text (cdr (assoc 'translatedText (cdr (assoc 'responseData json))))))
  (words-speak translated-text)
  translated-text)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
"你好。我的名字是约翰。我很高兴见到你。!"
#+END_SRC

So, can any Chinese readers and listeners confirm if the text translates correctly, and if Ting-Ting said it correctly? Hopefully it is good enough to make some sense and be useful!

* DONE Serializing an Atoms object in xml
  CLOSED: [2015-06-28 Sun 12:26]
  :PROPERTIES:
  :categories: python,xml,ase
  :date:     2015/06/28 12:26:00
  :updated:  2015/06/28 12:26:00
  :END:
I have a future need to serialize an Atoms object from [[https://wiki.fysik.dtu.dk/ase/][ase]] as XML. I would use json usually, but I want to use a program that will index xml. I have previously used [[https://pypi.python.org/pypi/pyxser/1.5.2-r2][pyxser]] for this, but I recall it being difficult to install, and it does not pip install on my Mac. So, here we look at [[https://pypi.python.org/pypi/xmlwitch/0.2.1][xmlwitch]] which does pip install ;). This package does some serious magic with context managers.

One thing I am not sure about here is the best way to represent numbers and lists/arrays. I am using repr here, and assuming you would want to read this back in to Python where this could simply be eval'ed. Some alternatives would be to convert them to lists, or save them as arrays of xml elements.

#+BEGIN_SRC python
from ase.data.g2 import data
from ase.structure import molecule
import xmlwitch

atoms = molecule('H2O')

def serialize_atoms(atoms):
    'Return an xml string of an ATOMS object.'
    xml = xmlwitch.Builder(version='1.0', encoding='utf-8')

    with xml.atoms():
        for atom in atoms:
            with xml.atom(index=repr(atom.index)):
                xml.symbol(atom.symbol)
                xml.position(repr(atom.position))
                xml.magmom(repr(atom.magmom))
                xml.mass(repr(atom.mass))
                xml.momentum(repr(atom.momentum))
                xml.number(repr(atom.number))
        xml.cell(repr(atoms.cell))
        xml.pbc(repr(atoms.pbc))
    return xml

atoms_xml = serialize_atoms(atoms)
print atoms_xml

with open('atoms.xml', 'w') as f:
    f.write(str(atoms_xml))
#+END_SRC

#+RESULTS:
#+begin_example
<?xml version="1.0" encoding="utf-8"?>
<atoms>
  <atom index="0">
    <symbol>O</symbol>
    <position>array([ 0.      ,  0.      ,  0.119262])</position>
    <magmom>0.0</magmom>
    <mass>15.9994</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>8</number>
  </atom>
  <atom index="1">
    <symbol>H</symbol>
    <position>array([ 0.      ,  0.763239, -0.477047])</position>
    <magmom>0.0</magmom>
    <mass>1.0079400000000001</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>1</number>
  </atom>
  <atom index="2">
    <symbol>H</symbol>
    <position>array([ 0.      , -0.763239, -0.477047])</position>
    <magmom>0.0</magmom>
    <mass>1.0079400000000001</mass>
    <momentum>array([ 0.,  0.,  0.])</momentum>
    <number>1</number>
  </atom>
  <cell>array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])</cell>
  <pbc>array([False, False, False], dtype=bool)</pbc>
</atoms>
#+end_example

Now, we can try reading that file. I am going to use emacs-lisp here for fun, and compute the formula.

#+BEGIN_SRC emacs-lisp
(let* ((xml (car (xml-parse-file "atoms.xml")))
       (atoms (xml-get-children xml 'atom))
       (symbol-elements (mapcar (lambda (atom)
				  (car (xml-get-children atom 'symbol)))
				atoms))
       (symbols (mapcar (lambda (x)
			  (car (xml-node-children x)))
			symbol-elements)))
  (mapconcat (lambda (c)
	       (format "%s%s" (car c)
		       (if (= 1 (cdr c))
			   ""
			 (cdr c))))
	     (loop for sym in (-uniq symbols)
		   collect (cons
			    sym
			    (-count (lambda (x) (string= x sym)) symbols)))
	     ""))
#+END_SRC

#+RESULTS:
: OH2

Here is a (misleadingly) concise way to do this in Python. It is so short thanks to there being a Counter that does what we want, and some pretty nice list comprehension!

#+BEGIN_SRC python
import xml.etree.ElementTree as ET
from collections import Counter
with open('atoms.xml') as f:
    xml = ET.fromstring(f.read())

counts = Counter([el.text for el in xml.findall('atom/symbol')])

print ''.join(['{0}{1}'.format(a,b) if b>1 else a for a,b in counts.iteritems()])
#+END_SRC

#+RESULTS:
: H2O

And finally a test on reading a unit cell.

#+BEGIN_SRC python
import xml.etree.ElementTree as ET
from numpy import array

with open('atoms.xml') as f:
    xml = ET.fromstring(f.read())

print eval(xml.find('cell').text)
#+END_SRC

#+RESULTS:
: [[ 1.  0.  0.]
:  [ 0.  1.  0.]
:  [ 0.  0.  1.]]

That seems to work but, yeah, you won't want to read untrusted xml with that! See http://stupidpythonideas.blogspot.com/2013/11/repr-eval-bad-idea.html. It might be better (although not necessarily more secure) to use pickle or some other serialization strategy for this.

* DONE Clickable text for learning environments
  CLOSED: [2015-06-26 Fri 11:22]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/06/26 11:22:17
  :updated:  2015/06/26 11:22:17
  :END:

One use for clickable text is in educational texts, or technical documents where you want easy access to glossaries for jargon or new words, or other context specific information. Here we consider some approaches to highlight words in an Emacs buffer that are defined in a glossary, to give them tooltips and make them clickable.

You may want to see the video of this in action, the blog post does not do it justice: http://www.youtube.com/watch?v=Ogavyl_QXiU

We assume we have a [[*Glossary]] in the current document that has the words we want to highlight as headlines.  Here is a somewhat hacky way to get the list of keywords (hacky because we use cdr to get rid of the Glossary in the list). Our glossary only has two terms: INCAR and KPOINTS.

#+BEGIN_SRC emacs-lisp
(save-excursion
    (org-open-link-from-string "[[*Glossary]]")
    (cdr  (org-map-entries (lambda ()
			     (nth 4 (org-heading-components)))
			   nil 'tree)))
#+END_SRC

#+RESULTS:
| INCAR | KPOINTS |

We can use that list to make the regexp for button lock with regexp-opt like we did before. We illustrate two ideas here for the highlighted text. One is a dynamic tooltip, which we calculate on the fly and use to display the contents of the glossary heading when you mouse over the word or call local help from the keyboard (C-h .). Second, when you click on the word, you jump to the section in the glossary, and you can readily jump back with C-c & (Thanks org-mode!).

#+BEGIN_SRC emacs-lisp
(defun highlight-glossary-words ()
  (button-lock-set-button
   (regexp-opt (save-excursion
		 (org-open-link-from-string "[[*Glossary]]")
		 (cdr  (org-map-entries
			(lambda ()
			  (nth 4 (org-heading-components)))
			nil 'tree))))
   (lambda ()
     "Jump to definition."
     (interactive)
     (let ((keyword (get-surrounding-text-with-property 'glossary)))
       (org-open-link-from-string (format "[[*%s]]" keyword))))
   :additional-property 'glossary
   :face '((:background "gray80") (:underline t))
   :help-echo (lambda (window object position)
		(save-excursion
		  (goto-char position)
		  (save-restriction
		    (org-open-link-from-string
		     (format "[[*%s]]" (get-surrounding-text-with-property 'glossary)))
		    (org-narrow-to-subtree)
		    (buffer-string))))))

(highlight-glossary-words)
#+END_SRC

#+RESULTS:
| \(?:INCAR\ | KPOINTS\) | (0 (quote (face ((:background gray80) (:underline t)) keymap (keymap (mouse-3 lambda nil (interactive) (message-box done)) (mouse-1 lambda nil Jump to definition. (interactive) (let ((keyword (get-surrounding-text-with-property (quote glossary)))) (org-open-link-from-string (format [[*%s]] keyword))))) button-lock t glossary t mouse-face button-lock-mouse-face help-echo (lambda (window object position) (save-excursion (goto-char position) (save-restriction (org-open-link-from-string (format [[*%s]] (get-surrounding-text-with-property (quote glossary)))) (org-narrow-to-subtree) (buffer-string)))) rear-nonsticky t)) append) |

That is pretty cool. You might want something a little smarter for the tooltip, e.g. just the first line of the headline, but this works fine for this little example. I noticed that flyspell seems to get the tooltip in KPOINTS, sometimes, when it thinks it is misspelled.

It might take some local variables to make this work only in this just a file, rather than in every file. Alternatively, you could define a function that opens the file and then applies this.

** Glossary
*** INCAR
The file containing all the input parameters for VASP.



*** KPOINTS
The file containing the definitions of the kpoint grid.

See http://cms.mpi.univie.ac.at/vasp/vasp/KPOINTS_file.html

* Indexing MS Office and PDF documents with swish-e :ARCHIVE:
  :PROPERTIES:
  :ID:       2444338F-B4A1-4F87-B98C-867F344EFDA8
  :END:

We use file filters here. This is a little slow because each program is opened by another program.

there are also lots of errors from xml parsing.
#+BEGIN_SRC text :tangle ~/.swish-e/swish-office.conf
# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox

# where to save the index
IndexFile /Users/jkitchin/.swish-e/office-index.swish-e

# What to index
IndexOnly .docx .pptx .xlsx .pdf

# Tell Swish-e that .txt files are to use the text parser.
IndexContents XML* .docx .pptx .xlsx .pdf

FileFilter  .docx  /sw/bin/unzip "-p \"%p\" word/document.xml
FileFilter  .pptx  /sw/bin/unzip "-p \"%p\" ppt/slides/slide*.xml
FileFilter  .xlsx  /sw/bin/unzip "-p \"%p\" xl/worksheets/sheet*.xml
FileFilter  .pdf /Users/jkitchin/Library/Enthought/Canopy_64bit/User/bin/pdf2txt.py "-t xml \"%p\""

MetaNames swishtitle

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
#+END_SRC



#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish-office.conf
#+END_SRC

#+RESULTS:
#+begin_example
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox"

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [11]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]

Warning: filter '/sw/bin/unzip' exited with non-zero status: [9]
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 1,382,832 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
1,382,832 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
3,598 files indexed.  5,154,618,509 total bytes.  19,696,066 total words.
Elapsed time: 00:01:57 CPU time: 00:01:36
Indexing done!
#+end_example





#+BEGIN_SRC sh
swish-e -f ~/.swish-e/office-index.swish-e -x '%r\t%p\n' -w bingyun
#+END_SRC

#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: bingyun
# Removed stopwords:
# Number of hits: 47
# Search time: 0.003 seconds
# Run time: 0.015 seconds
1000	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-april-2012-kitchin.docx
1000	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-january-2012-kitchin.docx
1000	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-june-2012-kitchin.docx
1000	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-march-2012-kitchin.docx
1000	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-may-2012-kitchin.docx
922	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/August-2012-all-reports-RUA.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/May-2012-all-reports-RUA.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/January-2012-all-reports-RUA.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/amine-co2/monthly-reports/Carbon Capture Monthly Report - December 2011 - kitchin.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-september-2012-kitchin.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-july-2012-kitchin.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-february-2012-kitchin.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-august-2012-kitchin.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/Carbon Capture Monthly September 2012 Ver 3.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/April-2012-all-reports-RUA.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/amine-co2/monthly-reports/December-2011-luebke-monthly.docx
824	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/February-2012-all-reports-RUA.docx
711	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/Carbon Capture Monthly Oct 2012 Ver 2.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/FY13-URS/Carbon Capture Monthly Template FY-13 ver 1.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/amine-co2/monthly-reports/November-2011-luebke-summary.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/March-2012-all-reports-RUA.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/kitchin-sept-2013-quarterly-Carbon Capture Monthly Template FY-13 ver 10.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/Carbon Capture Monthly Template FY-13 ver 7 Solvents Hydrophobic Enick  rme.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-Mar-Carbon Capture Monthly Template FY-13 ver 7.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-july-2013-Carbon Capture Monthly Template FY-13 ver 9.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-Carbon Capture Monthly Template FY-13 - Feb.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-august-2013-Carbon Capture Monthly Template FY-13 ver 10.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-april-Carbon Capture Monthly Template FY-13 ver 7.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/CarbonCaptureAugust.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/CarbonCaptureApril-1.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/CaptureMonthlyMay-1.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/amine-co2/monthly-reports/October-2011-luebke-monthly.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/December-2012.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-october-2012-kitchin.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-november-2012-kitchin.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/Carbon Capture Monthly Nov 2012 Final.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-january-2013-kitchin.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY12/Task-94-solvent-Raman/monthly-reports/co2-december-2012-kitchin.docx
561	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-may-2013Carbon Capture Monthly Template FY-13 ver 8-1.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/kitchin-feb-2014-Carbon Capture Monthly Template FY-14 ver 9.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/2014-08-monthly-kitchin.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/carbon-capture-templates/kitchin-2014-3rd-quarterly-report.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/kitchin-may-2014-Carbon Capture Monthly Template FY-14 ver 9.docx
355	/Users/jkitchin/Dropbox/kitchingroup/students/ahallenb/reports/2014-01-kitchin-Carbon Capture Monthly Template FY-14 ver 6.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/CC-November-2013.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY14/kitchin-Carbon Capture Monthly Template FY-14 ver 11-2.docx
355	/Users/jkitchin/Dropbox/CMU/projects/archive/RUA/FY13/task-136/kitchin-Carbon Capture Monthly Template FY-14 ver 4.docx
.
#+end_example

* DONE Integrating swish-e and Emacs
  CLOSED: [2015-06-25 Thu 10:37]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/06/25 10:37:05
  :updated:  2015/06/25 11:10:22
  :END:

[[http://swish-e.org][swish-e]] is a software package that indexes files on your computer, and then allows you to search the index. Spotlight on my Mac is not working too well (sometimes not at all), and I want some more flexibility so today we try getting swish-e up and running and integrated with Emacs. I don't know that swish-e is the best tool for this available, but it has been on my radar a /long/ time (probably since 2003 from this [[http://joshr.com/src/docs/HowToIndexAnything.pdf][article]]), and it was easy to setup and use.

I use homebrew, so installation was this simple:

#+BEGIN_SRC sh
brew install swish-e
#+END_SRC

To test things out, I will only index org-files. I have these all over the place, and they are not all in my org-mode agenda. So, finding them quickly would be awesome.

#+BEGIN_SRC text :tangle ~/.swish-e/swish.conf
# Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox
IndexDir "/Users/jkitchin/Box Sync"
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

# Otherwise, use the HTML parser
DefaultContents HTML*

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
#+END_SRC

Now, we create our index.

#+BEGIN_SRC sh
swish-e -c ~/.swish-e/swish.conf
#+END_SRC

#+RESULTS:
#+begin_example
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox"
Indexing "/Users/jkitchin/Box Sync"
Indexing "/Users/jkitchin/blogofile-jkitchin.github.com"
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 130,109 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
130,109 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
3,208 files indexed.  54,104,974 total bytes.  8,038,594 total words.
Elapsed time: 00:00:16 CPU time: 00:00:13
Indexing done!
#+end_example


Now an example search. I have been looking into the Energy frontier research centers, and I want to find my notes on it. Here is a little query. I use a special output format to keep things simple for the parsing later, just the rank and path, separated by a tab.

#+BEGIN_SRC sh
swish-e -f ~/.swish-e/index.swish-e -x '%r\t%p\n' -w efrc
#+END_SRC
#+RESULTS:
#+begin_example
# SWISH format: 2.4.7
# Search words: efrc
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/Dropbox/org-mode/journal.org
471	/Users/jkitchin/Dropbox/org-mode/proposals.org
.
#+end_example

Now, for the integration with Emacs. We just get that output in a string, split it, and get the parts we want.  I think I will use helm to provide a selection buffer to these results. We need a list of cons cells (string . candidate). Then we write an interactive helm function. We provide two sources. One for the initial query, and another to start a new search, in case you don't find what you want.

#+BEGIN_SRC emacs-lisp
(defun helm-swish-e-candidates (query)
  "Generate a list of cons cells (swish-e result . path)."
  (let* ((result (shell-command-to-string
		  (format "swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"
			  (shell-quote-argument query))))
	 (lines (s-split "\n" result t))
	 (candidates '()))
    (loop for line in lines
	  unless (or  (s-starts-with? "#" line)
		      (s-starts-with? "." line))
	  collect (cons line (cdr (s-split "\t" line))))))


(defun helm-swish-e (query)
  "Run a swish-e query and provide helm selection buffer of the results."
  (interactive "sQuery: ")
  (helm :sources `(((name . ,(format "swish-e: %s" query))
		    (candidates . ,(helm-swish-e-candidates query))
		    (action . (("open" . (lambda (f)
					   (find-file (car f)))))))
		   ((name . "New search")
		    (dummy)
		    (action . (("search" . (lambda (f)
					     (helm-swish-e helm-pattern)))))))))
#+END_SRC

#+RESULTS:
: helm-swish-e

Now I can run M-x helm-swish-e and enter "efrc AND computing infrastructure" to find org files containing those words, then press enter to find the file. Nice and easy. I have not tested the query syntax very fully, but so far it is working fine!

* Links to Acrobat pages

#+BEGIN_SRC emacs-lisp
(do-applescript "tell application \"Adobe Acrobat Pro\"
open file \"Macintosh HD:Users:jkitchin:Desktop:ALL_EFRC_technical_summaries.pdf\" options \"nameddest=light\"
end tell")
#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC emacs-lisp
(org-add-link-type "acrobat" 'org-mac-acrobat-open)

(defun org-mac-acrobat-open (uri)
  "Visit page of pdf in Acrobat"
  (let* ((page (when (string-match "::\\(.+\\)\\'" uri)
                 (match-string 1 uri)))
         (document (substring uri 0 (match-beginning 0))))
    (do-applescript
     (concat
      "tell application \"Adobe Acrobat Pro\"\n"
      "  activate\n"
      "  set theDoc to \"" document "\"\n"
      "  set thePage to " page "\n"
      "  open theDoc\n"
      "  tell PDF Window 1\n"
      "    goto page thePage\n"
      "  end tell\n"
      "end tell"))))

;; The applescript returns link in the format
;; path_to_pdf_file::document_title::page_number::page_label

(defun as-get-acrobat-page-link ()
  (do-applescript
   (concat
    "tell application \"Adobe Acrobat Pro\"\n"
    "  set theDoc to active doc\n"
    "  set theWindow to (PDF Window 1 of theDoc)\n"
    "  set thePath to (file alias of theDoc)\n"
    "  set theTitle to (name of theWindow)\n"
    "  set thePage to (page number of theWindow)\n"
    "  set theLabel to (label text of (page thePage of theWindow))\n"
    "end tell\n"
    "set theResult to thePath & \"::\" & theTitle & \"::\" & thePage & \"::\" & theLabel\n"
    "return theResult as string\n")))

(defun org-mac-acrobat-get-page ()
  (interactive)
  (message "Applescript: Getting Acrobat page link...")
  (let* ((descriptor (as-get-acrobat-page-link))
         (components (split-string descriptor "::"))
         (path (car components))
         (title (nth 1 components))
         (page (nth 2 components))
         (label (nth 3 components))
         (link (concat "acrobat:" path "::" page))
         (description (concat title ", p." label))
         (org-link))
    (when (not (string= link ""))
      (setq org-link (org-make-link-string link description)))
    (kill-new org-link)
    org-link))

(defun org-mac-acrobat-insert-page ()
  (interactive)
  (insert (org-mac-acrobat-get-page)))
#+END_SRC

#+RESULTS:
: org-mac-acrobat-insert-page

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::190][v4.pdf, p.190]]

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::191][v4.pdf, p.191]] number 54

[[acrobat:Macintosh%20HD:Users:jkitchin:Dropbox:CMU:meetings:@planning:NAM-2015:NAM-final-program-pdf:v4.pdf::190]]


[[acrobat:

* DONE Conditional hydra menus
  CLOSED: [2015-06-24 Wed 07:31]
  :PROPERTIES:
  :categories: emacs,hydra
  :date:     2015/06/24 07:31:41
  :updated:  2015/06/24 07:31:41
  :END:

Usually the [[https://github.com/abo-abo/hydra][hydra]] menu is hard coded in the defhydra macro. Sometimes, you would like conditional options, that is, depending on some condition we get different options /when we run the hydra/ and not when it was defined. This is an open [[https://github.com/abo-abo/hydra/issues/86][issue]] in hydra. Here we explore a way to achieve that. The idea is to construct the code for the hydra, then eval it, and run the hydra. In this example we make the conditional menu depend on whether we are on an even or odd numbered line. I use the `' syntax for defining the list of code. ` is a variation of ' (quote) that enables you to use the , operator to evaluate that element while in data mode. So, here is our first idea:

#+BEGIN_SRC emacs-lisp
(defun my-hydra-1 ()
  (interactive)
  (eval
   `(defhydra my-hydra-1 (:color blue) "My hydra"
      ,(if (evenp (line-number-at-pos))
	   '("e" (message-box "Even line") "Even")
	 '("o" (message-box "Odd line") "Odd"))
      ,(when t '("a" (message-box "always true") "always"))
      ;; This does not work. you must return a legitimate hydra menu item
      ;;      ,(when nil '("n" (message-box "never") "never"))
      ))
  (my-hydra-1/body))

(my-hydra-1)
(my-hydra-1)
#+END_SRC

#+RESULTS:
: my-hydra

As long as it is not expensive to compute the conditionals, this seems like an easy enough way to get conditional options in a hydra. One limitation of the previous approach is our menu conditionals must return a hydra menu, and not nil. Here is an alternative approach to writing the function that solves the issue of the nil return in the last function. Here we build up the code list using append. It might seem like a macro should be used here, but I have not figured out how to get the macro to run the conditionals at the run-time. Note, we cannot use funcall on the defhydra because that is a macro.

#+BEGIN_SRC emacs-lisp
(defun my-hydra-2 ()
  (interactive)
  (let ((conditionals '((if (evenp (line-number-at-pos))
			    '("e" (message-box "Even second") "Even")
			  '("o" (message-box "Odd second") "Odd"))
			(when t '("a" (message-box "always true") "always"))
			(when nil '("n" (message-box "never") "never")))))
    (eval
     (append
      '(defhydra my-hydra-2 (:color blue) "My hydra")
      (loop for cond in conditionals
	    with result = (eval cond)
	    if (eval cond)
	    collect (eval cond))))
    (my-hydra-2/body)))

(my-hydra-2)
(my-hydra-2)
#+END_SRC

#+RESULTS:

That works too. Let us try another type of syntax where the conditional statements have a cons cell with a conditional statement, and a hydra menu option for when the statement is true. This is functionally similar to our first method, but has some advantages in brevity and less quoting. We add a conditional hint here too (at some expense of additional quoting).

#+BEGIN_SRC emacs-lisp
(defun my-hydra-3 ()
  (interactive)
  (let ((conditionals
	 `(((evenp (line-number-at-pos)) . ("e" (message-box "Even second") ,(format "Even: %s" (line-number-at-pos))))
	   ((oddp (line-number-at-pos)) . ("o" (message-box "Odd second") ,(format "Odd: %s" (line-number-at-pos))))
	   (t . ("a" (message-box "always true") "always"))
	   (nil . ("n" (message-box "never") "never")))))
    (eval
     (append
      '(defhydra my-hydra-3 (:color blue) "My hydra")
      (loop for cond in conditionals
	    if (eval (car  cond))
	    collect (cdr cond))))
    (my-hydra-3/body)))

(my-hydra-3)
(my-hydra-3)
#+END_SRC

I cannot figure out how to abstract this much further. There is a little redundancy in names, e.g. in the defhydra and at the end, but it is not too bad, which would usually be handled by a macro. I tried some defmacros to try this, but I could not figure out how to get the conditionals to expand at the right times, which is at run time, and not at macro expansion time. I need a macro that generates a function that has the call to defhydra in it! Maybe next year ;)

** failed macro attempt :noexport:
#+BEGIN_SRC emacs-lisp
(defmacro cond-hydra (name color sname &rest conditionals)
  `(let ((conditionals (list ,@conditionals)))
     (eval
      (append
       (defhydra ,name ,color ,sname)
       ,(loop for cond in conditionals
	      if (eval (car  cond))
	      collect (cdr cond))))
     (funcall ,(intern (format "%s/body" name)))))


(cond-hydra
 hyd-3 (:color blue) "true-hyd"
 ((evenp (line-number-at-pos)) . ("e" (message-box "Even second") (format "Even: %s" (line-number-at-pos))))
 ((oddp (line-number-at-pos)) . ("o" (message-box "Odd second") (format "Odd: %s" (line-number-at-pos))))
 (t . ("a" (message-box "always true") "always"))
 (nil . ("n" (message-box "never") "never")))

(hyd-3/body)
#+END_SRC

* DONE Clickable org-contacts in text files
  CLOSED: [2015-06-22 Mon 13:07]
  :PROPERTIES:
  :categories: orgmode,contacts
  :date:     2015/06/22 13:07:03
  :updated:  2015/06/22 13:07:03
  :END:

Continuing my adventures with clickable text (See [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/21/Clickable-email-addresses-in-emacs/][clickable email addresses]] and [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/18/Clickable-links-for-Twitter-handles-in-Emacs/][clickable twitter handles]]), here we consider how to get clickable names that are also in my org-contacts database. The goal is to have these names highlighted and clickable so that when I click on them I get a hydra menu of actions, e.g. to open the contact, email them, etc... We will again use button-lock to do the action. We will construct a fairly large regexp to match all the names in the org-contacts database. This turns out to be very easy using the regexp-opt function.

First, I formalize the code I used last time to get text around the point that has a text-property. We will use that to get the text that has been highlighted by button-lock.

#+BEGIN_SRC emacs-lisp
(defun get-surrounding-text-with-property (property)
  "Return text surrounding point with the text-property PROPERTY."
  (let ((start) (end))
    (when (get-text-property (point) property)
      (save-excursion
	(while (get-text-property (point) property)
	  (backward-char))
	(forward-char)
	(setq start (point))
	(while (get-text-property (point) property)
	  (forward-char))
	(setq end (point)))
      (buffer-substring start end))))
#+END_SRC

#+RESULTS:
: get-surrounding-text-with-property

I want to use nicknames that are defined in my org-contacts database. We first try to return an assoc lookup, then the slower approach of looping through the entries to find a matching nickname.

#+BEGIN_SRC emacs-lisp
(defun get-contact-from-name-or-nickname (name-or-nickname)
  "Return a contact from the org-contacts database for NAME-OR-NICKNAME."
  (or
   (assoc name-or-nickname (org-contacts-db))
   ;; no assoc, so now we have to find a nickname
   (catch 'contact
     (dolist (contact (org-contacts-db))
       (when (-contains? (s-split "," (or (cdr (assoc "NICKNAMES" (caddr contact))) " ")) name-or-nickname)
	 (throw 'contact contact))))))
#+END_SRC

#+RESULTS:
: get-contact-from-name-or-nickname

Now, let us write a hydra function that will be our menu of actions. For some reason, when you click on a highlighted text the mouse moves to the end of the text, so in our hydra function we move back a char, and then get the info. Basically, we get the name, then get the contact, and extract what we need from there. Here we provide functionality to open a contact, email a contact or open the url of the contact (if it exists). I also want a conditional hydra, which doesn't seem to be an option yet, so we we roll our own here. Basically, we construct the code for a hydra, and only add a menu option to open the url if we find one in the contact. We will have to eval the code returned from this function to get the hydra body, and then call the body function in the action function for the highlighted text.

#+BEGIN_SRC emacs-lisp
(defun conditional-hydra-actions ()
  "Construct code to create a hydra with conditional options."
  (let ((code  '(defhydra org-contacts (:color blue)
		  "Org contacts")))
    (setq code
	  (append
	   code
	   '(("o" (progn
		    (backward-char)
		    (let* ((name (get-surrounding-text-with-property 'org-contact))
			   (contact (get-contact-from-name-or-nickname name))
			   (contact-marker (nth 1 contact)))
		      (switch-to-buffer (marker-buffer contact-marker))
		      (goto-char (marker-position contact-marker))
		      (show-subtree)))
	      "Open contact"))))

    (setq code
	  (append
	   code '(("e" (progn
			 (backward-char)
			 (let* ((name (get-surrounding-text-with-property 'org-contact))
				(contact (get-contact-from-name-or-nickname name))
				(email (cdr (assoc "EMAIL" (caddr contact))))))
			 (mu4e~compose-mail email))
		   "Email contact"))))

    ;; conditional menu for opening a URL
    (let* ((name (get-surrounding-text-with-property 'org-contact))
	   (contact (assoc name (org-contacts-db)))
	   (url (cdr (assoc "URL" (caddr contact)))))
      (when url
	(setq code
	      (append
	       code '(("w" (progn
			     (backward-char)
			     (let* ((name (get-surrounding-text-with-property 'org-contact))
				    (contact (get-contact-from-name-or-nickname name))
				    (url (cdr (assoc "URL" (caddr contact)))))
			       (if url
				   (browse-url url)
				 (message "No url found."))))
		       "Open in browser"))))))
    code))
#+END_SRC

#+RESULTS:
: conditional-hydra-actions

I also want to have nicknames in this list, because sometimes I don't use the full names in my contact database. These are stored in a comma-separated property called NICKNAMES in entries that have them. A subtle point here is that it complicates looking up the contact in the database. Normally, I can get this by a simple assoc lookup. For the nicknames, that will fail, so we need a back up method. Now, the highlighting code. You can make the regexp by passing a list of strings to match to regexp-opt. We get our list of strings from:

#+BEGIN_SRC emacs-lisp
(append
 (mapcar 'car (org-contacts-db))
 (let ((nicknames '()))
   (dolist (contact (org-contacts-db))
     (when (assoc "NICKNAMES" (caddr contact))
       (setq nicknames
	     (append nicknames (s-split "," (cdr (assoc "NICKNAMES" (caddr contact))))))))
   nicknames))
#+END_SRC

I am not going to show them here to protect my contacts ;). Now, we create the function that highlights the contacts. and add it as a hook function to text-mode-hook.

#+BEGIN_SRC emacs-lisp
(defun highlight-org-contacts ()
  (button-lock-set-button
   (regexp-opt
    (append
     (mapcar 'car (org-contacts-db))
     (let ((nicknames '()))
       (dolist (contact (org-contacts-db))
	 (when (assoc "NICKNAMES" (caddr contact))
	   (setq nicknames
		 (append
		  nicknames
		  (s-split "," (cdr (assoc "NICKNAMES" (caddr contact))))))))
       nicknames)))
   (lambda ()
     (interactive)
     (eval (conditional-hydra-actions))
     (org-contacts/body))
   :face '((:background "MistyRose1")
	   (:underline t))
   :help-echo (format "An org contact")
   :keyboard-binding (kbd "RET")
   :additional-property 'org-contact))

(add-hook 'text-mode-hook 'highlight-org-contacts)
#+END_SRC

That does it. Now, whenever I open a text-based file, the names that are in my contacts are highlighted and actionable. This should be useful for meeting notes, etc...

* DONE Clickable email addresses in emacs
  CLOSED: [2015-06-21 Sun 16:42]
  :PROPERTIES:
  :categories: emacs,email
  :date:     2015/06/21 16:42:40
  :updated:  2015/06/21 16:42:40
  :END:

There are clickable mailto:jkitchin@andrew.cmu.edu links in org-mode, but standalone email addresses like jkitchin@cmu.edu are just ordinary text. Here, I want to explore using clickable text instead. I will use the button-lock package for this. I borrowed an email regexp from [[http://www.emacswiki.org/emacs/RegularExpression][EmacsWiki: Regular Expression]] for this. The idea is to define a regular expression for an email address, and use it to make the emails clickable.

I am still not sure what the canonical way to get the value of the text that was highlighted. Here we use the :additional-property feature to set a property to t, and then use that property to get the characters that have a non-nil "email-address" property. It seems clunky, but it works. The main action is to compose an email in mu4e (my preferred email program in emacs). You could also put a call to helm here, or to a hydra for other options.

I make the email addresses stand out a little by giving them a gray background, and a tooltip so you can see why they are highlighted. I also bind RET so I don't have to use the mouse. Don't forget you can type C-h . to see the local help instead of mousing over it! Finally, we add a text-mode hook so this will get loaded when we open a text file (or one with a mode derived from text-moe like org-mode).

#+BEGIN_SRC emacs-lisp
(defun highlight-email-addresses ()
  "Add button to email address. Clicking or RET will open a compose email window."
  (button-lock-set-button
   "\\w+\\(\\.\\w+\\)?@\\(\\w\\|\\.\\)+"
   (lambda ()
     (interactive)
     (let ((start) (end) (email-address))
       (while (get-text-property (point) 'email-address)
	 (backward-char))
       (forward-char)
       (setq start (point))
       (while (get-text-property (point) 'email-address)
	 (forward-char))
       (setq end (point))
       (setq email-address (buffer-substring start end))
       (mu4e~compose-mail email-address)))
     :face '((:background "gray80") (:underline t))
     :help-echo "click to send mu4e email"
     :keyboard-binding (kbd "RET")
     :additional-property 'email-address))

(add-hook 'text-mode-hook 'highlight-email-addresses)
#+END_SRC

That doesn't look too bad. Now, anytime I open an org-mode file with an email address in it, the address is highlighted in light gray, and underlined. I can click on it or put the cursor on it and press return and I get a compose email window open, with the email address pre-filled in! I am sure this will have some other applications.

* DONE A python version of the s-exp bibtex entry
  CLOSED: [2015-06-11 Thu 10:02]
  :PROPERTIES:
  :categories: Python,ref,bibtex
  :date:     2015/06/11 10:02:33
  :updated:  2015/06/11 10:02:33
  :END:

In this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/][post]] we explored representing a bibtex entry in lisp s-exp notation, and showed interesting things that enables. Here, I explore something similar in Python. The s-exp notation in Python is really more like tuples. It looks almost identical, except we need a lot of commas for the Python syntax. One significant difference in Python is we need to define the functions in advance because otherwise the function symbols are undefined. Similar to lisp, we can define the field functions at run-time in a loop. We have to use an eval statement, which some Pythonistas find distasteful, but it is not that different to me than what we did in lisp.

The syntax for "executing" the data structure is quite different than in lisp, because this data is /not/ code in Python. Instead, we have to deconstruct the data, knowing that the function is the first object, and it takes the remaining arguments in the tuple.

Here is the proof of concept:

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

for f in fields:
    locals()[f] = eval ('lambda x: "  {0} = {{{1}}}".format("' + f + '", x)')

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
	 (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
	 (journal, "Industrial \& Engineering Chemistry Research"),
	 (pages, "10788-10794"),
         (year, 2013),
	 (number, 31),
	 (doi, "10.1021/ie400582a"),
	 (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
	 (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


print entry[0](entry[1], entry[2:])
#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \& Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
#+end_example

Here is an approach that avoids using eval, and instead uses a function to generate a function.

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

def make_func(field):
    return lambda x: '  {0} = {{{1}}}'.format(field, x)

for f in fields:
    locals()[f] = make_func(f)

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
         (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
         (journal, "Industrial \& Engineering Chemistry Research"),
         (pages, "10788-10794"),
         (year, 2013),
         (number, 31),
         (doi, "10.1021/ie400582a"),
         (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
         (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


print entry[0](entry[1], entry[2:])

#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \& Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
#+end_example


We can still get specific fields out. Since we used a tuple here, it is not quite as nice as using a dictionary, but it is neither too bad, and it can be wrapped in a reasonably convenient function.

#+BEGIN_SRC python
def article(bibtex_key, *args):
    "Return the bibtex formatted entry"
    return ',\n'.join(['@article{{{0}}}'.format(bibtex_key)] +[arg[0](arg[1]) for arg in args[0]] + ['}'])

fields = ("author", "title", "journal", "pages", "number", "doi", "url", "eprint", "year")

for f in fields:
    locals()[f] = eval ('lambda x: "  {0} = {{{1}}}".format("' + f + '", x)')

entry = (article, "hallenbeck-2013-effec-o2",
         (author, "Hallenbeck, Alexander P. and Kitchin, John R."),
	 (title, "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"),
	 (journal, "Industrial \& Engineering Chemistry Research"),
	 (pages, "10788-10794"),
         (year, 2013),
	 (number, 31),
	 (doi, "10.1021/ie400582a"),
	 (url, "http://pubs.acs.org/doi/abs/10.1021/ie400582a"),
	 (eprint, "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))


for field in entry[2:]:
    if field[0] == author:
        print field

def get_field(entry, field):
    for element in entry[2:]:
        if element[0] == field:
            return element[1]
    else:
        return None

print get_field(entry, title)
print get_field(entry, "bad")
#+END_SRC

#+RESULTS:
: (<function <lambda> at 0x1005975f0>, 'Hallenbeck, Alexander P. and Kitchin, John R.')
: Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent
: None

So, it seems Python can do some things like lisp in treating functions like first-class objects that can be used as functions, or keys. I still like the lisp s-exp better, but this is an interesting idea for Python too.

* DONE A sexp version of a bibtex entry
  CLOSED: [2015-06-10 Wed 08:54]
  :PROPERTIES:
  :categories: bibtex,lisp
  :date:     2015/06/10 08:54:00
  :updated:  2015/06/10 08:54:00
  :END:

Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!

#+BEGIN_SRC bibtex
@article{hallenbeck-2013-effec-o2,
  author =	 "Hallenbeck, Alexander P. and Kitchin, John R.",
  title =	 {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  keywords =	 {RUA, orgmode},
  journal =	 "Industrial \& Engineering Chemistry Research",
  pages =	 "10788-10794",
  year =	 2013,
  volume =	 {52},
  number =	 {31},
  doi =		 "10.1021/ie400582a",
  url =		 "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
  eprint =	 "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
#+END_SRC

Here is what that same data structure might look like as a sexp-based lisp data structure.
#+BEGIN_SRC emacs-lisp
(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
         (year 2013)
	 (number 31)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

We can retrieve data from the sexp form pretty easily. Here we get the authors.
#+BEGIN_SRC emacs-lisp
(let* ((art '(article "hallenbeck-2013-effec-o2"
		      (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		      (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		      (journal "Industrial \& Engineering Chemistry Research")
		      (pages "10788-10794")
		      (year 2013)
		      (number 31)
		      (doi "10.1021/ie400582a")
		      (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		      (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a")))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R.

That is simple enough you might just write a little function to streamline it like this, and return a formatted string.

#+BEGIN_SRC emacs-lisp
(defun get-article-field (article field)
  "Return value of FIELD in ARTICLE."
  (cadr (assoc field (cddr article))))

(let ((art '(article "hallenbeck-2013-effec-o2"
		     (author "Hallenbeck, Alexander P. and Kitchin, John R.")
		     (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		     (journal "Industrial \& Engineering Chemistry Research")
		     (pages "10788-10794")
		     (year 2013)
		     (number 31)
		     (doi "10.1021/ie400582a")
		     (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		     (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
  (format "%s, doi:%s (%s)"
	  (get-article-field art 'author)
	  (get-article-field art 'doi)
	  (get-article-field art 'year)))

#+END_SRC

#+RESULTS:
: Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)

You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.

#+BEGIN_SRC emacs-lisp
(defmacro make-field (field-name)
  "define a field that returns a string"
  `(defun ,(intern field-name) (content)
     (format "  %s = {%s}" ,field-name content)))

(loop for field in '("author" "title" "journal" "pages" "number" "doi" "url" "eprint" "year")
  do (eval `(make-field ,field)))

(defun article (bibtex-key &rest fields)
  (concat
   (format "@article{%s,\n" bibtex-key)
   (mapconcat (lambda (field) (eval field)) fields ",\n")
   "\n}\n"))

(article "hallenbeck-2013-effec-o2"
	 (author "Hallenbeck, Alexander P. and Kitchin, John R.")
	 (title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
	 (journal "Industrial \& Engineering Chemistry Research")
	 (pages "10788-10794")
	 (number 31)
         (year 2013)
	 (doi "10.1021/ie400582a")
	 (url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
	 (eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial & Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
#+end_example

Wow. We /executed/ our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "  <%s>%s</%s>" ,field content ,field)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "<article bibtex-key=\"%s\">\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields "\n")
			   "\n</article>")))
	       )
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
<article bibtex-key="hallenbeck-2013-effec-o2">
  <author>Hallenbeck, Alexander P. and Kitchin, John R.</author>
  <title>Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent</title>
  <journal>Industrial & Engineering Chemistry Research</journal>
  <pages>10788-10794</pages>
  <number>31</number>
  <year>2013</year>
  <doi>10.1021/ie400582a</doi>
  <url>http://pubs.acs.org/doi/abs/10.1021/ie400582a</url>
  <eprint>http://pubs.acs.org/doi/pdf/10.1021/ie400582a</eprint>
</article>
#+end_example

Prefer json? No problem, just reformat the functions!

#+BEGIN_SRC emacs-lisp
(eval
 (list 'cl-flet
       (append (loop for field in '("author" "title" "journal" "pages"
				      "number" "doi" "url" "eprint" "year")
		       collect (list (intern field)
				     '(content)
				     `(format "   \"%s\": \"%s\"" ,field content)))
	       '((article (bibtex-key &rest fields)
			  (concat
			   (format
			    "{\"article\":\n  {\"bibtex-key\": \"%s\",\n" bibtex-key)
			   (mapconcat (lambda (field) (eval field)) fields ",\n")
			   "}\n}"))))
       ;; body of cl-flet
       '(article "hallenbeck-2013-effec-o2"
		(author "Hallenbeck, Alexander P. and Kitchin, John R.")
		(title "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent")
		(journal "Industrial \& Engineering Chemistry Research")
		(pages "10788-10794")
		(number 31)
		(year 2013)
		(doi "10.1021/ie400582a")
		(url "http://pubs.acs.org/doi/abs/10.1021/ie400582a")
		(eprint "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"))))
#+END_SRC

#+RESULTS:
#+begin_example
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial & Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
#+end_example

Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc... Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.

I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we /never/ had to write a parser for the sexp notation. That /already exists as the lisp interpreter/. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!

* DONE Converting a DOI to other scientific identifiers in Pubmed
  CLOSED: [2015-06-09 Tue 07:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/09 07:29:08
  :updated:  2015/06/09 07:29:08
  :END:

Sometimes it is useful to convert a DOI to another type of identifier. For example, in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/][post]] we converted a DOI to a Scopus EID, and in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/][one]] we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:

http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/

We will use the DOI tool. According to the documentation, we need to form a URL like this:

DOI: http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195

We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max)))))
xml)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
((pmcids
  ((status . "ok"))
  "\n"
  (request
   ((idtype . "doi")
    (dois . "")
    (versions . "yes")
    (showaiid . "no"))
   "\n"
   (echo nil "tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195")
   "\n")
  "\n"
  (record
   ((requested-id . "10.1093/NAR/GKS1195")
    (pmcid . "PMC3531190")
    (pmid . "23193287")
    (doi . "10.1093/nar/gks1195"))
   (versions nil
	     (version
	      ((pmcid . "PMC3531190.1")
	       (current . "true")))))
  "\n"))
#+END_SRC

The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.

#+BEGIN_SRC emacs-lisp :results value code
(let* ((url-request-method "GET")
       (doi"10.1093/nar/gks1195")
       (my-tool "org-ref")
       (url (format "http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&email=%s&ids=%s"
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (with-current-buffer  (url-retrieve-synchronously url)
		   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list :doi doi :pmid pmid :pmcid pmcid :eid (scopus-doi-to-eid doi) :wos (wos-doi-to-accession-number doi)))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(:doi "10.1093/nar/gks1195" :pmid "23193287" :pmcid "PMC3531190" :eid "2-s2.0-80053651587" :wos "000312893300006")
#+END_SRC

Well, there you have it, four new scientific document ids from one DOI. /Of course/ we have defined org-mode links for each one of these:

doi:10.1093/nar/gks1195

pmid:23193287

pmcid:PMC3531190

eid:2-s2.0-80053651587

wos:000312893300006

I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.

* DONE Getting a WOS Accession number from a DOI
  CLOSED: [2015-06-08 Mon 11:23]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/08 11:23:33
  :updated:  2015/06/09 07:25:39
  :END:
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/][post]] we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j is redirected to
http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44. You can see the wos:000225079300029 in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "KeyUT" (url-parse-query-string (url-filename (url-generic-parse-url  "http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44")))))
#+END_SRC

#+RESULTS:
| WOS:000225079300029 |

It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).

#+BEGIN_SRC emacs-lisp
(defvar *wos-redirect* nil)
(defvar *wos-waiting* nil)

(defun wos-get-wos-redirect (url)
  "Return final redirect url for open-url"
  (setq *wos-waiting* t)
  (url-retrieve
   url
   (lambda (status)
     (setq *wos-redirect* (car (last status)))
     (setq *wos-waiting* nil)))
  (while *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(defun wos-doi-to-accession-number (doi)
  "Return a WOS Accession number for a DOI."
  (let* ((open-url (concat "http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/" doi))
	 (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
		 (assoc
		  "KeyUT"
		  (url-parse-query-string
		   (url-filename
		    (url-generic-parse-url redirect)))))
    4)))

(concat "wos:" (wos-doi-to-accession-number "10.1021/jp047349j"))
#+END_SRC

#+RESULTS:
: wos:000225079300029

I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:

http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029

http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029

That might turn out to be handy at some point.

* DONE Getting a Scopus EID from a DOI
  CLOSED: [2015-06-07 Sun 16:29]
  :PROPERTIES:
  :categories: orgmode,ref
  :date:     2015/06/07 16:29:05
  :updated:  2015/06/07 16:54:38
  :END:
[[http://www.scopus.com][Scopus]] is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: http://dev.elsevier.com/myapikey.html and set *scopus-api-key* in Emacs to use this code.

Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:

Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial & Engineering Chemistry Research, 52:10788-10794 (2013)

With the EID, we can construct a URL to the Scopus document page:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/record/display.url?eid=%s&origin=resultslist" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist

We can construct a URL to citing documents:
#+BEGIN_SRC emacs-lisp
(let ((eid "2-s2.0-84881394200"))
  (format "http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=%s&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage" eid))
#+END_SRC

#+RESULTS:
: http://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84881394200&src=s&imp=t&sot=cite&sdt=a&sl=0&origin=recordpage

And there are three types of related document urls we can create: by author, keyword or references.

By authors:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=aut&zone=relatedDocuments")
            eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments

By keywords:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat "http://www.scopus.com/search/submit/mlt.url"
                  "?eid=%s&src=s&all=true&origin=recordpage"
                  "&method=key&zone=relatedDocuments")
          eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments

And by references:
#+BEGIN_SRC emacs-lisp :results raw
(let ((eid "2-s2.0-84881394200"))
  (format (concat  "http://www.scopus.com/search/submit/mlt.url?"
                   "eid=%s&src=s&all=true&origin=recordpage"
                   "&method=ref&zone=relatedDocuments")
           eid))
#+END_SRC

#+RESULTS:
http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments

We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, /not/ the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is doi:10.1021/ie400582a.

The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.

I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/json")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (json-object-type 'plist)
       (json-data (with-current-buffer  (url-retrieve-synchronously url)
		    (json-read-from-string
		     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.

#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid-json (doi)
  "Return a parsed xml from the Scopus article retrieval api for DOI.
This does not always seem to work for the most recent DOIs."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/json")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (json-object-type 'plist)
	 (json-data (with-current-buffer  (url-retrieve-synchronously url)
		      (json-read-from-string
		       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data :search-results) :entry) 0) :eid)))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.

#+BEGIN_SRC emacs-lisp
(let* ((doi "10.1021/ie400582a")
       (url-request-method "GET")
       (url-mime-accept-string "application/xml")
       (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					 '("field" . "eid")))
       (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
       (xml (with-current-buffer  (url-retrieve-synchronously url)
	      (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

Now we wrap this in a function for reusability.
#+BEGIN_SRC emacs-lisp
(defun scopus-doi-to-eid (doi)
  "Get a Scopus eid from a DOI."
  (let* ((url-request-method "GET")
	 (url-mime-accept-string "application/xml")
	 (url-request-extra-headers  (list (cons "X-ELS-APIKey" *scopus-api-key*)
					   '("field" . "eid")))
	 (url (format  "http://api.elsevier.com/content/search/scopus?query=doi(%s)" doi))
	 (xml (with-current-buffer  (url-retrieve-synchronously url)
		(xml-parse-region url-http-end-of-headers (point-max))))
	 (results (car xml))
	 (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid "10.1021/ie400582a")
#+END_SRC

#+RESULTS:
: 2-s2.0-84881394200

This code is wrapped up in [[https://github.com/jkitchin/org-ref/blob/master/scopus.el][org-ref/scopus.el]]. It provides a new org-mode eid link, e.g. eid:2-s2.0-84881394200 which is functional and provides access to the citing and related article Scopus pages for that eid.

There are also new links and functions for a [[scopus-search:alloy Au segregation]] and [[scopus-advanced-search:auth(kitchin) and title(segregation)]].

Let's not forget the scopusid:7004212771 link to Scopus Author pages.

Now you can use org-mode for reproducible scientific literature searching in Scopus!

* document similarity
[[http://brandonrose.org/clustering][Document Clustering with Python]]

#+BEGIN_SRC python
import numpy as np
import pandas as pd
import nltk
import re
import os
import codecs
from sklearn import feature_extraction
import mpld3

stopwords = nltk.corpus.stopwords.words('english')
print stopwords[:10]

# load nltk's SnowballStemmer as variabled 'stemmer'
from nltk.stem.snowball import SnowballStemmer
stemmer = SnowballStemmer("english")

# here I define a tokenizer and stemmer which returns the set of stems in the text that it is passed

def tokenize_and_stem(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    stems = [stemmer.stem(t) for t in filtered_tokens]
    return stems


def tokenize_only(text):
    # first tokenize by sentence, then by word to ensure that punctuation is caught as it's own token
    tokens = [word.lower() for sent in nltk.sent_tokenize(text) for word in nltk.word_tokenize(sent)]
    filtered_tokens = []
    # filter out any tokens not containing letters (e.g., numeric tokens, raw punctuation)
    for token in tokens:
        if re.search('[a-zA-Z]', token):
            filtered_tokens.append(token)
    return filtered_tokens
#+END_SRC

#+RESULTS:
: [u'i', u'me', u'my', u'myself', u'we', u'our', u'ours', u'ourselves', u'you', u'your']

#+BEGIN_SRC python
from sklearn.externals import joblib
#+END_SRC

#+RESULTS:

* enumerate and zip in emacs lisp using the loop
here are hand-rolled functions.

#+BEGIN_SRC emacs-lisp :results output
(defun enumerate (lst)
  (loop for i from 0
	for el in lst
	collect (cons i el)))

(loop for (i . el) in (enumerate '(a b c d))
      do (princ (format "%s: %s\n" i el)))
#+END_SRC
#+RESULTS:
: 0: a
: 1: b
: 2: c
: 3: d


#+BEGIN_SRC emacs-lisp
(-annotate
#+END_SRC


#+BEGIN_SRC emacs-lisp :results output
(defun zip (&rest args)
  (unless (memq 'nil args)
    (cons (mapcar 'car args)
	  (apply 'zip (mapcar 'cdr args)))))

(loop for (i j k) in (zip '(a b c) '(1 2 3) '(5 6 7))
  do (princ (format "-%s--%s--%s\n" i j k)))
#+END_SRC
#+RESULTS:
: -a--1--5
: -b--2--6
: -c--3--7

dash provides a zip function
#+BEGIN_SRC emacs-lisp
(require 'dash)
(-zip '(a b c) '(1 2 3) '(5 6 7))
#+END_SRC
#+RESULTS:
| a | 1 | 5 |
| b | 2 | 6 |
| c | 3 | 7 |

* see link message under point

#+BEGIN_SRC emacs-lisp
(defun link-message ()
  (let ((object (org-element-context)))
    (when (eq (car object) 'link)
      (message "%s"
	       (org-element-property :raw-link object)))))

(add-hook 'post-command-hook 'link-message)
#+END_SRC

#+RESULTS:
| link-message | eldoc-schedule-timer |

(org-activate-bracket-links (point-max))

foobar

#+BEGIN_SRC emacs-lisp
; add a tooltip to every instance of foobar
(save-excursion  ;return cursor to current-point
  (goto-char 1)
    (while (search-forward "foobar" (point-max) t)
      (set-text-properties  (match-beginning 0) (match-end 0)
                            `(help-echo "You know... a bar for foos!"
					font-lock-face (:foreground "dark slate gray")
					point-entered (lambda (old-point new-point) (message-box "point-entered %s" new-point))
					point-left (lambda (old-point new-point) (message-box "point-left %s old-point")))
)))

#+END_SRC

* DONE Python data structures to lisp
  CLOSED: [2015-05-16 Sat 10:48]
  :PROPERTIES:
  :categories: python,emacs,lisp
  :date:     2015/05/16 10:47:59
  :updated:  2015/05/16 10:47:59
  :END:
I have an idea in mind that would use the output of python scripts in lisp functions. Xah Lee posted an [[http://ergoemacs.org/emacs/elisp_perl_wrapper.html][idea for writing emacs commands in scripting languages]]. In this post I want to explore an extension of the idea, where a Python script will return output that can be read in Lisp, e.g. we can convert a Python list to a lisp list, or a dictionary to an a-list or p-list. I can already see that simple data structures will be "simple", and arbitrary data structures will offer a lot of challenges, e.g. nested lists or dictionaries...

If I could add some custom functions to the basic builtin types in Python, then I could use another approach to format python objects as lisp data types. This isn't recommended by Pythonistas, but I guess they don't want to use lisp as much as I do ;) I found this approach to modifying builtins:

http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a

We use that almost verbatim here to get what I want. This is a super low level way to add functions to the builtins. I add some simple formatting to floats, ints and strings. I add a more complex recursive formatting function to lists, tuples and dictionaries. A dictionary can be represented as an alist or plist. Both examples are shown, but I leave the alist version commented out. Finally, we add a lispify function to numpy arrays.

#+BEGIN_SRC python :tangle pylisp.py
import ctypes as c

class PyObject_HEAD(c.Structure):
    _fields_ = [('HEAD', c.c_ubyte * (object.__basicsize__ -
                                      c.sizeof(c.c_void_p))),
                ('ob_type', c.c_void_p)]

_get_dict = c.pythonapi._PyObject_GetDictPtr
_get_dict.restype = c.POINTER(c.py_object)
_get_dict.argtypes = [c.py_object]

def get_dict(object):
    return _get_dict(object).contents.value

import collections
import numpy as np

def lispify(L):
    "Convert a Python object L to a lisp representation."
    if (isinstance(L, str)
        or isinstance(L, float)
        or isinstance(L, int)):
        return L.lisp()
    elif (isinstance(L, list)
          or isinstance(L, tuple)
          or isinstance(L, np.ndarray)):
        s = []
        for element in L:
            s += [element.lisp]
        return '(' + ' '.join(s) + ')'
    elif isinstance(L, dict):
        s = []
        for key in L:
            # alist format
            # s += ["({0} . {1})".format(key, L[key].lisp())]
            # plist
            s += [":{0} {1}".format(key, L[key].lisp)]
        return '(' + ' '.join(s) + ')'

get_dict(str)['lisp'] = property(lambda s:'"{}"'.format(str(s)))
get_dict(float)['lisp'] = property(lambda f:'{}'.format(str(f)))
get_dict(int)['lisp'] = property(lambda f:'{}'.format(str(f)))


get_dict(list)['lisp'] = property(lispify)
get_dict(tuple)['lisp'] = property(lispify)
get_dict(dict)['lisp'] = property(lispify)
get_dict(np.ndarray)['lisp'] = property(lispify)
#+END_SRC

#+RESULTS:

Let us test these out.
#+BEGIN_SRC python
from pylisp import *
a = 4.5
print int(a).lisp
print a.lisp
print "test".lisp

print [1, 2, 3].lisp
print (1, 2, 3).lisp

print [[1, 3], (5, 6)].lisp

print {"a": 5}.lisp
print [[1, 3], (5, 6), {"a": 5, "b": "test"}].lisp


A = np.array([1, 3, 4])
print A.lisp
print ({"tree": [5, 6]}, ["a", 4, "list"], 5, 2.0 / 3.0).lisp
#+END_SRC

#+RESULTS:
#+begin_example
4
4.5
"test"
(1 2 3)
(1 2 3)
((1 3) (5 6))
(:a 5)
((1 3) (5 6) (:a 5 :b "test"))
(1 3 4)
((:tree (5 6)) ("a" 4 "list") 5 0.666666666667)
#+end_example


Now, is that better than a single lisp function with a lot of conditionals to handle each type? I am not sure. This seems to work pretty well.


Here is how I imagine using this idea. We would have some emacs-lisp variables and use them to dynamically generate a python script. We run the python script, capturing the output, and read it back in as a lisp data structure. Here is a simple kind of example that generates a dictionary.

#+BEGIN_SRC emacs-lisp :results code
(let* ((elisp-var 6)
       (result)
      (script (format "
from pylisp import *
print {x: [2*y for y in range(x)] for x in range(1, %s)}.lisp()
" elisp-var)))

  ;; start a python process
  (run-python)
  (setq result (read (python-shell-send-string-no-output
   script)))
  (plist-get result :5))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(0 2 4 6 8)
#+END_SRC

That seems to work pretty well. One alternative idea to this is [[https://github.com/pinard/Pymacs][Pymacs]], which I have written about [[http://kitchingroup.cheme.cmu.edu/blog/2014/10/19/Using-Pymacs-to-integrate-Python-into-Emacs/][before]]. This project isn't currently under active development, and I ran into some difficulties with it before.

Here we can solve the problem I previously posed and get the result back as an elisp float, and then reuse the result

#+BEGIN_SRC emacs-lisp
(let* ((myvar 3)
       (script (format "from pylisp import *
from scipy.optimize import fsolve
def objective(x):
    return x - 5

ans, = fsolve(objective, %s)
print ans.lisp()" myvar)))
  (run-python)
  (setq result (read (python-shell-send-string-no-output
		       script)))
  (- 5 result))
#+END_SRC

#+RESULTS:
: 0.0

Bottom line: we can write python code in lisp functions that are dynamically updated, execute them, and get lisp data structures back for simple data types. I think that could be useful in some applications, where it is easier to do parsing/analysis in Python, but you want to do something else that is easier in Lisp.

* DONE Another approach to embedding org-source in html
  CLOSED: [2015-05-09 Sat 19:19]
  :PROPERTIES:
  :date:     2015/05/09 19:19:10
  :updated:  2015/05/10 09:34:55
  :categories: orgmode, data
  :END:
In this [[http://kitchingroup.cheme.cmu.edu/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts/][post]] I examined a way to embed the org-source in a comment in the html of the post, and developed a reasonably convenient way to extract the source in emacs. One downside of the approach was the need to escape at least the dashes, and then unescape them on extraction. I came across another idea, which is to put the org-source in base64 encoded form in a [[http://en.wikipedia.org/wiki/Data_URI_scheme][data uri]].

First let us see what the encoding means:

#+BEGIN_SRC emacs-lisp
(base64-encode-string "<!-- test-->")
#+END_SRC
#+RESULTS:
: PCEtLSB0ZXN0LS0+

And decoding:

#+BEGIN_SRC emacs-lisp
(base64-decode-string "PCEtLSB0ZXN0LS0+")
#+END_SRC

#+RESULTS:
: <!-- test-->

The encoding looks random, but it is reversible. More importantly, it probably will not have any html like characters in it that need escaped. The idea of a data uri is that the data it serves is embedded in the URL href attribute. This is basically how to make a data uri. We give the url here a class so we can find it later.
#+BEGIN_EXAMPLE
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_EXAMPLE

Here is the actual html for the browser. If you click on it, your browser automatically decodes it for you!
#+BEGIN_HTML
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>
#+END_HTML

So, during the blog publish step, we just need to add this little step to the html generation, and it will be included as a data uri. Here is the function that generates the data uri for us, and example of using it. The encoded source is not at all attractive to look at it, but you almost never need to look at it, it is invisible in the browser. Interestingly, if you click on the link, you will see the org source right in your browser!

#+BEGIN_SRC emacs-lisp  :results html
(defun source-data-uri (source)
  "Encode the string in SOURCE to a data uri."
  (format
   "<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\">source</a>"
   (base64-encode-string source)))

(source-data-uri (buffer-string))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBBbm90aGVyIGFwcHJvYWNoIHRvIGVtYmVkZGluZyBvcmctc291cmNlIGluIGh0bWwKSW4gdGhp
cyBbW2h0dHA6Ly9raXRjaGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4t
YWx0ZXJuYXRpdmUtYXBwcm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0
cy9dW3Bvc3RdXSBJIGV4YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEg
Y29tbWVudCBpbiB0aGUgaHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFi
bHkgY29udmVuaWVudCB3YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93
bnNpZGUgb2YgdGhlIGFwcHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhl
IGRhc2hlcywgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNy
b3NzIGFub3RoZXIgaWRlYSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2
NCBlbmNvZGVkIGZvcm0gaW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9V
Uklfc2NoZW1lXVtkYXRhIHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGlu
ZyBtZWFuczoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8
IS0tIHRlc3QtLT4iKQojK0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFu
ZCBkZWNvZGluZzoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5n
ICJQQ0V0TFNCMFpYTjBMUzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+
CgpBbmQgdGhpcyBpcyBiYXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0
aGUgdXJsIGhlcmUgYSBjbGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFN
UExFCjxhIGNsYXNzPSJvcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9FWEFNUExF
CgpIZXJlIGlzIHRoZSBhY3R1YWwgaHRtbCBmb3IgdGhlIGJyb3dzZXI6IAojK0JFR0lOX0hUTUwK
PGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFT
Q0lJO2Jhc2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0hUTUwKClNvLCBk
dXJpbmcgdGhlIGJsb2cgcHVibGlzaCBzdGVwLCB3ZSBqdXN0IG5lZWQgdG8gYWRkIHRoaXMgbGl0
dGxlIHN0ZXAgdG8gdGhlIGh0bWwgZ2VuZXJhdGlvbiwgYW5kIGl0IHdpbGwgYmUgaW5jbHVkZWQg
YXMgYSBkYXRhIHVyaS4gSGVyZSBpcyB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIGRh
dGEgdXJpIGZvciB1cywgYW5kIGV4YW1wbGUgb2YgdXNpbmcgaXQ6CgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIiBkb3dubG9hZD1cInNvdXJjZS5vcmdcIj5zb3VyY2U8L2E+IiAK
ICAgKGJhc2U2NC1lbmNvZGUtc3RyaW5nIHNvdXJjZSkpKQoKKHNvdXJjZS1kYXRhLXVyaSAoYnVm
ZmVyLXN0cmluZykpCiMrRU5EX1NSQwoKCgoKCgoK" download="source.org">source</a>
#+END_HTML

Now, we integrate it into the blogofile function:

#+BEGIN_SRC emacs-lisp
(defun bf-get-post-html ()
  "Return a string containing the YAML header, the post html, my
copyright line, and a link to the org-source code."
  (interactive)
  (let ((org-source (buffer-string))
	(url-to-org (bf-get-url-to-org-source))
	(yaml (bf-get-YAML-heading))
	(body (bf-get-HTML)))

    (with-temp-buffer
      (insert yaml)
      (insert body)
      (insert
       (format "<p>Copyright (C) %s by John Kitchin. See the <a href=\"/copying.html\">License</a> for information about copying.<p>"
	       (format-time-string "%Y")))
      (insert (format "<p><a href=\"%s\">org-mode source</a><p>"
		      url-to-org))
      (insert (format "<p>Org-mode version = %s</p>" (org-version)))
      ;; this is the only new code we need to add.
      (insert (source-data-uri org-source))
      ;; return value
      (buffer-string))))
#+END_SRC

Now we need a new adaptation of the grab-org-source function. We still need a regexp search to get the source, and we still need to decode it.

#+BEGIN_SRC emacs-lisp
(defun grab-org-source (url)
  "Extract org-source from URL to a buffer named *grab-org-source*."
  (interactive "sURL: ")
  (switch-to-buffer (get-buffer-create "*grab-org-source*"))
  (erase-buffer)
  (org-mode)
  (insert
   (with-current-buffer
       (url-retrieve-synchronously url)
     (let (start)
       (re-search-forward
	"<a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,\\([^\"]*\\)\\\">" nil t)
       (base64-decode-string  (match-string 1))))))
#+END_SRC

What else could we do with this? One idea would be to generate data uris for each code block that you could open in your browser. For example, here we generate a list of data uris for each code block in the buffer. We don't take care to label them or make it easy to see what they are, but if you click on one, you should see a plain text version of the block. If this is done a lot, it might even make sense to change the mime type to download the code in some native app.

#+BEGIN_SRC emacs-lisp :results html
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (src-block)
    (source-data-uri (org-element-property :value src-block))))
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
(<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBMUzArIikK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIHNvdXJjZS1kYXRhLXVyaSAoc291cmNlKQogICJFbmNvZGUgdGhlIHN0cmluZyBpbiBT
T1VSQ0UgdG8gYSBkYXRhIHVyaS4iCiAgKGZvcm1hdAogICAiPGEgY2xhc3M9XCJvcmctc291cmNl
XCIgaHJlZj1cImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jhc2U2NCwlc1wiPnNv
dXJjZTwvYT4iCiAgIChiYXNlNjQtZW5jb2RlLXN0cmluZyBzb3VyY2UpKSkKCihzb3VyY2UtZGF0
YS11cmkgKGJ1ZmZlci1zdHJpbmcpKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGJmLWdldC1wb3N0LWh0bWwgKCkKICAiUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcg
dGhlIFlBTUwgaGVhZGVyLCB0aGUgcG9zdCBodG1sLCBteQpjb3B5cmlnaHQgbGluZSwgYW5kIGEg
bGluayB0byB0aGUgb3JnLXNvdXJjZSBjb2RlLiIKICAoaW50ZXJhY3RpdmUpCiAgKGxldCAoKG9y
Zy1zb3VyY2UgKGJ1ZmZlci1zdHJpbmcpKQoJKHVybC10by1vcmcgKGJmLWdldC11cmwtdG8tb3Jn
LXNvdXJjZSkpCgkoeWFtbCAoYmYtZ2V0LVlBTUwtaGVhZGluZykpCgkoYm9keSAoYmYtZ2V0LUhU
TUwpKSkKCiAgICAod2l0aC10ZW1wLWJ1ZmZlcgogICAgICAoaW5zZXJ0IHlhbWwpCiAgICAgIChp
bnNlcnQgYm9keSkKICAgICAgKGluc2VydAogICAgICAgKGZvcm1hdCAiPHA+Q29weXJpZ2h0IChD
KSAlcyBieSBKb2huIEtpdGNoaW4uIFNlZSB0aGUgPGEgaHJlZj1cIi9jb3B5aW5nLmh0bWxcIj5M
aWNlbnNlPC9hPiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY29weWluZy48cD4iCgkgICAgICAgKGZv
cm1hdC10aW1lLXN0cmluZyAiJVkiKSkpCiAgICAgIChpbnNlcnQgKGZvcm1hdCAiPHA+PGEgaHJl
Zj1cIiVzXCI+b3JnLW1vZGUgc291cmNlPC9hPjxwPiIKCQkgICAgICB1cmwtdG8tb3JnKSkKICAg
ICAgKGluc2VydCAoZm9ybWF0ICI8cD5PcmctbW9kZSB2ZXJzaW9uID0gJXM8L3A+IiAob3JnLXZl
cnNpb24pKSkKICAgICAgOzsgdGhpcyBpcyB0aGUgb25seSBuZXcgY29kZSB3ZSBuZWVkIHRvIGFk
ZC4KICAgICAgKGluc2VydCAoc291cmNlLWRhdGEtdXJpIG9yZy1zb3VyY2UpKQogICAgICA7OyBy
ZXR1cm4gdmFsdWUKICAgICAgKGJ1ZmZlci1zdHJpbmcpKSkpCg==">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGdyYWItb3JnLXNvdXJjZSAodXJsKQogICJFeHRyYWN0IG9yZy1zb3VyY2UgZnJvbSBV
UkwgdG8gYSBidWZmZXIgbmFtZWQgKmdyYWItb3JnLXNvdXJjZSouIgogIChpbnRlcmFjdGl2ZSAi
c1VSTDogIikKICAoc3dpdGNoLXRvLWJ1ZmZlciAoZ2V0LWJ1ZmZlci1jcmVhdGUgIipncmFiLW9y
Zy1zb3VyY2UqIikpCiAgKGVyYXNlLWJ1ZmZlcikKICAob3JnLW1vZGUpCiAgKGluc2VydAogICAo
d2l0aC1jdXJyZW50LWJ1ZmZlcgogICAgICAgKHVybC1yZXRyaWV2ZS1zeW5jaHJvbm91c2x5IHVy
bCkKICAgICAobGV0IChzdGFydCkKICAgICAgIChyZS1zZWFyY2gtZm9yd2FyZAoJIjxhIGNsYXNz
PVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSTti
YXNlNjQsXFwoW15cIl0qXFwpXFxcIj4iIG5pbCB0KQogICAgICAgKGJhc2U2NC1kZWNvZGUtc3Ry
aW5nICAobWF0Y2gtc3RyaW5nIDEpKSkpKSkK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KG9yZy1lbGVtZW50LW1hcCAob3JnLWVsZW1lbnQtcGFyc2UtYnVmZmVyKSAnc3JjLWJsb2NrCiAg
KGxhbWJkYSAoc3JjLWJsb2NrKQogICAgKHNvdXJjZS1kYXRhLXVyaSAob3JnLWVsZW1lbnQtcHJv
cGVydHkgOnZhbHVlIHNyYy1ibG9jaykpKSkK">source</a>)
#+END_HTML


I am not sure if this is better or worse than the other approach. I have not tested it very thoroughly, but it seems like it should work pretty generally. I imagine you could also embed other kinds of files in the html, if for some reason you did not want to put the files on your server. Overall this seems to lack some elegance in searching for data, e.g. like [[http://en.wikipedia.org/wiki/Embedded_RDF][RDF]] or [[http://en.wikipedia.org/wiki/RDFa][RDFa]] is supposed to enable, but it might be a step in that direction, using org-mode and Emacs as the editor.

* A new annotation syntax

[@annotate :type comment :author John Kitchin :content This is great]

is matched by "\\[@annotate[^]]*\\]"

#+BEGIN_SRC emacs-lisp
(require 'ov)
(ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment" 'ov1 t)

(defun my-ov-evaporate-ov1 (_ov _after _beg _end &optional _length)
  (let ((inhibit-modification-hooks t))
    (if _after (ov-clear 'ov1))))

;; remove overlays if you edit one. it would be nice to do this on one, not all.
(ov-set "ov-" 'face 'warning
              'ov1 t
              'modification-hooks '(my-ov-evaporate-ov1))
;(ov-clear 'ov1)
#+END_SRC

#+RESULTS:
| #<overlay from 255369 to 255372 in blog.org> | #<overlay from 255352 to 255355 in blog.org> | #<overlay from 255342 to 255345 in blog.org> | #<overlay from 255307 to 255310 in blog.org> | #<overlay from 255165 to 255168 in blog.org> | #<overlay from 255044 to 255047 in blog.org> | #<overlay from 254702 to 254705 in blog.org> | #<overlay from 254681 to 254684 in blog.org> | #<overlay from 254601 to 254604 in blog.org> | #<overlay from 254593 to 254596 in blog.org> | #<overlay from 254492 to 254495 in blog.org> | #<overlay from 254378 to 254381 in blog.org> | #<overlay from 254249 to 254252 in blog.org> |



I don't know how to get a specific overlay, eg. the content, or to make a different overlay for different types of annotation. Also, this does not automatically update new content. [@annotate :type insert :content these words].

[@annotate :type delete :Date today]


#+BEGIN_SRC emacs-lisp
(setq ov1 (ov-set "\\[@annotate\\([^]]\\)*\\]" 'face '(:foreground "red") 'help-echo (match-string 1) 'display "comment"))
(mapcar 'ov-end ov1)
#+END_SRC
#+RESULTS:
| 996 | 933 | 894 | 201 | 129 | 97 |

#+BEGIN_SRC emacs-lisp
(defun mod-ov () (interactive)
 (let ((overlay (ov-at)))
 (message "%s" overlay)
 (ov-clear (ov-beg overlay) (ov-end overlay))))
#+END_SRC

** With fontlock


[@annotate :type delete :Date today]

#+BEGIN_SRC emacs-lisp
(font-lock-add-keywords
 'org-mode
 '(("\\[@annotate\\([^]]*\\)\\]"
    (1 'font-lock-variable-name-face))))

(font-lock-add-keywords
 'org-mode
 '("\\[@annotate\\([^]]*\\)\\]" . 'font-lock-variable-name-face))

(font-lock-add-keywords nil
  '(("foo" . (:foreground "red"))))
#+END_SRC

[@annotate :type delete]

foo  foo  foo foo  foo

foo

(defface extra-whitespace-face
  '((t (:background "pale green")))
  "Used in text-mode and friends for exactly one space after a period.")

(mapcar (lambda (mode)
	  (font-lock-add-keywords
	   mode
	   '(("FIXME" 0 'show-paren-mismatch-face)
	     ("\\.\\( \\)\\b" 1 'extra-whitespace-face))))
	'(text-mode latex-mode html-mode emacs-lisp-mode org-mode
	  texinfo-mode)) FIXME fdksaf
* Colorize comments


#+BEGIN_SRC emacs-lisp
(defvar org-comment-color "red")

(defvar org-comment-re
  "\\(\\[\\[\\)?comment:\\([^]]\\)+\\]?\\[?\\([^]]\\)*\\(\\]\\]\\)")

(defface org-comment-face2
  `((t (:inherit org-link :slant italic :foreground ,org-comment-color)))
  "Face for ref links in org-ref.")


(defun org-comment-colorize-links ()
  "Colorize org-ref links."
  (hi-lock-mode 1)
  (highlight-regexp org-comment-re 'org-comment-face2))
#+END_SRC

[[comment:test]]

[[comment:second test][Test]]


[[comment:check baby]]
* DONE Commenting in org-files
  CLOSED: [2015-04-24 Fri 12:41]
  :PROPERTIES:
  :categories: org
  :date:     2015/04/24 12:41:39
  :updated:  2015/11/19 09:22:50
  :END:
There was an interesting discussion on the org-mode mail list about putting comments in org files. Eric Fraga suggested using inline tasks, and customizing the export of them so they make a footnote, or use the todonotes package (suggested by Marcin Borkowski). Here is Eric's export. A big advantage of this is integration with the Agenda, so you can see what there is todo in your document.

#+begin_src emacs-lisp
  (setq org-inlinetask-export-templates
        '((latex "%s\\footnote{%s\\\\ %s}\\marginpar{\\fbox{\\thefootnote}}"
                 '((unless
                       (eq todo "")
                     (format "\\fbox{\\textsc{%s%s}}" todo priority))
                   heading content))))
#+end_src

Eric Abrahamsen suggested an idea to use a link syntax. I like the idea a lot, so here we develop some ideas. A link has two parts, the path, and description. A simple comment would just be a simple link, probably in double square brackets so you can have spaces in your comment. [[comment:Why do you think there are only two parts]] It might be feasible to use [[comment:Why do you quote mark?][the description to "mark text" that the comment refers to]]. The remaining question is what functionality should our link have when you click on it, and how to export it. For functionality, a click will show the comment in the minibuffer and offer to delete it. For export, for now we will make it export with todonotes in LaTeX, and as a red COMMENT with a tooltip in html. To use this, you need to have the LaTeX package todonotes included in your org file.
#+LATEX_HEADER: \usepackage{todonotes}

Here is our comment link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "comment"
 (lambda (linkstring)
   (let ((elm (org-element-context))
         (use-dialog-box nil))
     (when (y-or-n-p "Delete comment? ")
       (setf (buffer-substring
	      (org-element-property :begin elm)
	      (org-element-property :end elm))
	     (cond
	      ((org-element-property :contents-begin elm)
	       (buffer-substring
		(org-element-property :contents-begin elm)
		(org-element-property :contents-end elm)))
	      (t
	       ""))))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'html)
     (format "<font color=\"red\"><abbr title=\"%s\" color=\"red\">COMMENT</abbr></font> %s" keyword (or desc "")))
    ((eq format 'latex)
     (format "\\todo{%s}{%s}" keyword (or desc ""))))))
#+END_SRC


It would be convenient to have a quick function for adding a comment to some highlighted text.

#+BEGIN_SRC emacs-lisp
(defun add-comment (begin end)
  (interactive "r")
  (if (region-active-p)
      (let ((selected-text (buffer-substring begin end)))
	(setf (buffer-substring begin end)
	      (format "[[comment:%s][%s]]"
		      (read-input "Comment: ") selected-text)))
  (insert (format  "[[comment:%s]]" (read-input "Comment: ")))))
#+END_SRC

Test 1: [[comment:test comment]]

[[comment:You seem to have forgotten Test 2][Test 2]]

That is it. I could see a few other enhancements that might be very useful, e.g. a command to list all the comments, remove all the comments, etc... I am pretty satisfied with this for now though.

** An updated approach to comments.
Rainer asked about making some comments inline. It would be nice if a single link syntax could accommodate both styles of comments. I previously developed an approach to extend links with attributes (http://kitchingroup.cheme.cmu.edu/blog/2015/02/05/Extending-the-org-mode-link-syntax-with-attributes/), which I will reuse here for that purpose. The idea is to add an ":inline" attribute to change the export behavior. We only modify the LaTeX export here.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "comment"
 ;;  follow function
(lambda (linkstring)
   (let ((elm (org-element-context))
         (use-dialog-box nil))
     (when (y-or-n-p "Delete comment? ")
       (setf (buffer-substring
	      (org-element-property :begin elm)
	      (org-element-property :end elm))
	     (cond
	      ((org-element-property :contents-begin elm)
	       (buffer-substring
		(org-element-property :contents-begin elm)
		(org-element-property :contents-end elm)))
	      (t
	       ""))))))
 ;; format function
 (lambda (path description format)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cdr data)))
     (cond
      ((eq format 'html)
       (format "<font color=\"red\"><abbr title=\"%s\" color=\"red\">COMMENT</abbr></font> %s" path (or description "")))
      ((eq format 'latex)
       (format "\\todo%s{%s}%s"
	       (if (-contains? data :inline) "[inline]" "")
	       (mapconcat (lambda (s)
			    (format "%s" s))
			  (-remove-item :inline data) " ")
	       (if description (format "{%s}" description) "")))))))
#+END_SRC

Here are some examples of the syntax:
#+BEGIN_EXAMPLE
[[comment: :inline the rest of your text]]

[[comment:Some text you want to highlight]]

[[comment:Some text you want to highlight :inline]]
#+END_EXAMPLE

It doesn't matter where the :inline attribute is added. This seems to work pretty well.

We can modify our convenience function to allow us to use a prefix arg to make the comment inline. Here is one way to do it.

#+BEGIN_SRC emacs-lisp
(defun add-comment (begin end &optional arg)
  "Comment the region. With a prefix ARG, make the comment inline."
  (interactive (list (region-beginning)
		     (region-end)
		     current-prefix-arg))
  (let ((inline (if arg ":inline " "")))
	(if (region-active-p)
	    (let ((selected-text (buffer-substring begin end)))
	      (setf (buffer-substring begin end)
		    (format
		     "[[comment:%s%s][%s]]"
		     inline
		     (read-input "Comment: ") selected-text)))
	  (insert (format
		   "[[comment:%s%s]]"
		   inline
		   (read-input "Comment: "))))))
#+END_SRC

#+RESULTS:
: add-comment

Test [[comment:a new regular comment][text]] to  [[comment::inline an inline comment][comment]] on.

* DONE Extending the org-mode link syntax with attributes
  CLOSED: [2015-04-20 Mon 12:55]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2015/02/05 10:06:25
  :updated:  2015/04/20 12:56:35
  :END:
I make super heavy use of links in org-mode. I use them extensively in org-ref to create functional citations. One detail that has never been very satisfactory is the need for pre/post text in citations. I don't need that capability often, but it seems important to some. I have implemented a kind of clunky solution where I use the description part of a link with the pre/post text separated by a ::. Although that works, I dislike the way it looks, the need to parse it, and that the description covers the link.

#+BEGIN_EXAMPLE
[[cite:key][pre text::post text]]
#+END_EXAMPLE

Some [[https://lists.gnu.org/archive/html/emacs-orgmode/2010-08/msg00404.html][time ago]] there was a suggestion of how to extend the link syntax, which was to my knowledge never implemented. Here is the proposed syntax:
#+BEGIN_EXAMPLE
$[link http://google.com
         :last-followed [2009-02-25 Wed 02:00]
         :label "click here for evil search engine"
         :export-label "click here for nice search engine"]
#+END_EXAMPLE

This is interesting because this syntax suggests the link has attributes which can be updated.

We will show here how to implement part of this idea with the existing link syntax. We will make a link that has attributes like that. The basic idea is to simply incorporate the attributes into the path, and use lisp to read them. We will wrap the link path in parentheses and read that as a lisp data structure. So, a link like [[link:key :pre "some pre text" :post "some post text"]] will be parsed as:

#+BEGIN_SRC emacs-lisp
(read "(key :pre \"some pre text\" :post \"some post text\")")
#+END_SRC

#+RESULTS:
| key | :pre | some pre text | :post | some post text |

The car of that list is the key, and the cdr contains the attributes. The quotes are necessary here to make sure all the text is correctly parsed as a single element for each attribute. So, here is an example link

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "slink"
 ;;  follow function
 (lambda (path)
   (let* ((data (read (format "(%s)" path)))
	  (head (car data))
	  (plist (cdr data))
	  (link (org-element-context))
	  (begin (org-element-property :begin link))
	  (end (org-element-property :end link)))
     (setq plist (plist-put plist :last-clicked (current-time-string)))
     (save-excursion
     (setf (buffer-substring begin end) "")
     (goto-char begin)
     (insert (format "[[slink:%s %s]]" head
         (substring (format "%S" plist) 1 -1))))))
 ;; format function
 (lambda (path description backend)
   (let* ((data (read (concat "(" path ")")))
	  (head (car data))
	  (plist (cdr data)))
     (format "\\%s[%s][%s]{%s}"
             (plist-get plist :type)
	     (plist-get plist :pre)
	     (plist-get plist :post)
             head))))
#+END_SRC

Now, each time I click on this link, the time stamp gets updated.

[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Mon Apr 20 12:54:40 2015"]]

#+BEGIN_EXAMPLE
[[slink:kitchin-2010 :pre "See for example" :post "page 47" :type "cite" :last-clicked "Thu Feb  5 09:31:15 2015"]]
#+END_EXAMPLE


And, the generic export of this link is:

#+BEGIN_EXAMPLE
\cite[See for example][page 47]{kitchin-2010}
#+END_EXAMPLE

Is this a good idea? I am not using this for anything right now. Sometimes my version of org-mode has trouble recognizing that is a link. It is strange, as I am typing, sometimes it flashes in and out of being recognized as a link. Anyway, it is an interesting idea!
* sweet new babel things

Thanks to William Henney for sharing this on the orgmode mailing list. specify return value

#+BEGIN_SRC python :results value :return mytable
NROWS, NCOLS = 6, 4
mytable = []
mytable.append(['A', 'B', 'C', 'D'])  # Table header
mytable.append(None)                  # hline
for irow in range(NROWS):
    mytable.append([icol**irow for icol in range(NCOLS)])
mytable.append(None)                  # hline
 #+END_SRC

#+RESULTS:
| A | B |  C |   D |
|---+---+----+-----|
| 1 | 1 |  1 |   1 |
| 0 | 1 |  2 |   3 |
| 0 | 1 |  4 |   9 |
| 0 | 1 |  8 |  27 |
| 0 | 1 | 16 |  81 |
| 0 | 1 | 32 | 243 |
|---+---+----+-----|



* DONE Using the Scopus api with xml output
  CLOSED: [2015-04-06 Mon 09:36]
  :PROPERTIES:
  :categories: python,xml,scopus
  :date:     2015/04/06 09:35:57
  :updated:  2015/04/06 09:35:57
  :END:
According to http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl, the native form of the Scopus abstract document is xml, and the full abstract cannot always be represented  as json. So... I am going to just bite the bullet and learn to deal with the xml. This is a companion post to http://kitchingroup.cheme.cmu.edu/blog/2015/04/04/Making-highly-linked-bibliographies-from-the-Scopus-API/. Most of the code in this post gets tangled out to scopus_xml.py. I know it is not totally robust yet, but I have been using it for a lot of analysis, and it works pretty well so far.

This is another long post, with code that probably runs off screen. You can see the end result of what we do in this post here:  http://kitchingroup.cheme.cmu.edu/publications.html.


We start with a general function to return an xml elementtree. We build in some caching to avoid downloading things we already have; this is slow, and there are limits on how many times you can download.

#+BEGIN_SRC python :tangle scopus_xml.py
import requests
import os
import xml.etree.ElementTree as ET

from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-xml/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return ET.fromstring(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID + '?view=META_ABS')
    resp = requests.get(url,
                    headers={'Accept':'application/xml',
                             'X-ELS-APIKey': MY_API_KEY})
    with open(fname, 'w') as f:
        f.write(resp.text.encode('utf-8'))

    results = ET.fromstring(resp.text.encode('utf-8'))

    return results
#+END_SRC

Next, we do some introspection to see what we have.

#+BEGIN_SRC python :results html
from scopus_xml import *
#results = get_abstract_info('2-s2.0-84896759135')
:   File "<string>", line 7
    (template (format import
                           ^
SyntaxError: EOF while scanning triple-quoted string literal
/bin/bash: -c: line 7: syntax error near unexpected token `'''%s''''
/bin/bash: -c: line 7: `test_%s.test_%s('''%s''')" name name name code)))'

#results = get_abstract_info('2-s2.0-84924911828')
results = get_abstract_info('2-s2.0-84901638552')
for el in results:
    print el.tag
    for el1 in el:
        print '  -->',el1.tag
    print
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata
  --> {http://prismstandard.org/namespaces/basic/2.0/}url
  --> {http://purl.org/dc/elements/1.1/}identifier
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}eid
  --> {http://prismstandard.org/namespaces/basic/2.0/}doi
  --> {http://purl.org/dc/elements/1.1/}title
  --> {http://prismstandard.org/namespaces/basic/2.0/}aggregationType
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}srctype
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count
  --> {http://prismstandard.org/namespaces/basic/2.0/}publicationName
  --> {http://purl.org/dc/elements/1.1/}publisher
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}source-id
  --> {http://prismstandard.org/namespaces/basic/2.0/}issn
  --> {http://prismstandard.org/namespaces/basic/2.0/}volume
  --> {http://prismstandard.org/namespaces/basic/2.0/}startingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}endingPage
  --> {http://prismstandard.org/namespaces/basic/2.0/}pageRange
  --> {http://prismstandard.org/namespaces/basic/2.0/}coverDate
  --> {http://purl.org/dc/elements/1.1/}creator
  --> {http://purl.org/dc/elements/1.1/}description
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}link

{http://www.elsevier.com/xml/svapi/abstract/dtd}affiliation
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}affilname

{http://www.elsevier.com/xml/svapi/abstract/dtd}authors
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author
  --> {http://www.elsevier.com/xml/svapi/abstract/dtd}author

#+END_HTML

Now, some examples for myself to see how to get things.

#+BEGIN_SRC python :results html
from scopus_xml import *

results = get_abstract_info('2-s2.0-84901638552')

coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}srctype').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text

#authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
#for author in results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors'):
#    print author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text

for creator in coredata.find('{http://purl.org/dc/elements/1.1/}creator'):
    print creator.attrib

print coredata.find('{http://purl.org/dc/elements/1.1/}title').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text
print coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}citedby-count').text
print coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi').text

for link in coredata.findall('{http://www.elsevier.com/xml/svapi/abstract/dtd}link'):
    if link.attrib['rel'] == 'scopus':
        print link.attrib['href']
    else:
        print link.attrib['href']

# alternative xpath to get the link
print coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href']
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
j
22746
{'auid': '55569461200', 'seq': '1'}
Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
Catalysis Communications
52
60-64
2014-07-05
2
10.1016/j.catcom.2013.10.028
http://api.elsevier.com/content/abstract/scopus_id/84901638552
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
http://api.elsevier.com/content/search/scopus?query=refeid%282-s2.0-84901638552%29
http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward
#+END_HTML

That is basically it. In the next sections, we basically recreate the previous functions from scopus.py using the xml data.

** Authors
#+BEGIN_SRC python :tangle scopus_xml.py
def get_author_link(EID):
    results = get_abstract_info(EID)
    authors = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}authors')
    if authors is None:
        return 'No authors found'
    s = []

    for author in authors:
        name = author.find('{http://www.elsevier.com/xml/ani/common}indexed-name').text
        auid = author.attrib['auid']
        s += ['<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'.format(auid, name)]

    return ', '.join(s)
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from scopus_xml import *
print get_author_link('2-s2.0-84896759135')
print get_author_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>
: <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>

** Journal

#+BEGIN_SRC python :tangle scopus_xml.py
def get_journal_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    journal = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}publicationName').text
    sid = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}source-id').text
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)
#+END_SRC

#+BEGIN_SRC python
from scopus_xml import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
: <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>

** DOI link

#+BEGIN_SRC python :tangle scopus_xml.py
def get_doi_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=doi)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Abstract link

#+BEGIN_SRC python  :tangle scopus_xml.py
def get_abstract_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')

    data = get_abstract_info(EID)

    title = coredata.find('{http://purl.org/dc/elements/1.1/}title').text.encode('utf-8')
    link = coredata.find("./{http://www.elsevier.com/xml/svapi/abstract/dtd}link/[@rel='scopus']").attrib['href'].encode('utf-8')
    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Citation image

#+BEGIN_SRC python :tangle scopus_xml.py
def get_cite_img_link(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    doi = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}doi')
    if doi is not None: doi = doi.text
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'

    return s.format(doi=doi, apikey=MY_API_KEY, cite_link=None)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** Getting it all together

#+BEGIN_SRC python :tangle scopus_xml.py
def get_html_citation(EID):
    results = get_abstract_info(EID)
    coredata = results.find('./{http://www.elsevier.com/xml/svapi/abstract/dtd}coredata')
    s = '{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, {pages}, ({year}), {doi}, {cites}.'

    issue = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier') is not None:
        issue = '({})'.format(    coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}issueIdentifier').text)

    volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume')
    if volume is not None:
        volume = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}volume').text
    else:
        volume = 'None'

    pages = ''
    if coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange') is not None:
        pages = 'p. ' + coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}pageRange').text
    elif coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number') is not None:
        pages = coredata.find('{http://www.elsevier.com/xml/svapi/abstract/dtd}article-number').text
    else:
        pages = 'no pages found'


    year = coredata.find('{http://prismstandard.org/namespaces/basic/2.0/}coverDate').text

    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=volume,
                    issue=issue,
                    pages=pages,
                    year=year,
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus_xml import *
print '<ol>'
print '<li>',get_html_citation('2-s2.0-84896759135'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84924911828'),'</li>'
print
print '<li>',get_html_citation('2-s2.0-84901638552'),'</li>'
print '</ol>'
#+END_SRC
#+RESULTS:
#+BEGIN_HTML
<ol>
<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=8724572500">Thompson R.L.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=22981503200">Shi W.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6506329719">Albenze E.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=23004637900">Kusuma V.A.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55676869000">Hopkinson D.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7003584159">Damodaran K.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55005205100">Lee A.S.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=6701399651">Luebke D.R.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=24081524800">Nulwala H.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84896759135&origin=inward">Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=21100199840">RSC Advances</a>, <b>4(25)</b>, p. 12748-12755, (2014-03-17), <a href="http://dx.doi.org/10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1039/c3ra47097k&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84924911828&origin=inward">Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=28134">Journal of Chemical Physics</a>, <b>142(10)</b>, 104703, (2015-03-14), <a href="http://dx.doi.org/10.1063/1.4914093">doi:10.1063/1.4914093</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1063/1.4914093&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>

<li> <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>, <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>. </li>
</ol>
#+END_HTML


** Finally getting my documents

Here we get the EIDs from a search query. We use these in the next section to get a new bibliography.

#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['eid']), str(r['prism:aggregationType'])] for r in results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']
#+END_SRC


#+tblname: my-eids
| 2-s2.0-84924911828 | Journal |
| 2-s2.0-84923164062 | Journal |
| 2-s2.0-84924778427 | Journal |
| 2-s2.0-84924130725 | Journal |
| 2-s2.0-84901638552 | Journal |
| 2-s2.0-84898934670 | Journal |
| 2-s2.0-84896759135 | Journal |
| 2-s2.0-84896380535 | Journal |
| 2-s2.0-84896585411 | Journal |
| 2-s2.0-84916613197 | Journal |
| 2-s2.0-84908637059 | Journal |
| 2-s2.0-84880986072 | Journal |
| 2-s2.0-84881394200 | Journal |
| 2-s2.0-84873706643 | Journal |
| 2-s2.0-84876703352 | Journal |
| 2-s2.0-84867809683 | Journal |
| 2-s2.0-84864914806 | Journal |
| 2-s2.0-84865730756 | Journal |
| 2-s2.0-84864592302 | Journal |
| 2-s2.0-84863684845 | Journal |
| 2-s2.0-84866142469 | Journal |
| 2-s2.0-84861127526 | Journal |
| 2-s2.0-80052944171 | Journal |
| 2-s2.0-80051809046 | Journal |
| 2-s2.0-79953651013 | Journal |
| 2-s2.0-79952860396 | Journal |
| 2-s2.0-77956568341 | Journal |
| 2-s2.0-77954747189 | Journal |
| 2-s2.0-77956693843 | Journal |
| 2-s2.0-77949916234 | Journal |
| 2-s2.0-77955464573 | Journal |
| 2-s2.0-72049114200 | Journal |
| 2-s2.0-73149124752 | Journal |
| 2-s2.0-73149109096 | Journal |
| 2-s2.0-67449106405 | Journal |
| 2-s2.0-63649114440 | Journal |
| 2-s2.0-60849113132 | Journal |
| 2-s2.0-58649114498 | Journal |
| 2-s2.0-40949100780 | Journal |
| 2-s2.0-33750804660 | Journal |
| 2-s2.0-20544467859 | Journal |
| 2-s2.0-15744396507 | Journal |
| 2-s2.0-9744261716  | Journal |
| 2-s2.0-13444307808 | Journal |
| 2-s2.0-3042820285  | Journal |
| 2-s2.0-2942640180  | Journal |
| 2-s2.0-0142023762  | Journal |
| 2-s2.0-0141924604  | Journal |
| 2-s2.0-0037368024  | Journal |
| 2-s2.0-0037197884  | Journal |

** And my html bibliography
This generates my blog bibliography page..
#+BEGIN_SRC python
from scopus.scopus_xml import *

import requests
import json
from scopus.my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=eid,aggregationType&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

data = [[str(r['eid']), str(r['prism:aggregationType'])] for r in
        results['search-results']["entry"] if str(r['prism:aggregationType']) == 'Journal']


with open('../publications.html.mako', 'w') as f:
    f.write('''<%inherit file="_templates/site.mako" />
<article class="page_box">
<%self:filter chain="markdown">

<h1>Online collections of our work</h1>
Pick your favorite:
<ul>
<li><a href="http://orcid.org/0000-0003-2625-9232">orcid:0000-0003-2625-9232</a></li>

<li><a href="http://www.researcherid.com/rid/A-2363-2010">researcherid:A-2363-2010</a></li>

<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a></li>

<li><a href="https://scholar.google.com/citations?user=jD_4h7sAAAAJ">Google Scholar</a></li>

<li><a href="https://www.researchgate.net/profile/John_Kitchin">Research Gate</a></li>

<li><a href="https://www.growkudos.com/profiles/40205">Kudos</a></li>
</ul>

<h1>Publications</h1>
The authors are linked to their Scopus page, the title linked to the Scopus abstract, the journal linked to the Scopus journal page, and the DOI is linked to http://dx.doi.org which normally redirects you to the journal page.

<ol reversed="reversed">
''')

    for eid,type in data:
        f.write('<li>{}</li>'.format(get_html_citation(eid)))
    f.write('''</ol>

</%self:filter>
</article>
''')
#+END_SRC

#+RESULTS:

** Summary
The XML format is not that intuitive to me. It takes some practice writing robust code, e.g. sometimes the find command does not find anything, and then there is not text attribute to get, so you should check for success on finding things. Also, some text is unicode, and you have to take care to encode it, which my library does not do uniformly. Finally, not all journals have things like volume or issue. My formatting code is not super flexible, so these bibliography entries show None in them occasionally. Still, it is not too bad, and this enables a lot of analysis of your publications, as well as displaying them in different ways. See the result of this page here: http://kitchingroup.cheme.cmu.edu/publications.html

* DONE Making highly linked bibliographies from the Scopus API
  CLOSED: [2015-04-04 Sat 11:32]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/04 11:32:05
  :updated:  2015/04/04 11:32:05
  :END:

A given article entry in a bibliography might have the following kinds of links in it. I think we can generate these from a Scopus query.

- Author page: http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771
- [[https://www.scopus.com/record/display.url?eid=2-s2.0-84901638552&origin=resultslist&sort=plf-f&src=s&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a50&sot=autdocs&sdt=autdocs&sl=17&s=AU-ID%287004212771%29&relpos=4&relpos=4&citeCnt=2&searchTerm=][Document page]]
- Journal page: http://www.scopus.com/source/sourceInfo.url?sourceId=22746&origin=resultslist
- [[https://www.scopus.com/results/citedbyresults.url?sort=plf-f&cite=2-s2.0-84901638552&src=s&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a230&sot=cite&sdt=a&sl=0&origin=resultslist&editSaveSearch=&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a23][Cited by]]
- http://dx.doi.org/10.1016/j.catcom.2013.10.028
- [[https://www.scopus.com/results/citedbyresults.url?sort=r-f&src=s&mltEid=2-s2.0-84901638552&mltType=ref&mltAll=t&imp=t&sid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a290&sot=mlt&sdt=mlt&sl=730&s=REFEID%28%28%222-s2.0-79953651013%22%29+OR+%28%222-s2.0-84855602300%22%29+OR+%28%222-s2.0-33750453016%22%29+OR+%28%222-s2.0-33645349847%22%29+OR+%28%222-s2.0-0034814842%22%29+OR+%28%222-s2.0-77955464573%22%29+OR+%28%222-s2.0-13444307808%22%29+OR+%28%222-s2.0-53349153662%22%29+OR+%28%222-s2.0-80051809046%22%29+OR+%28%222-s2.0-84876703352%22%29+OR+%28%222-s2.0-80053316882%22%29+OR+%28%222-s2.0-83255187152%22%29+OR+%28%222-s2.0-80052944171%22%29+OR+%28%222-s2.0-84865730756%22%29+OR+%28%222-s2.0-0000778362%22%29+OR+%28%222-s2.0-60349090198%22%29+OR+%28%222-s2.0-2442537377%22%29+OR+%28%222-s2.0-0030190741%22%29+OR+%28%222-s2.0-25744460922%22%29+OR+%28%222-s2.0-0011236321%22%29+OR+%28%222-s2.0-4243943295%22%29+OR+%28%222-s2.0-4944232881%22%29+OR+%28%222-s2.0-1842816907%22%29+OR+%28%222-s2.0-33646343022%22%29+OR+%28%222-s2.0-4143079428%22%29+OR+%28%222-s2.0-77954807118%22%29+OR+%28%222-s2.0-11544320930%22%29%29+AND+NOT+EID+%282-s2.0-84901638552%29&origin=resultslist&txGid=66816438A83B9A7B72A35BF872F8E10E.WeLimyRvBMk2ky9SFKc8Q%3a29][Related articles]]

We are going to look at the document above, with eid=2-s2.0-84901638552. This is another long post, so here is a teaser of what we are doing. For this eid, we want to generate an html entry where each part of the entry is clickable. Here is what we will be able to do by the end of this post:

#+BEGIN_SRC python :results html
from scopus import *

print '<ol>', get_html('2-s2.0-84901638552'), '</ol>'
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<ol> <li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li> </ol>
#+END_HTML

In this post, we work out code that works for this document. This code in the form shown here might not work on all entries, e.g. for ones that are in press and are missing data, or for APS journals that have no page range. Later, I will fix those so this is more robust. To minimize repeating the code below, I create a python module here called [[./scopus.py]].  Tangle it out with elisp:org-babel-tangle. As in the last [[http://kitchingroup.cheme.cmu.edu/blog/2015/04/03/Getting-data-from-the-Scopus-API/][post]], I am not sharing my API key here, since it is not clear if that key is private or not.

I like json, so we use that data format here. XML would be more robust, as the Scopus site admits not all of the data can be turned into the json format, but for now we stick to json for its simplicity.

#+BEGIN_SRC python :tangle scopus.py
import requests
import json, os
from my_scopus import MY_API_KEY

def get_abstract_info(EID, refresh=False):
    'Get and save the json data for EID.'
    base = 'scopus-data/get_abstract_info'
    if not os.path.exists(base):
        os.makedirs(base)

    fname = '{0}/{1}'.format(base, EID)
    if os.path.exists(fname) and not refresh:
        with open(fname) as f:
            return json.loads(f.read())

    # Otherwise retrieve and save results
    url = ("http://api.elsevier.com/content/abstract/eid/" + EID)
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))
    with open(fname, 'w') as f:
        f.write(json.dumps(results))

    return results
#+END_SRC

** Author pages
Here, we generate the html that will make each author a clickable link that goes to their Scopus ID author page.

#+BEGIN_SRC python :tangle scopus.py

def get_author_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    html = '<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId={0}">{1}</a>'
    authors = [html.format(auid, name) for auid, name in
               zip([x['@auid'] for x in result['authors']['author']],
                   [x['ce:indexed-name'] for x in result['authors']['author']])]

    return ','.join(authors)

#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_author_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>
#+END_HTML

** Journal link
The most important pieces of information we need is the journal name and the source-id from the coredata.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['source-id']
print result['coredata']['prism:publicationName']
#+END_SRC

#+RESULTS:
: 22746
: Catalysis Communications

#+BEGIN_SRC python :tangle scopus.py
def get_journal_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    sid = result['coredata']['source-id']
    journal = result['coredata']['prism:publicationName']
    s = '<a href="http://www.scopus.com/source/sourceInfo.url?sourceId={sid}">{journal}</a>'

    return s.format(sid=sid, journal=journal)

#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_journal_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>
#+END_HTML

** DOI link
It would be helpful to have a doi link, which is actually independent of Scopus so people without Scopus access can still access information.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']
print result['coredata']['prism:doi']
#+END_SRC

#+RESULTS:
: 10.1016/j.catcom.2013.10.028

#+BEGIN_SRC python :tangle scopus.py
def get_doi_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<a href="http://dx.doi.org/{doi}">doi:{doi}</a>'
    return s.format(doi=result['coredata']['prism:doi'])
#+END_SRC


#+BEGIN_SRC python :results html
from scopus import *
print get_doi_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>
#+END_HTML

** Citation count image
It is nice to show impact of a paper by showing the citations. These change with time, so a static view is not ideal. Scopus provides a way to get an image they generate that should update when viewed. We need the doi to get that.

#+BEGIN_SRC python :tangle scopus.py
def get_cite_img_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    s = '<img src="http://api.elsevier.com/content/abstract/citation-count?doi={doi}&httpAccept=image/jpeg&apiKey={apikey}"></img>'
    return s.format(doi=result['coredata']['prism:doi'].strip(), apikey=MY_API_KEY)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results html
from scopus import *
print get_cite_img_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>
#+END_HTML

** The document link
The document link is sort of buried in the coredata. It seems like & has been replaced by &amp; in the json data so we have to do a clunky fix here.

#+BEGIN_SRC python
from scopus import *
EID = '2-s2.0-84901638552'
data = get_abstract_info(EID)
result = data['abstracts-retrieval-response']

print result['coredata']['dc:title']
for ref in result['coredata']['link']:
    if ref['@rel'] == 'scopus':
        print ref['@href'].replace('&amp;', '&')
        break
#+END_SRC

#+RESULTS:
: Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces
: http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward

#+BEGIN_SRC python :tangle scopus.py
def get_abstract_link(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']
    title = result['coredata']['dc:title']
    for ref in result['coredata']['link']:
        if ref['@rel'] == 'scopus':
            link = ref['@href'].replace('&amp;', '&')

    s = '<a href="{link}">{title}</a>'
    return s.format(link=link, title=title)
#+END_SRC

#+BEGIN_SRC python :results html
from scopus import *
print get_abstract_link('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a>
#+END_HTML

** Putting it all together
Our goal is ultimately an html formatted citation where nearly every piece is a hyperlink to additional information, e.g. each author is linked to their page, the title is linked to the scopus document page, the journal is linked to the scopus journal page, a DOI link, and an image of the number of citations. Here it is.

#+BEGIN_SRC python :tangle scopus.py
def get_html(EID):
    data = get_abstract_info(EID)
    result = data['abstracts-retrieval-response']

    s = '<li>{authors}, <i>{title}</i>, {journal}, <b>{volume}{issue}</b>, p. {pages}, ({year}), {doi}, {cites}.</li>'

    issue = ''
    if result['coredata'].get('prism:issue'):
        issue = '({})'.format(result['coredata'].get('prism:issue'))
    return s.format(authors=get_author_link(EID),
                    title=get_abstract_link(EID),
                    journal=get_journal_link(EID),
                    volume=result['coredata'].get('prism:volume'),
                    issue=issue,
                    pages=result['coredata'].get('prism:pageRange'),
                    year=result['coredata'].get('prism:coverDate'),
                    doi=get_doi_link(EID),
                    cites=get_cite_img_link(EID))

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :results html
from scopus import *
print get_html('2-s2.0-84901638552')
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
<li><a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=55569461200">Xu Z.</a>,<a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">Kitchin J.R.</a>, <i><a href="http://www.scopus.com/inward/record.url?partnerID=HzOxMe3b&scp=84901638552&origin=inward">Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces</a></i>, <a href="http://www.scopus.com/source/sourceInfo.url?sourceId=22746">Catalysis Communications</a>, <b>52</b>, p. 60-64, (2014-07-05), <a href="http://dx.doi.org/10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a>, <img src="http://api.elsevier.com/content/abstract/citation-count?doi=10.1016/j.catcom.2013.10.028&httpAccept=image/jpeg&apiKey=5cd06d8a7df3de986bf3d0cd9971a47c"></img>.</li>
#+END_HTML


Well, that is the end for now. We have a reusable function that generates a nice HTML formatted citation that links out to many different resources. Why aren't all citations on the web this helpful?
* DONE Getting data from the Scopus API
  CLOSED: [2015-04-03 Fri 15:17]
  :PROPERTIES:
  :categories: python,scopus
  :date:     2015/04/03 15:17:27
  :updated:  2015/04/03 15:19:45
  :END:

I have been exploring the Scopus API (http://dev.elsevier.com/index.html) lately. This is a RESTful API that allows you to retrieve data about publications via http requests, i.e. from a script. This service is not free; you need to be at an institution that has a Scopus license.

Scopus is very good at finding your papers, and associating them with a Scopus ID. You don't have to do anything to get one, they make it. I have a Scopus ID (http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771) that has all this data via the web, but I wanted to get this data in a tabular form I could use and analyze. Sure you can download a CSV file from that page and analyze that, but I want to script it. I am just like that ;) To use the API, you need to get an API key (http://www.developers.elsevier.com/action/devprojects). I still cannot figure out if this key is "private" so I am not going to share mine here. I have stored it in a python file called my_scopus.py, and I will import it in these examples.

The code below is "wide", so apologies in advance that some of it will run out of the usual area it belongs.

** About me from Scopus
There is an author API that provides a metrics view of a Scopus ID. Here this shows there are about 77 documents for me, cited about 3028 times. Why do I say "about"? Apparently there are two different databases that Scopus uses, one for the web, and one for this API, and they do not return the same data. It is close, but not the same. The API database includes thing that are published after 1995, and it may not be updated as quickly as the web database. For example the web page reports 79 documents and 3143 citations. In the next sections we will use the search API, which returns the same information as what is on the web. Here we just illustrate how to setup an http request in Python. I like json output, so we ask for it.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** Get my documents from Scopus
To find my documents, we will use the Search API, http://api.elsevier.com/documentation/SCOPUSSearchAPI.wadl. We specify a Scopus ID, and to limit the quantity of data that comes back we specify that we want the dc:identifier field, which corresponds to the scopus id for each document. We will use that in the next section to get info for each document.

#+name: identifiers
#+BEGIN_SRC python :results value
import requests
import json
from my_scopus import MY_API_KEY
resp = requests.get("http://api.elsevier.com/content/search/scopus?query=AU-ID(7004212771)&field=dc:identifier&count=100",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

results = resp.json()

return [[str(r['dc:identifier'])] for r in results['search-results']["entry"]]
#+END_SRC

#+RESULTS: identifiers
| SCOPUS_ID:84924911828 |
| SCOPUS_ID:84923164062 |
| SCOPUS_ID:84924778427 |
| SCOPUS_ID:84924130725 |
| SCOPUS_ID:84901638552 |
| SCOPUS_ID:84898934670 |
| SCOPUS_ID:84896759135 |
| SCOPUS_ID:84896380535 |
| SCOPUS_ID:84896585411 |
| SCOPUS_ID:84916613197 |
| SCOPUS_ID:84908637059 |
| SCOPUS_ID:84880986072 |
| SCOPUS_ID:84881394200 |
| SCOPUS_ID:84873706643 |
| SCOPUS_ID:84876703352 |
| SCOPUS_ID:84872843990 |
| SCOPUS_ID:84872872509 |
| SCOPUS_ID:84872845400 |
| SCOPUS_ID:84872841108 |
| SCOPUS_ID:84872855250 |
| SCOPUS_ID:84872864754 |
| SCOPUS_ID:84886483703 |
| SCOPUS_ID:84872854676 |
| SCOPUS_ID:84867809683 |
| SCOPUS_ID:84864914806 |
| SCOPUS_ID:84865730756 |
| SCOPUS_ID:84864592302 |
| SCOPUS_ID:84863684845 |
| SCOPUS_ID:84866142469 |
| SCOPUS_ID:84861127526 |
| SCOPUS_ID:84857224144 |
| SCOPUS_ID:84857197729 |
| SCOPUS_ID:84856818654 |
| SCOPUS_ID:80052944171 |
| SCOPUS_ID:80051860134 |
| SCOPUS_ID:80051809046 |
| SCOPUS_ID:79953651013 |
| SCOPUS_ID:79952860396 |
| SCOPUS_ID:79951537083 |
| SCOPUS_ID:79251517782 |
| SCOPUS_ID:77956568341 |
| SCOPUS_ID:77954747189 |
| SCOPUS_ID:77956693843 |
| SCOPUS_ID:77949916234 |
| SCOPUS_ID:77955464573 |
| SCOPUS_ID:72049114200 |
| SCOPUS_ID:78649528829 |
| SCOPUS_ID:78649504144 |
| SCOPUS_ID:77952266872 |
| SCOPUS_ID:73149124752 |
| SCOPUS_ID:73149109096 |
| SCOPUS_ID:67449106405 |
| SCOPUS_ID:63649114440 |
| SCOPUS_ID:60849113132 |
| SCOPUS_ID:58649114498 |
| SCOPUS_ID:79952218110 |
| SCOPUS_ID:79952292116 |
| SCOPUS_ID:78049295221 |
| SCOPUS_ID:79952296916 |
| SCOPUS_ID:79952225819 |
| SCOPUS_ID:78049231913 |
| SCOPUS_ID:79952234104 |
| SCOPUS_ID:79952301915 |
| SCOPUS_ID:45149129361 |
| SCOPUS_ID:40949100780 |
| SCOPUS_ID:37349101648 |
| SCOPUS_ID:58049109348 |
| SCOPUS_ID:33750804660 |
| SCOPUS_ID:33645645065 |
| SCOPUS_ID:20544467859 |
| SCOPUS_ID:15744396507 |
| SCOPUS_ID:9744261716  |
| SCOPUS_ID:13444307808 |
| SCOPUS_ID:3042820285  |
| SCOPUS_ID:2942640180  |
| SCOPUS_ID:0142023762  |
| SCOPUS_ID:0141924604  |
| SCOPUS_ID:0037368024  |
| SCOPUS_ID:0037197884  |


** Retrieve info for a document
Here, we work out how to retrieve data for a document. We use the Abstract API (http://api.elsevier.com/documentation/AbstractRetrievalAPI.wadl). We again use a field to limit the amount of data. Here is an example that works for an article. Scopus also lists books and conferences so, we will see how that works later. Note the unicode stuff. I was getting some errors about non-ascii characters causing the json file not to read, and then issues in constructing the string. This was only a problem for some entries.

#+BEGIN_SRC python
import requests
import json
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})
    results = json.loads(resp.text.encode('utf-8'))

    fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). {doi} (cited {cites} times).\n'
    return fstring.format(authors=', '.join([au['ce:indexed-name'] for au in results['abstracts-retrieval-response']['authors']['author']]),
                          title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                          journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                          volume=results['abstracts-retrieval-response']['coredata']['prism:volume'].encode('utf-8'),
                          articlenum=(results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                              results['abstracts-retrieval-response']['coredata'].get('article-number')).encode('utf-8'),
                          date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                          doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                          cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))



print get_scopus_info('SCOPUS_ID:0037368024')
#+END_SRC

#+RESULTS:
: Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1 × 2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). doi:10.1016/S0039-6028(02)02679-1 (cited 27 times).
:


** Get information for all documents
We will use the data we previously got in the long list of Scopus IDs. A few subtle points here are that I made that a nested list so it would print as a column, and so we will have to index each entry to get the scopus id. Also, it seems that some entries generate json that cannot be parsed by python, so we wrap this in a try block and skip those entries. We need to check for the entry being a Journal article, to avoid errors with our format string. We also need to accomodate journals that do not have page ranges, but have artice numbers instead. Finally, we will format each entry so there is some html code for it.

#+BEGIN_SRC python :var scopus_ids=identifiers :results html
import requests
import json
import textwrap
from my_scopus import MY_API_KEY

def get_scopus_info(SCOPUS_ID):
    url = ("http://api.elsevier.com/content/abstract/scopus_id/"
          + SCOPUS_ID
          + "?field=authors,title,publicationName,volume,issueIdentifier,"
          + "prism:pageRange,coverDate,article-number,doi,citedby-count,prism:aggregationType")
    resp = requests.get(url,
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey': MY_API_KEY})

    return json.loads(resp.text.encode('utf-8'))


i = 0
for sid in scopus_ids:
    # some entries seem to have json parse errors, so we catch those
    try:
        results = get_scopus_info(sid[0])  # index 0 because the input data is a 2d array
        if results['abstracts-retrieval-response']['coredata']['prism:aggregationType'] == 'Journal':
            i += 1
            fstring = '{authors}, {title}, {journal}, {volume}, {articlenum}, ({date}). <a href="http://dx.doi.org/{doi}">{doi}</a> (cited {cites} times)\n\n'

            s = fstring.format(authors=', '.join([au['ce:indexed-name'].encode('utf-8') for au in results['abstracts-retrieval-response']['authors']['author']]),
                               title=results['abstracts-retrieval-response']['coredata']['dc:title'].encode('utf-8'),
                               journal=results['abstracts-retrieval-response']['coredata']['prism:publicationName'].encode('utf-8'),
                               volume=results['abstracts-retrieval-response']['coredata'].get('prism:volume', 'None').encode('utf-8'),
                               articlenum=str((results['abstracts-retrieval-response']['coredata'].get('prism:pageRange') or
                                           results['abstracts-retrieval-response']['coredata'].get('article-number'))).encode('utf-8'),
                               date=results['abstracts-retrieval-response']['coredata']['prism:coverDate'].encode('utf-8'),
                               doi='doi:' + results['abstracts-retrieval-response']['coredata']['prism:doi'].encode('utf-8'),
                               cites=int(results['abstracts-retrieval-response']['coredata']['citedby-count'].encode('utf-8')))
            print '{0:3d}. {1}<br>'.format(i, s)
    except:
        print '{0:3d}. {1}'.format(i, sid)
#+END_SRC

#+RESULTS:
#+BEGIN_HTML
  1. Xu Z., Kitchin J.R., Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides, Journal of Chemical Physics, 142, 104703, (2015-03-14). <a href="http://dx.doi.org/doi:10.1063/1.4914093">doi:10.1063/1.4914093</a> (cited 0 times)

<br>
  2. Boes J.R., Gumuslu G., Miller J.B., Gellman A.J., Kitchin J.R., Estimating bulk-composition-dependent H2 adsorption energies on CuxPd1- x alloy (111) surfaces, ACS Catalysis, 5, 1020-1026, (2015-02-06). <a href="http://dx.doi.org/doi:10.1021/cs501585k">doi:10.1021/cs501585k</a> (cited 0 times)

<br>
  3. Boes J.R., Kondratyuk P., Yin C., Miller J.B., Gellman A.J., Kitchin J.R., Core level shifts in Cu-Pd alloys as a function of bulk composition and structure, Surface Science, None, None, (2015-01-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2015.02.011">doi:10.1016/j.susc.2015.02.011</a> (cited 0 times)

<br>
  4. Xu Z., Rossmeisl J., Kitchin J.R., A linear response DFT+U study of trends in the oxygen evolution activity of transition metal rutile dioxides, Journal of Physical Chemistry C, 119, 4827-4833, (2015-01-01). <a href="http://dx.doi.org/doi:10.1021/jp511426q">doi:10.1021/jp511426q</a> (cited 0 times)

<br>
  5. Xu Z., Kitchin J.R., Relating the electronic structure and reactivity of the 3d transition metal monoxide surfaces, Catalysis Communications, 52, 60-64, (2014-07-05). <a href="http://dx.doi.org/doi:10.1016/j.catcom.2013.10.028">doi:10.1016/j.catcom.2013.10.028</a> (cited 2 times)

<br>
  6. Demeter E.L., Hilburg S.L., Washburn N.R., Collins T.J., Kitchin J.R., Electrocatalytic oxygen evolution with an immobilized TAML activator, Journal of the American Chemical Society, 136, 5603-5606, (2014-04-16). <a href="http://dx.doi.org/doi:10.1021/ja5015986">doi:10.1021/ja5015986</a> (cited 4 times)

<br>
  7. Thompson R.L., Shi W., Albenze E., Kusuma V.A., Hopkinson D., Damodaran K., Lee A.S., Kitchin J.R., Luebke D.R., Nulwala H., Probing the effect of electron donation on CO2 absorbing 1,2,3-triazolide ionic liquids, RSC Advances, 4, 12748-12755, (2014-03-17). <a href="http://dx.doi.org/doi:10.1039/c3ra47097k">doi:10.1039/c3ra47097k</a> (cited 1 times)

<br>
  8. Mehta P., Salvador P.A., Kitchin J.R., Identifying potential BO2 oxide polymorphs for epitaxial growth candidates, ACS Applied Materials and Interfaces, 6, 3630-3639, (2014-03-12). <a href="http://dx.doi.org/doi:10.1021/am4059149">doi:10.1021/am4059149</a> (cited 0 times)

<br>
  9. Miller S.D., Pushkarev V.V., Gellman A.J., Kitchin J.R., Simulating temperature programmed desorption of oxygen on Pt(111) using DFT derived coverage dependent desorption barriers, Topics in Catalysis, 57, 106-117, (2014-02-01). <a href="http://dx.doi.org/doi:10.1007/s11244-013-0166-3">doi:10.1007/s11244-013-0166-3</a> (cited 2 times)

<br>
 10. Curnan M.T., Kitchin J.R., Effects of concentration, crystal structure, magnetism, and electronic structure method on first-principles oxygen vacancy formation energy trends in perovskites, Journal of Physical Chemistry C, 118, 28776-28790, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp507957n">doi:10.1021/jp507957n</a> (cited 2 times)

<br>
 11. Xu Z., Kitchin J.R., Probing the coverage dependence of site and adsorbate configurational correlations on (111) surfaces of late transition metals, Journal of Physical Chemistry C, 118, 25597-25602, (2014-01-01). <a href="http://dx.doi.org/doi:10.1021/jp508805h">doi:10.1021/jp508805h</a> (cited 0 times)

<br>
 12. Lee A.S., Eslick J.C., Miller D.C., Kitchin J.R., Comparisons of amine solvents for post-combustion CO2 capture: A multi-objective analysis approach, International Journal of Greenhouse Gas Control, 18, 68-74, (2013-10-01). <a href="http://dx.doi.org/doi:10.1016/j.ijggc.2013.06.020">doi:10.1016/j.ijggc.2013.06.020</a> (cited 3 times)

<br>
 13. Hallenbeck A.P., Kitchin J.R., Effects of O2 and SO2 on the capture capacity of a primary-amine based polymeric CO2 sorbent, Industrial and Engineering Chemistry Research, 52, 10788-10794, (2013-08-07). <a href="http://dx.doi.org/doi:10.1021/ie400582a">doi:10.1021/ie400582a</a> (cited 7 times)

<br>
 13. ['SCOPUS_ID:84873706643']
 14. Calle-Vallejo F., Inoglu N.G., Su H.-Y., Martinez J.I., Man I.C., Koper M.T.M., Kitchin J.R., Rossmeisl J., Number of outer electrons as descriptor for adsorption processes on transition metals and their oxides, Chemical Science, 4, 1245-1249, (2013-03-01). <a href="http://dx.doi.org/doi:10.1039/c2sc21601a">doi:10.1039/c2sc21601a</a> (cited 16 times)

<br>
 15. Lee A.S., Kitchin J.R., Chemical and molecular descriptors for the reactivity of amines with CO
                    2 , Industrial and Engineering Chemistry Research, 51, 13609-13618, (2012-10-24). <a href="http://dx.doi.org/doi:10.1021/ie301419q">doi:10.1021/ie301419q</a> (cited 3 times)

<br>
 16. Rubin E.S., Mantripragada H., Marks A., Versteeg P., Kitchin J., The outlook for improved carbon capture technology, Progress in Energy and Combustion Science, 38, 630-671, (2012-10-01). <a href="http://dx.doi.org/doi:10.1016/j.pecs.2012.03.003">doi:10.1016/j.pecs.2012.03.003</a> (cited 91 times)

<br>
 17. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the surface electronic structure and reactivity of 3d perovskite surfaces, Journal of Chemical Physics, 137, 084703, (2012-08-28). <a href="http://dx.doi.org/doi:10.1063/1.4746117">doi:10.1063/1.4746117</a> (cited 8 times)

<br>
 18. Landon J., Demeter E., Inoglu N., Keturakis C., Wachs I.E., Vasic R., Frenkel A.I., Kitchin J.R., Spectroscopic characterization of mixed Fe-Ni oxide electrocatalysts for the oxygen evolution reaction in alkaline electrolytes, ACS Catalysis, 2, 1793-1801, (2012-08-03). <a href="http://dx.doi.org/doi:10.1021/cs3002644">doi:10.1021/cs3002644</a> (cited 39 times)

<br>
 19. Chao R., Munprom R., Petrova R., Gerdes K., Kitchin J.R., Salvador P.A., Structure and relative thermal stability of mesoporous (La, Sr) MnO 3powders prepared using evaporation-induced self-assembly methods, Journal of the American Ceramic Society, 95, 2339-2346, (2012-07-01). <a href="http://dx.doi.org/doi:10.1111/j.1551-2916.2012.05236.x">doi:10.1111/j.1551-2916.2012.05236.x</a> (cited 4 times)

<br>
 20. Kitchin J., Preface: Trends in computational catalysis, Topics in Catalysis, 55, 227-228, (2012-06-01). <a href="http://dx.doi.org/doi:10.1007/s11244-012-9808-0">doi:10.1007/s11244-012-9808-0</a> (cited 0 times)

<br>
 21. Alesi W.R., Kitchin J.R., Evaluation of a primary amine-functionalized ion-exchange resin for CO
                    2 capture, Industrial and Engineering Chemistry Research, 51, 6907-6915, (2012-05-16). <a href="http://dx.doi.org/doi:10.1021/ie300452c">doi:10.1021/ie300452c</a> (cited 15 times)

<br>
 22. Akhade S.A., Kitchin J.R., Effects of strain, d-band filling, and oxidation state on the bulk electronic structure of cubic 3d perovskites, Journal of Chemical Physics, 135, 104702, (2011-09-14). <a href="http://dx.doi.org/doi:10.1063/1.3631948">doi:10.1063/1.3631948</a> (cited 3 times)

<br>
 23. Man I.C., Su H.-Y., Calle-Vallejo F., Hansen H.A., Martinez J.I., Inoglu N.G., Kitchin J., Jaramillo T.F., Norskov J.K., Rossmeisl J., Universality in Oxygen Evolution Electrocatalysis on Oxide Surfaces, ChemCatChem, 3, 1159-1165, (2011-07-11). <a href="http://dx.doi.org/doi:10.1002/cctc.201000397">doi:10.1002/cctc.201000397</a> (cited 199 times)

<br>
 24. Inoglu N., Kitchin J.R., Identification of sulfur-tolerant bimetallic surfaces using dft parametrized models and atomistic thermodynamics, ACS Catalysis, 1, 399-407, (2011-04-01). <a href="http://dx.doi.org/doi:10.1021/cs200039t">doi:10.1021/cs200039t</a> (cited 9 times)

<br>
 25. Miller S.D., Inoglu N., Kitchin J.R., Configurational correlations in the coverage dependent adsorption energies of oxygen atoms on late transition metal fcc(111) surfaces, Journal of Chemical Physics, 134, 104709, (2011-03-14). <a href="http://dx.doi.org/doi:10.1063/1.3561287">doi:10.1063/1.3561287</a> (cited 16 times)

<br>
 26. Alesi Jr. W.R., Gray M., Kitchin J.R., CO2 adsorption on supported molecular amidine systems on activated carbon, ChemSusChem, 3, 948-956, (2010-08-01). <a href="http://dx.doi.org/doi:10.1002/cssc.201000056">doi:10.1002/cssc.201000056</a> (cited 18 times)

<br>
 27. Landon J., Kitchin J.R., Electrochemical concentration of carbon dioxide from an oxygen/carbon dioxide containing gas stream, Journal of the Electrochemical Society, 157, None, (2010-07-23). <a href="http://dx.doi.org/doi:10.1149/1.3432440">doi:10.1149/1.3432440</a> (cited 3 times)

<br>
 28. Inoglu N., Kitchin J.R., Simple model explaining and predicting coverage-dependent atomic adsorption energies on transition metal surfaces, Physical Review B - Condensed Matter and Materials Physics, 82, 045414, (2010-07-16). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.82.045414">doi:10.1103/PhysRevB.82.045414</a> (cited 14 times)

<br>
 29. Pennline H.W., Granite E.J., Luebke D.R., Kitchin J.R., Landon J., Weiland L.M., Separation of CO2 from flue gas using electrochemical cells, Fuel, 89, 1307-1314, (2010-06-01). <a href="http://dx.doi.org/doi:10.1016/j.fuel.2009.11.036">doi:10.1016/j.fuel.2009.11.036</a> (cited 20 times)

<br>
 30. Inoglu N., Kitchin J.R., New solid-state table: Estimating d-band characteristics for transition metal atoms, Molecular Simulation, 36, 633-638, (2010-06-01). <a href="http://dx.doi.org/doi:10.1080/08927022.2010.481794">doi:10.1080/08927022.2010.481794</a> (cited 16 times)

<br>
 31. Tierney H.L., Baber A.E., Kitchin J.R., Sykes E.C.H., Hydrogen dissociation and spillover on individual isolated palladium atoms, Physical Review Letters, 103, 246102, (2009-12-10). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.103.246102">doi:10.1103/PhysRevLett.103.246102</a> (cited 45 times)

<br>
 32. Miller S.D., Kitchin J.R., Uncertainty and figure selection for DFT based cluster expansions for oxygen adsorption on Au and Pt (111) surfaces, Molecular Simulation, 35, 920-927, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833137">doi:10.1080/08927020902833137</a> (cited 14 times)

<br>
 33. Inolu N., Kitchin J.R., Sulphur poisoning of water-gas shift catalysts: Site blocking and electronic structure modification, Molecular Simulation, 35, 936-941, (2009-09-01). <a href="http://dx.doi.org/doi:10.1080/08927020902833129">doi:10.1080/08927020902833129</a> (cited 6 times)

<br>
 34. Kitchin J.R., Correlations in coverage-dependent atomic adsorption energies on Pd(111), Physical Review B - Condensed Matter and Materials Physics, 79, 205412, (2009-05-01). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.79.205412">doi:10.1103/PhysRevB.79.205412</a> (cited 26 times)

<br>
 35. Han J.W., Kitchin J.R., Sholl D.S., Step decoration of chiral metal surfaces, Journal of Chemical Physics, 130, 124710, (2009-04-08). <a href="http://dx.doi.org/doi:10.1063/1.3096964">doi:10.1063/1.3096964</a> (cited 11 times)

<br>
 36. Miller S.D., Kitchin J.R., Relating the coverage dependence of oxygen adsorption on Au and Pt fcc(1 1 1) surfaces through adsorbate-induced surface electronic structure effects, Surface Science, 603, 794-801, (2009-03-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2009.01.021">doi:10.1016/j.susc.2009.01.021</a> (cited 39 times)

<br>
 37. Inoglu N., Kitchin J.R., Atomistic thermodynamics study of the adsorption and the effects of water-gas shift reactants on Cu catalysts under reaction conditions, Journal of Catalysis, 261, 188-194, (2009-01-25). <a href="http://dx.doi.org/doi:10.1016/j.jcat.2008.11.020">doi:10.1016/j.jcat.2008.11.020</a> (cited 20 times)

<br>
 38. Kitchin J.R., Reuter K., Scheffler M., Alloy surface segregation in reactive environments: First-principles atomistic thermodynamics study of Ag3 Pd(111) in oxygen atmospheres, Physical Review B - Condensed Matter and Materials Physics, 77, 075437, (2008-02-29). <a href="http://dx.doi.org/doi:10.1103/PhysRevB.77.075437">doi:10.1103/PhysRevB.77.075437</a> (cited 49 times)

<br>
 39. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Response to "comment on 'trends in the exchange current for hydrogen evolution' [J. Electrochem. Soc., 152, J23 (2005)]", Journal of the Electrochemical Society, 153, 054612JES, (2006-11-14). <a href="http://dx.doi.org/doi:10.1149/1.2358292">doi:10.1149/1.2358292</a> (cited 9 times)

<br>
 40. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Trends in the chemical properties of early transition metal carbide surfaces: A density functional study, Catalysis Today, 105, 66-73, (2005-07-15). <a href="http://dx.doi.org/doi:10.1016/j.cattod.2005.04.008">doi:10.1016/j.cattod.2005.04.008</a> (cited 70 times)

<br>
 41. Norskov J.K., Bligaard T., Logadottir A., Kitchin J.R., Chen J.G., Pandelov S., Stimming U., Trends in the exchange current for hydrogen evolution, Journal of the Electrochemical Society, 152, None, (2005-04-07). <a href="http://dx.doi.org/doi:10.1149/1.1856988">doi:10.1149/1.1856988</a> (cited 282 times)

<br>
 42. Norskov J.K., Rossmeisl J., Logadottir A., Lindqvist L., Kitchin J.R., Bligaard T., Jonsson H., Origin of the overpotential for oxygen reduction at a fuel-cell cathode, Journal of Physical Chemistry B, 108, 17886-17892, (2004-11-18). <a href="http://dx.doi.org/doi:10.1021/jp047349j">doi:10.1021/jp047349j</a> (cited 1055 times)

<br>
 43. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Role of strain and ligand effects in the modification of the electronic and chemical Properties of bimetallic surfaces, Physical Review Letters, 93, None, (2004-10-08). <a href="http://dx.doi.org/doi:10.1103/PhysRevLett.93.156801">doi:10.1103/PhysRevLett.93.156801</a> (cited 361 times)

<br>
 44. Mhadeshwar A.B., Kitchin J.R., Barteau M.A., Vlachos D.G., The role of adsorbate-adsorbate interactions in the rate controlling step and the most abundant reaction intermediate of NH 3 decomposition on RU, Catalysis Letters, 96, 13-22, (2004-07-01). <a href="http://dx.doi.org/doi:10.1023/B:CATL.0000029523.22277.e1">doi:10.1023/B:CATL.0000029523.22277.e1</a> (cited 45 times)

<br>
 45. Kitchin J.R., Norskov J.K., Barteau M.A., Chen J.G., Modification of the surface electronic and chemical properties of Pt(111) by subsurface 3d transition metals, Journal of Chemical Physics, 120, 10240-10246, (2004-06-01). <a href="http://dx.doi.org/doi:10.1063/1.1737365">doi:10.1063/1.1737365</a> (cited 443 times)

<br>
 46. McCormick J.R., Kitchin J.R., Barteau M.A., Chen J.G., A four-point probe correlation of oxygen sensitivity to changes in surface resistivity of TiO2(0 0 1) and Pd-modified TiO2(0 0 1), Surface Science, 545, None, (2003-11-01). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.08.041">doi:10.1016/j.susc.2003.08.041</a> (cited 11 times)

<br>
 47. Kitchin J.R., Khan N.A., Barteau M.A., Chen J.G., Yakshinskiy B., Madey T.E., Elucidation of the active surface and origin of the weak metal-hydrogen bond on Ni/Pt(1 1 1) bimetallic surfaces: A surface science and density functional theory study, Surface Science, 544, 295-308, (2003-10-20). <a href="http://dx.doi.org/doi:10.1016/j.susc.2003.09.007">doi:10.1016/j.susc.2003.09.007</a> (cited 108 times)

<br>
 48. Kitchin J.R., Barteau M.A., Chen J.G., A comparison of gold and molybdenum nanoparticles on TiO2(1 1 0) 1 × 2 reconstructed single crystal surfaces, Surface Science, 526, 323-331, (2003-03-01). <a href="http://dx.doi.org/doi:10.1016/S0039-6028(02)02679-1">doi:10.1016/S0039-6028(02)02679-1</a> (cited 27 times)

<br>
 49. Song I.K., Kitchin J.R., Barteau M.A., H3PW12O40-functionalized tip for scanning tunneling microscopy, Proceedings of the National Academy of Sciences of the United States of America, 99, 6471-6475, (2002-04-30). <a href="http://dx.doi.org/doi:10.1073/pnas.072514399">doi:10.1073/pnas.072514399</a> (cited 12 times)

<br>
#+END_HTML

** Summary thoughts
I see a lot of potential here for analytics on publications, generation of bibliography files, etc... Instead of retrieving this data every time, it would make much more sense to cache it, e.g. writing each result to a file that could then be used locally, and much faster. The downside of that is, the citations would not be updated in those files. The upside is, you could fix the titles so they are properly marked up. I do not know what the issues with some of the json files was. Some of them were unicode issues. Some other day I will try to track down the other ones.

The entries could be made a lot more functional than this. Each author could be turned into a link back to the scopus author page, for example, the title could be linked to the scopus abstract page, etc... The citations could be a button that automatically updates (like the one in this [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/30/1000+-citations-for-fuel-cell-paper-on-the-oxygen-reduction-reaction/][post]]). That is another exercise, for another day!

* miscellaneous scopus things I have used.
** author 1 - metrics view
This seems to return a simple view with basic metrics.

http://api.elsevier.com/content/author

http://api.elsevier.com/content/author/AUTHOR_ID:7202762180?start=0&count=200&view=DOCUMENTS


#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((url-request-method "GET")
      (url-mime-accept-string "application/json")
      (url-request-extra-headers  '(("X-ELS-APIKey" . "5cd06d8a7df3de986bf3d0cd9971a47c")))
      (json-object-type 'plist)
      (json-data))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://api.elsevier.com/content/author?author_id=7102750465&view=metrics")
    (setq json-data
	  (elt (plist-get
	   (json-read-from-string
	    (buffer-substring url-http-end-of-headers (point-max)))
	   :author-retrieval-response)
	       0)))
  (list (plist-get json-data :h-index)
    (plist-get (plist-get json-data :coredata) :document-count)
    (plist-get (plist-get json-data :coredata) :citation-count)))
#+END_SRC

#+RESULTS:
| 56 | 451 | 10188 |


#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7102750465&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "270",
            "coredata": {
                "citation-count": "10009",
                "cited-by-count": "5002",
                "dc:identifier": "AUTHOR_ID:7102750465",
                "document-count": "447",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7102750465"
            },
            "h-index": "56"
        }
    ]
}
#+end_example

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=metrics",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18"
        }
    ]
}
#+end_example

** author - enhanced view
This provides affiliation history, and a lot more information, but interestingly not the list of published documents.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author?author_id=7004212771&view=enhanced",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "affiliation-current": {
                "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/110785688",
                "@id": "110785688"
            },
            "affiliation-history": {
                "affiliation": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60026531",
                        "@id": "60026531"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60090776",
                        "@id": "60090776"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60027757",
                        "@id": "60027757"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60008644",
                        "@id": "60008644"
                    }
                ]
            },
            "author-profile": {
                "affiliation-current": {
                    "affiliation": {
                        "@affiliation-id": "110785688",
                        "@parent": "60027950",
                        "ip-doc": {
                            "@id": "110785688",
                            "@relationship": "author",
                            "@type": "dept",
                            "address": {
                                "@country": "usa",
                                "address-part": "5000 Forbes Avenue",
                                "city": "Pittsburgh",
                                "country": "United States",
                                "postal-code": "15213",
                                "state": "PA"
                            },
                            "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                            "org-URL": "http://www.cmu.edu/index.shtml",
                            "org-domain": "cmu.edu",
                            "parent-preferred-name": "Carnegie Mellon University",
                            "preferred-name": "Department of Chemical Engineering",
                            "sort-name": "Department of Chemical Engineering"
                        }
                    }
                },
                "affiliation-history": {
                    "affiliation": [
                        {
                            "@affiliation-id": "110785688",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "110785688",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104568870",
                            "@parent": "60030926",
                            "ip-doc": {
                                "@id": "104568870",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "state": "GA"
                                },
                                "afdispname": "TECH Lab, US Dept. of Energy",
                                "parent-preferred-name": "TECH Lab",
                                "preferred-name": "US Dept. of Energy",
                                "sort-name": "US Dept. of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "60026531",
                            "ip-doc": {
                                "@id": "60026531",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "P.O. Box 880",
                                    "city": "Morgantown",
                                    "country": "United States",
                                    "postal-code": "26507-0880",
                                    "state": "WV"
                                },
                                "afdispname": "National Energy Technology Laboratory, Morgantown",
                                "afnameid": "National Energy Technology Laboratory, Morgantown#60026531",
                                "org-URL": "http://www.netl.doe.gov/",
                                "org-domain": "netl.doe.gov",
                                "preferred-name": "National Energy Technology Laboratory, Morgantown",
                                "sort-name": "National Energy Technology Laboratory, Morgantown"
                            }
                        },
                        {
                            "@affiliation-id": "60090776",
                            "ip-doc": {
                                "@id": "60090776",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "626 Cochrans Mill Road",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15236-0940",
                                    "state": "PA"
                                },
                                "afdispname": "National Energy Technology Laboratory, Pittsburgh",
                                "afnameid": "National Energy Technology Laboratory, Pittsburgh#60090776",
                                "org-URL": "http://www.netl.doe.gov/",
                                "preferred-name": "National Energy Technology Laboratory, Pittsburgh",
                                "sort-name": "National Energy Technology Laboratory, Pittsburgh"
                            }
                        },
                        {
                            "@affiliation-id": "60027757",
                            "ip-doc": {
                                "@id": "60027757",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "1000 Independence Ave., SW",
                                    "city": "Washington",
                                    "country": "United States",
                                    "postal-code": "20585",
                                    "state": "DC"
                                },
                                "afdispname": "United States Department of Energy",
                                "afnameid": "United States Department of Energy#60027757",
                                "org-URL": "http://www.energy.gov/",
                                "org-domain": "energy.gov",
                                "preferred-name": "United States Department of Energy",
                                "sort-name": "United States Department of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "109531166",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "109531166",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108790916",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108790916",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108336146",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108336146",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105243609",
                            "@parent": "60023143",
                            "ip-doc": {
                                "@id": "105243609",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Medford",
                                    "country": "United States",
                                    "postal-code": "02155",
                                    "state": "MA"
                                },
                                "afdispname": "Tufts University, Department of Chemistry",
                                "org-URL": "http://www.tufts.edu/",
                                "org-domain": "tufts.edu",
                                "parent-preferred-name": "Tufts University",
                                "preferred-name": "Department of Chemistry",
                                "sort-name": "Department of Chemistry"
                            }
                        },
                        {
                            "@affiliation-id": "104415945",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "104415945",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105144364",
                            "@parent": "60019647",
                            "ip-doc": {
                                "@id": "105144364",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "postal-code": "30332",
                                    "state": "GA"
                                },
                                "afdispname": "Georgia Institute of Technology, School of Chemical and Biomolecular Engineering",
                                "org-URL": "http://www.gatech.edu/",
                                "org-domain": "gatech.edu",
                                "parent-preferred-name": "Georgia Institute of Technology",
                                "preferred-name": "School of Chemical and Biomolecular Engineering",
                                "sort-name": "School of Chemical and Biomolecular Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "60008644",
                            "ip-doc": {
                                "@id": "60008644",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "deu",
                                    "address-part": "Faradayweg 4 - 6",
                                    "city": "Berlin",
                                    "country": "Germany",
                                    "postal-code": "14195",
                                    "state": "Berlin"
                                },
                                "afdispname": "Fritz Haber Institute of the Max Planck Society",
                                "afnameid": "Fritz Haber Institute of the Max Planck Society#60008644",
                                "org-URL": "http://www.fhi-berlin.mpg.de",
                                "org-domain": "fhi-berlin.mpg.de",
                                "preferred-name": "Fritz Haber Institute of the Max Planck Society",
                                "sort-name": "Fritz Haber Institute of the Max Planck Society"
                            }
                        },
                        {
                            "@affiliation-id": "100258138",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "100258138",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "112570754",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "112570754",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108425177",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "108425177",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104168124",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "104168124",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Materials Science and Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Materials Science and Engineering",
                                "sort-name": "Department of Materials Science and Engineering"
                            }
                        }
                    ]
                },
                "classificationgroup": {
                    "classifications": {
                        "@type": "ASJC",
                        "classification": [
                            {
                                "$": "2207",
                                "@frequency": "2"
                            },
                            {
                                "$": "2700",
                                "@frequency": "1"
                            },
                            {
                                "$": "1502",
                                "@frequency": "1"
                            },
                            {
                                "$": "3100",
                                "@frequency": "7"
                            },
                            {
                                "$": "2310",
                                "@frequency": "1"
                            },
                            {
                                "$": "1503",
                                "@frequency": "17"
                            },
                            {
                                "$": "3311",
                                "@frequency": "2"
                            },
                            {
                                "$": "2200",
                                "@frequency": "2"
                            },
                            {
                                "$": "2500",
                                "@frequency": "6"
                            },
                            {
                                "$": "1000",
                                "@frequency": "1"
                            },
                            {
                                "$": "2611",
                                "@frequency": "3"
                            },
                            {
                                "$": "1603",
                                "@frequency": "3"
                            },
                            {
                                "$": "2103",
                                "@frequency": "4"
                            },
                            {
                                "$": "3107",
                                "@frequency": "1"
                            },
                            {
                                "$": "3110",
                                "@frequency": "7"
                            },
                            {
                                "$": "1305",
                                "@frequency": "1"
                            },
                            {
                                "$": "1607",
                                "@frequency": "1"
                            },
                            {
                                "$": "2300",
                                "@frequency": "1"
                            },
                            {
                                "$": "2504",
                                "@frequency": "7"
                            },
                            {
                                "$": "1303",
                                "@frequency": "1"
                            },
                            {
                                "$": "1500",
                                "@frequency": "30"
                            },
                            {
                                "$": "2308",
                                "@frequency": "1"
                            },
                            {
                                "$": "3104",
                                "@frequency": "13"
                            },
                            {
                                "$": "2503",
                                "@frequency": "1"
                            },
                            {
                                "$": "2208",
                                "@frequency": "1"
                            },
                            {
                                "$": "2213",
                                "@frequency": "3"
                            },
                            {
                                "$": "1605",
                                "@frequency": "4"
                            },
                            {
                                "$": "1606",
                                "@frequency": "21"
                            },
                            {
                                "$": "2304",
                                "@frequency": "2"
                            },
                            {
                                "$": "1501",
                                "@frequency": "7"
                            },
                            {
                                "$": "2100",
                                "@frequency": "8"
                            },
                            {
                                "$": "2508",
                                "@frequency": "9"
                            },
                            {
                                "$": "1604",
                                "@frequency": "2"
                            },
                            {
                                "$": "1505",
                                "@frequency": "1"
                            },
                            {
                                "$": "1602",
                                "@frequency": "1"
                            },
                            {
                                "$": "2105",
                                "@frequency": "1"
                            },
                            {
                                "$": "2102",
                                "@frequency": "4"
                            },
                            {
                                "$": "1311",
                                "@frequency": "1"
                            },
                            {
                                "$": "1710",
                                "@frequency": "3"
                            },
                            {
                                "$": "2505",
                                "@frequency": "4"
                            },
                            {
                                "$": "1600",
                                "@frequency": "23"
                            },
                            {
                                "$": "1508",
                                "@frequency": "2"
                            },
                            {
                                "$": "2209",
                                "@frequency": "7"
                            }
                        ]
                    }
                },
                "date-created": {
                    "@day": "03",
                    "@month": "12",
                    "@year": "2005"
                },
                "journal-history": {
                    "@type": "author",
                    "journal": [
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00134651",
                            "sourcetitle": "Journal of the Electrochemical Society",
                            "sourcetitle-abbrev": "J Electrochem Soc"
                        },
                        {
                            "@type": "j",
                            "issn": "1864564X",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "00162361",
                            "sourcetitle": "Fuel",
                            "sourcetitle-abbrev": "Fuel"
                        },
                        {
                            "@type": "j",
                            "issn": "15667367",
                            "sourcetitle": "Catalysis Communications",
                            "sourcetitle-abbrev": "Catal. Commun."
                        },
                        {
                            "@type": "j",
                            "issn": "17505836",
                            "sourcetitle": "International Journal of Greenhouse Gas Control",
                            "sourcetitle-abbrev": "Int. J. Greenh. Gas Control"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE Annu. Meet. Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "10526102",
                            "sourcetitle": "Proceedings of the Air and Waste Management Association's Annual Conference and Exhibition, AWMA",
                            "sourcetitle-abbrev": "Proc. Air Waste Manage. Assoc. Annu. Conf. Exhib. AWMA"
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10225528",
                            "sourcetitle": "Topics in Catalysis",
                            "sourcetitle-abbrev": "Top. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "00027820",
                            "sourcetitle": "Journal of the American Ceramic Society",
                            "sourcetitle-abbrev": "J Am Ceram Soc"
                        },
                        {
                            "@type": "k",
                            "issn": "01400568",
                            "sourcetitle": "Catalysis",
                            "sourcetitle-abbrev": "Catal."
                        },
                        {
                            "@type": "p",
                            "issn": "00657727",
                            "sourcetitle": "ACS National Meeting Book of Abstracts",
                            "sourcetitle-abbrev": "ACS Natl. Meet. Book Abstr."
                        },
                        {
                            "@type": "j",
                            "issn": "00222860",
                            "sourcetitle": "Journal of Molecular Structure",
                            "sourcetitle-abbrev": "J. Mol. Struct."
                        },
                        {
                            "@type": "j",
                            "issn": "20462069",
                            "sourcetitle": "RSC Advances",
                            "sourcetitle-abbrev": "RSC Adv."
                        },
                        {
                            "@type": "j",
                            "issn": "20416520",
                            "sourcetitle": "Chemical Science",
                            "sourcetitle-abbrev": "Chem. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J Phys Chem B"
                        },
                        {
                            "@type": "j",
                            "issn": "03601285",
                            "sourcetitle": "Progress in Energy and Combustion Science",
                            "sourcetitle-abbrev": "Prog. Energy Combust. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal. Lett."
                        },
                        {
                            "@type": "j",
                            "issn": "00319007",
                            "sourcetitle": "Physical Review Letters",
                            "sourcetitle-abbrev": "Phys Rev Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10897690",
                            "sourcetitle": "The Journal of chemical physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "issn": "0277786X",
                            "sourcetitle": "Proceedings of SPIE - The International Society for Optical Engineering",
                            "sourcetitle-abbrev": "Proc SPIE Int Soc Opt Eng"
                        },
                        {
                            "@type": "j",
                            "issn": "08927022",
                            "sourcetitle": "Molecular Simulation",
                            "sourcetitle-abbrev": "Mol Simul"
                        },
                        {
                            "@type": "j",
                            "issn": "19327455",
                            "sourcetitle": "Journal of Physical Chemistry C",
                            "sourcetitle-abbrev": "J. Phys. Chem. C"
                        },
                        {
                            "@type": "j",
                            "issn": "21555435",
                            "sourcetitle": "ACS Catalysis",
                            "sourcetitle-abbrev": "ACS Catal."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "19385862",
                            "sourcetitle": "ECS Transactions",
                            "sourcetitle-abbrev": "ECS Transactions"
                        },
                        {
                            "@type": "j",
                            "issn": "00396028",
                            "sourcetitle": "Surface Science",
                            "sourcetitle-abbrev": "Surf Sci"
                        },
                        {
                            "@type": "j",
                            "issn": "00219517",
                            "sourcetitle": "Journal of Catalysis",
                            "sourcetitle-abbrev": "J. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "19448252",
                            "sourcetitle": "ACS Applied Materials and Interfaces",
                            "sourcetitle-abbrev": "ACS Appl. Mater. Interfaces"
                        },
                        {
                            "@type": "j",
                            "issn": "09205861",
                            "sourcetitle": "Catalysis Today",
                            "sourcetitle-abbrev": "Catal Today"
                        },
                        {
                            "@type": "j",
                            "issn": "00219606",
                            "sourcetitle": "Journal of Chemical Physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "Conference Proceedings - 2009 AIChE Spring National Meeting and 5th Global Congress on Process Safety",
                            "sourcetitle-abbrev": "Conf. Proc. - AIChE Spring Natl. Meet. Global Congr. Process Saf."
                        },
                        {
                            "@type": "j",
                            "issn": "18645631",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "18673880",
                            "sourcetitle": "ChemCatChem",
                            "sourcetitle-abbrev": "ChemCatChem"
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J. Phys. Chem. B"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 100 - 2008 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00278424",
                            "sourcetitle": "Proceedings of the National Academy of Sciences of the United States of America",
                            "sourcetitle-abbrev": "Proc. Natl. Acad. Sci. U. S. A."
                        },
                        {
                            "@type": "j",
                            "issn": "10980121",
                            "sourcetitle": "Physical Review B - Condensed Matter and Materials Physics",
                            "sourcetitle-abbrev": "Phys. Rev. B Condens. Matter Mater. Phys."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "2007 AIChE Annual Meeting",
                            "sourcetitle-abbrev": "AIChE Ann. Meet."
                        },
                        {
                            "@type": "j",
                            "issn": "08885885",
                            "sourcetitle": "Industrial and Engineering Chemistry Research",
                            "sourcetitle-abbrev": "Ind. Eng. Chem. Res."
                        },
                        {
                            "@type": "j",
                            "issn": "15205126",
                            "sourcetitle": "Journal of the American Chemical Society",
                            "sourcetitle-abbrev": "J. Am. Chem. Soc."
                        }
                    ]
                },
                "name-variant": [
                    {
                        "given-name": null,
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John",
                        "indexed-name": "Kitchin J.",
                        "initials": "J.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John R",
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    }
                ],
                "preferred-name": {
                    "given-name": "John R.",
                    "indexed-name": "Kitchin J.",
                    "initials": "J.R.",
                    "surname": "Kitchin"
                },
                "publication-range": {
                    "@end": "2015",
                    "@start": "2002"
                },
                "status": "update"
            },
            "coauthor-count": "90",
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "eid": "9-s2.0-7004212771",
                "link": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=refauid%287004212771%29",
                        "@rel": "scopus-citedby"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=7004212771&origin=inward",
                        "@rel": "scopus-author"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/author/author_id/7004212771",
                        "@rel": "self"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=au-id%287004212771%29",
                        "@rel": "search"
                    },
                    {
                        "@href": "http://api.elsevier.com/content/search/author?co-author=7004212771",
                        "@rel": "coauthor-search"
                    }
                ],
                "orcid": "0000-0003-2625-9232",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "h-index": "18",
            "subject-areas": {
                "subject-area": [
                    {
                        "$": "Control and Systems Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2207"
                    },
                    {
                        "$": "Medicine (all)",
                        "@_fa": "true",
                        "@abbrev": "MEDI",
                        "@code": "2700"
                    },
                    {
                        "$": "Bioengineering",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1502"
                    },
                    {
                        "$": "Physics and Astronomy (all)",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3100"
                    },
                    {
                        "$": "Pollution",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2310"
                    },
                    {
                        "$": "Catalysis",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1503"
                    },
                    {
                        "$": "Safety Research",
                        "@_fa": "true",
                        "@abbrev": "SOCI",
                        "@code": "3311"
                    },
                    {
                        "$": "Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2200"
                    },
                    {
                        "$": "Materials Science (all)",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2500"
                    },
                    {
                        "$": "Multidisciplinary",
                        "@_fa": "true",
                        "@abbrev": "MULT",
                        "@code": "1000"
                    },
                    {
                        "$": "Modeling and Simulation",
                        "@_fa": "true",
                        "@abbrev": "MATH",
                        "@code": "2611"
                    },
                    {
                        "$": "Electrochemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1603"
                    },
                    {
                        "$": "Fuel Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2103"
                    },
                    {
                        "$": "Atomic and Molecular Physics, and Optics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3107"
                    },
                    {
                        "$": "Surfaces and Interfaces",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3110"
                    },
                    {
                        "$": "Biotechnology",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1305"
                    },
                    {
                        "$": "Spectroscopy",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1607"
                    },
                    {
                        "$": "Environmental Science (all)",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2300"
                    },
                    {
                        "$": "Electronic, Optical and Magnetic Materials",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2504"
                    },
                    {
                        "$": "Biochemistry",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1303"
                    },
                    {
                        "$": "Chemical Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1500"
                    },
                    {
                        "$": "Management, Monitoring, Policy and Law",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2308"
                    },
                    {
                        "$": "Condensed Matter Physics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3104"
                    },
                    {
                        "$": "Ceramics and Composites",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2503"
                    },
                    {
                        "$": "Electrical and Electronic Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2208"
                    },
                    {
                        "$": "Safety, Risk, Reliability and Quality",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2213"
                    },
                    {
                        "$": "Organic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1605"
                    },
                    {
                        "$": "Physical and Theoretical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1606"
                    },
                    {
                        "$": "Environmental Chemistry",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2304"
                    },
                    {
                        "$": "Chemical Engineering (miscellaneous)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1501"
                    },
                    {
                        "$": "Energy (all)",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2100"
                    },
                    {
                        "$": "Surfaces, Coatings and Films",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2508"
                    },
                    {
                        "$": "Inorganic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1604"
                    },
                    {
                        "$": "Colloid and Surface Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1505"
                    },
                    {
                        "$": "Analytical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1602"
                    },
                    {
                        "$": "Renewable Energy, Sustainability and the Environment",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2105"
                    },
                    {
                        "$": "Energy Engineering and Power Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2102"
                    },
                    {
                        "$": "Genetics",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1311"
                    },
                    {
                        "$": "Information Systems",
                        "@_fa": "true",
                        "@abbrev": "COMP",
                        "@code": "1710"
                    },
                    {
                        "$": "Materials Chemistry",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2505"
                    },
                    {
                        "$": "Chemistry (all)",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1600"
                    },
                    {
                        "$": "Process Chemistry and Technology",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1508"
                    },
                    {
                        "$": "Industrial and Manufacturing Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2209"
                    }
                ]
            }
        }
    ]
}
#+end_example

** Author retrieval 2
This seems to be almost the same as the enhanced view
#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/author/author_id/7004212771",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC

#+RESULTS:
#+begin_example
{
    "author-retrieval-response": [
        {
            "@_fa": "true",
            "@status": "found",
            "affiliation-current": {
                "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/110785688",
                "@id": "110785688"
            },
            "affiliation-history": {
                "affiliation": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60026531",
                        "@id": "60026531"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60090776",
                        "@id": "60090776"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60027757",
                        "@id": "60027757"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/affiliation/affiliation_id/60008644",
                        "@id": "60008644"
                    }
                ]
            },
            "author-profile": {
                "affiliation-current": {
                    "affiliation": {
                        "@affiliation-id": "110785688",
                        "@parent": "60027950",
                        "ip-doc": {
                            "@id": "110785688",
                            "@relationship": "author",
                            "@type": "dept",
                            "address": {
                                "@country": "usa",
                                "address-part": "5000 Forbes Avenue",
                                "city": "Pittsburgh",
                                "country": "United States",
                                "postal-code": "15213",
                                "state": "PA"
                            },
                            "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                            "org-URL": "http://www.cmu.edu/index.shtml",
                            "org-domain": "cmu.edu",
                            "parent-preferred-name": "Carnegie Mellon University",
                            "preferred-name": "Department of Chemical Engineering",
                            "sort-name": "Department of Chemical Engineering"
                        }
                    }
                },
                "affiliation-history": {
                    "affiliation": [
                        {
                            "@affiliation-id": "110785688",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "110785688",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104568870",
                            "@parent": "60030926",
                            "ip-doc": {
                                "@id": "104568870",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "state": "GA"
                                },
                                "afdispname": "TECH Lab, US Dept. of Energy",
                                "parent-preferred-name": "TECH Lab",
                                "preferred-name": "US Dept. of Energy",
                                "sort-name": "US Dept. of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "60026531",
                            "ip-doc": {
                                "@id": "60026531",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "P.O. Box 880",
                                    "city": "Morgantown",
                                    "country": "United States",
                                    "postal-code": "26507-0880",
                                    "state": "WV"
                                },
                                "afdispname": "National Energy Technology Laboratory, Morgantown",
                                "afnameid": "National Energy Technology Laboratory, Morgantown#60026531",
                                "org-URL": "http://www.netl.doe.gov/",
                                "org-domain": "netl.doe.gov",
                                "preferred-name": "National Energy Technology Laboratory, Morgantown",
                                "sort-name": "National Energy Technology Laboratory, Morgantown"
                            }
                        },
                        {
                            "@affiliation-id": "60090776",
                            "ip-doc": {
                                "@id": "60090776",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "626 Cochrans Mill Road",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15236-0940",
                                    "state": "PA"
                                },
                                "afdispname": "National Energy Technology Laboratory, Pittsburgh",
                                "afnameid": "National Energy Technology Laboratory, Pittsburgh#60090776",
                                "org-URL": "http://www.netl.doe.gov/",
                                "preferred-name": "National Energy Technology Laboratory, Pittsburgh",
                                "sort-name": "National Energy Technology Laboratory, Pittsburgh"
                            }
                        },
                        {
                            "@affiliation-id": "60027757",
                            "ip-doc": {
                                "@id": "60027757",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "1000 Independence Ave., SW",
                                    "city": "Washington",
                                    "country": "United States",
                                    "postal-code": "20585",
                                    "state": "DC"
                                },
                                "afdispname": "United States Department of Energy",
                                "afnameid": "United States Department of Energy#60027757",
                                "org-URL": "http://www.energy.gov/",
                                "org-domain": "energy.gov",
                                "preferred-name": "United States Department of Energy",
                                "sort-name": "United States Department of Energy"
                            }
                        },
                        {
                            "@affiliation-id": "109531166",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "109531166",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108790916",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108790916",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108336146",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "108336146",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105243609",
                            "@parent": "60023143",
                            "ip-doc": {
                                "@id": "105243609",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Medford",
                                    "country": "United States",
                                    "postal-code": "02155",
                                    "state": "MA"
                                },
                                "afdispname": "Tufts University, Department of Chemistry",
                                "org-URL": "http://www.tufts.edu/",
                                "org-domain": "tufts.edu",
                                "parent-preferred-name": "Tufts University",
                                "preferred-name": "Department of Chemistry",
                                "sort-name": "Department of Chemistry"
                            }
                        },
                        {
                            "@affiliation-id": "104415945",
                            "@parent": "60027950",
                            "ip-doc": {
                                "@id": "104415945",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "5000 Forbes Avenue",
                                    "city": "Pittsburgh",
                                    "country": "United States",
                                    "postal-code": "15213",
                                    "state": "PA"
                                },
                                "afdispname": "Carnegie Mellon University, Department of Chemical Engineering",
                                "org-URL": "http://www.cmu.edu/index.shtml",
                                "org-domain": "cmu.edu",
                                "parent-preferred-name": "Carnegie Mellon University",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "105144364",
                            "@parent": "60019647",
                            "ip-doc": {
                                "@id": "105144364",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "city": "Atlanta",
                                    "country": "United States",
                                    "postal-code": "30332",
                                    "state": "GA"
                                },
                                "afdispname": "Georgia Institute of Technology, School of Chemical and Biomolecular Engineering",
                                "org-URL": "http://www.gatech.edu/",
                                "org-domain": "gatech.edu",
                                "parent-preferred-name": "Georgia Institute of Technology",
                                "preferred-name": "School of Chemical and Biomolecular Engineering",
                                "sort-name": "School of Chemical and Biomolecular Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "60008644",
                            "ip-doc": {
                                "@id": "60008644",
                                "@relationship": "author",
                                "@type": "parent",
                                "address": {
                                    "@country": "deu",
                                    "address-part": "Faradayweg 4 - 6",
                                    "city": "Berlin",
                                    "country": "Germany",
                                    "postal-code": "14195",
                                    "state": "Berlin"
                                },
                                "afdispname": "Fritz Haber Institute of the Max Planck Society",
                                "afnameid": "Fritz Haber Institute of the Max Planck Society#60008644",
                                "org-URL": "http://www.fhi-berlin.mpg.de",
                                "org-domain": "fhi-berlin.mpg.de",
                                "preferred-name": "Fritz Haber Institute of the Max Planck Society",
                                "sort-name": "Fritz Haber Institute of the Max Planck Society"
                            }
                        },
                        {
                            "@affiliation-id": "100258138",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "100258138",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "112570754",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "112570754",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "108425177",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "108425177",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Chemical Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Chemical Engineering",
                                "sort-name": "Department of Chemical Engineering"
                            }
                        },
                        {
                            "@affiliation-id": "104168124",
                            "@parent": "60023004",
                            "ip-doc": {
                                "@id": "104168124",
                                "@relationship": "author",
                                "@type": "dept",
                                "address": {
                                    "@country": "usa",
                                    "address-part": "301 McKinly Lab",
                                    "city": "Newark",
                                    "country": "United States",
                                    "postal-code": "19716",
                                    "state": "DE"
                                },
                                "afdispname": "University of Delaware, Department of Materials Science and Engineering",
                                "org-URL": "http://www.udel.edu/",
                                "org-domain": "udel.edu",
                                "parent-preferred-name": "University of Delaware",
                                "preferred-name": "Department of Materials Science and Engineering",
                                "sort-name": "Department of Materials Science and Engineering"
                            }
                        }
                    ]
                },
                "classificationgroup": {
                    "classifications": {
                        "@type": "ASJC",
                        "classification": [
                            {
                                "$": "2207",
                                "@frequency": "2"
                            },
                            {
                                "$": "2700",
                                "@frequency": "1"
                            },
                            {
                                "$": "1502",
                                "@frequency": "1"
                            },
                            {
                                "$": "3100",
                                "@frequency": "7"
                            },
                            {
                                "$": "2310",
                                "@frequency": "1"
                            },
                            {
                                "$": "1503",
                                "@frequency": "17"
                            },
                            {
                                "$": "3311",
                                "@frequency": "2"
                            },
                            {
                                "$": "2200",
                                "@frequency": "2"
                            },
                            {
                                "$": "2500",
                                "@frequency": "6"
                            },
                            {
                                "$": "1000",
                                "@frequency": "1"
                            },
                            {
                                "$": "2611",
                                "@frequency": "3"
                            },
                            {
                                "$": "1603",
                                "@frequency": "3"
                            },
                            {
                                "$": "2103",
                                "@frequency": "4"
                            },
                            {
                                "$": "3107",
                                "@frequency": "1"
                            },
                            {
                                "$": "3110",
                                "@frequency": "7"
                            },
                            {
                                "$": "1305",
                                "@frequency": "1"
                            },
                            {
                                "$": "1607",
                                "@frequency": "1"
                            },
                            {
                                "$": "2300",
                                "@frequency": "1"
                            },
                            {
                                "$": "2504",
                                "@frequency": "7"
                            },
                            {
                                "$": "1303",
                                "@frequency": "1"
                            },
                            {
                                "$": "1500",
                                "@frequency": "30"
                            },
                            {
                                "$": "2308",
                                "@frequency": "1"
                            },
                            {
                                "$": "3104",
                                "@frequency": "13"
                            },
                            {
                                "$": "2503",
                                "@frequency": "1"
                            },
                            {
                                "$": "2208",
                                "@frequency": "1"
                            },
                            {
                                "$": "2213",
                                "@frequency": "3"
                            },
                            {
                                "$": "1605",
                                "@frequency": "4"
                            },
                            {
                                "$": "1606",
                                "@frequency": "21"
                            },
                            {
                                "$": "2304",
                                "@frequency": "2"
                            },
                            {
                                "$": "1501",
                                "@frequency": "7"
                            },
                            {
                                "$": "2100",
                                "@frequency": "8"
                            },
                            {
                                "$": "2508",
                                "@frequency": "9"
                            },
                            {
                                "$": "1604",
                                "@frequency": "2"
                            },
                            {
                                "$": "1505",
                                "@frequency": "1"
                            },
                            {
                                "$": "1602",
                                "@frequency": "1"
                            },
                            {
                                "$": "2105",
                                "@frequency": "1"
                            },
                            {
                                "$": "2102",
                                "@frequency": "4"
                            },
                            {
                                "$": "1311",
                                "@frequency": "1"
                            },
                            {
                                "$": "1710",
                                "@frequency": "3"
                            },
                            {
                                "$": "2505",
                                "@frequency": "4"
                            },
                            {
                                "$": "1600",
                                "@frequency": "23"
                            },
                            {
                                "$": "1508",
                                "@frequency": "2"
                            },
                            {
                                "$": "2209",
                                "@frequency": "7"
                            }
                        ]
                    }
                },
                "date-created": {
                    "@day": "03",
                    "@month": "12",
                    "@year": "2005"
                },
                "journal-history": {
                    "@type": "author",
                    "journal": [
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 2012 - 2012 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "11AIChE - 2011 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00134651",
                            "sourcetitle": "Journal of the Electrochemical Society",
                            "sourcetitle-abbrev": "J Electrochem Soc"
                        },
                        {
                            "@type": "j",
                            "issn": "1864564X",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "00162361",
                            "sourcetitle": "Fuel",
                            "sourcetitle-abbrev": "Fuel"
                        },
                        {
                            "@type": "j",
                            "issn": "15667367",
                            "sourcetitle": "Catalysis Communications",
                            "sourcetitle-abbrev": "Catal. Commun."
                        },
                        {
                            "@type": "j",
                            "issn": "17505836",
                            "sourcetitle": "International Journal of Greenhouse Gas Control",
                            "sourcetitle-abbrev": "Int. J. Greenh. Gas Control"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE Annu. Meet. Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "10526102",
                            "sourcetitle": "Proceedings of the Air and Waste Management Association's Annual Conference and Exhibition, AWMA",
                            "sourcetitle-abbrev": "Proc. Air Waste Manage. Assoc. Annu. Conf. Exhib. AWMA"
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10225528",
                            "sourcetitle": "Topics in Catalysis",
                            "sourcetitle-abbrev": "Top. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "00027820",
                            "sourcetitle": "Journal of the American Ceramic Society",
                            "sourcetitle-abbrev": "J Am Ceram Soc"
                        },
                        {
                            "@type": "k",
                            "issn": "01400568",
                            "sourcetitle": "Catalysis",
                            "sourcetitle-abbrev": "Catal."
                        },
                        {
                            "@type": "p",
                            "issn": "00657727",
                            "sourcetitle": "ACS National Meeting Book of Abstracts",
                            "sourcetitle-abbrev": "ACS Natl. Meet. Book Abstr."
                        },
                        {
                            "@type": "j",
                            "issn": "00222860",
                            "sourcetitle": "Journal of Molecular Structure",
                            "sourcetitle-abbrev": "J. Mol. Struct."
                        },
                        {
                            "@type": "j",
                            "issn": "20462069",
                            "sourcetitle": "RSC Advances",
                            "sourcetitle-abbrev": "RSC Adv."
                        },
                        {
                            "@type": "j",
                            "issn": "20416520",
                            "sourcetitle": "Chemical Science",
                            "sourcetitle-abbrev": "Chem. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J Phys Chem B"
                        },
                        {
                            "@type": "j",
                            "issn": "03601285",
                            "sourcetitle": "Progress in Energy and Combustion Science",
                            "sourcetitle-abbrev": "Prog. Energy Combust. Sci."
                        },
                        {
                            "@type": "j",
                            "issn": "1011372X",
                            "sourcetitle": "Catalysis Letters",
                            "sourcetitle-abbrev": "Catal. Lett."
                        },
                        {
                            "@type": "j",
                            "issn": "00319007",
                            "sourcetitle": "Physical Review Letters",
                            "sourcetitle-abbrev": "Phys Rev Lett"
                        },
                        {
                            "@type": "j",
                            "issn": "10897690",
                            "sourcetitle": "The Journal of chemical physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "issn": "0277786X",
                            "sourcetitle": "Proceedings of SPIE - The International Society for Optical Engineering",
                            "sourcetitle-abbrev": "Proc SPIE Int Soc Opt Eng"
                        },
                        {
                            "@type": "j",
                            "issn": "08927022",
                            "sourcetitle": "Molecular Simulation",
                            "sourcetitle-abbrev": "Mol Simul"
                        },
                        {
                            "@type": "j",
                            "issn": "19327455",
                            "sourcetitle": "Journal of Physical Chemistry C",
                            "sourcetitle-abbrev": "J. Phys. Chem. C"
                        },
                        {
                            "@type": "j",
                            "issn": "21555435",
                            "sourcetitle": "ACS Catalysis",
                            "sourcetitle-abbrev": "ACS Catal."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "10AIChE - 2010 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "p",
                            "issn": "19385862",
                            "sourcetitle": "ECS Transactions",
                            "sourcetitle-abbrev": "ECS Transactions"
                        },
                        {
                            "@type": "j",
                            "issn": "00396028",
                            "sourcetitle": "Surface Science",
                            "sourcetitle-abbrev": "Surf Sci"
                        },
                        {
                            "@type": "j",
                            "issn": "00219517",
                            "sourcetitle": "Journal of Catalysis",
                            "sourcetitle-abbrev": "J. Catal."
                        },
                        {
                            "@type": "j",
                            "issn": "19448252",
                            "sourcetitle": "ACS Applied Materials and Interfaces",
                            "sourcetitle-abbrev": "ACS Appl. Mater. Interfaces"
                        },
                        {
                            "@type": "j",
                            "issn": "09205861",
                            "sourcetitle": "Catalysis Today",
                            "sourcetitle-abbrev": "Catal Today"
                        },
                        {
                            "@type": "j",
                            "issn": "00219606",
                            "sourcetitle": "Journal of Chemical Physics",
                            "sourcetitle-abbrev": "J Chem Phys"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "Conference Proceedings - 2009 AIChE Spring National Meeting and 5th Global Congress on Process Safety",
                            "sourcetitle-abbrev": "Conf. Proc. - AIChE Spring Natl. Meet. Global Congr. Process Saf."
                        },
                        {
                            "@type": "j",
                            "issn": "18645631",
                            "sourcetitle": "ChemSusChem",
                            "sourcetitle-abbrev": "ChemSusChem"
                        },
                        {
                            "@type": "j",
                            "issn": "18673880",
                            "sourcetitle": "ChemCatChem",
                            "sourcetitle-abbrev": "ChemCatChem"
                        },
                        {
                            "@type": "j",
                            "issn": "15206106",
                            "sourcetitle": "Journal of Physical Chemistry B",
                            "sourcetitle-abbrev": "J. Phys. Chem. B"
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "AIChE 100 - 2008 AIChE Annual Meeting, Conference Proceedings",
                            "sourcetitle-abbrev": "AIChE - AIChE Annu. Meet., Conf. Proc."
                        },
                        {
                            "@type": "j",
                            "issn": "00278424",
                            "sourcetitle": "Proceedings of the National Academy of Sciences of the United States of America",
                            "sourcetitle-abbrev": "Proc. Natl. Acad. Sci. U. S. A."
                        },
                        {
                            "@type": "j",
                            "issn": "10980121",
                            "sourcetitle": "Physical Review B - Condensed Matter and Materials Physics",
                            "sourcetitle-abbrev": "Phys. Rev. B Condens. Matter Mater. Phys."
                        },
                        {
                            "@type": "p",
                            "sourcetitle": "2007 AIChE Annual Meeting",
                            "sourcetitle-abbrev": "AIChE Ann. Meet."
                        },
                        {
                            "@type": "j",
                            "issn": "08885885",
                            "sourcetitle": "Industrial and Engineering Chemistry Research",
                            "sourcetitle-abbrev": "Ind. Eng. Chem. Res."
                        },
                        {
                            "@type": "j",
                            "issn": "15205126",
                            "sourcetitle": "Journal of the American Chemical Society",
                            "sourcetitle-abbrev": "J. Am. Chem. Soc."
                        }
                    ]
                },
                "name-variant": [
                    {
                        "given-name": null,
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John",
                        "indexed-name": "Kitchin J.",
                        "initials": "J.",
                        "surname": "Kitchin"
                    },
                    {
                        "given-name": "John R",
                        "indexed-name": "Kitchin J.R.",
                        "initials": "J.R.",
                        "surname": "Kitchin"
                    }
                ],
                "preferred-name": {
                    "given-name": "John R.",
                    "indexed-name": "Kitchin J.",
                    "initials": "J.R.",
                    "surname": "Kitchin"
                },
                "publication-range": {
                    "@end": "2015",
                    "@start": "2002"
                },
                "status": "update"
            },
            "coredata": {
                "citation-count": "3028",
                "cited-by-count": "2369",
                "dc:identifier": "AUTHOR_ID:7004212771",
                "document-count": "77",
                "eid": "9-s2.0-7004212771",
                "link": [
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=refauid%287004212771%29",
                        "@rel": "scopus-citedby"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://www.scopus.com/authid/detail.url?partnerID=HzOxMe3b&authorId=7004212771&origin=inward",
                        "@rel": "scopus-author"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/author/author_id/7004212771",
                        "@rel": "self"
                    },
                    {
                        "@_fa": "true",
                        "@href": "http://api.elsevier.com/content/search/scopus?query=au-id%287004212771%29",
                        "@rel": "search"
                    }
                ],
                "orcid": "0000-0003-2625-9232",
                "prism:url": "http://api.elsevier.com/content/author/author_id/7004212771"
            },
            "subject-areas": {
                "subject-area": [
                    {
                        "$": "Control and Systems Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2207"
                    },
                    {
                        "$": "Medicine (all)",
                        "@_fa": "true",
                        "@abbrev": "MEDI",
                        "@code": "2700"
                    },
                    {
                        "$": "Bioengineering",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1502"
                    },
                    {
                        "$": "Physics and Astronomy (all)",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3100"
                    },
                    {
                        "$": "Pollution",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2310"
                    },
                    {
                        "$": "Catalysis",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1503"
                    },
                    {
                        "$": "Safety Research",
                        "@_fa": "true",
                        "@abbrev": "SOCI",
                        "@code": "3311"
                    },
                    {
                        "$": "Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2200"
                    },
                    {
                        "$": "Materials Science (all)",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2500"
                    },
                    {
                        "$": "Multidisciplinary",
                        "@_fa": "true",
                        "@abbrev": "MULT",
                        "@code": "1000"
                    },
                    {
                        "$": "Modeling and Simulation",
                        "@_fa": "true",
                        "@abbrev": "MATH",
                        "@code": "2611"
                    },
                    {
                        "$": "Electrochemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1603"
                    },
                    {
                        "$": "Fuel Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2103"
                    },
                    {
                        "$": "Atomic and Molecular Physics, and Optics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3107"
                    },
                    {
                        "$": "Surfaces and Interfaces",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3110"
                    },
                    {
                        "$": "Biotechnology",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1305"
                    },
                    {
                        "$": "Spectroscopy",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1607"
                    },
                    {
                        "$": "Environmental Science (all)",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2300"
                    },
                    {
                        "$": "Electronic, Optical and Magnetic Materials",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2504"
                    },
                    {
                        "$": "Biochemistry",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1303"
                    },
                    {
                        "$": "Chemical Engineering (all)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1500"
                    },
                    {
                        "$": "Management, Monitoring, Policy and Law",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2308"
                    },
                    {
                        "$": "Condensed Matter Physics",
                        "@_fa": "true",
                        "@abbrev": "PHYS",
                        "@code": "3104"
                    },
                    {
                        "$": "Ceramics and Composites",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2503"
                    },
                    {
                        "$": "Electrical and Electronic Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2208"
                    },
                    {
                        "$": "Safety, Risk, Reliability and Quality",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2213"
                    },
                    {
                        "$": "Organic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1605"
                    },
                    {
                        "$": "Physical and Theoretical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1606"
                    },
                    {
                        "$": "Environmental Chemistry",
                        "@_fa": "true",
                        "@abbrev": "ENVI",
                        "@code": "2304"
                    },
                    {
                        "$": "Chemical Engineering (miscellaneous)",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1501"
                    },
                    {
                        "$": "Energy (all)",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2100"
                    },
                    {
                        "$": "Surfaces, Coatings and Films",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2508"
                    },
                    {
                        "$": "Inorganic Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1604"
                    },
                    {
                        "$": "Colloid and Surface Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1505"
                    },
                    {
                        "$": "Analytical Chemistry",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1602"
                    },
                    {
                        "$": "Renewable Energy, Sustainability and the Environment",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2105"
                    },
                    {
                        "$": "Energy Engineering and Power Technology",
                        "@_fa": "true",
                        "@abbrev": "ENER",
                        "@code": "2102"
                    },
                    {
                        "$": "Genetics",
                        "@_fa": "true",
                        "@abbrev": "BIOC",
                        "@code": "1311"
                    },
                    {
                        "$": "Information Systems",
                        "@_fa": "true",
                        "@abbrev": "COMP",
                        "@code": "1710"
                    },
                    {
                        "$": "Materials Chemistry",
                        "@_fa": "true",
                        "@abbrev": "MATE",
                        "@code": "2505"
                    },
                    {
                        "$": "Chemistry (all)",
                        "@_fa": "true",
                        "@abbrev": "CHEM",
                        "@code": "1600"
                    },
                    {
                        "$": "Process Chemistry and Technology",
                        "@_fa": "true",
                        "@abbrev": "CENG",
                        "@code": "1508"
                    },
                    {
                        "$": "Industrial and Manufacturing Engineering",
                        "@_fa": "true",
                        "@abbrev": "ENGI",
                        "@code": "2209"
                    }
                ]
            }
        }
    ]
}
#+end_example

** Citation retrieval
Retrieves citation data for a DOI.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://api.elsevier.com/content/search/index:SCOPUS?query=DOI(10.1021/jp047349j)&field=citedby-count",
                    headers={'Accept':'application/json',
                             'X-ELS-APIKey':'5cd06d8a7df3de986bf3d0cd9971a47c'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))

#+END_SRC

#+RESULTS:
#+begin_example
{
    "search-results": {
        "entry": [
            {
                "@_fa": "true",
                "citedby-count": "1050",
                "prism:url": "http://api.elsevier.com/content/abstract/scopus_id:9744261716"
            }
        ],
        "link": [
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "self",
                "@type": "application/json"
            },
            {
                "@_fa": "true",
                "@href": "http://api.elsevier.com:80/content/search/index:scopus?start=0&count=25&query=DOI%2810.1021%2Fjp047349j%29&field=citedby-count",
                "@ref": "first",
                "@type": "application/json"
            }
        ],
        "opensearch:Query": {
            "@role": "request",
            "@searchTerms": "DOI%2810.1021%2Fjp047349j%29",
            "@startPage": "0"
        },
        "opensearch:itemsPerPage": "1",
        "opensearch:startIndex": "0",
        "opensearch:totalResults": "1"
    }
}
#+end_example

requests.el [[http://tkf.github.io/emacs-request/][Request.el – Easy HTTP request for Emacs Lisp — Request.el 0.2.0 documentation]]

* Kitchingroup products
** Youtube videos
https://www.youtube.com/analytics?o=U

#+BEGIN_HTML
<script src="https://apis.google.com/js/platform.js"></script>

<div class="g-ytsubscribe" data-channelid="UCQp2VLAOlvq142YN3JO3y8w" data-layout="full" data-count="default"></div>
#+END_HTML
- Reproducible Research at Scipy 2013
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/1-dUkyn_fZA" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- org-mode is awesome
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/fgizHHd7nOo" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- A Success Story in Using Python in a Graduate Chemical Engineering Course at Scipy 2014
#+BEGIN_HTML
<iframe width="560" height="315" src="https://www.youtube.com/embed/IsSMs-4GlT8" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- Teaching with Emacs + org-mode
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/cRUCiF2MwP4" frameborder="0" allowfullscreen></iframe>
#+END_HTML

- The org-ref show
#+BEGIN_HTML
<iframe width="420" height="315" src="https://www.youtube.com/embed/JyvpSVl4_dg" frameborder="0" allowfullscreen></iframe>
#+END_HTML
* Scientific writing references


cite:whitesides-2004-whites-group

cite:powell-2010-public

https://medium.com/@write4research/why-do-academics-and-phders-carefully-choose-useless-titles-for-articles-and-chapters-518f02a2ecbb


http://pubs.acs.org/isbn/9780841239999

cite:2006-acs-style-guide


* Filtering subsets of a bibtex file

I guess this is basically what bibtex-map-entries does.
#+BEGIN_SRC emacs-lisp :results output
(defun filter-bibtex (bibfile &rest keys)
  "keys are pairs of :field regexp"
  (set-buffer (find-file-noselect bibfile))
  (goto-char (point-min))
  (let ((results '()))
    (bibtex-map-entries
     (lambda (key start end)
       (let ((entry (bibtex-parse-entry))
	     (temp-keys keys))
	 (when
	     (catch 'nomatch
	       (while temp-keys
		 (let ((field (replace-regexp-in-string "^:" "" (symbol-name (car temp-keys))))
		       (regex (cadr temp-keys)))
		   (setq temp-keys (cddr temp-keys))
		   (unless (string-match-p
			    (format "%s" regex) ; use format to get a string
			    (org-ref-reftex-get-bib-field field entry))
		     (throw 'nomatch nil))))
	       t)
	   (add-to-list 'results key)))))
    results))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(filter-bibtex "../../Dropbox/bibliography/references.bib" :author "gellman" :year 2014)
#+END_SRC

#+RESULTS:
| miller-2014-simul-temper |








* Scientific researcher IDs
** ORCID
"ORCID provides a persistent digital identifier that distinguishes you from every other researcher and, through integration in key research workflows such as manuscript and grant submission, supports automated linkages between you and your professional activities ensuring that your work is recognized."

orcid:0000-0003-2625-9232

** Researcher ID
"ResearcherID provides a solution to the author ambiguity problem within the scholarly research community. Each member is assigned a unique identifier to enable researchers to manage their publication lists, track their times cited counts and h-index, identify potential collaborators and avoid author misidentification. In addition, your ResearcherID information integrates with the Web of Science and is ORCID compliant, allowing you to claim and showcase your publications from a single one account."

researcherid:A-2363-2010

One thing I like about ResearcherID is they provide some HTML to give you a dynamic "badge":

#+BEGIN_HTML
<span id='badgeCont777711' style='width:126px'><script src='http://labs.researcherid.com/mashlets?el=badgeCont777711&mashlet=badge&showTitle=false&className=a&rid=A-2363-2010'></script></span>
#+END_HTML

You also get interesting things like my [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid%3DA-2363-2010&mid%3DCollaborationNetwork&cat%3DMap][collaboration map]], and a map of who [[http://labs.researcherid.com/mashlets/rid/mashletsServer.jsp?rid=A-2363-2010&mid=CitationDistribution&cat=Map][cites my work]].

** Scopus ID
I really like Scopus. It does a remarkable job identifying your papers and giving you a Scopus ID. Here is mine: scopusid:7004212771. While it is at it, you can see citation information, h-index, and other things.

** Google Scholar
Who knows who long this will be around (e.g. Google reader, Google Code, Google+, ...). It is pretty easy to use, but it tends to over citations, and to make correspondingly higher h-index (mine is 20 in Google Scholar).

https://scholar.google.com/citations?user=jD_4h7sAAAAJ

** ResearchGate
One nice feature of ResearchGate is it provides a way to serve full text versions of your papers.
https://www.researchgate.net/profile/John_Kitchin

* DONE The orcid api and generating a bibtex file from it
  CLOSED: [2015-03-28 Sat 14:22]
  :PROPERTIES:
  :categories: python,orcid
  :date:     2015/03/28 14:21:59
  :updated:  2015/03/28 14:21:59
  :END:

I found this interesting package [[https://pypi.python.org/pypi/orcid-python][orcid-python 0.1 : Python Package Index]]. Unfortunately, it seems to have some issues and it did not work for me. But, the idea is pretty simple, there is a restful API (see http://members.orcid.org/api/tutorial-retrieve-data-public-api-curl-12-and-earlier) that we can use to retrieve data. We explore that a bit here.

I have an orcid:0000-0003-2625-9232 which contains my data. First, we just retrieve some basic information using Python.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232",
                    headers={'Accept':'application/orcid+json'})

print json.dumps(resp.json(),
                 sort_keys=True,
                 indent=4, separators=(',', ': '))
#+END_SRC
#+RESULTS:
#+begin_example
{
    "message-version": "1.1",
    "orcid-profile": {
        "client-type": null,
        "group-type": null,
        "orcid": null,
        "orcid-activities": {
            "affiliations": null
        },
        "orcid-bio": {
            "applications": null,
            "contact-details": {
                "address": {
                    "country": {
                        "value": "US",
                        "visibility": null
                    }
                },
                "email": []
            },
            "delegation": null,
            "external-identifiers": {
                "external-identifier": [
                    {
                        "external-id-common-name": {
                            "value": "ResearcherID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0001-7707-4137",
                            "uri": "http://orcid.org/0000-0001-7707-4137",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "A-2363-2010"
                        },
                        "external-id-url": {
                            "value": "http://www.researcherid.com/rid/A-2363-2010"
                        }
                    },
                    {
                        "external-id-common-name": {
                            "value": "Scopus Author ID"
                        },
                        "external-id-orcid": {
                            "host": "orcid.org",
                            "path": "0000-0002-5982-8983",
                            "uri": "http://orcid.org/0000-0002-5982-8983",
                            "value": null
                        },
                        "external-id-reference": {
                            "value": "7004212771"
                        },
                        "external-id-url": {
                            "value": "http://www.scopus.com/inward/authorDetails.url?authorID=7004212771&partnerID=MN8TOARS"
                        }
                    }
                ],
                "visibility": null
            },
            "keywords": {
                "keyword": [
                    {
                        "value": "Computational catalysis, electrochemistry, CO2 capture"
                    }
                ],
                "visibility": null
            },
            "personal-details": {
                "family-name": {
                    "value": "Kitchin"
                },
                "given-names": {
                    "value": "John"
                }
            },
            "researcher-urls": {
                "researcher-url": [
                    {
                        "url": {
                            "value": "http://kitchingroup.cheme.cmu.edu"
                        },
                        "url-name": {
                            "value": "Research website"
                        }
                    }
                ],
                "visibility": null
            },
            "scope": null
        },
        "orcid-history": {
            "claimed": {
                "value": true
            },
            "completion-date": {
                "value": 1376581428004
            },
            "creation-method": "WEBSITE",
            "last-modified-date": {
                "value": 1427557747595
            },
            "source": null,
            "submission-date": {
                "value": 1376581211104
            },
            "visibility": null
        },
        "orcid-identifier": {
            "host": "orcid.org",
            "path": "0000-0003-2625-9232",
            "uri": "http://orcid.org/0000-0003-2625-9232",
            "value": null
        },
        "orcid-preferences": {
            "locale": "EN"
        },
        "type": "USER"
    }
}
#+end_example

That information is not too interesting, but it would allow you to scrape out my website, scopus id, and researcher id. Next, we look at the publications orcid knows about for me. These are integrated from a few sources, notably my researcherid:A-2363-2010, scopusid:7004212771, and http://crossref.org.  The next code block prints the bibtex entry for the first few entries. The bibtex entries are not too well formed, and would need some cleaning, but it is a pretty good start.

#+BEGIN_SRC python
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})

results = resp.json()
for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    print result['work-citation']['citation'].encode('utf-8') + '\n'
    if i == 2:
        break
#+END_SRC

#+RESULTS:
: @article{Xu_2015,doi = {10.1021/jp511426q},url = {http://dx.doi.org/10.1021/jp511426q},year = 2015,month = {mar},publisher = {American Chemical Society ({ACS})},volume = {119},number = {9},pages = {4827--4833},author = {Zhongnan Xu and Jan Rossmeisl and John R. Kitchin},title = { A Linear Response {DFT}$\mathplus$ U Study of Trends in the Oxygen Evolution Activity of Transition Metal Rutile Dioxides },journal = {J. Phys. Chem. C}}
:
: @article{Xu_2015,doi = {10.1063/1.4914093},url = {http://dx.doi.org/10.1063/1.4914093},year = 2015,month = {mar},publisher = {{AIP} Publishing},volume = {142},number = {10},pages = {104703},author = {Zhongnan Xu and John R. Kitchin},title = {Relationships between the surface electronic and chemical properties of doped 4d and 5d late transition metal dioxides},journal = {J. Chem. Phys.}}
:
: @article{Boes_2015,doi = {10.1016/j.susc.2015.02.011},url = {http://dx.doi.org/10.1016/j.susc.2015.02.011},year = 2015,month = {mar},publisher = {Elsevier {BV}},author = {Jacob Boes and Peter Kondratyuk and Chunrong Yin and James B. Miller and Andrew J. Gellman and John R. Kitchin},title = {Core level shifts in Cu{\textendash}Pd alloys as a function of bulk composition and structure},journal = {Surface Science}}
:

Let us look at a tabular form of that data so it is sortable. We attempt to remove some duplicates based on the title and doi. The duplicates come about because there is more than one source where this data is pulled from. This is a little tricky, we do a case insensitive title comparison, but that still fails if the titles have different white space in them, e.g. "111" vs "1 1 1", and different sources do that. Also, the DOIs are sometimes missing, and sometimes have different cases, and sometimes are not correct. This code tries to fix most of those issues.

#+BEGIN_SRC python :results org
import requests
import json

resp = requests.get("http://pub.orcid.org/0000-0003-2625-9232/orcid-works",
                    headers={'Accept':'application/orcid+json'})
results = resp.json()

data = []
TITLES, DOIs = [], []

for i, result in enumerate( results['orcid-profile']['orcid-activities']
                            ['orcid-works']['orcid-work']):
    title = str(result['work-title']['title']['value'].encode('utf-8'))
    doi = 'None'

    for x in result.get('work-external-identifiers', []):
        for eid in result['work-external-identifiers']['work-external-identifier']:
            if eid['work-external-identifier-type'] == 'DOI':
                doi = str(eid['work-external-identifier-id']['value'].encode('utf-8'))

    # AIP journals tend to have a \n in the DOI, and the doi is the second line. we get
    # that here.
    if len(doi.split('\n')) == 2:
        doi = doi.split('\n')[1]

    pub_date = result.get('publication-date', None)
    if pub_date:
        year = pub_date.get('year', None).get('value').encode('utf-8')
    else:
        year = 'Unknown'

    # Try to minimize duplicate entries that are found
    dup = False
    if title.lower() in TITLES:
        dup = True
    if (doi != 'None'
        and doi.lower() in DOIs):
        dup = True

    if not dup:
        # truncate title to first 50 characters
        print('| {3} | {0}  | {1} | [[doi:{2}]]|'.format(title[0:50], year, doi, result['work-type']))

    TITLES.append(title.lower())
    DOIs.append(doi.lower())
#+END_SRC

#+RESULTS:
#+BEGIN_SRC org
| JOURNAL_ARTICLE  | A Linear Response DFT+ U Study of Trends in the Ox | 2015 | [[doi:10.1021/jp511426q]]                                |
| JOURNAL_ARTICLE  | Relationships between the surface electronic and c | 2015 | [[doi:10.1063/1.4914093]]                                |
| JOURNAL_ARTICLE  | Core level shifts in Cu–Pd alloys as a function    | 2015 | [[doi:10.1016/j.susc.2015.02.011]]                       |
| JOURNAL_ARTICLE  | Estimating bulk-composition-dependent H2 adsorptio | 2015 | [[doi:10.1021/cs501585k]]                                |
| JOURNAL_ARTICLE  | Probing the Coverage Dependence of Site and Adsorb | 2014 | [[doi:10.1021/jp508805h]]                                |
| JOURNAL_ARTICLE  | Relating the electronic structure and reactivity o | 2014 | [[doi:10.1016/j.catcom.2013.10.028]]                     |
| JOURNAL_ARTICLE  | Electrocatalytic Oxygen Evolution with an Immobili | 2014 | [[doi:10.1021/ja5015986]]                                |
| JOURNAL_ARTICLE  | Identifying Potential BO 2 Oxide Polymorphs for Ep | 2014 | [[doi:10.1021/am4059149]]                                |
| JOURNAL_ARTICLE  | Simulating temperature programmed desorption of ox | 2014 | [[doi:10.1007/s11244-013-0166-3]]                        |
| JOURNAL_ARTICLE  | Probing the effect of electron donation on CO2 abs | 2014 | [[doi:10.1039/c3ra47097k]]                               |
| JOURNAL_ARTICLE  | Effects of concentration, crystal structure, magne | 2014 | [[doi:10.1021/jp507957n]]                                |
| JOURNAL_ARTICLE  | Effects of O 2 and SO 2 on the Capture Capacity of | 2013 | [[doi:10.1021/ie400582a]]                                |
| JOURNAL_ARTICLE  | Number of outer electrons as descriptor for adsorp | 2013 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Interactions in 1-ethyl-3-methyl imidazolium tetra | 2013 | [[doi:http://dx.doi.org/10.1016/j.molstruc.2013.01.046]] |
| JOURNAL_ARTICLE  | Comparisons of amine solvents for post-combustion  | 2013 | [[doi:http://dx.doi.org/10.1016/j.ijggc.2013.06.020]]    |
| JOURNAL_ARTICLE  | Chemical and Molecular Descriptors for the Reactiv | 2012 | [[doi:10.1021/ie301419q]]                                |
| JOURNAL_ARTICLE  | Spectroscopic Characterization of Mixed Fe–Ni Ox   | 2012 | [[doi:10.1021/cs3002644]]                                |
| REPORT           | Modeling Coverage Dependence in Surface Reaction N | 2012 | [[doi:10.2172/1149701]]                                  |
| CONFERENCE_PAPER | Vibrational spectroscopy characterization of CO2-i | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | The role of electrolytes in the oxygen evolution r | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The outlook for improved carbon capture technology | 2012 | [[doi:10.1016/j.pecs.2012.03.003]]                       |
| JOURNAL_ARTICLE  | Structure and Relative Thermal Stability of Mesopo | 2012 | [[doi:10.1111/j.1551-2916.2012.05236.x]]                 |
| JOURNAL_ARTICLE  | Preface: Trends in computational catalysis         | 2012 | [[doi:10.1007/s11244-012-9808-0]]                        |
| CONFERENCE_PAPER | Exergetic analysis of chemical looping reforming   | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Evaluation of a Primary Amine-Functionalized Ion-E | 2012 | [[doi:10.1021/ie300452c]]                                |
| CONFERENCE_PAPER | Electrocatalytic water oxidation using iron-center | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2012 | [[doi:10.1063/1.4746117]]                                |
| BOOK             | Coverage dependent adsorption properties of atomic | 2012 | [[doi:10.1039/9781849734776-00083]]                      |
| CONFERENCE_PAPER | Comparisons of solvents for post-combustion CO2 ca | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Characterization of an ion exchange resin for CO2  | 2012 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Assessing the ability of using first principles to | 2012 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Universality in Oxygen Evolution Electrocatalysis  | 2011 | [[doi:10.1002/cctc.201000397]]                           |
| CONFERENCE_PAPER | The effect of CO 2 partial pressure on capture wit | 2011 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Preparation of Mesoporous La 0.8Sr 0.2MnO 3 infilt | 2011 | [[doi:10.1149/1.3570235]]                                |
| JOURNAL_ARTICLE  | Identification of sulfur-tolerant bimetallic surfa | 2011 | [[doi:10.1021/cs200039t]]                                |
| JOURNAL_ARTICLE  | Effects of strain, d-band filling, and oxidation s | 2011 | [[doi:10.1063/1.3631948]]                                |
| CONFERENCE_PAPER | Determining the conditions necessary for optimal C | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Configurational correlations in the coverage depen | 2011 | [[doi:10.1063/1.3561287]]                                |
| CONFERENCE_PAPER | An electronic structure based understanding of ami | 2011 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | CO2 Adsorption on Supported Molecular Amidine Syst | 2010 | [[doi:10.1002/cssc.201000056]]                           |
| JOURNAL_ARTICLE  | Separation of CO2 from flue gas using electrochemi | 2010 | [[doi:10.1016/j.fuel.2009.11.036]]                       |
| JOURNAL_ARTICLE  | New solid-state table: estimating d-band character | 2010 | [[doi:10.1080/08927022.2010.481794]]                     |
| JOURNAL_ARTICLE  | Simple model explaining and predicting coverage-de | 2010 | [[doi:10.1103/PhysRevB.82.045414]]                       |
| CONFERENCE_PAPER | Intrinsic and extrinsic factors associated with CO | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Electrochemical concentration of carbon dioxide fr | 2010 | [[doi:10.1149/1.3432440]]                                |
| CONFERENCE_PAPER | Catalyzing the catalyst: Hydrogen dissociation and | 2010 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Uncertainty and figure selection for DFT based clu | 2009 | [[doi:10.1080/08927020902833137]]                        |
| JOURNAL_ARTICLE  | Sulphur poisoning of water-gas shift catalysts: Si | 2009 | [[doi:10.1080/08927020902833129]]                        |
| JOURNAL_ARTICLE  | Step decoration of chiral metal surfaces           | 2009 | [[doi:10.1063/1.3096964]]                                |
| JOURNAL_ARTICLE  | Relating the coverage dependence of oxygen adsorpt | 2009 | [[doi:10.1016/j.susc.2009.01.021]]                       |
| JOURNAL_ARTICLE  | Hydrogen Dissociation and Spillover on Individual  | 2009 | [[doi:10.1103/PhysRevLett.103.246102]]                   |
| JOURNAL_ARTICLE  | Correlations in coverage-dependent atomic adsorpti | 2009 | [[doi:10.1103/PhysRevB.79.205412]]                       |
| CONFERENCE_PAPER | Catalyzing the catalyst: Novel pathways to hydroge | 2009 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Atomistic thermodynamics study of the adsorption a | 2009 | [[doi:10.1016/j.jcat.2008.11.020]]                       |
| CONFERENCE_PAPER | Ancillary oxygen-fired combustion using electroche | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Adsorbate Cu interactions and catalyst morphologie | 2009 | [[doi:None]]                                             |
| CONFERENCE_PAPER | <title>Rotational isomeric state theory applied to | 2008 | [[doi:10.1117/12.776303]]                                |
| CONFERENCE_PAPER | The effect of hydration on the adsorption of carbo | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt-decorated electrocatalysts for direct alcohol f | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | PEM-based electrochemical separation of gases      | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | First principles, atomistic thermodynamics for sul | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Evaluating uncertainty in Ab initio phase diagrams | 2008 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | ENVR 1-Basic research needs to assure a secure ene | 2008 | [[doi:None]]                                             |
| OTHER            | Density functional theory studies of alloys in het | 2008 | [[doi:10.1039/b608782p]]                                 |
| JOURNAL_ARTICLE  | Alloy surface segregation in reactive environments | 2008 | [[doi:10.1103/PhysRevB.77.075437]]                       |
| CONFERENCE_PAPER | A first principles evaluation of the role of subst | 2008 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle electrocatalyst synthesis for dire | 2007 | [[doi:None]]                                             |
| CONFERENCE_PAPER | Pt nanoparticle anode electrocatalysts for direct  | 2007 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Response to &quot;comment on 'Trends in the exchan | 2006 | [[doi:10.1149/1.2358292]]                                |
| JOURNAL_ARTICLE  | Trends in the exchange current for hydrogen evolut | 2005 | [[doi:10.1149/1.1856988]]                                |
| JOURNAL_ARTICLE  | Trends in the chemical properties of early transit | 2005 | [[doi:10.1016/j.cattod.2005.04.008]]                     |
| CONFERENCE_PAPER | Alloy surface segregation in reactive environments | 2005 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | The role of adsorbate-adsorbate interactions in th | 2004 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Role of strain and ligand effects in the modificat | 2004 | [[doi:10.1103/PhysRevLett.93.156801]]                    |
| JOURNAL_ARTICLE  | Origin of the overpotential for oxygen reduction a | 2004 | [[doi:10.1021/jp047349j]]                                |
| JOURNAL_ARTICLE  | Modification of the surface electronic and chemica | 2004 | [[doi:10.1063/1.1737365]]                                |
| JOURNAL_ARTICLE  | Elucidation of the active surface and origin of th | 2003 | [[doi:10.1016/j.susc.2003.09.007]]                       |
| JOURNAL_ARTICLE  | A four-point probe correlation of oxygen sensitivi | 2003 | [[doi:10.1016/j.susc.2003.08.041]]                       |
| JOURNAL_ARTICLE  | A comparison of gold and molybdenum nanoparticles  | 2003 | [[doi:10.1016/s0039-6028(02)02679-1]]                    |
| JOURNAL_ARTICLE  | H3PW12O40-functionalized tip for scanning tunnelin | 2002 | [[doi:10.1073/pnas.072514399]]                           |
| JOURNAL_ARTICLE  | Preparation of paramagnetic ligands for coordinati | 1997 | [[doi:None]]                                             |
| JOURNAL_ARTICLE  | Preparation and Characterization of a Bis-Semiquin | 1995 | [[doi:10.1021/jo00117a004]]                              |
| JOURNAL_ARTICLE  | SYNTHESIS AND CHARACTERIZATION OF TRISEMIQUINONE L | 1995 | [[doi:None]]                                             |
#+END_SRC

Not too bad. Clearly we could do a lot more work to fine tune exactly what data we retrieve, and then what to do with it. The tools are all here to do that.

* debugging outshine issue

#+BEGIN_SRC emacs-lisp
outline-regexp
#+END_SRC

#+RESULTS:
: \*+

#+BEGIN_SRC emacs-lisp
(require 'outshine)
#+END_SRC

#+RESULTS:
: outshine

#+BEGIN_SRC emacs-lisp
outline-regexp
#+END_SRC

#+RESULTS:
: \*+

* Finding and handling duplicate bibtex entries
Duplicate bibtex entries in your bibtex file is a problem. Finding them is tricky because minor spelling differences, differences in capitalization, etc... make it difficult to use code to find duplicates. I find it good practice to keep your bibtex file sorted, so that duplicates tend to be near each other, and hence easier to spot. But with a large number of entries, this is still tedious to do.

I have been trying to learn more about the bibtex.el library, so I am going to use this opportunity to write some code for duplicate detection. The idea is to go through each entry, generate a key for it, and see if the key has already been generated. bibtex comes with bibtex-generate-autokey for generating keys automatically.

Here is my bibtex autokey setup. This is a reasonable balance (for me) of almost always generating new keys that are not too long, and with enough information to often tell which reference it is. Every once in a while there are title/author/year combinations that are close enough that the same key is generated, but it is not too frequent.

#+BEGIN_SRC emacs-lisp
;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
#+END_SRC

So, we will just map over our entries looking for places where the same key is generated. We will save markers to these, and generate a clickable link to jump to the places where we suspect duplicates. We will temporarily redefine the key algorithm to make longer, less likely to be the same, keys.

#+BEGIN_SRC emacs-lisp :results output org raw
(let ((bibtex-autokey-year-length 4)
      (bibtex-autokey-names nil)
      (bibtex-autokey-name-year-separator "-")
      (bibtex-autokey-year-title-separator "-")
      (bibtex-autokey-titleword-separator "-")
      (bibtex-autokey-titlewords nil)
      (bibtex-autokey-titlewords-stretch nil)
      (bibtex-autokey-titleword-length nil))
  (dolist (pd (with-current-buffer (find-file-noselect  "~/Dropbox/bibliography/references.bib")
		(let ((possible-duplicates '())
		      (found '()))
		  (bibtex-map-entries
		   (lambda (key start end)
		     (let ((akey (bibtex-generate-autokey)))
                       (unless (not (string= "" akey)) (setq akey key))
		       (if (assoc akey found)
			   (add-to-list
			    'possible-duplicates
			    (list (cons akey (cdr (assoc akey found)))
				  (cons akey (point-marker))))
			 (add-to-list 'found (cons akey (point-marker)))))))
		  possible-duplicates)))
    (princ (format "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][1. %S]] [[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][%S]]\n"
		   (marker-buffer (cdr (nth 0 pd)))
		   (marker-position (cdr (nth 0 pd)))
		   (car (nth 0 pd))
		   (marker-buffer (cdr (nth 1 pd)))
		   (marker-position (cdr (nth 1 pd)))
		   (car (nth 1 pd))))))
#+END_SRC

#+RESULTS:
[[elisp:(progn (switch-to-buffer "references.bib")(goto-char 339249))][1. "jayaramanhillier-2001-construction-reactivity-mapping-platinum-catalyst-gradient-using-scanning-electrochemical-microscope"]] [[elisp:(progn (switch-to-buffer "references.bib")(goto-char 339881))]["jayaramanhillier-2001-construction-reactivity-mapping-platinum-catalyst-gradient-using-scanning-electrochemical-microscope"]]


* A new approach to extracting bibtex file from org

org-ref has a function org-ref-extract-bibtex-entries that uses reftex to build a bibliography from an exported LaTeX file. I have learned a lot since I wrote that code, and in this post illustrate how to avoid the lengthy export process, and use mostly org-mode and built in bibtex functions to extract a bibtex file from org-ref citations.

This paragraph contains a single citation cite:goedecker-2004-minim. A
multicitation cite:kitchin-2002-molyb,kitchin-2004-tunin-the and some articles
cite:xu-2015-linear-respon,boes-2015-estim-bulk-si.

To extract the bibtex entries, we get all the unique keys in the buffer that we have cited.

#+BEGIN_SRC emacs-lisp
(defun get-cite-keys ()
  "Return list of cite keys in current buffer."
  (let ((all-keys '()))
    (org-element-map (org-element-parse-buffer) 'link
      (lambda (link)
	(when (-contains?
	       org-ref-cite-types
	       (org-element-property :type link))
	  (let* ((path (org-element-property :path link))
		 (keys (split-string path ",")))
	    (mapc (lambda (key) (add-to-list 'all-keys key)) keys)))))
    all-keys))

(get-cite-keys)
#+END_SRC
#+RESULTS:
| boes-2015-estim-bulk-si | xu-2015-linear-respon | kitchin-2004-tunin-the | kitchin-2002-molyb | goedecker-2004-minim |

Next we get data structures for each entry in the bibtex files. We will use this to construct the new bibtex file. Here is an example of an a-list we can use. Note, we use add-to-list here, so duplicate keys will be problematic; the second entry will not be included. Since you don't have duplicate entries (right ;) this won't be a big problem.

#+BEGIN_SRC emacs-lisp
(defun get-bibtex-entry-a-list ()
  "Return a-list of (key . entry-string) from files from
`org-ref-find-bibliography'."
  (let ((entries '()))
     (loop for bib-file in (org-ref-find-bibliography)
	   do
	   (with-current-buffer
	     (find-file-noselect bib-file)
	     (bibtex-map-entries
	      (lambda (key start end)
		(add-to-list 'entries (cons key (buffer-substring start end)))))))
     entries))

(cdr (assoc "boes-2015-estim-bulk-si" (get-bibtex-entry-a-list)))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}
#+end_example

Now, we just put these together to get an entry for each key in the current file:

#+BEGIN_SRC emacs-lisp
(let ((entries (get-bibtex-entry-a-list)))
  (mapconcat
   'identity
   (mapcar
    (lambda (key)
      (cdr (assoc key entries)))
    (get-cite-keys))
   "\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example
@article{boes-2015-estim-bulk-si,
  author =	 {Jacob R. Boes and Gamze Gumuslu and James B. Miller and Andrew
                  J. Gellman and John R. Kitchin},
  title =	 {Supporting Information: Estimating Bulk-Composition-Dependent
                  \ce{H2} Adsorption Energies on \ce{Cu_{x}Pd_{1-x}} Alloy (111)
                  Surfaces},
  keywords =	 {orgmode},
  journal =	 {ACS Catalysis},
  volume =	 5,
  pages =	 {1020-1026},
  year =	 2015,
  doi =		 {10.1021/cs501585k},
  url =
                  {http://pubs.acs.org/doi/suppl/10.1021/cs501585k/suppl_file/cs501585k_si_001.pdf},
}

@article{xu-2015-linear-respon,
  author =	 {Xu, Zhongnan and Rossmeisl, Jan and Kitchin, John R.},
  title =	 {A Linear Response {DFT}+{U} Study of Trends in the Oxygen
                  Evolution Activity of Transition Metal Rutile Dioxides},
  keywords =	 {DESC0004031, early-career, orgmode, },
  journal =	 {The Journal of Physical Chemistry C},
  volume =	 119,
  number =	 9,
  pages =	 {4827-4833},
  year =	 2015,
  doi =		 {10.1021/jp511426q},
  url =		 { http://dx.doi.org/10.1021/jp511426q },
  eprint =	 { http://dx.doi.org/10.1021/jp511426q },
}

@phdthesis{kitchin-2004-tunin-the,
  Author =	 {John R. Kitchin},
  Title =	 {Tuning the electronic and chemical properties
of metals: bimetallics and transition metal
carbides},
  School =	 {University of Delaware},
  Year =	 2004}

@MastersThesis{kitchin-2002-molyb,
  author =	 {John R. Kitchin},
  title =	 {Molybdenum nanoclusters on titanium dioxide single crystal surfaces},
  school =	 {University of Delaware},
  year =	 2002}

@article{goedecker-2004-minim,
  author =	 {Stefan Goedecker},
  title =	 {Minima Hopping: An Efficient Search Method for the Global
                  Minimum of the Potential Energy Surface of Complex Molecular
                  Systems},
  journal =	 {J. Chem. Phys.},
  volume =	 120,
  number =	 21,
  pages =	 9911,
  year =	 2004,
  doi =		 {10.1063/1.1724816},
  url =		 {http://dx.doi.org/10.1063/1.1724816},
  date_added =	 {Sat Mar 21 09:58:27 2015},
}
#+end_example

Well, that looks like it. All that is left is writing that string to a file.

#+BEGIN_SRC emacs-lisp
(defun org-ref-create-bib-file-from-org (bib-file)
  "Copy cited references to BIB-FILE."
  (interactive (list (ido-read-file-name "Bib file: " "." nil nil "references.bib")))
  (let ((all-entries (get-bibtex-entry-a-list))
	(content))
    (setq content
	  (mapconcat
	   'identity
	   (mapcar
	    (lambda (key)
	      (cdr (assoc key all-entries)))
	    (get-cite-keys))
	   "\n\n"))
    (with-temp-file bib-file
      (insert content)))
  (find-file bib-file))
#+END_SRC
#+RESULTS:
: org-ref-create-bib-file-from-org


* DONE Restarting org-babel sessions in org-mode more effectively
  CLOSED: [2015-03-19 Thu 18:53]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/03/19 18:53:18
  :updated:  2015/03/19 18:53:18
  :END:

In a previous [[http://kitchingroup.cheme.cmu.edu/blog/2015/03/12/Making-org-mode-Python-sessions-look-better/][post]] I eliminated one annoying problem with sessions, which was getting rid of extraneous Python interpreter characters in the output. Another thing that has bothered me is when you close Emacs, or even the session buffer, the session is, of course, lost. That means when you reopen the file, you have to run each block in order to continue your work. There does not seem to be a selective way to do this in org. So, in this post, we consider a simple approach to automate that. We want a function that will run all the blocks in a current session that are above the current point.


The idea is we will go to the beginning of the buffer, find all blocks that match the language of the block we are in, and in the session, and execute them. We can tell if a block is in a session by looking at the :parameters property of the block. Interestingly, if a block is not in a session, then session will be "none", if it is in an unnamed session, session will be nil, and otherwise, session will be the session name.

| scenario        | :session value |
|-----------------+----------------|
| no session      | "none"         |
| unnamed session | nil            |
| named session   | "name"         |

Here is a function for testing if a block is in a session.

#+BEGIN_SRC emacs-lisp
(defun src-block-in-session-p (&optional name)
  "Return if src-block is in a session of NAME.
NAME may be nil for unnamed sessions."
  (let* ((info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (body (nth 1 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))

    (cond
     ;; unnamed session, both name and session are nil
     ((and (null session)
	   (null name))
      t)
     ;; Matching name and session
     ((and
       (stringp name)
       (stringp session)
       (string= name session))
      t)
     ;; no match
     (t nil))))
#+END_SRC

Now, we need to get some information about the current point and block. We will want to run blocks that start before the current point, but not after. We will use org-element-map to find code blocks, and when the language and session of a code block matches the current block, and the block starts at a point earlier than the current point, then we will go to that block, and run it. Here is that code.

#+BEGIN_SRC emacs-lisp
(defun org-babel-restart-session-to-point (&optional arg)
  "Restart session up to the src-block in the current point.
Goes to beginning of buffer and executes each code block with
`org-babel-execute-src-block' that has the same language and
session as the current block. ARG has same meaning as in
`org-babel-execute-src-block'."
  (interactive "P")
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (let* ((current-point (point-marker))
	 (info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (params (nth 2 info))
         (session (cdr (assoc :session params))))
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-babel-src-block-regexp nil t)
	;; goto start of block
        (goto-char (match-beginning 0))
	(let* ((this-info (org-babel-get-src-block-info))
	       (this-lang (nth 0 this-info))
	       (this-params (nth 2 this-info))
	       (this-session (cdr (assoc :session this-params))))
	    (when
		(and
		 (< (point) (marker-position current-point))
		 (string= lang this-lang)
		 (src-block-in-session-p session))
	      (org-babel-execute-src-block arg)))
	;; move forward so we can find the next block
	(forward-line)))))
#+END_SRC


In the course of testing this, I found this function a little helpful to kill the current session so we start fresh.

#+BEGIN_SRC emacs-lisp
(defun org-babel-kill-session ()
  "Kill session for current code block."
  (interactive)
  (unless (org-in-src-block-p)
    (error "You must be in a src-block to run this command"))
  (save-window-excursion
    (org-babel-switch-to-session)
    (kill-buffer)))
#+END_SRC

And also this one to remove all results in the buffer. This not at all selective, it removes results for session and non-session blocks.

#+BEGIN_SRC emacs-lisp
(defun org-babel-remove-result-buffer ()
  "Remove results from every code block in buffer."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-remove-result))))
#+END_SRC

Ok, now for some testing. The rest of this post is pretty boring, just some blocks of mixed session and non-session to see if they get run. Skip to the [[*Summary]].

#+BEGIN_SRC python :session test  :var d=4
def f(x):
    y = 4 * x
    return y

print(f(d))
#+END_SRC

#+RESULTS:
: 16

Let us put a non-session block in this buffer for testing.

#+BEGIN_SRC python
a = 5
print(a)
#+END_SRC

Now, some more named session blocks.
#+BEGIN_SRC python :session test
print f(5)
#+END_SRC

#+RESULTS:
: 20

#+BEGIN_SRC python :session test
print 'ok'
#+END_SRC

#+RESULTS:
: ok

#+BEGIN_SRC python :session test
print 2
#+END_SRC

#+RESULTS:
: 2

An unnamed session that should not get run in restarting the named test session.

#+BEGIN_SRC python :session
print 886
#+END_SRC


#+BEGIN_SRC python :session test
print f(6)
#+END_SRC

#+RESULTS:
: 24

** Summary
This works pretty well so far.  It would be nice to consider making C-c C-c do this automatically, if the session does not exist, and maybe to take a prefix arg that would restart the session. Maybe on another day ;)

* DONE Clickable links for Twitter handles in Emacs
  CLOSED: [2015-03-18 Wed 12:20]
  :PROPERTIES:
  :categories: emacs
  :date:     2015/03/18 12:20:18
  :updated:  2015/03/18 12:21:53
  :END:

Org-mode has clickable links, and they are awesome. You can make your own links, for example here is a link for twitter handles that opens a browser to the handle, and exports as an html link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type "twitter"
 (lambda (handle)
   (browse-url (concat "http://twitter.com/" handle)))
 (lambda (path desc backend)
   (format "<a href=\"http://twitter.com/%s\">%s</a>" path path)))
#+END_SRC

Check it out here: twitter:johnkitchin.

There is another alternative to make clickable text, and that is the button-lock package. You define a regular expression for the text you want to be clickable, and a function to run when it is clicked. Here is an example.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(button-lock-set-button
 "@\\([-a-zA-Z0-9_:]*\\)"
 (lambda ()
   (interactive)
   (re-search-backward "@")
   (re-search-forward  "@\\([a-zA-Z0-9_]*\\)")
   (let* ((handle (match-string-no-properties 1)))
     (browse-url (concat "http://twitter.com/" handle))))
 :face '(:foreground "red"  :underline t))
#+END_SRC

Check it out: @johnkitchin. Of course, you can make your clicking function more sophisticated, e.g. to give you a [[http://kitchingroup.cheme.cmu.edu/blog/2015/02/22/org-mode-links-meet-hydra/][menu of options]], e.g. to send a tweet to someone, or open the web page, or look them up in your org-contacts. The differences between this and an org-mode link are that this works in any mode, and it has no export in org-mode, so it will go as plain text. Since this is just a feature for Emacs though, that should be fine.


* font-locking to make clickable links for pandoc citations

Org-mode has clickable links, and they are awesome. There is a new citation syntax being discussed, and these too will be clickable. Here we just explore a little approach to make clickable text using the button-lock package. We will use it to make pandoc citations clickable in Emacs. A pandoc citation looks like [@dominik-2010-org-mode].

This code makes pandoc citation links clickable, as you type them in.

#+BEGIN_SRC emacs-lisp :results silent
(require 'button-lock)
(global-button-lock-mode)

(button-lock-set-button
 "@\\([-a-zA-Z0-9_:]*\\)"
 (lambda ()
   (interactive)
   (re-search-backward "@")
   (re-search-forward  "@\\([-a-zA-Z0-9_:]*\\)")
   (let* ((key (match-string-no-properties 1))
	  (bibfile (cdr (org-ref-get-bibtex-key-and-file key))))
     (if bibfile
	(save-excursion
	  (with-temp-buffer
	    (insert-file-contents bibfile)
	    (bibtex-search-entry key)
	    (message (org-ref-bib-citation))))
       (message "No entry found"))))
 :face (list 'org-link))
#+END_SRC

* DONE Update on org-ref - it is now all emacs-lisp
  CLOSED: [2015-03-16 Mon 08:51]
  :PROPERTIES:
  :categories: emacs,orgmode,orgref
  :date:     2015/03/16 08:51:50
  :updated:  2015/03/16 08:51:50
  :END:

The [[https://github.com/jkitchin/org-ref][org-ref]] code is finally all in emacs-lisp! This should make it much easier to install, and is another step closer to getting org-ref into MELPA. Previously, I had written the most significant code in org-mode source blocks that were intended to be tangled out. I found this was not really portable, because what gets tangled depends on your org-mode setup. I had to specifically set example blocks to not tangle, or org-ref would not work for other people, and if I forgot to set a block to tangle, it also would not work for others. That should not happen again now, since there is no more tangling.


There are some relatively new features in org-ref:
1. New colored org-ref links to differentiate them from other
   org-links. Citations are greenish, refs and labels are maroonish.
2. Context messages about links. With your cursor on a cite, ref or label link
   you will get a context message, e.g. a formatted citation, some context about
   the label a ref refers to, or a count of the labels in the mini-buffer.
3. There is now an org-ref menu in the Org menu.
4. There is a new org-ref-help function that opens an org-file of org-ref
   documentation.
5. Pretty thorough integration of helm throughout org-ref, and some integration
   of hydra.
6. A few utility libraries: doi-utils, isbn, wos, pubmed, arxiv, jmax-bibtex, sci-id,
   x2bib. Not all these are new, but if you didn't know about them, check them out.
7. Cask integration. This mostly provides access to testing and dependencies
   right now. org-ref is also now tested continuously at
   https://travis-ci.org/jkitchin/org-ref.

org-ref is basically feature complete I think (which is to say that once again, I do not have any big ideas for new features ;). There are some places where it could be refactored a little, e.g. there are some bibtex only functions in org-ref.el that really should go into jmax-bibtex.el (which also could be renamed). This is a very low priority though, because things are working fine as far as I can tell.

What does it need before going into MELPA? Probably some tests would be a good idea. On Travis, all that is really tested is that it loads with no errors. I would like to see some stability on my end, e.g. at least a week where no commits get made, and no errors are reported. And finally, I would like to make sure I have some time to handle issues that come up when a broader audience is trying it out.

My target date to get this in MELPA is June 1, 2015. Try out the new org-ref, and let me know how it goes!
* PDFsync for org files


\(e^x = 3.14\)

First, we need a way to check if the current buffer has changed since the last time we built so we can avoid unnecessary builds. We can use an md5 sum for this. We will just store the md5 sum in a global variable, so we can compare it at any point in time.

#+BEGIN_SRC emacs-lisp
(md5 (current-buffer))
#+END_SRC

#+RESULTS:
: 62126c8993a8caa7541c42a907660b08

We want our build to happen asynchronously, so we can continue typing. First, we develop the build function.

#+BEGIN_SRC emacs-lisp
(defvar *last-md5* nil "md5 of current buffer")
(defvar *async-building* nil "is a build happening")

(defun async-build ()
  (interactive)
  (cond
   (*async-building*
    (message "Build in progress"))
   ((equal *last-md5* (md5 (current-buffer)))
    (message "No change to build"))
   (t
    (message "building")
    (setq *last-md5* (md5 (current-buffer)))
    (setq *async-building* t)
    (save-buffer)
    (org-latex-export-to-pdf t))))
#+END_SRC
#+RESULTS:
: async-build

That last function will launch an asynchronous build process. We can see the contents and progress of this in this variable.

#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC
#+RESULTS:
| *Org Export Process*                                         | nil   | org-export-process    |
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.pdf | latex | (21752 50592 42735 0) |
| #<killed buffer>                                             | nil   | org-export-process    |


When the export is done,
#+BEGIN_SRC emacs-lisp
org-export-stack-contents
#+END_SRC
#+RESULTS:
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.pdf | latex | (21752 51636 244054 0) |
| /Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.tex | latex | (21752 51630 69022 0)  |
| #<killed buffer>                                             | nil   | org-export-process<10> |
| #<killed buffer>                                             | nil   | org-export-process<9>  |
| #<killed buffer>                                             | nil   | org-export-process<8>  |
| #<killed buffer>                                             | nil   | org-export-process<7>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process<6>  |
| #<killed buffer>                                             | nil   | org-export-process<5>  |
| #<killed buffer>                                             | nil   | org-export-process<4>  |
| #<killed buffer>                                             | nil   | org-export-process<3>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<2>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process<4>  |
| #<killed buffer>                                             | nil   | org-export-process<3>  |
| #<killed buffer>                                             | nil   | org-export-process<2>  |
| #<killed buffer>                                             | nil   | org-export-process<1>  |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |
| #<killed buffer>                                             | nil   | org-export-process     |


We can view the result here in docview.
#+BEGIN_SRC emacs-lisp
(find-file-other-window (caar org-export-stack-contents))
#+END_SRC
#+RESULTS:
: #<buffer blog.pdf>

The last little idea is to create an idle timer to launch the build whenever we are idle. There are some tricks we want to use. First, we need to save the timer so we can cancel it later. Second, we need two timers, one to start the build, and one to check when it is done.

#+BEGIN_SRC emacs-lisp
(defvar async-message-timer1 nil
  "Variable to store the timer in.")

(defvar async-message-timer2 nil
  "Variable to store the timer in.")

;; timer that starts builds when we are idle
(setq async-message-timer1 (run-with-idle-timer 0.5 t 'async-build))

(setq async-message-timer2
      (run-with-idle-timer
       0.5 t
       (lambda ()
	 (when (and (stringp (caar org-export-stack-contents))
		    (file-exists-p (caar org-export-stack-contents))
                    (string= "pdf" (f-ext (caar org-export-stack-contents))))
	   (setq *async-building* nil)
	   (find-file-other-window (caar org-export-stack-contents))))))
#+END_SRC

#+RESULTS:
: [nil 0 0 500000 t (lambda nil (when (and (stringp (caar org-export-stack-contents)) (file-exists-p (caar org-export-stack-contents)) (string= "pdf" (f-ext (caar org-export-stack-contents)))) (setq *async-building* nil) (find-file-other-window (caar org-export-stack-contents)))) nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer async-message-timer1)
(cancel-timer async-message-timer2)
#+END_SRC
#+RESULTS:

* Writing emacs-lisp code with lentic
  :PROPERTIES:
  :categories: emacs
  :END:
org-mode provides a way to do literate programming where you can intermingle code and narrative text. The code can be "tangled" out to the real executable code file. I mostly love this capability, and have used it to write several packages in [[https://github.com/jkitchin/org-ref][jkitchin/org-ref]]. There are some things that are tricky though. I find I have to manage carefully which blocks get tangled explicitly because different setups might have different default tangle behavior. This does allow me to intermingle code, example usage, and even tests in one document.  After it has been tangled, all the narrative text is gone, and separated from what I consider to be the "source". Not everyone is fluent in using org to automatically load code from an org file. Finally, it is not currently possible to distribute org-ref through MELPA or to include it in org because the code is in org-format. I could have some kind of release tool, perhaps a Makefile that tangles the file to make an elisp file, and ideally run some tests on it. I want to avoid this redirection, and keep the source as close to what I use as possible, ideally the same as what I use.

Here we consider [[https://github.com/phillord/lentic][phillord/lentic]], which is an alternative point of view to literate programming. In lentic, you have a source file that is in its native language, e.g. emacs-lisp, but you can create a view of the file as if it was an org-mode file. You can edit either view, and both views are automatically updated in the proper format, i.e. narrative text in org appears as comments in emacs-lisp, and code in emacs-lisp appears in a source block in org. There is only one permanent file, and the views exist temporarily.

Is this useful? The code in the end is functionally equivalent, and a user would never know the difference. It is useful then, if it helps the author write better code, or a maintainer to maintain it. Being both of those for some packages, hopefully this will be useful!

So, lentic works by having some minor markup in the emacs-lisp code that enables it to transform the elisp to an org-file. For example consider this example from the lentic package:
#+BEGIN_SRC emacs-lisp
;;; orgel-org.el --- A test file -*- lexical-binding: t -*-

;; Author: Phillip Lord

;;; Commentary:

;; This is an "orgel" file. That is a valid emacs lisp file with comments in
;; org-mode. The header comments are translated into header one in org mode.


;; #+BEGIN_SRC emacs-lisp
(defun orgel-function ())
;; #+END_SRC

;; And we finish off with the local variables declaration.

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:
#+END_SRC

There is mostly the usual header section, but the code is wrapped in comments that resemble the org-mode code-block. There is also a local variable that is defined when the file is opened. There is a small amount of boiler-plate stuff here, namely the top line and the local variables. I should note that lentic provides a function to insert the local variables for you, and it is bound to "C-c , f", and it even has completion. It is important that the lentic-init variable be defined before you can create a lentic view. This makes for a minor dilemma in starting a new file you want to edit with lentic. When you first create the file you need to create the file and either manually set this variable, or open it and close it. You need this file because it might be possible you prefer a LaTeX file instead of an org-file, or in the future perhaps some other kind of markup like markdown, etc... Maybe the file wouldn't even be emacs-lisp, it could be clojure, or one might hope Python in the future.

Anyway, this brings me to the point of this post, which is to write a little function that generates this boilerplate stuff and creates a lentic view for a new file, or that opens an existing file in my preferred view.

#+BEGIN_SRC emacs-lisp
(defun lentic-open-orgel (base-name)
 "Create a new lentic el file if base-name.el does not exist, or open it if it does.
Create a lentic view with org-file on the right."
 (interactive "sBase name (no extension): ")
 (delete-other-windows)
 (unless (file-exists-p (concat base-name ".el"))
   (with-temp-file (concat base-name ".el")
     (insert
      (format ";;; %s.el ---    -*- lexical-binding: t -*-
;;; Header:

;;; Commentary:

;;; Reminders about lentic:
;; Lentic key binding reminders
;; C-c , h  Move here in other view
;; C-c , s  Swap windows
;; [[elisp:lentic-mode-split-window-right]]  C-c o to open this link and make the view

;;; Code:

;;; %s.el ends here

;; # Local Variables:
;; # lentic-init: lentic-orgel-org-init
;; # End:" base-name base-name))))
 (find-file (concat base-name ".el"))
 (lentic-mode-split-window-right))
#+END_SRC
#+RESULTS:
: lentic-open-orgel

#+BEGIN_SRC emacs-lisp
(lentic-open-orgel "test-orgel")
#+END_SRC

Time will tell if I use this often. Maybe there are other simpler ways to do this that bypass the local variables. The lentic source uses a directory variable, but that is nearly the same except that it might have less impact on the distributed code. In any case, I really like this idea.

* Exceptions on entering a context manager

#+BEGIN_SRC python
class WithContext(object):
    def __init(self, context):
        print('within context init({0})'.format(context))

    def __enter__(self):
        print('Entering')

        try:
            raise Exception('NotImplemented')
        except:
            self.__exit__('exception in enter')
            raise

    def __exit__(self, *args):
        print('Exiting with {0}'.format(args))
        return False

with WithContext() as c:
    print("running context test")
#+END_SRC

#+RESULTS:

* Find value in column 2 corresponding to maximum of column 4

#+tblname: tab-data
| Menge (x) | P(x) |   E(x) |   K(x) |  Gewinn |
|-----------+------+--------+--------+---------|
|         0 |   20 |   0.00 | 140.00 | -140.00 |
|        10 |   18 | 180.00 | 180.00 |    0.00 |
|        20 |   16 | 320.00 | 220.00 |  100.00 |
|        30 |   14 | 420.00 | 260.00 |  160.00 |
|        40 |   12 |    100 |    158 |      50 |



#+BEGIN_SRC emacs-lisp :var data=tab-data :results code
(let ((c4 (mapcar (lambda (x) (nth 4 x)) data))
      (c2 (mapcar (lambda (x) (nth 2 x)) data)))
   (nth (-elem-index (-max c4) c4) c2))
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
420.0
#+END_SRC


org-table-get-field
(org-table-next-row)
(org-table-goto-column
(org-table-current-column)

#+BEGIN_SRC emacs-lisp
(defun jt ()
 "find max in column, message the corresponding value in column 3."
 (interactive)
 (let ((max (string-to-number (org-table-get-field)))
       (row (org-table-current-line)))
   (while (org-table-next-row)
     (when (>  (string-to-number (org-table-get-field)) max)
       (setq max (string-to-number (org-table-get-field))
	     ind (org-table-current-line))))
   (org-table-goto-line ind)
   ; columns start at 1?
   (org-table-goto-column 3)
   (message-box "%s" (org-table-get-field))))
#+END_SRC

#+RESULTS:
: jt

* Wrapping selected text into an org-block
** Wrap selected text in an org block
:PROPERTIES:
:EXPORT_TITLE: An Interesting Article
:EXPORT_AUTHOR: Simon Jones
:EXPORT_FILE_NAME: an-interesting-article
:EXPORT_DATE: 2015-02-16
:END:


#+BEGIN_SRC emacs-lisp
(defun export-subtree ()
 (interactive)
 (let ((fname  (concat (org-entry-get (point) "EXPORT_FILE_NAME") ".org"))
       (author (org-entry-get (point) "EXPORT_AUTHOR"))
       (title (org-entry-get (point) "EXPORT_TITLE"))
       (date (org-entry-get (point) "EXPORT_DATE"))
       (content (progn (set-buffer (org-org-export-as-org nil t t))
                   (buffer-string))))
   ;; warning you can delete something unintentionally
   (when (file-exists-p fname) (delete-file fname))
   (find-file fname)
   (insert "#+TITLE: " title "\n")
   (insert "#+AUTHOR: " author "\n")
   (insert "#+DATE: " date "\n")
   (insert "\n" content)
   ;; remove properties drawer. Kind of hacky.
   (goto-char (point-min))
   (re-search-forward ":PROPERTIES:")
   (setf (buffer-substring
	  (org-element-property :begin (org-element-context))
	  (org-element-property :end (org-element-context)))
           "")
   (save-buffer)))

(export-subtree)
#+END_SRC

#+RESULTS:



#+BEGIN_SRC emacs-lisp
(defun wrap-text-in-org-block (start end)
  (interactive "r")
  (goto-char end)
  (insert "\n#+END_QUOTE\n")
  (goto-char start)
  (insert "\n#+BEGIN_QUOTE:\n"))
#+END_SRC


#+BEGIN_QUOTE:
TEstesat
#+END_QUOTE

* Command line export of a section in an org-file
#+LATEX_CLASS: article
#+BEGIN_SRC emacs-lisp :tangle export-org-section :shebang #!/bin/sh
:;exec emacs -batch  -l ~/Dropbox/kitchingroup/jmax/init.el -l "$0" "$@"

;; usage: export-org-section section-id org-file

;; now goto, narrow and export the section
(let ((section-id (pop command-line-args-left))
      (org-file (pop command-line-args-left)))
  (print (format "Opened %s" org-file))
  (find-file (expand-file-name org-file))
  (org-open-link-from-string (format "[[#%s]]" section-id))
  (org-narrow-to-subtree)
  (org-latex-export-to-pdf)
)
#+END_SRC


#+BEGIN_SRC sh :results silent
rm -f blog.pdf
./export-org-section sec-2 blog.org
open blog.pdf
#+END_SRC

** Test section 1
   :PROPERTIES:
   :CUSTOM_ID: sec-1
   :END:

Some words and an equation \(e^x-1=0\).


** Test section 2
   :PROPERTIES:
   :CUSTOM_ID: sec-2
   :END:

Some words and a table:

| a | b |
|---+---|
| 9 | 8 |
| 8 | 8 |


#+BEGIN_SRC emacs-lisp :tangle test2 :shebang #!/bin/sh
#!/bin/sh
":"; exec emacs --script "$0" "$@" # -*- mode: emacs-lisp; lexical-binding: t; -*-
(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(main)
;; Local Variables:
;; mode: emacs-lisp
;; End:
#+END_SRC


#+BEGIN_SRC sh
./test2 arg1 arg2 arg3
#+END_SRC
#+RESULTS:
:
: "GNU Emacs 25.0.50.1 (x86_64-apple-darwin13.4.0, NS appkit-1265.21 Version 10.9.5 (Build 13F34))
:  of 2015-01-18 on vpn-128-237-146-193.library.vpn.cmu.edu"
:
: "I did it. you passed in (arg1 arg2 arg3)"
* About face

You have probably wondered why some words are colored in Emacs and wondered how some text behaves like a link. That happens from font locking. Here we look at some ways you can modify this behavior too.

Following and lightly adapting the example here [[info:emacs#Font%20Lock][info:emacs#Font Lock]], we can add some keywords that get highlighted for us like this:

#+BEGIN_SRC emacs-lisp :results silent
(font-lock-add-keywords
 nil  ;; mode, nil for current buffer
 '(("FIXME"  ; regexp with group you want to match
    'font-lock-warning-face	; the face to use
)))
#+END_SRC

FIXME some text. FIXME again. It works!

How do you know what faces are available? M-x list-faces-display will give you a nice buffer of face names you can choose from. Let's do one better though, and create our own face.

#+BEGIN_SRC emacs-lisp
(defface my-face
  '((t		; display type
     (:background "yellow" :foreground "black")))
     "My custom face.")

(font-lock-add-keywords
 'org-mode  ;; mode, nil for current buffer
 '(("BROKEN"  ; regexp with group you want to match
    0
    'my-face	; the face to use
)))
#+END_SRC

#+RESULTS:


 BROKEN  fdsafdFIXME



* Count headlines in current level


#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (1- (length
   (org-element-map
       (org-element-parse-buffer)
       'headline
     (lambda (x) 1)))))
#+END_SRC

#+RESULTS:
: 5

** one
** two
*** three
**** four
** five

* org-element-explorer
  :PROPERTIES:
  :CATEGORY: emacs
  :END:

#+OPTIONS: toc:nil ^:{}

#+TITLE: org-element-explorer

#+caption: some table.
| 2 | 4 |
| e | r |
| 5 | 6 |

cite:shi-2007-first-au

#+caption: image caption
#+label: citations
[[./images/2014-citations.png]]


\( sin(x) = 5\)

#+BEGIN_EXAMPLE
example
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defvar org-ref-last-mouse-pos nil
 "Stores last mouse position for use in `org-ref-mouse-message'.")

(defun can-move-p ()
  "See if a character is under the mouse. If so return the position for `goto-char'."
  (let* ((line (cddr org-ref-last-mouse-pos))
	 (col  (cadr org-ref-last-mouse-pos)))
    (save-excursion
      (goto-char (window-start))
      (forward-line line)
      (if
	  (> (- (line-end-position) (line-beginning-position)) col)
	  (progn  (forward-char col) (point))
	nil))))

(defun org-element-explorer ()
  "Display buffer with org-element context under mouse cursor."
  (interactive)

        (let ((context (org-element-context))
              (cb (current-buffer)))
	  (switch-to-buffer "*org-element*")
	  (erase-buffer)
	  (emacs-lisp-mode)
	  (insert (format "%s"  context))
	  (goto-char (point-min))
	  (while (re-search-forward ":" nil t)
	    (backward-char)
	    (insert "\n")
	    (forward-char))
	  (goto-char (point-min))
	  (special-lispy-multiline)
	  (switch-to-buffer cb)
          ))

(add-hook 'post-command-hook 'org-element-explorer nil t)
;(remove-hook 'post-command-hook 'org-element-explorer)
#+END_SRC

#+RESULTS:
| org-element-explorer | whitespace-post-command-hook | t | flyspell-post-command-hook |

** TODO a subheading
   SCHEDULED: <2015-01-28 Wed> DEADLINE: <2015-01-29 Thu>

* Getting messages about the link under the mouse cursor
Now that I have set up org-ref to give minibuffer messages when the cursor is on a link, I thought, why can't this happen when I mouse over a link. I am likely to just mouse over links while reading them, and not necessarily have the cursor moving. Well, here is the idea. We can get the mouse position, which is approximately the number of lines from the top of the frame, and a number of characters from the beginning of a line. A trick is that there may not be a character at that position, if the line is shorter than those characters. So, we will have to calculate from the mouse position whether there is a character where the mouse is.

Another trick is we don't want to remessage our selves constantly, so we will store the last mouse position, and not do anything unless it changes.

An idle timer does not do what we want here. Apparently, idle refers to the cursor, not the mouse. I use a regular timer here, and run it every 1/2 second. I don't notice any performance issues with this.

#+BEGIN_SRC emacs-lisp
efvar org-ref-last-mouse-pos nil
 "Stores last mouse position for use in `org-ref-mouse-message'.")

(defun can-move-p ()
  "See if a character is under the mouse. If so return the position for `goto-char'."
  (let* ((line (cddr org-ref-last-mouse-pos))
	 (col  (cadr org-ref-last-mouse-pos)))
    (save-excursion
      (goto-char (window-start))
      (forward-line line)
      (if
	  (> (- (line-end-position) (line-beginning-position)) col)
	  (progn  (forward-char col) (point))
	nil))))

(defun org-ref-mouse-message ()
  "Display message for link under mouse cursor"
  (interactive)
  (when (not (equal (mouse-position) org-ref-last-mouse-pos))
    (setq org-ref-last-mouse-pos (mouse-position))
    (when (can-move-p)
      (save-excursion
	(goto-char (can-move-p))
	(org-ref-link-message)))))


(setq org-ref-message-timer-mouse
       (run-at-time "0.5 sec" 0.5 'org-ref-mouse-message))

;(cancel-timer org-ref-message-timer-mouse)
#+END_SRC

#+RESULTS:
: [nil 21706 25351 779030 0.5 org-ref-mouse-message nil nil 0]

Ok, that is the code. Here are some links to test it out.

ref:icon


label:icon


cite:shi-2007-first-au

cite:needs-1989-calcul,jarvi-2008-devel-reaxf

It looks like it worked pretty well for me!




* org to org


http://google.com

mailto:jkitchin@andrew.cmu.edu



one citation cite:shi-2007-first-au


multi-citation cite:shi-2007-first-au,jarvi-2008-devel-reaxf,kondratyuk-2013


pre and post text  [[cite:grimme-2006-semiem-gga][See::page 34]]


Just pre text [[cite:marjolin-2015-therm-descr][See also]]

#+BEGIN_SRC emacs-lisp
(defun pandoc-cite-format (link contents info)
  (if (-contains? org-ref-cite-types  (org-element-property :type link))
      (cond
       ;; link with description
       ((org-element-property :contents-begin link)
	(let* ((contents (buffer-substring
			  (org-element-property :contents-begin link)
			  (org-element-property :contents-end link)))
	       (split (split-string contents "::"))
	       (pre-text (nth 0 split))
	       (post-text (nth 1 split)))
	  (concat
	   "[@" (org-element-property :path link)
	   (when pre-text (concat ", " pre-text))
	   (when post-text (concat ", " post-text))
	   "]"
	   )
	  ))
       ;; plain citations
       (t
	(concat "["
	      (mapconcat (lambda (key) (concat "@" key))
			 (split-string (org-element-property :path link) ",")
			 "; ")
	      "]")))
    ;; not a cite link. just return the original link
    (org-org-identity link contents info)))

(org-export-define-derived-backend 'pandoc-org 'org
  :translate-alist '((link . pandoc-cite-format)))

(find-file (org-export-to-file 'pandoc-org "org-to-org.org"))
#+END_SRC

#+RESULTS:





* exploring Zotero sqlite

#+BEGIN_SRC sh
cp /Users/jkitchin/Library/Application\ Support/Zotero/Profiles/hiro2nsy.default/zotero/zotero.sqlite .
#+END_SRC

#+RESULTS:

What tables do we have?
#+BEGIN_SRC sqlite :db zotero.sqlite :list
.tables
#+END_SRC

#+RESULTS:
#+begin_example
annotations                itemNotes
baseFieldMappings          itemSeeAlso
baseFieldMappingsCombined  itemTags
charsets                   itemTypeCreatorTypes
collectionItems            itemTypeFields
collections                itemTypeFieldsCombined
creatorData                itemTypes
creatorTypes               itemTypesCombined
creators                   items
customBaseFieldMappings    libraries
customFields               proxies
customItemTypeFields       proxyHosts
customItemTypes            relations
deletedItems               savedSearchConditions
fieldFormats               savedSearches
fields                     settings
fieldsCombined             storageDeleteLog
fileTypeMimeTypes          syncDeleteLog
fileTypes                  syncObjectTypes
fulltextItemWords          syncedSettings
fulltextItems              tags
fulltextWords              transactionLog
groupItems                 transactionSets
groups                     transactions
highlights                 translatorCache
itemAttachments            users
itemCreators               version
itemData                   zoteroDummyTable
itemDataValues
#+end_example

Best I can tell, items contains a list of our items. Although, this db should have 4 items. presumably it kept some things I deleted.

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemID,key from items;
#+END_SRC
#+RESULTS:
: 1|ABCD2345
: 2|ABCD3456
: 3|95VXFTCD
: 4|TKAZVJDH
: 5|NMW5IEF2
: 6|EU3FEG47

This lists the fields defined in item 3, itemid, fieldid, valueid

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select itemData.itemID, fields.fieldName, itemDataValues.value from itemData
inner join ItemDataValues
on itemData.valueID == itemDataValues.valueID
inner join fields
on fields.fieldID == itemData.fieldID
where itemData.itemID==3;
#+END_SRC
#+RESULTS:
#+begin_example
3|url|http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5756277
3|volume|13
3|issue|3
3|pages|66-73
3|publicationTitle|Computing in Science & Engineering
3|ISSN|1521-9615
3|date|2011-05-00 05/2011
3|DOI|10.1109/MCSE.2011.41
3|accessDate|2015-01-27 23:27:14
3|libraryCatalog|CrossRef
3|title|Active Documents with Org-Mode
#+end_example

To get the authors:

#+BEGIN_SRC sqlite :db zotero.sqlite :list
select firstName, lastName from creatorData
inner join itemCreators
on itemCreators.creatorID == creatorData.creatorDataID
where itemCreators.itemID==3;
#+END_SRC

#+RESULTS:
: Eric|Schulte
: Dan|Davison


* Revisiting tooltips on cite links
This is not going to work permanently. maybe i could map over the links and put some properties on though.

(insert (propertize "cite:kondratyuk-2013"
                          'help-echo "testing"))cite:kondratyuk-2013

cite:

cite:kondratyuk-2013

These links work in the code block, but not in org.

#+BEGIN_SRC emacs-lisp
(insert (concat "cite:"
(mapconcat
(lambda (key)
 (propertize key 'help-echo (org-ref-get-bibtex-entry-citation key)))
'("kondratyuk-2013" "paier-2006-errat" "marjolin-2015-therm-descr")
",")))cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr

#+END_SRC

#+RESULTS:
:


cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr

(setq tooltip-use-echo-area nil)
cite:kondratyuk-2013,paier-2006-errat,marjolin-2015-therm-descr


#+BEGIN_SRC emacs-lisp
(defun org-ref-cite-link-p () (interactive)
       (let* ((object (org-element-context))
	      (type (org-element-property :type object)))
	 ;;   We only want this to work on citation links
	 (when (-contains? org-ref-cite-types type)
	   (message (org-ref-get-citation-string-at-point)))))

(add-hook 'post-command-hook 'cite-link-p)
;(remove-hook 'post-command-hook 'cite-link-p)
#+END_SRC

#+RESULTS:
| cite-link-p | matlab-start-block-highlight-timer |


* Helm source for headings with TODO


For a helm source we need a list of cons cells that have a car of a selection, and a cdr that corresponds to that selection.

#+BEGIN_SRC emacs-lisp :results raw
(defun helm-todo-candidates ()
  (let ((results '()))
    (org-map-entries
     (lambda ()
       (add-to-list 'results
		    (cons
		     (concat (make-string (nth 1 (org-heading-components)) ?*)
			     " TODO "
			     (nth 4 (org-heading-components)))
		     (point-marker))))
     "TODO=\"TODO\"")
    results))

(helm-todo-candidates)
#+END_SRC

#+RESULTS:
((** post it . #<marker at 977 in blog.org>) (** work it out . #<marker at 941 in blog.org>))

Now to run helm, there is a subtle point. We need to map the current buffer /before/ running helm, otherwise we will map an empty helm buffer.

#+BEGIN_SRC emacs-lisp
(defun helm-todo ()
  "Helm interface to headlines with TODO status in current buffer."
  (interactive)
  (let ((candidates (helm-todo-candidates)))
    (setq helm-todo-source '((name . "TODO headlines")
			     (candidates . candidates)
			     (action . (("open" . goto-char)))))
    (helm :sources '(helm-todo-source))))

(helm-todo)
#+END_SRC

#+RESULTS:

Now, let us expand the idea to a helm-agenda. We want a function that prompts for a match criteria, then presents a helm buffer to select matching entries in your agenda files.

#+BEGIN_SRC emacs-lisp
(defun helm-agenda-candidates (query)
  (let ((results '()))
    (mapc (lambda (f)
      (with-current-buffer (find-file-noselect f)
	(org-map-entries
	 (lambda ()
	   (add-to-list 'results
			(cons
			 (concat
			  (file-name-nondirectory f) " | "
			  (make-string (nth 1 (org-heading-components)) ?*)
			  " "
			  (org-get-heading))
			 (point-marker))))
	 query))) (org-agenda-files))
    results))


(defun helm-query-agenda (query)
  "Helm interface to headlines with TODO status in current buffer."
  (interactive "sQuery: ")
  (let ((candidates (helm-agenda-candidates query)))
    (helm :sources '(((name . "TODO headlines")
		      (candidates . candidates)
		      (action . (("open" . (lambda (m)
					     (switch-to-buffer (marker-buffer m))
					     (goto-char m)
					     (show-children))))))))))
#+END_SRC

#+RESULTS:

** TODO work it out
** DONE test it
** TODO post it



* Copy the bibtex entry for a link to a new file
Sometimes I am reading a document with citations from org-ref in it, and I want to copy the bibtex entry for that link from the file it is in to a new file. Right now, I have to click on the link, open the entry, copy the file, open the new file, and paste it. Here we develop a function that does all that.

Some functions will help us with this. First, org-ref-open-citation-at-point will open the bibtex file with the point in the entry. Second, bibtex-copy-entry-as-kill will copy the entry to the bibtex-entry-kill-ring. Finally bibtex-yank will put the entry in the new file we select. We should try not to add entries if there is already a key present in the file.

A subtlety is the function should not take an argument, so it can work in our cite menu, but it needs an interactive file selection to say where the entry is copied to.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-at-point-to-file ()
  "Copy the bibtex entry for the citation at point to NEW-FILE.
Prompt for NEW-FILE includes bib files in org-ref-default-bibliography, and bib files in current working directory. You can also specify a new file."
  (interactive)
  (let ((new-file (ido-completing-read
		   "Copy to bibfile: "
		   (append org-ref-default-bibliography
			   (f-entries "." (lambda (f) (f-ext? f "bib"))))))
	(key (org-ref-get-bibtex-key-under-cursor)))
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (bibtex-copy-entry-as-kill))

    (let ((bibtex-files (list (file-truename new-file))))
      (if (assoc key (bibtex-global-key-alist))
	  (message "That key already exists in %s" new-file)
	;; add to file
	(save-window-excursion
	  (find-file new-file)
	  (goto-char (point-max))
          ;; make sure we are at the beginning of a line.
	  (unless (looking-at "^") (insert "\n\n"))
	  (bibtex-yank)
	  (save-buffer))))))
#+END_SRC

#+RESULTS:
: #<marker at 1038 in blog.org>

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("y" "Copy entry to file" org-ref-copy-entry-at-point-to-file) t)
#+END_SRC

We might also want to copy a short summary to the clipboard, so we could readily paste it somewhere. Here is one way to do it. You might prefer (bibtex-copy-summary-as-kill) instead.

#+BEGIN_SRC emacs-lisp
(defun org-ref-copy-entry-as-summary ()
  "Copy the bibtex entry for the citation at point as a summary."
  (interactive)
    (save-window-excursion
      (org-ref-open-citation-at-point)
      (kill-new (org-ref-bib-citation))))
#+END_SRC
#+RESULTS:
: org-ref-copy-entry-as-summary

#+BEGIN_SRC emacs-lisp
(add-to-list
'org-ref-user-cite-menu-funcs
       '("s" "Copy summary" org-ref-copy-entry-as-summary) t)
#+END_SRC

Here is a citation to test these out on cite:mehta-2014-ident-poten.

They seem to work! These are built in to org-ref now, so if you update to the latest version they should work for you too.

* A voting system for org-mode headlines

Over on [[http://stackoverflow.com/questions/27937446/how-to-vote-for-a-heading-in-org-mode][Stack Overflow]] someone wanted a system to "vote" for headlines. Basically they have a lot of headlines, and they want a +1 feature that will set a VOTES property on a headline. Then, they could filter the headlines by some voting criteria. Org-mode is made for that kind of thing, but we have to implement it ourselves. We just need to define a function that sets the property. The only subtle points in this are that properties are defined as strings, and we have to put a string in the property. That means we have to convert the string to a number, increment it, and convert it back to a string. We also add an org-mode speed command to + so when our cursor is at the beginning of the headline, we just press + to increment the VOTES property.

#+BEGIN_SRC emacs-lisp
(defun plusone ()
  "Increase the VOTES property in an org-heading by one. Create
the property if needed."
  (interactive)
  (org-entry-put
   (point)
   "VOTES"
   (format "%s" (+ 1 (string-to-number
		      (or
		       (org-entry-get (point) "VOTES")
		       "0"))))))

(add-to-list 'org-speed-commands-user '("+" . (plusone)))
#+END_SRC

#+RESULTS:
| + | quote | plusone |

Now some test headlines. We can use the agenda to filter headlines. Here is the agenda command that is equivalent to the key sequence "C-c a < m". Type in VOTES>2, for example, to see headlines that have more than two votes.

#+BEGIN_SRC emacs-lisp
(org-agenda nil "m" "<")
#+END_SRC

** heading 1
   :PROPERTIES:
   :VOTES:    2
   :END:
** heading 2
   :PROPERTIES:
   :VOTES:    5
   :END:
** heading 3
   :PROPERTIES:
   :VOTES:    1
   :END:




* vtk

#+BEGIN_SRC python
import vtk
from ase.cluster.icosahedron import Icosahedron
from ase.io import write
from ase.visualize import view

# With almost everything else ready, its time to initialize the renderer and window, as well as creating a method for exiting the application
renderer = vtk.vtkRenderer()
renderWin = vtk.vtkRenderWindow()
renderWin.AddRenderer(renderer)
renderInteractor = vtk.vtkRenderWindowInteractor()
renderInteractor.SetRenderWindow(renderWin)



atoms = Icosahedron('Au', noshells=3)

from ase.visualize.vtk.atoms import vtkAtoms

va = vtkAtoms(atoms)
va.add_actors_to_renderer(renderer)


renderInteractor.Initialize()
# Because nothing will be rendered without any input, we order the first render manually before control is handed over to the main-loop.
renderWin.Render()
renderInteractor.Start()
#+END_SRC

#+RESULTS:


* bullet

notes about this mail: [[mu4e:msgid:CANniJEwZu8UcvbB6G%2B0Q%2Be_ZYQNFUsw9DJxxVg9cfKvSnoSQOw@mail.gmail.com][{O} Getting beginning postiion of a description list]]

- foo :: bar    (goto-char (org-element-property :contents-begin (org-element-at-point)))
-     baz :: goo
- 1 egg
- 0.5 cups
- :punc

#+BEGIN_SRC emacs-lisp
(defun gg ()
 (interactive)
 (beginning-of-line)
 (forward-word)
 (backward-word)
 (while (not (looking-at " "))
   (backward-char)))
#+END_SRC


#+BEGIN_SRC emacs-lisp
; display element at point as a message.
(defun eap ()
  (interactive)
  (message "%s" (org-element-at-point)))


(defun gg ()
(interactive)
(when (eq (car (org-element-at-point)) 'item)
(message-box "on item")
(goto-char (org-element-property :end (org-element-at-point)))))

(add-hook 'post-command-hook 'eap)
(remove-hook 'post-command-hook 'eap)
#+END_SRC

#+RESULTS:
| eap |

* wok3
from https://github.com/mstrupler/WOS3/blob/master/wok3.py

#+BEGIN_SRC python :tangle wok3.py
# -*- coding: utf-8 -*-
"""
Created on Wed Aug 27 10:12:00 2014

@author: mathiasstrupler
"""


import sys
import re
import datetime

#try:
#    import urllib2
#except ImportError:
#    print('We need urllib2, sorry...')
#    sys.exit(1)

try:
    from suds.client import Client
except ImportError:
    print('We need suds.client, sorry...')
    sys.exit(1)

try:
    import xml.etree.ElementTree as ET
except ImportError:
    print('We need xml.etree.ElementTree, sorry...')
    sys.exit(1)

class Error(Exception):
    """Base class for any wok3 error."""

class SearchQueryError(Error):
    """You need to set a user query"""

class Edition(object):
    """
    This class is only used to let you know easily all the databases
    that can be searched in World of sciences
    example : wokSearch.setEdition(Edition.SCI)
    """
    SCI   = {'collection' : 'WOS', 'edition' : 'SCI'}    #Science Citation Index Expanded
    SSCI  = {'collection' : 'WOS', 'edition' : 'SSCI'}   #Social Sciences Citation Index
    AHCI  = {'collection' : 'WOS', 'edition' : 'AHCI'}   #Arts & Humanities Citation Index
    ISTP  = {'collection' : 'WOS', 'edition' : 'ISTP'}   #Conference Proceedings Citation Index - Science
    ISSHP = {'collection' : 'WOS', 'edition' : 'ISSHP'}  #Conference Proceedings Citation Index - Social Sciences
    IC    = {'collection' : 'WOS', 'edition' : 'IC'}     #Index Chemicus
    CCR   = {'collection' : 'WOS', 'edition' : 'CCR'}    #Current Chemical Reactions
    BSCI  = {'collection' : 'WOS', 'edition' : 'BSCI'}   #Book Citation Index - Science
    BHCI  = {'collection' : 'WOS', 'edition' : 'BHCI'}   #Book Citation Index - Social Sciences and Humanities


class SearchRespAnalyzer(object):
    """
    This class is used to parse the soap answer received
    after a search request
    """
    def __init__(self,searchResp):
        self._searchResp = searchResp

    def toDict(self):
        """
        This method parse the answer into a dictonnary
        It does not retreive all the information that gives WOS
        It looks for the following info:
            UID : WOS identifier
            title : Title of the document
            journal : Name of the journal
            year : Year of publication
            volume : Volume
            issue : Issue
            page : page [begin, end]
            authors : list of author dict {name, dais_id, affiliations list}
            language : primary language of the document
            docType : document type (article, review, book,...)
            publisher : name of the publisher
        """

        ans = {'records' : [] }
        records = re.sub(' xmlns="http://scientific.thomsonreuters.com/schema/wok5.4/public/FullRecord"', '', self._searchResp.records, count=1)
        #records = re.sub(' r_id_disclaimer="ResearcherID data provided by Thomson Reuters"', '', resp.records, count=resp.recordsFound)
        recordsTree = ET.fromstring( records)
        for rec in recordsTree.iter('REC'):
            #retreive UID
            record = {'UID' : rec.find('UID').text}
            #retreive title and journal name
            record['title'] = None
            record['journal'] = None
            for title in rec.findall('static_data/summary/titles/title'):
                if title.attrib['type'] == 'item':
                    record['title'] = title.text
                if title.attrib['type'] == 'source':
                    record['journal'] = title.text
            #retreive publication information
            pubinfo = rec.find('static_data/summary/pub_info').attrib
            record['year'] = pubinfo['pubyear']
            record['volume'] = pubinfo['vol']
            if 'issue' in  pubinfo:
                record['issue'] = pubinfo['issue']
            else:
                record['issue'] = ''
            page = rec.find('static_data/summary/pub_info/page').attrib
            if 'begin' in  page:
                record['page'] = [page['begin'],page['end']]
            else:
                record['page'] = []
            #retreive author list
            record['authors'] = []
            for name in rec.findall('static_data/summary/names/name'):
                if name.attrib['role']=='author':
                    author = {'name' : ''}
                    if name.find('wos_standard') is not None:
                        author['name'] = name.find('wos_standard').text
                    elif name.find('display_name') is not None:
                        author['name'] = name.find('display_name').text
                    elif name.find('full_name') is not None:
                        author['name'] = name.find('full_name').text
                    if 'dais_id' in name.attrib:
                        author['dais_id'] = name.attrib['dais_id']
                    author['affiliation']=[]
                    record['authors'].append(author)
            #retrieve publication language
            record['language'] = None
            for language in rec.findall('static_data/fullrecord_metadata/languages/language'):
                if language.attrib['type']=='primary':
                    record['language'] = language.text
            #retrieve adressess
            affiliations = []
            for adresses in rec.findall('static_data/fullrecord_metadata/addresses/address_name'):
                affiliations.append({'nb' : adresses.find('address_spec').attrib['addr_no'],'add' : adresses.find('address_spec/full_address').text})
            record['affiliations'] = affiliations
            if len(affiliations)==1:
                for author in record['authors']:
                    author['affiliation']=[affiliations[0]['add']]
            if len(affiliations)>=1:
                aff_names = rec.findall('static_data/fullrecord_metadata/addresses/address_name/names/name')
                aff_names_list = []
                for aff_name in aff_names:
                    tmp = {'nb' : aff_name.attrib['addr_no'], 'name' : aff_name.find('wos_standard').text}
                    aff_names_list.append(tmp)
                for author in record['authors']:
                    for name in aff_names_list:
                        if author['name'] == name['name']:
                            author['affiliation'].append(name['nb'])

            #retrieve doctype
            record['docType'] = []
            for docType in rec.findall('static_data/fullrecord_metadata/normalized_doctypes/doctype'):
                record['docType'].append(docType.text)
            #retrieve publisher
            record['publisher'] = rec.find('static_data/summary/publishers/publisher/names/name/full_name').text

            #append record to answer
            ans['records'].append(record)
        return ans

    def saveAsJSON(self,directory):
        """
        This method save as a JSON file
        the dictionnary produced by the toDict() method
        """
        try:
            import json
        except ImportError:
            print('We need JSON, sorry...')
            sys.exit(1)

        searchRespDict = self.toDict()
        with open(directory, 'wb') as fp:
            json.dump(searchRespDict , fp, sort_keys=True, indent=4, separators=(',', ': '))

    def saveRawAsXML(self,directory):
        """
        This method save as a XML file the raw records
        returned by the WOS search
        It only adds identations to make it more pretty
        """
        from xml.dom import minidom
        records = re.sub(' xmlns="http://scientific.thomsonreuters.com/schema/wok5.4/public/FullRecord"', '', self._searchResp.records, count=1)
        #records = re.sub(' r_id_disclaimer="ResearcherID data provided by Thomson Reuters"', '', resp.records, count=resp.recordsFound)
        recordsTree = ET.fromstring( records)
        rough_string = ET.tostring(recordsTree, 'utf-8')
        reparsed = minidom.parseString(rough_string)
        with open(directory, 'wb') as fp:
            reparsed.writexml(fp, indent="", addindent="\t", newl="\n")

    def saveAsBibtex(self,directory):
        """
        This method save as a bibtex files all the records
        It should be rewritten better handle different document types
        """
        searchRespDict = self.toDict()
        with open(directory, 'w') as fp:
            for rec in searchRespDict['records']:
                if rec['docType'][0]=='Article' or rec['docType'][0]=='Review' or rec['docType'][0]=='Letter':
                    bibtexentry = '@article{'
                elif rec['docType'][0]=='Proceedings Paper' or rec['docType'][0]=='Meeting':
                    bibtexentry = '@proceedings{'
                elif rec['docType'][0]=='Book':
                    bibtexentry = '@book{'
                elif rec['docType'][0]=='Book Chapter':
                    bibtexentry = '@inbook{'
                else:
                    bibtexentry = '@misc{'
                bibtexentry = bibtexentry + rec['UID'] + ',\n'
                bibtexentry = bibtexentry + '  title={' + rec['title'] + '},\n'

                authors = ''
                authorlist = rec['authors']
                firstauthor = authorlist.pop(0)
                authors = firstauthor['name']
                for author in authorlist:
                    authors = authors + ' and ' + author['name']

                bibtexentry = bibtexentry + '  author={' + authors + '},\n'
                bibtexentry = bibtexentry + '  journal={' + rec['journal'] + '},\n'
                if not(rec['volume']==''):
                    bibtexentry = bibtexentry + '  volume={' + rec['volume'] + '},\n'
                if not(rec['issue']==''):
                    bibtexentry = bibtexentry + '  number={' + rec['issue'] + '},\n'
                if rec['page']:
                    bibtexentry = bibtexentry + '  pages={'  + rec['page'][0] + '--' + rec['page'][1] + '},\n'
                if not(rec['year']==''):
                    bibtexentry = bibtexentry + '  year={' + rec['year'] + '},\n'
                if not(rec['publisher']==''):
                    bibtexentry = bibtexentry + '  publisher={' + rec['publisher'] + '},\n'
                bibtexentry = bibtexentry  + '}\n'
                fp.write(bibtexentry)





class WokSearch(object):
    """
    This class is used
        - to define the query parameters of a WOK search
        - open a session on WOK
        - send requests
        - close the session

    """
    AUTH_URL = 'http://search.webofknowledge.com/esti/wokmws/ws/WOKMWSAuthenticate?wsdl'
    SEARCH_URL = 'http://search.webofknowledge.com/esti/wokmws/ws/WokSearch?wsdl'
    def __init__(self):
        #initialization
        self._queryLanguage = 'en'
        self._databaseId = 'WOS'
        self._timeSpanStart = None
        self._timeSpanEnd = None
        self._edition = None
        self._query = None
        self._resultsRetrieved = 0
        self._resultsPerRequest = 100

    def setQuery(self, query):
        self._query = query

    def setEdition(self, edition):
        self._edition = edition

    def setTimeSpanStart(self, date):
        self._timeSpanStart = date

    def setTimeSpanEnd(self, date):
        self._timeSpanEnd = date

    def clearEdition(self):
        self._edition = None

    def clearSpanTime(self):
        self._timeSpanStart = None
        self._timeSpanEnd = None

    def queryToSOAP(self):
        if self._query is not None:
            soap =  {'databaseId' : self._databaseId, 'userQuery' : self._query, 'queryLanguage': self._queryLanguage}
            if self._edition is not None:
                soap['editions'] = self._edition
            soaptime = {}
            if self._timeSpanStart is not None:
                soaptime['begin'] = self._timeSpanStart.isoformat()
            if self._timeSpanEnd is not None:
                soaptime['end'] = self._timeSpanEnd.isoformat()
            if soaptime :
                soap['timeSpan'] = soaptime
            return soap
        else:
            raise SearchQueryError

    def retrieveParamToSOAP(self):
        soap = {'firstRecord' : self._resultsRetrieved+1, 'count' : self._resultsPerRequest}
        return soap

    def openSOAPsession(self):
        self._authClient = Client(self.AUTH_URL)
        self._sid = self._authClient.service.authenticate()
        headers = { 'Cookie': 'SID='+self._sid}
        self._authClient.set_options(soapheaders=headers)
        self._searchClient = Client(self.SEARCH_URL, headers= { 'Cookie': 'SID='+self._sid})

    def closeSOAPsession(self):
        self._authClient.service.closeSession()

    def sendSearchRequest(self):
        resp = self._searchClient.factory.create('searchResponse')
        resp = self._searchClient.service.search(self.queryToSOAP(),self.retrieveParamToSOAP())
        return resp



def main():
    wokSearch = WokSearch()

    wokSearch.setQuery('TS = Optical Coherence Tomography')

    #wokSearch.setEdition(Edition.SCI)
    wokSearch.setTimeSpanEnd(datetime.date(2014,01,01))
    wokSearch.setTimeSpanStart(datetime.date(2003,01,01))
    print wokSearch.queryToSOAP()
    print wokSearch.retrieveParamToSOAP()

    wokSearch.openSOAPsession()
    resp = wokSearch.sendSearchRequest()
    aResp = SearchRespAnalyzer(resp)
    aResp.saveRawAsXML('/Users/mathiasstrupler/WOS3/OCT2003_2010.xml')
    aResp.saveAsJSON('/Users/mathiasstrupler/WOS3/OCT2003_2010.JSON')
    aResp.saveAsBibtex('/Users/mathiasstrupler/WOS3/OCT2003_2010.bib')
    wokSearch.closeSOAPsession()

if __name__ == "__main__":
    sys.exit(main())

#+END_SRC

#+BEGIN_SRC python
from wok3 import *
wokSearch = WokSearch()

wokSearch.setQuery('TS = Optical Coherence Tomography')

wokSearch.setEdition(Edition.SCI)
wokSearch.setTimeSpanEnd(datetime.date(2014,01,01))
wokSearch.setTimeSpanStart(datetime.date(2003,01,01))
print wokSearch.queryToSOAP()
print wokSearch.retrieveParamToSOAP()

wokSearch.openSOAPsession()
resp = wokSearch.sendSearchRequest()
#aResp = SearchRespAnalyzer(resp)
#aResp.saveRawAsXML('OCT2003_2010.xml')
#aResp.saveAsJSON('/Users/mathiasstrupler/WOS3/OCT2003_2010.JSON')
#aResp.saveAsBibtex('OCT2003_2010.bib')

#wokSearch.closeSOAPsession()
#+END_SRC

#+RESULTS:
#+begin_example
{'editions': {'edition': 'SCI', 'collection': 'WOS'}, 'databaseId': 'WOS', 'timeSpan': {'begin': '2003-01-01', 'end': '2014-01-01'}, 'userQuery': 'TS = Optical Coherence Tomography', 'queryLanguage': 'en'}
{'count': 100, 'firstRecord': 1}
No handlers could be found for logger "suds.client"
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "wok3.py", line 309, in sendSearchRequest
    resp = self._searchClient.service.search(self.queryToSOAP(),self.retrieveParamToSOAP())
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 542, in __call__
    return client.invoke(args, kwargs)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 602, in invoke
    result = self.send(soapenv)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 649, in send
    result = self.failed(binding, e)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/client.py", line 702, in failed
    r, p = binding.get_fault(reply)
  File "/Users/jkitchin/Library/Enthought/Canopy_64bit/User/lib/python2.7/site-packages/suds/bindings/binding.py", line 265, in get_fault
    raise WebFault(p, faultroot)
suds.WebFault: Server raised fault: 'User has no entitlement for this service level - WOKSearchPremium'

#+end_example

#+BEGIN_SRC bibtex

#+END_SRC

* completing in python


#+BEGIN_SRC python

def completer(text, state):
    options = [i for i in commands if i.startswith(text)]
    if state < len(options):
        return options[state]
    else:
        return None

print completer('os.', 0)
#+END_SRC

#+RESULTS:
:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "<stdin>", line 2, in completer
: NameError: global name 'commands' is not defined
:

#+BEGIN_SRC python
import rlcompleter
completer = rlcompleter.Completer()

print completer.complete("sy", 1)

#+END_SRC

#+RESULTS:
: Traceback (most recent call last):
:   File "<stdin>", line 1, in <module>
:   File "/Applications/Canopy.app/appdata/canopy-1.5.1.2730.macosx-x86_64/Canopy.app/Contents/lib/python2.7/rlcompleter.py", line 87, in complete
:     return self.matches[state]
: AttributeError: Completer instance has no attribute 'matches'
:

#+BEGIN_SRC python

import pip
installed_packages = pip.get_installed_distributions()
installed_packages_list = sorted(["%s" % (i.key)
     for i in installed_packages])
print(installed_packages_list)
#+END_SRC

#+RESULTS:
:
: ['appinst', 'apptools', 'astroid', 'atom', 'backports.ssl-match-hostname', 'basemap', 'biopython', 'bitarray', 'blist', 'blockcanvas', 'blogofile', 'blogofile-blog', 'boto', 'bsdiff4', 'casuarius', 'chaco', 'cloud', 'codetools', 'configobj', 'curl', 'cython', 'doclinks', 'elpy', 'enable', 'enaml', 'encore', 'enstaller', 'envisage', 'epc', 'epydoc', 'ets', 'etsdevtools', 'etsproxy', 'examples', 'fiona', 'flake8', 'flask', 'foolscap', 'freetype', 'fwrap', 'gdal', 'graphcanvas', 'grin', 'h5py', 'hdf5', 'html5lib', 'idle', 'ipython', 'itsdangerous', 'jedi', 'jinja2', 'kernmagic', 'kiwisolver', 'lib-netcdf4', 'libgdal', 'libjpeg', 'libpng', 'libxml2', 'libxslt', 'logilab-common', 'lxml', 'mako', 'markdown', 'markupsafe', 'matplotlib', 'mayavi', 'mccabe', 'mdp', 'netcdf4', 'networkx', 'nltk', 'nose', 'numba', 'numexpr', 'numpy', 'openpyxl', 'pandas', 'pandasql', 'paramiko', 'patsy', 'pep8', 'pil', 'pint', 'ply', 'pychecker', 'pycluster', 'pycrypto', 'pycse', 'pydot', 'pyephem', 'pyface', 'pyfits', 'pyflakes', 'pygarrayimage', 'pyglet', 'pygments', 'pyhdf', 'pylint', 'pymacs', 'pymc', 'pyodbc', 'pyopengl', 'pyopenssl', 'pyparsing', 'pyproj', 'pysal', 'pyserial', 'pyshp', 'pytables', 'python-dateutil', 'pythondoc', 'pytz', 'pyyaml', 'pyzmq', 'quantities', 'readline', 'reportlab', 'requests', 'rope', 'scikit-learn', 'scikits.image', 'scikits.timeseries', 'scimath', 'scipy', 'scons', 'sexpdata', 'shapely', 'simpy', 'six', 'sphinx', 'sqlalchemy', 'sqlparse', 'statsmodels', 'suds', 'swig', 'sympy', 'textile', 'tornado', 'traits', 'traits-enaml', 'traitsui', 'twisted', 'uncertainties', 'unidecode', 'virtualenv', 'vtk', 'werkzeug', 'wxpython', 'xlrd', 'xlwt', 'zope.interface']
:

* Possibilities for pydoc completion

#+BEGIN_SRC python
import rlcompleter as rl
import sys
C = rl.Completer(namespace=globals())
matched = True
i = 0
matches = []
while matched:
    m = C.complete("sys.", i)
    if m:
        matches += [m]
        i +=1
    else:
        matched = False

print matches
#+END_SRC

#+RESULTS:
: ['sys.__displayhook__(', 'sys.__doc__', 'sys.__egginsert', 'sys.__excepthook__(', 'sys.__name__', 'sys.__package__', 'sys.__plen', 'sys.__stderr__', 'sys.__stdin__', 'sys.__stdout__', 'sys._clear_type_cache(', 'sys._current_frames(', 'sys._executable', 'sys._getframe(', 'sys._home', 'sys._mercurial', 'sys.api_version', 'sys.argv', 'sys.base_exec_prefix', 'sys.base_prefix', 'sys.builtin_module_names', 'sys.byteorder', 'sys.call_tracing(', 'sys.callstats(', 'sys.copyright', 'sys.displayhook(', 'sys.dont_write_bytecode', 'sys.exc_clear(', 'sys.exc_info(', 'sys.exc_type', 'sys.excepthook(', 'sys.exec_prefix', 'sys.executable', 'sys.exit(', 'sys.flags', 'sys.float_info', 'sys.float_repr_style', 'sys.getcheckinterval(', 'sys.getdefaultencoding(', 'sys.getdlopenflags(', 'sys.getfilesystemencoding(', 'sys.getprofile(', 'sys.getrecursionlimit(', 'sys.getrefcount(', 'sys.getsizeof(', 'sys.gettrace(', 'sys.hexversion', 'sys.long_info', 'sys.maxint', 'sys.maxsize', 'sys.maxunicode', 'sys.meta_path', 'sys.modules', 'sys.path', 'sys.path_hooks', 'sys.path_importer_cache', 'sys.platform', 'sys.prefix', 'sys.py3kwarning', 'sys.setcheckinterval(', 'sys.setdlopenflags(', 'sys.setprofile(', 'sys.setrecursionlimit(', 'sys.settrace(', 'sys.stderr', 'sys.stdin', 'sys.stdout', 'sys.subversion', 'sys.version', 'sys.version_info', 'sys.warnoptions', 'sys.__class__(', 'sys.__class__(', 'sys.__delattr__(', 'sys.__dict__', 'sys.__doc__', 'sys.__format__(', 'sys.__getattribute__(', 'sys.__hash__(', 'sys.__init__(', 'sys.__new__(', 'sys.__reduce__(', 'sys.__reduce_ex__(', 'sys.__repr__(', 'sys.__setattr__(', 'sys.__sizeof__(', 'sys.__str__(', 'sys.__subclasshook__(', 'sys.__class__(', 'sys.__delattr__(', 'sys.__doc__', 'sys.__format__(', 'sys.__getattribute__(', 'sys.__hash__(', 'sys.__init__(', 'sys.__new__(', 'sys.__reduce__(', 'sys.__reduce_ex__(', 'sys.__repr__(', 'sys.__setattr__(', 'sys.__sizeof__(', 'sys.__str__(', 'sys.__subclasshook__(']

* pydoc apropos

see https://github.com/philippp/apropos.py

This needs to be done asynchronously
#+BEGIN_SRC emacs-lisp
(defun pydoc-apropos (name)
  (interactive)
  (switch-to-buffer-other-window "*pydoc-apropos*")
  (erase-buffer)
  (insert (shell-command-to-string (format "python -c \"import pydoc; pydoc.apropos('%s')\"" "zip")))
  (goto-char (point-min)))

(pydoc-apropos "zip")
#+END_SRC

#+RESULTS:
: 1


* Convert word at point to internal link
must have been some org-mode list question

#+BEGIN_SRC emacs-lisp
(defun word-to-link ()
  (interactive)
  (save-excursion
    (let (start end word)
      (backward-word)
      (setq start (point))
      (forward-word)
      (setq end (point))
      (setq word (buffer-substring start end))
      (setf (buffer-substring start end)
	    (format "[[%s]]" word)))))
#+END_SRC

#+RESULTS:
: word-to-link

Test [[some]] word


* Quick access to your own cheat sheets
There are a lot of 1-2 page cheat sheets available on the Internet. In emacs It should be easy to make your own cheat sheets (in org-mode of course), and to access them from a command with completion. Here we explore a way to get that with a helm interface.

The idea is to keep an org-file with headings in it for each cheat sheet. I put mine here: file:cheat-sheets.org.

We don't even have to work very hard here, helm already has a slick function to give you quick searching of the headlines. We just open our file, and run the helm command.

#+BEGIN_SRC emacs-lisp
(defun cheatsheet ()
  (interactive)
  (find-file "cheat-sheets.org")
  (helm-org-headlines))
#+END_SRC

#+RESULTS:
: cheatsheet


* Automating version control on org files
  I came across this [[http://erikclarke.net/2014/10/21/keeping-a-lab-notebook-with-org-mode-git-papers-and-pandoc-part-ii/][post]] on keeping a lab notebook in org-mode and git. One interesting feature in the post is a lab-notebook minor mode that automates version control by adding a function to the after-save-hook. I am testing it out here.

#+BEGIN_SRC emacs-lisp
(defun ensure-in-vc-or-checkin ()
  (interactive)
  (if (file-exists-p (format "%s" (buffer-file-name)))
      (progn (vc-next-action nil) (message "Committed"))
    (ding) (message "File not checked in.")))

;; i set this to nil at some point for performance reasons
(setq vc-handled-backends '(Git))

(add-hook 'after-save-hook 'ensure-in-vc-or-checkin nil 'make-it-local)
#+END_SRC

#+RESULTS:
| ensure-in-vc-or-checkin | t |

#+BEGIN_SRC emacs-lisp
(remove-hook 'after-save-hook 'ensure-in-vc-or-checkin)
#+END_SRC

#+RESULTS:

Now, when I save this file, I am prompted for a commit message, then I press C-c C-c to commit it.

If we make a new file: file:new-file.org I do not get quite what I would have expected. The file is added, but not committed. The second save prompts for a commit message.

So, what should happen? I think you should only be prompted for a commit message when you want one. I often save to avoid losing work, but I wouldn't always want to write a commit message for that. Also, if the file is new, I want it added /and/ committed. Probably, you should commit when a buffer is killed.

It turns out there are a lot of helpful vc commands built into Emacs.

| C-x v l | Show log            |                          |
| C-x v i | add file            | vc-register              |
| C-x v = | diff current file   |                          |
| C-x v G | ignore file         | vc-ignore                |
| C-x v v | next logical action | (vc-next-action VERBOSE) |
|         |                     | vc-create-repo           |
|         |                     | vc-git-grep              |
|         |                     |                          |

vc-dir

vc-diff

We can get some idea of the state of the vc directory like this
#+BEGIN_SRC emacs-lisp
(vc-deduce-fileset nil t 'state-model-only-files)
#+END_SRC

#+RESULTS:
| Git | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | (/Users/jkitchin/blogofile-jkitchin.github.com/_blog/blog.org) | edited | implicit |

Checking if the current buffer is under vc:
#+BEGIN_SRC emacs-lisp
(vc-registered (buffer-file-name)) ;; return non-nil if file is registered
#+END_SRC

#+RESULTS:
: t




* Storing data files in a Word document


You probably know that the modern office documents are just thinly wrapped zip files full of other files. For example, this Word document file:kitchin_cv.docx opens as a Word document, but we can use Python and zipfile to examine the contents.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx') as myzip:
    print myzip.printdir()
#+END_SRC
#+RESULTS:
#+begin_example
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524045
word/footer1.xml                               1980-01-01 00:00:00         4036
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29812
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
None
#+end_example

You can see many of the files are xml files. In this post, I want to explore putting an arbitrary data file in the Word document, and then extracting it later. This is similar to the way we use LaTeX and attachfile to store data files in PDFs for supporting information files.

So first, lets create a simple json file.

#+BEGIN_SRC python :results silent
import json
with open('some-data.json', 'w') as f:
    f.write(json.dumps({'a': 1,
                        'b': 2}))
#+END_SRC

Here are the contents of our new file.
#+BEGIN_SRC sh
cat some-data.json
#+END_SRC

#+RESULTS:
: {"a": 1, "b": 2}

Now, we will add the file to the docx file. We just open the ZipFile in append mode, and write a new file to it.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'a') as myzip:
    print myzip.write('some-data.json')
    print myzip.printdir()
#+END_SRC

#+RESULTS:
#+begin_example
None
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524045
word/footer1.xml                               1980-01-01 00:00:00         4036
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29812
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
some-data.json                                 2014-12-14 12:08:56           16
None
#+end_example

Sure enough, there is a new entry in there! Finally, we show that the contents of this file can be read in. We simply have to know what the file to read is, and we can get the contents.

#+BEGIN_SRC python
import json
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'r') as myzip:
    contents = myzip.read('some-data.json')
    data = json.loads(contents)
    print data
#+END_SRC
#+RESULTS:

Unfortunately, this corrupts the Word file so it does not immediately open. Word is able to recover it and get it open. And, after it is open, the some-data.json entry is gone.

#+BEGIN_SRC python
from zipfile import ZipFile
with ZipFile('kitchin_cv.docx', 'a') as myzip:
    print myzip.printdir()
#+END_SRC
#+RESULTS:
#+begin_example
File Name                                             Modified             Size
[Content_Types].xml                            1980-01-01 00:00:00         2125
_rels/.rels                                    1980-01-01 00:00:00          590
word/_rels/document.xml.rels                   1980-01-01 00:00:00        14241
word/document.xml                              1980-01-01 00:00:00       524305
word/footer1.xml                               1980-01-01 00:00:00         4037
word/header1.xml                               1980-01-01 00:00:00         1706
word/endnotes.xml                              1980-01-01 00:00:00         1629
word/footnotes.xml                             1980-01-01 00:00:00         3117
word/theme/theme1.xml                          1980-01-01 00:00:00         7076
word/media/image1.tmp                          1980-01-01 00:00:00        99449
word/media/image2.tmp                          1980-01-01 00:00:00        85976
word/media/image3.tmp                          1980-01-01 00:00:00        61281
word/settings.xml                              1980-01-01 00:00:00        29890
word/fontTable.xml                             1980-01-01 00:00:00         3887
word/styles.xml                                1980-01-01 00:00:00        36430
word/stylesWithEffects.xml                     1980-01-01 00:00:00        37296
docProps/app.xml                               1980-01-01 00:00:00        21158
docProps/core.xml                              1980-01-01 00:00:00          748
word/webSettings.xml                           1980-01-01 00:00:00         2484
word/numbering.xml                             1980-01-01 00:00:00        82725
None
#+end_example

So, it appears this is not a good way to store data inside a Word document.

* Filtering an org-mode table

Suppose I have this table, and I want to filter it for all entries having a topic of 1. Of course you can sort the table by topic and find the group. I want something like Excel has where you filter and make the other rows disappear.

First, let's take a look at some org-table functions that will be useful. Let us assume our filtering command is run interactively in a table. We need to know what column we are in, which we can get with =org-table-current-column=. We then might go to the beginning of the table. WE can find that with =org-table-begin=. Then, we iterate through the rows with =org-table-next-row=, and check the value of a field in the desired column with =org-table-get-field=.

#+BEGIN_SRC emacs-lisp
(defun filter-message ()
  (interactive)
  (let* ((current-column (org-table-current-column))
	 (current-value (org-table-get-field))
	 (filtered-lines  '()))
    (goto-char (org-table-begin))
    ;(message-box "%s" (org-table-current-dline))
    (while (org-table-p)
      (forward-line)
      (message "%s" (org-table-get-field current-column))
      (if (not
	   (string= current-value (org-table-get-field current-column)))
	  (add-to-list 'filtered-lines nil)
	(add-to-list 'filtered-lines t)))
    (message-box "%s" filtered-lines    )
    ))
#+END_SRC

#+RESULTS:
: filter-message




maybe see https://gist.github.com/doitian/1571162 for a folding way

#+tblname: my-data
| name | topic |
|------+-------|
| a    |     1 |
| v    |     1 |
| c    |     2 |
| d    |     3 |
| e    |     2 |
| f    |     1 |

First, we try making a row invisible.

(remove-from-invisibility-spec '(org-table-filter))
#+BEGIN_SRC emacs-lisp :results silent
(re-search-backward "#\\+tblname: my-data")
(re-search-forward "| v")
(beginning-of-line)
(let ((beg (point))
      (end)(ov))

  (end-of-line)
  (setq end (point))
  (setq ov (make-overlay beg end))
  (message-box "%s" (buffer-substring beg end))
  ;(overlay-put (make-overlay beg end) 'invisible 'org-table-filter))
  (overlay-put ov 'display '(height 0)))

(add-to-invisibility-spec '(org-table-filter))
#+END_SRC


see http://www.gnu.org/software/emacs/manual/html_node/elisp/Pixel-Specification.html#Pixel-Specification

maybe we can make lines on pixel high

* Indirect buffer in another mode

#+BEGIN_SRC emacs-lisp
(defun dwiw-indirect ()
  (if (org-in-block-p '("src"))
    (let* ((temp (org-edit-src-find-region-and-lang))
	   (beg (nth 0 temp))
	   (end (nth 1 temp))
	   (lang (nth 2 temp)))
      (message "in block: %s" lang)
      (pop-to-buffer (or
		      (get-buffer "*indirect*")
		      (make-indirect-buffer (current-buffer) "*indirect*")))
      (narrow-to-region beg end)
      ;; set mode(major-mode)
      (funcall (intern (concat lang "-mode"))))

    (when (eq major-mode 'org-mode)
      (when (get-buffer "*indirect*")
	(kill-buffer (get-buffer "*indirect*")))
      (font-lock-fontify-buffer))))


(add-hook 'post-command-hook 'dwiw-indirect)
;(remove-hook 'post-command-hook 'dwiw-indirect)
#+END_SRC




* toggle images in section

#+BEGIN_SRC emacs-lisp
(defun show-images-subtree ()
 (interactive)
(save-restriction
  (org-narrow-to-subtree)
  (org-display-inline-images nil t (point-min) (point-max))))
#+END_SRC
** section 1

[[./images/eos.png]]



** section 1

[[./images/eos.png]]

* get a count of unique elements

  ;; we need counts for each atom type. eventually we need to make sure the POTCAR file is written consistently with the order here. This is the clumsiest part of VASP, and the reason for the complex sorting done in ase. Some effort is made to group the atoms together so there is only one copy of each POTCAR.
  (insert "\n")
  (let* ((all-symbols (loop for atom in (oref atoms atoms)
			    collect (oref atom symbol)))
	 (unique-syms (-uniq all-symbols))
	 (counts (loop for usym in unique-syms
		       collect (cl-count usym all-symbols))))

    (dolist (c counts)
      (insert (format "%d " c))))

* OOP in emacs-lisp

#+BEGIN_SRC emacs-lisp
(defclass student ()
  ((first-name :initarg :first-name
	       :documentation "First name")
   (last-name :initarg :last-name
	      :documentation "Last name")
   (email :initarg :email
	  :documentation "Email address")))

(defmethod email-student ((rec student))
  "send email to student stored in REC."
  (message "sending email to %s"
	   (oref rec email)))

(setq s1 (student "s1" :first-name "John"
		 :last-name "Kitchin"
		 :email "jkitchin@andrew.cmu.edu"))

(email-student s1)
#+END_SRC

#+RESULTS:
: sending email to jkitchin@andrew.cmu.edu

* Getting items done today

** DONE item 1
   CLOSED: [2014-11-26 Wed 13:09] DEADLINE: <2014-11-26 Wed>



** DONE item 2
   CLOSED: [2014-11-25 Tue 13:09] DEADLINE: <2014-11-26 Wed>


** Mapping entries to find what closed today.

First, we look at a timestamp comparison function.
#+BEGIN_SRC emacs-lisp
(org-time= "<2014-11-26 Wed>" "<2014-11-26 Wed>")
#+END_SRC

#+RESULTS:
: t

#+BEGIN_SRC emacs-lisp
(org-map-entries
  (lambda ()
    (let* ((closed (org-entry-get (point) "CLOSED"))
           (today (format-time-string "<%Y-%m-%d>")))
      (when closed
	(when
	    (org-time=
	     today
	     (let ((parts (org-parse-time-string closed)))
	       (format "<%s-%s-%s>"
		       (nth 5 parts) ; year
		       (nth 4 parts) ; month
		       (nth 3 parts) ; day
		       )))
	  (message-box "Found a closed task: %s"
		       (org-heading-components)))))))

#+END_SRC

#+RESULTS:
| nil | Found a closed task: (2 2 DONE nil item 1 nil) | nil | nil |

* A new data structure for me in emacs-lisp

I am examining the struct data type in emacs-lisp today. This creates something like an object with fields of data that are accessed by name. We will create a student object that contains first name, last name and an email address.

#+BEGIN_SRC emacs-lisp
(defstruct student first-name last-name email)
#+END_SRC

#+RESULTS:
: student

Let us make a student now, and assign it to a variable.
#+BEGIN_SRC emacs-lisp
(setq s1
      (make-student :first-name "John"
		    :last-name "Kitchin"
		    :email "jkitchin@andrew.cmu.edu"))
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

The defstruct macro automatically creates accessor functions with names of NAME-SLOT. NAME in this case is student, and SLOT is one of the words we defined in the defstruct call. We access data from the student like this.

#+BEGIN_SRC emacs-lisp
(list
 (student-first-name s1)
 (student-last-name s1)
 (student-email s1))
#+END_SRC

#+RESULTS:
| John | Kitchin | jkitchin@andrew.cmu.edu |

Now, let us print the object.
#+BEGIN_SRC emacs-lisp
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@andrew.cmu.edu"]

We can use generalized setf to change the values in the object.

#+BEGIN_SRC emacs-lisp
(setf (student-email s1) "jkitchin@cmu.edu")
(princ s1)
#+END_SRC

#+RESULTS:
: [cl-struct-student "John" "Kitchin" "jkitchin@cmu.edu"]

Finally, the defstruct macro also defines a function to test if a variable is one of these objects. We can confirm a variable is a student object like this:
#+BEGIN_SRC emacs-lisp
(student-p s1)
#+END_SRC

#+RESULTS:
: t

This looks like a relatively handy way to encapsulate data in emacs-lisp, and accessing the data seems more readable than using any combination of car, cdr, elt and nth.


* A custom block in orgmode

#+BEGIN_EXAMPLE
Example text in a block to make sure it gets handled
#+END_EXAMPLE

Some instructions for the quiz.

#+ATTR_quiz: :points 5 :correct-answer A
#+BEGIN_quiz
test quiz
- [ ] answer A
- [ ] answer B
#+END_quiz


#+BEGIN_SRC emacs-lisp :exports none
(defun my-org-html-export-block (export-block contents info)
  "Transcode a EXPORT-BLOCK element from Org to HTML.
CONTENTS is nil.  INFO is a plist used as a communication
channel. QUIZ blocks are handled separately."

  (cond
   ;; handle our special quiz block
   ((string= (org-element-property :type export-block) "QUIZ")

    (format
     "<b>got it:</b> %s points, correct answer = %s
<br>
You would have to parse the body to generate your html here.
<br>
<pre>%s</pre>"
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :points)
     (plist-get
      (read (format "%s" (org-element-property :attr_quiz export-block)))
     :correct-answer)
     (org-element-property :value export-block)
     ))
   ;; handle every other kind of block
   (t
    (org-html-export-block (export-block contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((export-block . my-org-html-export-block))
  ;; quiz blocks will not be parsed, they are handled directly in org-html-export-block.
  :export-block "quiz"
)


(browse-url (org-export-to-file 'my-html "custom-element.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-element.html>


* Helm notes

from [[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#loom.20140114T194900-298@post.gmane.org][Email from Tom: Making google suggest even mor]]
#+BEGIN_SRC emacs-lisp
(setq helm-source-google-suggest
  '((name . "Google Suggest")
    (candidates . (lambda ()
                    (funcall helm-google-suggest-default-function)))
    (action . (("Google Search" . helm-google-suggest-action)
               ("Wikipedia" . (lambda (candidate)
                     (browse-url
                      (concat "https://en.wikipedia.org/wiki/Special:Search?search="
                              (url-hexify-string candidate)))))
               ("Youtube" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.youtube.com/results?aq=f&search_query="
                              (url-hexify-string candidate)))))
               ("IMDb" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.imdb.com/find?s=all&q="
                              (url-hexify-string candidate)))))
               ("Google Maps" . (lambda (candidate)
                     (browse-url
                      (concat "http://maps.google.com/maps?f=q&source=s_q&hl=en&geocode=&q="
                              (url-hexify-string candidate)))))
               ("Google News" . (lambda (candidate)
                     (browse-url
                      (concat "http://www.google.com/search?hl=en&safe=off&prmd=nvlifd&source=lnms&tbs=nws:1&q="
                              (url-hexify-string candidate)))))
               ))
    (volatile)
    (requires-pattern . 3)))

(helm :sources 'helm-source-google-suggest)
#+END_SRC

#+RESULTS:
: #<process open http://www.imdb.com/find?s=all&q=kitchen%20cabinets>


https://github.com/krisajenkins/helm-spotify/blob/master/helm-spotify.el

(require 'multi)

** dictionary
[[https://raw.githubusercontent.com/emacs-helm/helm-dictionary/master/helm-dictionary.el]]

#+BEGIN_SRC emacs-lisp
;;; helm-dictionary.el --- Helm source for looking up dictionaries

;; Copyright 2013 Titus von der Malsburg <malsburg@posteo.de>

;; Author: Titus von der Malsburg <malsburg@posteo.de>
;;         Michael Heerdegen <michael_heerdegen@web.de>
;; Maintainer: Titus von der Malsburg <malsburg@posteo.de>
;; URL: https://github.com/emacs-helm/helm-dictionary
;; Version: 1.0.0
;; Package-Requires: ((helm "1.5.5"))

;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <http://www.gnu.org/licenses/>.

;;; Commentary:

;; This helm source can be used to look up words in local (offline)
;; dictionaries.  It also provides short-cuts for various online
;; dictionaries, which is useful in situations where the local
;; dictionary doesn't have an entry for a word.
;;
;; Dictionaries are available for a variety of language pairs.  See
;; the project page for an incomplete list:
;;
;;     https://github.com/emacs-helm/helm-dictionary

;;; Install:

;; Put this file on your Emacs-Lisp load path and add the following in
;; your Emacs startup file:
;;
;;     (require 'helm-dictionary)
;;
;; Alternatively, you can use autoload:
;;
;;     (autoload 'helm-dictionary "helm-dictionary" "" t)
;;
;; In order to specify a dictionary set the variable
;; `helm-dictionary-database' to the filename of that dictionary.
;;
;; A dictionary for German and English can be found in the Debian
;; package trans-de-en.  This package is also available in many
;; distributions derived from Debian such as Ubuntu.  Alternatively,
;; this dictionary can also be downloaded here:
;;
;;   http://www-user.tu-chemnitz.de/~fri/ding/
;;
;; A dictionary for German and Spanish can be found here:
;;
;;   https://savannah.nongnu.org/projects/ding-es-de
;;
;; A variety of dictionaries with English as the source or target
;; language can be found here:
;;
;;   https://en.wiktionary.org/wiki/User:Matthias_Buchmeier
;;
;; These dictionaries were automatically created from the Wiktionary
;; database.  Their size and quality may vary.  Also generated from
;; Wiktionary are the following dictionaries with Russian as the
;; source or target language:
;;
;;   http://wiktionary-export.nataraj.su/en/
;;
;; If the local dictionary doesn't have an entry for a word, it can be
;; useful to try online dictionaries available on the
;; web.  Helm-dictionary has a dummy source that provides shortcuts
;; for looking up the currently entered string in these online
;; dictionaries.  The variable `helm-dictionary-online-dicts'
;; specifies which online dictionaries should be listed.  The value of
;; that variable is a list conses.  The first element of each cons
;; specifies the name of an online dictionary for display during
;; searches.  The second element is the URL used for retrieving search
;; results from the respective dictionary.  This URL has to contain a
;; "%s" at the position where the search term should be inserted.
;;

;; The browser specified in `helm-dictionary-browser-function' will be
;; used to show results from online dictionaries.  If this variable is
;; nil (default), the value of the variable
;; `browse-url-browser-function' will be used (the currently
;; configured Emacs-wide default browser).  If that variable is also
;; nil, helm uses the first available browser in
;; `helm-browse-url-default-browser-alist'.

;;; Usage:

;; Use the command `helm-dictionary' to start a new search.  As usual,
;; a search is case-insensitive unless the expression contains capital
;; letters.  Regular expressions can also be used as search
;; terms.  During a search, you can use `M-n` to search for the word
;; at which you called `helm-dictionary`.

;; There are two actions available: insert the currently selected term
;; in the source language (left) or in the target language (right) at
;; point, i.e., the cursor position at which `helm-dictionary' was
;; called.

;; In the section "Look up online", you can choose among several online
;; dictionaries.  If you select one of the entries listed in this
;; section, a browser will be used to display search results from the
;; respective dictionary.

;;; Code:

(require 'cl-lib)
(require 'helm)
(require 'helm-net)
(require 'helm-plugin)

(defgroup helm-dictionary nil
  "Helm plugin for looking up a dictionary."
  :group 'helm)

(defcustom helm-dictionary-database "/usr/share/trans/de-en"
  "The file containing the dictionary."
  :group 'helm-dictionary
  :type  'file)

(defcustom helm-dictionary-online-dicts
  '(("translate.reference.com de->eng" .
     "http://translate.reference.com/translate?query=%s&src=de&dst=en")
    ("translate.reference.com eng->de" .
     "http://translate.reference.com/translate?query=%s&src=en&dst=de")
    ("leo eng<->de" .
     "http://dict.leo.org/ende?lp=ende&lang=de&search=%s")
    ("en.wiktionary.org" . "http://en.wiktionary.org/wiki/%s")
    ("de.wiktionary.org" . "http://de.wiktionary.org/wiki/%s")
    ("linguee-eng<->de" . "http://www.linguee.de/deutsch-englisch/search\
?sourceoverride=none&source=auto&query=%s"))
  "Alist of online dictionaries.  The key of each entry is the
name of the online dictionary.  The value is the URL used for
retrieving results.  This URL must contain a %s at the position
where the search term should be inserted.")

(defcustom helm-dictionary-browser-function nil
  "The browser that is used to access online dictionaries.  If
nil (default), the value of `browse-url-browser-function' is
used.  If that value is nil, Helm uses the first available
browser in `helm-browse-url-default-browser-alist'"
  :group 'helm-dictionary
  :type '(choice
          (const         :tag "Default" :value nil)
          (function-item :tag "Emacs interface to w3m" :value w3m-browse-url)
          (function-item :tag "Emacs W3" :value  browse-url-w3)
          (function-item :tag "W3 in another Emacs via `gnudoit'"
                         :value  browse-url-w3-gnudoit)
          (function-item :tag "Mozilla" :value  browse-url-mozilla)
          (function-item :tag "Firefox" :value browse-url-firefox)
          (function-item :tag "Chromium" :value browse-url-chromium)
          (function-item :tag "Galeon" :value  browse-url-galeon)
          (function-item :tag "Epiphany" :value  browse-url-epiphany)
          (function-item :tag "Netscape" :value  browse-url-netscape)
          (function-item :tag "eww" :value  eww-browse-url)
          (function-item :tag "Mosaic" :value  browse-url-mosaic)
          (function-item :tag "Mosaic using CCI" :value  browse-url-cci)
          (function-item :tag "Text browser in an xterm window"
                         :value browse-url-text-xterm)
          (function-item :tag "Text browser in an Emacs window"
                         :value browse-url-text-emacs)
          (function-item :tag "KDE" :value browse-url-kde)
          (function-item :tag "Elinks" :value browse-url-elinks)
          (function-item :tag "Specified by `Browse Url Generic Program'"
                         :value browse-url-generic)
          (function-item :tag "Default Windows browser"
                         :value browse-url-default-windows-browser)
          (function-item :tag "Default Mac OS X browser"
                         :value browse-url-default-macosx-browser)
          (function-item :tag "GNOME invoking Mozilla"
                         :value browse-url-gnome-moz)
          (function-item :tag "Default browser"
                         :value browse-url-default-browser)
          (function      :tag "Your own function")
          (alist         :tag "Regexp/function association list"
                         :key-type regexp :value-type function)))

(easy-menu-add-item nil '("Tools" "Helm" "Tools") ["Dictionary" helm-dictionary t])


(defun helm-dictionary-transformer (candidates)
  "Formats entries retrieved from the data base."
  (cl-loop for i in candidates
           with entry and l1terms and l2terms
           and width = (with-helm-window (window-width))
           unless (or (string-match "\\`#" i)
                      (not (string-match " :: ?" i)))
           do (progn (setq entry (split-string i " :: ?"))
                     (setq l1terms (split-string (car entry) " | "))
                     (setq l2terms (split-string (cadr entry) " | ")))
           and append
           (cl-loop for l1term in l1terms
                    for l2term in l2terms
                    if (or (string-match helm-pattern l1term)
                           (string-match helm-pattern l2term))
                    collect
                    (cons
                     (concat
                      (truncate-string-to-width l1term (- (/ width 2) 1) 0 ?\s)
                      " "
                      (truncate-string-to-width l2term (- (/ width 2) 1) 0 ?\s))
                     (cons l1term l2term)))))


(defun helm-dictionary-insert-l1term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (car entry))))

(defun helm-dictionary-insert-l2term (entry)
  (insert
    (replace-regexp-in-string
      " *{.+}\\| *\\[.+\\]" "" (cdr entry))))


(defvar helm-source-dictionary
  '((name . "Search dictionary")
    (candidates-file . helm-dictionary-database)
    (candidate-transformer . helm-dictionary-transformer)
    (action . (("Insert source language term" . helm-dictionary-insert-l1term)
               ("Insert target language term" . helm-dictionary-insert-l2term)))))

(defvar helm-source-dictionary-online
  '((name . "Look up online")
    (match (lambda (_candidate) t))
    (candidates . helm-dictionary-online-dicts)
    (no-matchplugin)
    (nohighlight)
    (action
     . (lambda (cand)
         (let ((browse-url-browser-function
                (or helm-dictionary-browser-function
                    browse-url-browser-function)))
           (helm-browse-url (format cand (url-hexify-string helm-pattern)))))))
  "Source for online look-up.")

;;;###autoload
(defun helm-dictionary ()
  (interactive)
  (helm :sources '(helm-source-dictionary helm-source-dictionary-online)
        :full-frame t
        :candidate-number-limit 500
        :buffer "*helm dictionary*"))

(provide 'helm-dictionary)

;; Local Variables:
;; byte-compile-warnings: (not cl-functions obsolete)
;; coding: utf-8
;; indent-tabs-mode: nil
;; End:

;;; helm-dictionary.el ends here
#+END_SRC

#+RESULTS:
: helm-dictionary


** mail list
[[gnus:nntp%2Bnews.gmane.org:gmane.emacs.helm.user#87eh8mpakg.fsf@gmail.com][Email from Thierry Volpiatto: Re: Get the full path to the c]]

helm-describe-helm-attribute

* Using filters to get pdf images into html export

#+BEGIN_SRC python
import matplotlib.pyplot as plt

plt.plot([1, 2, 4, 8])
plt.savefig('im.pdf')
#+END_SRC

Here is our inline image as a pdf file. We would like it to be converted to a png, and rendered in an html export. This is most easily done with a derived backend.

[[./im.pdf]]


#+BEGIN_SRC emacs-lisp
(defun my-link-format (link contents info)
  (let ((type (org-element-property :type link))
	(path (org-element-property :path link)))
    (cond
     ((and
       (string= type "file")
       (string-match "\.pdf" path))
      (shell-command
       (format
	"convert %s %s"
	path
	(replace-regexp-in-string "\.pdf" ".png" path)))
      (format "<img src=\"%s\">" (replace-regexp-in-string "\.pdf" ".png" path)))
     ;; anything else, we just do the regular thing
     (t
      (org-html-link link contents info)))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((link . my-link-format)))


(browse-url (org-export-to-file 'my-html "custom-link.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-link.html>




* A simple helm menu

Helm is an interesting way to interactively select something, and perform an action on it.
here is an example where I tried to get all the words in the buffer, select one from helm, and then search the word.

The setup is not intuitive yet. You need to provide some sources that helm will use to create the matching buffer. This is usually done in a variable that is a list of cons cells. The source provides "candidates", and "actions". After that


#+BEGIN_SRC emacs-lisp
(defun helm-words-google (word)
  "Google the WORD."
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s" word)))

(defun helm-words-twitter (word)
  "Search twitter for WORD."
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s" word)))


(defvar helm-source-words
 '()
  "Source for helm-words")

(setq helm-source-words
      '((name . "Words entries")
	(candidates . (lambda nil (with-current-buffer
				    cb
				    (split-string (buffer-string)))))
	(action . (("google" . helm-words-google)
		   ("twitter" . helm-words-twitter)))))

(defun helm-words ()
  "helm a word"
  (interactive)
  ;; we have to save the buffer we are in before we go to the helm buffer
  ;; so that we can get the words there.
  (let ((cb (current-buffer)))
    (helm :sources '(helm-source-words)
	  :buffer "*helm-words*")))

#+END_SRC

#+RESULTS:
: helm-words

#+BEGIN_SRC emacs-lisp :results code
(helm-bibtex-candidates)
#+END_SRC

#+RESULTS:


The candidates must be a list of items, and the car of the list is what gets listed in the helm selection buffer. The cdr of the list gets passed to the action functions. Here we hard code some candidates to make it more clear. We see the car in the helm buffer, and get the cdr passed to our action functions.

#+BEGIN_SRC emacs-lisp
(defun helm-words-google (word)
  "Google the WORD."
  (interactive)
  (browse-url
   (format
    "http://www.google.com/search?q=%s"
    (if (listp word)
	(mapconcat 'identity word " and ")
      word))))

(defun helm-words-twitter (word)
  "Search twitter for WORD."
  (interactive)
  (browse-url
   (format
    "https://twitter.com/search?q=%s"
    (if (listp word)
	(mapconcat 'identity word " and ")
      word))))

(defvar helm-source-words
 '()
  "Source for helm-words")

(setq helm-source-words
      '((name . "Words entries")
	(candidates . (lambda nil '(("a" . ("apple" "apricot"))
				    ("b" . "bear")
				    ("c" . "cat"))))
	(action . (("google" . helm-words-google)
		   ("twitter" . helm-words-twitter)))))

(defun helm-words ()
  "helm a word"
  (interactive)

  (let ((cb (current-buffer)))
    (helm :sources '(helm-source-words)
	  :buffer "*helm-words*")))

#+END_SRC

#+RESULTS:
: helm-words


* make any org link a menu link

It seems like it should be possible to make org links have variable behavior. For example, if one action is defined, it should be done. If more than one action is defined, you should get a menu. One way to achieve this is to hijack the org-link functions, or in cases where lambda functions are used, we have to redefine them. The follow functions are defined in org-link-protocols.

#+BEGIN_SRC emacs-lisp :results code
org-link-protocols
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(("google"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.google.com/search?q=%s"
	     (url-hexify-string link-string))))
  nil)
 ("ResearcherID"
  (lambda
    (link-string)
    (browse-url
     (format "http://www.researcherid.com/rid/%s" link-string)))
  nil)
 ("orcid"
  (lambda
    (link-string)
    (browse-url
     (format "http://orcid.org/%s" link-string)))
  nil)
 ("message" org-mac-message-open nil)
 ("mac-outlook" org-mac-outlook-message-open nil)
 ("skim" org-mac-skim-open nil)
 ("addressbook" org-mac-addressbook-item-open nil)
 ("x-together-item" org-mac-together-item-open nil)
 ("rmail" org-rmail-open nil)
 ("mhe" org-mhe-open nil)
 ("irc" org-irc-visit nil)
 ("info" org-info-open nil)
 ("gnus" org-gnus-open nil)
 ("docview" org-docview-open org-docview-export)
 ("bibtex" org-bibtex-open nil)
 ("bbdb" org-bbdb-open org-bbdb-export)
 ("ans"
  (lambda
    (path)
    (let*
	((fields
	  (split-string path "::"))
	 (label
	  (nth 0 fields))
	 (data
	  (nth 1 fields))
	 (data-file
	  (format "%s-%s.dat" tq-userid label)))
      (let
	  ((temp-file data-file)
	   (temp-buffer
	    (get-buffer-create
	     (generate-new-buffer-name " *temp file*"))))
	(unwind-protect
	    (prog1
		(save-current-buffer
		  (set-buffer temp-buffer)
		  (insert data))
	      (save-current-buffer
		(set-buffer temp-buffer)
		(write-region nil nil temp-file nil 0)))
	  (and
	   (buffer-name temp-buffer)
	   (kill-buffer temp-buffer))))
      (mygit
       (format "git add %s" data-file))
      (mygit
       (format "git commit -m \"%s\"" data-file))
      (mygit "git push origin master")))
  nil)
 ("exercise"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("solution"
  (lambda
    (label)
    (tq-check-internet)
    (let
	((default-directory
	   (file-name-as-directory
	    (expand-file-name tq-root-directory))))
      (if
	  (file-exists-p "solutions")
	  nil
	(make-directory "solutions"))
      (let
	  ((default-directory
	     (file-name-as-directory
	      (expand-file-name "solutions"))))
	(if
	    (file-exists-p label)
	    (progn
	      (find-file
	       (concat label "/" label ".org"))
	      (tq-update))
	  (mygit
	   (format "git clone %s@%s:solutions/%s" tq-current-course tq-git-server label))
	  (find-file
	   (concat label "/" label ".org"))))))
  nil)
 ("assignment"
  (lambda
    (arg)
    (tq-check-internet)
    (tq-get-assignment arg))
  nil)
 ("doi" doi-link-menu nil)
 ("bibentry" org-ref-cite-onclick-minibuffer-menu org-ref-format-bibentry)
 ("Autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocites)
 ("autocites" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocites)
 ("supercites" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercites)
 ("Textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcites)
 ("textcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcites)
 ("Smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcites)
 ("smartcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcites)
 ("footcitetexts" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetexts)
 ("footcites" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcites)
 ("Parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencites)
 ("parencites" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencites)
 ("Cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cites)
 ("cites" org-ref-cite-onclick-minibuffer-menu org-ref-format-cites)
 ("fnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fnotecite)
 ("Pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Pnotecite)
 ("pnotecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-pnotecite)
 ("Notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Notecite)
 ("notecite" org-ref-cite-onclick-minibuffer-menu org-ref-format-notecite)
 ("footfullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footfullcite)
 ("fullcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-fullcite)
 ("citeurl" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeurl)
 ("citedate*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate*)
 ("citedate" org-ref-cite-onclick-minibuffer-menu org-ref-format-citedate)
 ("citetitle*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle*)
 ("citetitle" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetitle)
 ("Citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor*)
 ("Autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite*)
 ("autocite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite*)
 ("Autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Autocite)
 ("autocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-autocite)
 ("supercite" org-ref-cite-onclick-minibuffer-menu org-ref-format-supercite)
 ("parencite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite*)
 ("cite*" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite*)
 ("Smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Smartcite)
 ("smartcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-smartcite)
 ("Textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Textcite)
 ("textcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-textcite)
 ("footcitetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcitetext)
 ("footcite" org-ref-cite-onclick-minibuffer-menu org-ref-format-footcite)
 ("Parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Parencite)
 ("parencite" org-ref-cite-onclick-minibuffer-menu org-ref-format-parencite)
 ("Cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-Cite)
 ("Citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citeauthor)
 ("Citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealp)
 ("Citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citealt)
 ("Citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citep)
 ("Citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-Citet)
 ("citeyear*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear*)
 ("citeyear" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeyear)
 ("citeauthor*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor*)
 ("citeauthor" org-ref-cite-onclick-minibuffer-menu org-ref-format-citeauthor)
 ("citetext" org-ref-cite-onclick-minibuffer-menu org-ref-format-citetext)
 ("citenum" org-ref-cite-onclick-minibuffer-menu org-ref-format-citenum)
 ("citealp*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp*)
 ("citealp" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealp)
 ("citealt*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt*)
 ("citealt" org-ref-cite-onclick-minibuffer-menu org-ref-format-citealt)
 ("citep*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep*)
 ("citep" org-ref-cite-onclick-minibuffer-menu org-ref-format-citep)
 ("citet*" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet*)
 ("citet" org-ref-cite-onclick-minibuffer-menu org-ref-format-citet)
 ("nocite" org-ref-cite-onclick-minibuffer-menu org-ref-format-nocite)
 ("cite" org-ref-cite-onclick-minibuffer-menu org-ref-format-cite)
 ("eqref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (goto-char
     (point-min))
    (if
	(or
	 (re-search-forward
	  (format "label:%s" label)
	  nil t)
	 (re-search-forward
	  (format "\\label{%s}" label)
	  nil t)
	 (re-search-forward
	  (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	  nil t))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<eqref>%s</eqref>)" path))
     ((eq format 'latex)
      (format "\\eqref{%s}" keyword)))))
 ("nameref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<nameref>%s</nameref>)" path))
     ((eq format 'latex)
      (format "\\nameref{%s}" keyword)))))
 ("pageref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<pageref>%s</pageref>)" path))
     ((eq format 'latex)
      (format "\\pageref{%s}" keyword)))))
 ("ref"
  (lambda
    (label)
    "on clicking goto the label. Navigate back with C-c &"
    (org-mark-ring-push)
    (widen)
    (if
	(or
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "label:%s\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "\\label{%s}" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+label:\\s-*\\(%s\\)\\b" label)
	    nil t))
	 (progn
	   (goto-char
	    (point-min))
	   (re-search-forward
	    (format "^#\\+tblname:\\s-*\\(%s\\)\\b" label)
	    nil t)))
	nil
      (org-mark-ring-goto)
      (error "%s not found" label))
    (org-show-entry)
    (message "go back with (org-mark-ring-goto) `C-c &`"))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<ref>%s</ref>)" path))
     ((eq format 'latex)
      (format "\\ref{%s}" keyword)))))
 ("label"
  (lambda
    (label)
    "on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels!"
    (message
     (format "%s occurences"
	     (+
	      (count-matches
	       (format "label:%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+tblname:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "\\label{%s}\\b" label)
	       (point-min)
	       (point-max)
	       t)
	      (count-matches
	       (format "^#\\+label:\\s-*%s\\b[^-:]" label)
	       (point-min)
	       (point-max)
	       t)))))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format "(<label>%s</label>)" path))
     ((eq format 'latex)
      (format "\\label{%s}" keyword)))))
 ("list-of-tables" org-ref-list-of-tables
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoftables")))))
 ("list-of-figures" org-ref-list-of-figures
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\listoffigures")))))
 ("addbibresource"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-addbibresource)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\addbibresource{%s}" keyword)))))
 ("bibliographystyle"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'latex)
      (format "\\bibliographystyle{%s}" keyword)))))
 ("printbibliography"
  (lambda
    (arg)
    (message "Nothing implemented for clicking here."))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      "\\printbibliography"))))
 ("nobibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\nobibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("bibliography"
  (lambda
    (link-string)
    (let*
	((bibfile)
	 (object
	  (org-element-context))
	 (link-string-beginning)
	 (link-string-end))
      (save-excursion
	(goto-char
	 (org-element-property :begin object))
	(search-forward link-string nil nil 1)
	(setq link-string-beginning
	      (match-beginning 0))
	(setq link-string-end
	      (match-end 0)))
      (set
       (make-local-variable 'reftex-default-bibliography)
       (split-string
	(org-element-property :path object)
	","))
      (save-excursion
	(if
	    (search-forward "," link-string-end 1 1)
	    (setq key-end
		  (-
		   (match-end 0)
		   1))
	  (setq key-end
		(point))))
      (save-excursion
	(if
	    (search-backward "," link-string-beginning 1 1)
	    (setq key-beginning
		  (+
		   (match-beginning 0)
		   1))
	  (setq key-beginning
		(point))))
      (setq bibfile
	    (org-ref-strip-string
	     (buffer-substring key-beginning key-end)))
      (find-file bibfile)))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'org)
      (org-ref-get-org-bibliography))
     ((eq format 'ascii)
      (org-ref-get-ascii-bibliography))
     ((eq format 'html)
      (org-ref-get-html-bibliography))
     ((eq format 'latex)
      (format "\\bibliography{%s}"
	      (replace-regexp-in-string "\\.bib" ""
					(mapconcat 'identity
						   (mapcar 'expand-file-name
							   (split-string keyword ","))
						   ",")))))))
 ("pydoc"
  (lambda
    (link-string)
    (shell-command
     (format "python -m pydoc %s" link-string)))
  nil)
 ("index"
  (lambda
    (path)
    (tq-index)
    (occur path))
  nil)
 ("attachfile"
  (lambda
    (link-string)
    (org-open-file link-string))
  (lambda
    (keyword desc format)
    (cond
     ((eq format 'html)
      (format ""))
     ((eq format 'latex)
      (format "\\attachfile{%s}" keyword)))))
 ("msx" org-msx-open nil)
 ("id" org-id-open nil)
 ("file+emacs" org-open-file-with-emacs nil)
 ("file+sys" org-open-file-with-system nil))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (link-string)
   (browse-url
    (format "http://www.google.com/search?q=%s"
	    (url-hexify-string link-string))))
 nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setf (cadr (assoc "google" org-link-protocols))
  (lambda (x) (message "You googled %s good" x)))
#+END_SRC

#+RESULTS:
| lambda | (x) | (message You googled %s good x) |

#+BEGIN_SRC emacs-lisp :results code
(car org-link-protocols)
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
("google"
 (lambda
   (x)
   (message "You googled %s good" x))
 nil)
#+END_SRC

google:test

This way you can make the function do what ever you want, without digging into the source code, advising functions etc...

#+BEGIN_SRC emacs-lisp
(assoc "file" org-link-protocols)
#+END_SRC

#+RESULTS:
skim:ts
* Unlinkify an org link

cnn

a f test.regfdsa


#+BEGIN_SRC emacs-lisp
(defun unlinkify ()
  "replace an org-link with the path, or description."
  (interactive)
  (let ((eop (org-element-context)))
    (when (eq 'link (car eop))
(message "%s" eop)
      (let* ((start (org-element-property :begin eop))
	     (end (org-element-property :end eop))
	     (contents-begin (org-element-property :contents-begin eop))
	     (contents-end (org-element-property :contents-end eop))
	     (path (org-element-property :path eop))
	     (desc (and contents-begin
			contents-end
			(buffer-substring contents-begin contents-end))))
	(setf (buffer-substring start end) (or desc path))))))
#+END_SRC

#+RESULTS:
: unlinkify

* retired wos python code

Get this here: https://gist.github.com/domoritz/2012629
#+BEGIN_SRC python :tangle wos.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from suds.client import Client
from suds.transport.http import HttpTransport
import urllib2

class HTTPSudsPreprocessor(urllib2.BaseHandler):
    def __init__(self, SID):
        self.SID = SID

    def http_request(self, req):
        req.add_header('cookie', 'SID="'+self.SID+'"')
        return req

    https_request = http_request


class WokmwsSoapClient():
    """
    main steps you have to do:
        soap = WokmwsSoapClient()
        results = soap.search(...)
    """
    def __init__(self):
        self.url = self.client = {}
        self.SID = ''

        self.url['auth'] = 'http://search.isiknowledge.com/esti/wokmws/ws/WOKMWSAuthenticate?wsdl'
        self.url['search'] = 'http://search.isiknowledge.com/esti/wokmws/ws/WokSearchLite?wsdl'

        self.prepare()

    def __del__(self):
        self.close()

    def prepare(self):
        """does all the initialization we need for a request"""
        self.initAuthClient()
        self.authenticate()
        self.initSearchClient()

    def initAuthClient(self):
        self.client['auth'] = Client(self.url['auth'])

    def initSearchClient(self):
        http = HttpTransport()
        opener = urllib2.build_opener(HTTPSudsPreprocessor(self.SID))
        http.urlopener = opener
        self.client['search'] = Client(self.url['search'], transport = http)

    def authenticate(self):
        self.SID = self.client['auth'].service.authenticate()

    def close(self):
        self.client['auth'].service.closeSession()

    def search(self, query):
        qparams = {
            'databaseID' : 'WOS',
            'userQuery' : query,
            'queryLanguage' : 'en',
            'editions' : [{
                'collection' : 'WOS',
                'edition' : 'SCI',
            },{
                'collection' : 'WOS',
                'edition' : 'SSCI',
            }]
        }

        rparams = {
            'count' : 5, # 1-100
            'firstRecord' : 1,
            'fields' : [{
                'name' : 'Relevance',
                'sort' : 'D',
            }],
        }

        return self.client['search'].service.search(qparams, rparams)
#+END_SRC

#+BEGIN_SRC sh
pip install suds
#+END_SRC

#+BEGIN_SRC python
from wos import *
soap = WokmwsSoapClient()
results = soap.search('AU=kitchin')
print results
#+END_SRC

#+RESULTS:

suds.WebFault: Server raised fault: 'The Web Service (version 2.0) has been retired permanently. Please contact Thomson Reuters IP and Science Technical Support http://ip-science.thomsonreuters.com/techsupport/ for information on how to obtain a new version of our Web Service.'
* Spelling and grammar checking in emacs with a web API

After the deadline (http://www.afterthedeadline.com/api.slp) has an API for checking spelling, grammar, statistics and style. You post to their server, and they send back some xml. Here is a minimal example in emacs.

#+BEGIN_SRC emacs-lisp
(let ((url-request-method "POST")
      (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not"))))
  (with-current-buffer
      (url-retrieve-synchronously
       "http://service.afterthedeadline.com/checkDocument")
    (buffer-substring url-http-end-of-headers (point-max))))
#+END_SRC

#+RESULTS:
#+begin_example

<results>
  <error>
    <string>spel</string>
    <description>Spelling</description>
    <precontext>be</precontext>
    <suggestions>
        <option>spell</option>
        <option>spelt</option>
        <option>sped</option>
        <option>spec</option>
        <option>spew</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>gud</string>
    <description>Spelling</description>
    <precontext>spel</precontext>
    <suggestions>
        <option>gd</option>
        <option>gu</option>
        <option>gcd</option>
        <option>gad</option>
        <option>guid</option>
    </suggestions>
    <type>spelling</type>

  </error>
  <error>
    <string>weather</string>
    <description>Did you mean...</description>
    <precontext>gud</precontext>
    <suggestions>
        <option>whether</option>
    </suggestions>
    <type>spelling</type>
    <url>http://service.afterthedeadline.com/info.slp?text=weather&amp;tags=NN&amp;engine=0</url>

  </error>
  <error>
    <string>to be</string>
    <description>Passive voice</description>
    <precontext>want</precontext>

    <type>grammar</type>
    <url>http://service.afterthedeadline.com/info.slp?text=to+be&amp;tags=TO%2FVB&amp;engine=3</url>

  </error>
</results>
#+end_example

It finds two spelling errors, and a probable other kind of error (whether/weather), and a grammar issue. It would be nice to parse this into something more helpful. Emacs has come xml parsing [[http://www.emacswiki.org/emacs/XmlParserExamples][capabilities]], which we consider next.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-get-children)
#+END_SRC

#+RESULTS:
: xml-get-children is a compiled Lisp function in `xml.el'.
:
: (xml-get-children NODE CHILD-NAME)
:
: Return the children of NODE whose tag is CHILD-NAME.
: CHILD-NAME should match the value returned by `xml-node-name'.

#+BEGIN_SRC emacs-lisp
(describe-function 'xml-node-children)
#+END_SRC

#+RESULTS:
: xml-node-children is a compiled Lisp function in `xml.el'.
:
: (xml-node-children NODE)
:
: Return the list of children of NODE.
: This is a list of nodes, and it can be nil.

#+BEGIN_SRC emacs-lisp :results drawer
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max)))))
  xml)
#+END_SRC

#+RESULTS:
:RESULTS:
((results nil
   (error nil
     (string nil spel)
     (description nil Spelling)
     (precontext nil be)
     (suggestions nil
         (option nil spell)
         (option nil spelt)
         (option nil sped)
         (option nil spec)
         (option nil spew)
    )
     (type nil spelling)

  )
   (error nil
     (string nil gud)
     (description nil Spelling)
     (precontext nil spel)
     (suggestions nil
         (option nil gd)
         (option nil gu)
         (option nil gcd)
         (option nil gad)
         (option nil guid)
    )
     (type nil spelling)

  )
   (error nil
     (string nil weather)
     (description nil Did you mean...)
     (precontext nil gud)
     (suggestions nil
         (option nil whether)
    )
     (type nil spelling)
     (url nil http://service.afterthedeadline.com/info.slp?text=weather&tags=NN&engine=0)

  )
   (error nil
     (string nil to be)
     (description nil Passive voice)
     (precontext nil want)

     (type nil grammar)
     (url nil http://service.afterthedeadline.com/info.slp?text=to+be&tags=TO%2FVB&engine=3)

  )
))
:END:

Here, we have some code that parses that xml into some more readable text. It took a while to work this out, and it still doesn't seem very beautiful.

#+BEGIN_SRC emacs-lisp :results output
(let* ((url-request-method "POST")
       (url-request-data (format
			 "key=jkitchin&data=%s"
			 (url-hexify-string
			  "I want to be spel gud weather you know it or not")))
       (xml  (with-current-buffer
		 (url-retrieve-synchronously
		  "http://service.afterthedeadline.com/checkDocument")
	       (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (errors (xml-get-children results 'error)))
  (dolist (err errors)
    (let* ((children (xml-node-children err))
	   ;; for some reason I could not get the string out, and had to do this.
	   (s (car (last (nth 1 children))))
	   ;; the last/car stuff doesn't seem right. there is probably
	   ;; a more idiomatic way to get this
           (desc (last (car (xml-get-children children 'description))))
	   (type (last (car (xml-get-children children 'type))))
	   (suggestions (xml-get-children children 'suggestions))
	   (options (xml-get-children (xml-node-name suggestions) 'option))
	   (opt-string  (mapconcat
		 (lambda (el)
		   (when (listp el)
		     (car (last el))))
		 options
		 " "))
	  )
      (princ (format "** %s ** %s
Description: %s
Suggestions: %s

" s type desc opt-string)))))
#+END_SRC

#+RESULTS:
#+begin_example
** spel ** (spelling)
Description: (Spelling)
Suggestions: spell spelt sped spec spew

** gud ** (spelling)
Description: (Spelling)
Suggestions: gd gu gcd gad guid

** weather ** (spelling)
Description: (Did you mean...)
Suggestions: whether

** to be ** (grammar)
Description: (Passive voice)
Suggestions:

#+end_example

Still, from here we could make some org links to go to different places in the buffer for editing.

** python approach

Basically, you post a request to the website, and you get an xml response back. I adapted this code from https://bitbucket.org/miguelventura/after_the_deadline/wiki/Home to do a simple spell check. The idea is to build this up to an emacs lisp library that does this from a command.

#+BEGIN_SRC python
import requests
import urllib

payload = urllib.urlencode({'key': None,
                            'data': 'I spel gud'})

url = "http://service.afterthedeadline.com/checkDocument"

r = requests.post(url, data=payload)

from xml.etree import ElementTree
e = ElementTree.fromstring(r.text)

errs = e.findall('message')
if len(errs) > 0:
    raise Exception('Server returned an error: %s' % errs[0].text)

for err in e.findall('error'):
    if err[1].text == 'Spelling':
        print '\n**{}** mispelled\nSuggestions:'.format(err[0].text)
        for opt in err.findall('suggestions/option'):
            print '  {}'.format(opt.text)
#+END_SRC

#+RESULTS:
#+begin_example

**spel** mispelled
Suggestions:
  sped
  spell
  spelt
  spec
  spew

**gud** mispelled
Suggestions:
  guy
  god
  gun
  gum
  gut
#+end_example



* Capturing stderr and stdout in org-mode

It looks like you have to send these to files, and then read them.

If we run this in org-mode, there is no message about stderr.
#+BEGIN_SRC python :tangle peo.py
import sys

print >>sys.stdout, "on stdout"
print >>sys.stderr, "on stderr"
#+END_SRC

#+RESULTS:
: on stdout

elisp:org-babel-tangle

Interestingly, we get stderr here...
#+BEGIN_SRC emacs-lisp
(shell-command-to-string "python peo.py")
#+END_SRC
#+RESULTS:
: on stderr
: on stdout



* TODO Saving state data to a file in Emacs
  :PROPERTIES:
  :categories: emacs,lisp
  :END:

I want to be able to save state data to a file from Emacs, and read it in later, possible after Emacs has been closed and re-opened. Here we document how to save the results to a file, and then later read them in. First, say we have a list containing a string, and we want to write it to disk. We will use the print function [[elisp:(describe-function 'print)]] for this. The basic strategy is to print the variable to a buffer that is written to file. Later, we can read the data in.

#+BEGIN_SRC emacs-lisp
(setq assignments '("one"))
(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| one |

Now, to read it back, we will load the file in a buffer, and then use the [[elisp:(describe-function 'read)]].

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
 (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

We can add to the list, and update the file easy enough.

#+BEGIN_SRC emacs-lisp
(add-to-list 'assignments "two")

(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

And, checking the results:

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
  (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

In the next sections, we consider saving more complex data structures.

** Saving an alist

We can save an alist

#+BEGIN_SRC emacs-lisp :results raw
(with-temp-file "state-alist.el"
  (print '(("title" . "the title")
           ("author" . "John Kitchin")
           ("email" . "jkitchin@cmu.edu"))
	 (current-buffer)))
#+END_SRC

#+RESULTS:
((title . the title) (author . John Kitchin) (email . jkitchin@cmu.edu))

And, then read it in and access data from it.

#+BEGIN_SRC emacs-lisp
(cdr (assoc "email"
	 (with-temp-buffer (insert-file-contents "state-alist.el")
	   (read (current-buffer)))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Writing and reading a plist

The print function can handle a plist.

#+BEGIN_SRC emacs-lisp
(with-temp-file "state-plist.el"
  (print '(:title   "the title"
		    :author  "John Kitchin"
		    :email   "jkitchin@cmu.edu")
	 (current-buffer)))
#+END_SRC

#+RESULTS:
| :title | the title | :author | John Kitchin | :email | jkitchin@cmu.edu |

#+BEGIN_SRC emacs-lisp
(plist-get (with-temp-buffer
	       (insert-file-contents "state-plist.el")
	     (read (current-buffer))) :author)
#+END_SRC

#+RESULTS:
: John Kitchin

** Writing and reading a hash table
We can save a hash table.

#+BEGIN_SRC emacs-lisp
(setq my-hash (make-hash-table :test 'equal))

(puthash "title" "the title" my-hash)
(puthash "author" "John Kitchin" my-hash)
(puthash "email" "jkitchin@cmu.edu" my-hash)

(with-temp-file "state-hash.el"
  (print my-hash (current-buffer)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ("title" "the title" "author" "John Kitchin" "email" "jkitchin@cmu.edu"))

#+BEGIN_SRC emacs-lisp
(gethash "email"
	 (with-temp-buffer (insert-file-contents "state-hash.el")
	   (read (current-buffer))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** Totally different approach using json
I like the symmetry of code and data in Emacs-lisp. There might be some advantages to using a structured data format other than Emacs Lisp data/code. One of them is interoperability with other programs. If there are subprograms that need to analyze the data in Python, for example. Here we consider json as a data format. We can write the data like this.

#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "this.json"
  (let ((data   '(:title   "the title"
			   :author  "John Kitchin"
			   :email   "jkitchin@cmu.edu")))
    (insert (json-encode-plist data))))
#+END_SRC

#+RESULTS:

It is simple enough to read the json data back in. Note, this reads in as an a-list by default.

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdr (assoc 'email (json-read-file "this.json")))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

To get the json read in another form, we have to temporarily define the json-object-type variable.

#+BEGIN_SRC emacs-lisp
(require 'json)
(let ((json-object-type 'plist))
  (plist-get (json-read-file "this.json") :email))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** COMMENT Saving several things in a file
I have some time to kill in an airport, so I am going to explore saving a few variable to file.

#+BEGIN_SRC emacs-lisp
(let ((x 1)
      (y 2))
  (with-temp-file "multi-values.el"
    (print x (current-buffer))
    (print y (current-buffer))))
#+END_SRC

#+RESULTS:
: 2

Now, I presume we have to do two reads to get those values back.

#+BEGIN_SRC emacs-lisp
(let (a b)
  (with-temp-buffer
    (insert-file-contents "multi-values.el")
    (setq a (read (current-buffer)))
    (setq b (read (current-buffer))))
(list a b))
#+END_SRC

#+RESULTS:
| 1 | 2 |

Indeed. That is exactly what we do. The downside of this is you must know in advance the data structure, and read it in the same way. That is reminiscent of binary data structures from Fortran or C. That probably is not too flexible to changes in data structure. For example, you can only add data to the end of the structure if you need to maintain backward compatibility.

** Summary
There are a few options for saving and reading data in different structures and formats. I did not explore very complex data structures here, e.g. deeply nested data, or different types of data within one structure. I still have not completely internalized best practices in writing/reading data. There are several approaches that all involve getting the data into a buffer. That can be done with find-file, or find-file-noselect, or with temp-buffers and insert-file-contents. I do not know which of these approaches are the best. Apparently find-file affects other things such as recent-files, and the buffer list, which may be undesirable. Emacs treats this very differently than Python, where you can simply open a file, and read it to get a string (the closest Python has to a buffer concept are related to StringIO). Interestingly, the json-read-file function uses a temp-buffer, inserts the file contents, and then reads the data. The code resembles this block:

#+BEGIN_SRC emacs-lisp
(defun read-file (file)
  "Read contents of a FILE into a string"
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))

(read-file "state-alist.el")
#+END_SRC
#+RESULTS:
:
: (("title" . "the title") ("author" . "John Kitchin") ("email" . "jkitchin@cmu.edu"))



* "live" graphics in org-mode on a timer

#+tblname: tbldata
|   x |   y |
|-----+-----|
|  10 |   1 |
|   1 |   0 |
|   2 |   4 |
|   3 |   5 |
| 0.2 | 0.3 |


#+RESULTS: make-table-graph
#+BEGIN_SRC org
[[1, 1], [1, 0], [2, 4], [3, 5], [0.2, 0.3]]
[[./live-chart.png]]
#+END_SRC

** Code

#+NAME: make-table-graph
#+BEGIN_SRC python :var data=tbldata :results org
import matplotlib.pyplot as plt
plt.plot([x[0] for x in data], [x[1] for x in data])
plt.savefig('live-chart.png')
print data
print '[[./live-chart.png]]'
#+END_SRC

Now, for the elisp part.

#+BEGIN_SRC emacs-lisp
(defun update-graph ()
  (save-excursion
    (goto-char (point-min))
    (re-search-forward "#\\+NAME: make-table-graph")
    (forward-line 2)
    (org-babel-execute-src-block)))

(defvar my-timer nil)

(setq my-timer (run-with-idle-timer
		5 ; idle for this many seconds
		t ; repeat indefinitely
		'update-graph))
#+END_SRC

#+RESULTS:
: [nil 0 5 0 t update-graph nil idle 0]

#+BEGIN_SRC emacs-lisp
(cancel-timer my-timer)
#+END_SRC
* An experiment of integrating git with save
  :PROPERTIES:
  :categories: git
  :END:
This is a little experiment to integrate saving a file with git. The idea is that every time we save, we also commit the changes. That way later we can undo changes, even after the file is closed and undo history is lost.

#+BEGIN_SRC emacs-lisp
(defun git-save-commit ()
  "Save buffer and commit it to the git repo."
  (interactive)
  (when
      (shell-command "git rev-parse --is-inside-work-tree")
    (save-buffer)

    ;; I am not sure if this works on a file nested in the repo
    (let ((f (file-relative-name
	      (buffer-file-name)
	      default-directory)))
      (shell-command (format "git add %s" f))
      (shell-command (format "git commit %s -m \"save\"" f)))))

(add-hook 'after-save-hook 'git-save-commit)

;; this runs just before autosave
(add-hook 'auto-save-hook 'git-save-commit)
#+END_SRC

#+RESULTS:
| git-save-commit | tramp-set-auto-save-file-modes |

#+BEGIN_SRC sh
git hist -n 10
#+END_SRC

* archived introspection work
some hints to get started

http://stackoverflow.com/questions/605785/how-do-i-get-a-list-of-emacs-lisp-non-interactive-functions

related code that might allow us to find all functions defined in a file with some filtering, if we find where the functions are from.

#+BEGIN_SRC emacs-lisp
(find-lisp-object-file-name 'jmax-stringify-journal-name  'defun)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(flet ((first-line (text)
         (if text
             (substring text 0 (string-match "\n" text))
           "")))
  (mapatoms
   (lambda (x)
     (and (fboundp x)                          ; does x name a function?
          (not (commandp (symbol-function x))) ; is it non-interactive?
          (subrp (symbol-function x))          ; is it built-in?
          (insert (symbol-name x) " - " (first-line (documentation x)) "\n")))))
#+END_SRC


#+BEGIN_SRC emacs-lisp :results drawer
(let ((r '()))
      (mapatoms
       (lambda (x)
	 (add-to-list 'r
		      (find-lisp-object-file-name x 'defun)))))
#+END_SRC

#+RESULTS:
:RESULTS:
nil
:END:

(documentation 'jmax-stringify-journal-name)

(describe-key)
(describe-function)



#+BEGIN_SRC emacs-lisp
(require 'bibtools)
(let ((funclist ()))
  (mapatoms
   (lambda (x)
     (when (and (fboundp x)                     ; does x name a function?
                (let ((f (symbol-file x)))
                  (and f (string= (file-name-base f) "jmax-bibtex"))))
       (push x funclist))))
  funclist)
#+END_SRC

#+RESULTS:
| jmax-replace-nonascii | jmax-stringify-journal-name | jmax-bibtex-next-entry | jmax-title-case-article | jmax-bibtex-generate-shorttitles | jmax-bibtex-mode-keys | jmax-bibtex-generate-longtitles | jmax-bibtex-previous-entry | jmax-sentence-case-article |


#+BEGIN_SRC emacs-lisp :results code
((find-file  "../../Dropbox/kitchingroup/jmax/jmax-bibtex.el")
(imenu-default-create-index-function))
;; (imenu-choose-buffer-index))
#+END_SRC

#+RESULTS:


http://stackoverflow.com/questions/26330363/how-do-i-get-a-list-of-functions-defined-in-an-emacs-lisp-file/26360946?iemail=1&noredirect=1#26360946

#+BEGIN_SRC emacs-lisp
(cdr (assoc "/Users/jkitchin/Dropbox/kitchingroup/jmax/jmax-bibtex.el" load-history ))
#+END_SRC

#+RESULTS:
| jmax-bibtex-journal-abbreviations | (defun . jmax-bibtex-generate-longtitles) | (defun . jmax-bibtex-generate-shorttitles) | (defun . jmax-stringify-journal-name) | (defun . jmax-set-journal-string) | jmax-nonascii-latex-replacements | (defun . jmax-replace-nonascii) | jmax-lower-case-words | (defun . jmax-title-case-article) | (defun . jmax-sentence-case-article) | (defun . jmax-bibtex-next-entry) | (defun . jmax-bibtex-previous-entry) | (defun . jmax-bibtex-mode-keys) | (provide . jmax-bibtex) |
* cycle src blocks

#+BEGIN_SRC emacs-lisp
(save-restriction
  (org-narrow-to-subtree)
  (goto-char (point-min))
  (let ((case-fold-search t))
    (while (re-search-forward "#\\+BEGIN_SRC" nil t)
      (org-cycle))))
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(save-excursion
  (save-restriction
    (org-narrow-to-subtree)
    (goto-char (point-min))
    (org-element-map
	(org-element-parse-buffer)
	'src-block
      (lambda (element)
	(goto-char (org-element-property :begin element))
	(org-cycle)))))
#+END_SRC

#+RESULTS:


(remove-hook 'org-cycle-hook 'org-hide-block-all)


#+BEGIN_SRC emacs-lisp
(defun my-hide (state)
  (message "%s" state)
  (if (or (eq state 'children)
	  (eq state 'subtree))
      (save-restriction
	(org-narrow-to-subtree)
	(org-hide-block-all))))

(add-hook 'org-cycle-hook 'my-hide)
#+END_SRC

#+RESULTS:
| my-hide | org-cycle-hide-archived-subtrees | org-cycle-hide-drawers | org-cycle-hide-inline-tasks | org-cycle-show-empty-lines | org-optimize-window-after-visibility-change |

** code blocks

#+BEGIN_SRC python
print 'hello'
#+END_SRC

#+BEGIN_SRC sh
echo hello
#+END_SRC

#+BEGIN_SRC emacs-lisp
(format "hello")
#+END_SRC
#+RESULTS:

** another heading
with test

* Using filters to redefine output

I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][this post]] I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this [[http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html][post]] on the org-mode mail list that made me think I have totally missed the boat on how to do this!

Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored sometimes as a text property.

file:bib1.bib

[[file:bib1.bib]]

[[./bib1.bib][bibliography]]


#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
#+END_SRC


#+tblname: my-table
| 1 | 3 |
| 3 | 4 |

#+BEGIN_SRC emacs-lisp :results output
(defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
#+END_SRC

#+RESULTS:
#+begin_example
198: (table-cell (:begin 2020 :end 2024 :contents-begin 2021 :contents-end 2022 :post-blank 0 :parent (table-row (:type standard :begin 2019 :end 2029 :contents-begin 2020 :contents-end 2028 :post-blank 0 :parent (table (:begin 1999 :end 2040 :type org :tblfm nil :contents-begin 2019 :contents-end 2039 :value nil :post-blank 1 :post-affiliated 2019 :name my-table :parent (section (:begin 38 :end 2530 :contents-begin 38 :contents-end 2523 :post-blank 7 :parent (headline (:raw-value Using filters to redefine output :begin 2 :end 2530 :pre-blank 1 :hiddenp nil :contents-begin 38 :contents-end 2523 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 7 :footnote-section-p nil :archivedp nil :commentedp nil :quotedp nil :CATEGORY blog :title (Using filters to redefine output) :parent (org-data nil #8)) #6)) (paragraph (:begin 38 :end 639 :contents-begin 38 :contents-end 638 :post-blank 1 :post-affiliated 38 :parent #6) I have written about filters before, but admittedly, I have never fully grasped how to get all the information you need. For example, in  (link (:type http :path //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :raw-link http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ :application nil :search-option nil :begin 175 :end 288 :contents-begin 276 :contents-end 285 :post-blank 1 :parent #7) this post) I came up with a convoluted method to preprocess an org-file to get a list of link properties, and then keep a running counter to access the nth property. Recently I saw this  (link (:type http :path //lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :raw-link http://lists.gnu.org/archive/html/emacs-orgmode/2014-10/msg00084.html :application nil :search-option nil :begin 463 :end 543 :contents-begin 536 :contents-end 540 :post-blank 1 :parent #7) post) on the org-mode mail list that made me think I have totally missed the boat on how to do this!
) (paragraph (:begin 639 :end 895 :contents-begin 639 :contents-end 894 :post-blank 1 :post-affiliated 639 :parent #6) Here is the key point I have missed all along. You can apparently get the element associated with the text, and from that you can get any property of the element. Apparently, you find the next property change, and then get them. The element is stored in
) (paragraph (:begin 895 :end 910 :contents-begin 895 :contents-end 909 :post-blank 1 :post-affiliated 895 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 895 :end 908 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 910 :end 929 :contents-begin 910 :contents-end 928 :post-blank 1 :post-affiliated 910 :parent #6) (link (:type file :path bib1.bib :raw-link file:bib1.bib :application nil :search-option nil :begin 910 :end 927 :contents-begin nil :contents-end nil :post-blank 0 :parent #7))
) (paragraph (:begin 929 :end 960 :contents-begin 929 :contents-end 958 :post-blank 2 :post-affiliated 929 :parent #6) (link (:type file :path ./bib1.bib :raw-link ./bib1.bib :application nil :search-option nil :begin 929 :end 957 :contents-begin 943 :contents-end 955 :post-blank 0 :parent #7) bibliography)
) (src-block (:language emacs-lisp :switches nil :parameters nil :begin 960 :end 1999 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-link (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (link (if beg (get-text-property beg :parent text))))
    (cond
     (link
      (princ (format "%s: %s\n\n\n" beg link (org-element-property :type link))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))
;; >     (cond ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "bib"))
;; >            (format "\\cite{%s}" (org-element-property :path link)))
;; >           ((and link
;; >                 (org-export-derived-backend-p backend 'latex)
;; >                 (string= (org-element-property :type link) "file")
;; >                 (string= (org-element-property :path link) "~/.bib.bib"))
;; >            (format "\\cite{%s}" (org-element-property :search-option link)))
;; >           (t text))))
(let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-html-export-as-html))
 :post-blank 2 :post-affiliated 960 :parent #6)) #4 (src-block (:language emacs-lisp :switches nil :parameters nil :begin 2040 :end 2495 :number-lines nil :preserve-indent t :retain-labels t :use-labels t :label-fmt nil :hiddenp nil :value (defun ox-mrkup-filter-table (text back-end info)
  (let* ((beg (next-property-change 0 text))
	 (table (if beg (get-text-property beg :parent text))))
    (cond
     (table
      (princ (format "%s: %s\n\n\n" beg table (org-element-property :name table))))
     (t
      (princ (concat "No change: " text "\n\n\n"))))))

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table)))
    (org-html-export-as-html))
 :post-blank 1 :post-affiliated 2040 :parent #6)) (fixed-width (:begin 2495 :end 2523 :value 198: nil


 :post-blank 0 :post-affiliated 2506 :results () :parent #6)))) #2 (table-row (:type standard :begin 2029 :end 2039 :contents-begin 2030 :contents-end 2038 :post-blank 0 :parent #4) (table-cell (:begin 2030 :end 2034 :contents-begin 2031 :contents-end 2032 :post-blank 0 :parent #5) 3) (table-cell (:begin 2034 :end 2038 :contents-begin 2035 :contents-end 2036 :post-blank 0 :parent #5) 4)))) #0 (table-cell (:begin 2024 :end 2028 :contents-begin 2025 :contents-end 2026 :post-blank 0 :parent #2) 3))) 1)


#+end_example








* redefining how images are displayed

#+BEGIN_SRC emacs-lisp
(defun org-display-inline-images (&optional include-linked refresh beg end)
  "Display inline images.
Normally only links without a description part are inlined, because this
is how it will work for export.  When INCLUDE-LINKED is set, also links
with a description part will be inlined.  This can be nice for a quick
look at those images, but it does not reflect what exported files will look
like.
When REFRESH is set, refresh existing images between BEG and END.
This will create new image displays only if necessary.
BEG and END default to the buffer boundaries."
  (interactive "P")
  (when (display-graphic-p)
    (unless refresh
      (org-remove-inline-images)
      (if (fboundp 'clear-image-cache) (clear-image-cache)))
    (save-excursion
      (save-restriction
	(widen)
	(setq beg (or beg (point-min)) end (or end (point-max)))
	(goto-char beg)
	(let ((re (concat "\\[\\[\\(\\(file:\\)\\|\\([./~]\\)\\)\\([^]\n]+?"
			  (substring (org-image-file-name-regexp) 0 -2)
			  "\\)\\]" (if include-linked "" "\\]")))
	      (case-fold-search t)
	      old file ov img type attrwidth width)
	  (while (re-search-forward re end t)
	    (setq old (get-char-property-and-overlay (match-beginning 1)
						     'org-image-overlay)
		  file (expand-file-name
			(concat (or (match-string 3) "") (match-string 4))))
	    (when (image-type-available-p 'imagemagick)
	      (setq attrwidth (if (or (listp org-image-actual-width)
				      (null org-image-actual-width))
				  (save-excursion
				    (save-match-data
				      (when (re-search-backward
;; I modified this regexp
					     "#\\+attr.*:width[ \t]+\\([0-9]+\\)\\(in\\|px\\|cm\\)"
					     (save-excursion
					       (re-search-backward "^[ \t]*$\\|\\`" nil t)) t)
;; and here, if we catch units, we fall back on org-image-actual-width
;; by setting attrwidth to nil
					(if (match-string 2) nil
					  (string-to-number (match-string 1)))))))
		    width (cond ((eq org-image-actual-width t) nil)
				((null org-image-actual-width) attrwidth)
				((numberp org-image-actual-width)
				 org-image-actual-width)
				((listp org-image-actual-width)
				 (or attrwidth (car org-image-actual-width))))
		    type (if width 'imagemagick)))
	    (when (file-exists-p file)
	      (if (and (car-safe old) refresh)
		  (image-refresh (overlay-get (cdr old) 'display))
		(setq img (save-match-data (create-image file type nil :width width)))
		(when img
		  (setq ov (make-overlay (match-beginning 0) (match-end 0)))
		  (overlay-put ov 'display img)
		  (overlay-put ov 'face 'default)
		  (overlay-put ov 'org-image-overlay t)
		  (overlay-put ov 'modification-hooks
			       (list 'org-display-inline-remove-overlay))
		  (push ov org-inline-image-overlays))))))))))
#+END_SRC

#+RESULTS:
: org-display-inline-images
:

#+attr_latex: :width 4in :placement [H]
#+ATTR_org: :width 200
[[./images/batch-multiple.png]]

elisp:org-display-inline-images
* org-mode and Perl

https://metacpan.org/pod/GD::Graph#EXAMPLES

#+BEGIN_SRC perl
load GD::Graph;
@data = (
  ["1st","2nd","3rd","4th","5th","6th","7th", "8th", "9th"],
  [    1,    2,    5,    6,    3,  1.5,    1,     3,     4],
  [ sort { $a <=> $b } (1, 2, 5, 6, 3, 1.5, 1, 3, 4) ]
);

my $graph = GD::Graph::chart->new(400, 300);

$graph->set(
    x_label           => 'X Label',
    y_label           => 'Y label',
    title             => 'Some simple graph',
    y_max_value       => 8,
    y_tick_number     => 8,
    y_label_skip      => 2
) or die $graph->error;

my $gd = $graph->plot(\@data) or die $graph->error;
#+END_SRC

#+RESULTS:
* Scripting git
I am running a project where I need to script git to "do the right thing" non-interactively. The project involves students creating assignments, and then turning them in. They create the assignments in Emacs+org-mode, and then "turn in" the assignment by running a menu command that commits their work to a git repository, and then pushes it to my server. Some emacs-lisp code does all this magic. Most of the time.

Occasionally, students have had trouble when it comes time to update their graded assignments. These assignments have been pulled from the server by me, graded, and pushed back. I did not anticipate that students would continue changing their local repos after turning the work in, and this causes issues when they try to pull the results back.

Here I document how to make this process a bit more robust. Basically, we need to make sure the local repo is clean before we pull, then we need to check if there were merge conflicts. Since the conflicts are probably notes the students took, we will be conservative and just accept the merge markers in the text so they do not lose their notes.

What we need to do is check the output of "git status --porcelain" and do an appropriate action for each file. The output of this command is one line per file that requires some action. Basically we can have untracked files, which should just be added and committed. The reason for this is that if I create a file with the same name, it will be a conflict for git to overwrite their existing file. There could be added or modified files, renamed files, deleted files  updated but unmerged, and some other possibilities too.

The "git status --porcelain" command gives a two letter status code for each file that is not "clean". The first letter is the status of the index, and the second letter is the status of the work-tree, unless there is a merge conflict, and then they are the status of the file on each side of the merge.

#+BEGIN_EXAMPLE
       o   ' ' = unmodified

       o    M = modified

       o    A = added

       o    D = deleted

       o    R = renamed

       o    C = copied

       o    U = updated but unmerged

       Ignored files are not listed, unless --ignored option is in effect, in
       which case XY are !!.

           X          Y     Meaning
           -------------------------------------------------
                     [MD]   not updated
           M        [ MD]   updated in index
           A        [ MD]   added to index
           D         [ M]   deleted from index
           R        [ MD]   renamed in index
           C        [ MD]   copied in index
           [MARC]           index and work tree matches
           [ MARC]     M    work tree changed since index
           [ MARC]     D    deleted in work tree
           -------------------------------------------------
           D           D    unmerged, both deleted
           A           U    unmerged, added by us
           U           D    unmerged, deleted by them
           U           A    unmerged, added by them
           D           U    unmerged, deleted by us
           A           A    unmerged, both added
           U           U    unmerged, both modified
           -------------------------------------------------
           ?           ?    untracked
           !           !    ignored
           -------------------------------------------------
#+END_EXAMPLE

The man page recommends we use the -z option for parsing which ends strings with a null character.
#+BEGIN_SRC sh :dir ~/Desktop/A
git status --porcelain
#+END_SRC

#+RESULTS:
: R  f1 -> f1-rname
:  D f2
: ?? f2-rname


It seems like we need to parse the porcelain command, get X, and Y, and depending on what those are, we have a set of cond statements to act appropriately.


Here is a function to parse a line of porcelain output.
#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results raw
(defun parse-line (line)
  (let* ((X (substring line 0 1))
	 (Y (substring line 1 2))
	 (PATHS (split-string (substring line 3)))
	 (PATH1 (nth 0 PATHS))
         ; for a rename there will be PATH1 -> PATH2
	 (PATH2 (if (= 3 (length PATHS)) (nth 2 PATHS) nil)))
    (list X Y PATH1 PATH2 line)))

(defun parse-git-status ()
 (interactive)
(loop for line in (split-string
		  (shell-command-to-string "git status --porcelain") "\n")
      when (not (string= "" line)) collect (parse-line line)))
#+END_SRC

Now we check out the results.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| R |   | f1       | f1-rname | R  f1 -> f1-rname |
|   | D | f2       | nil      | D f2              |
| ? | ? | f2-rname | nil      | ?? f2-rname       |

That function gives us a list of X, Y, FROM, and TO, and the original string.

Now, we can start building the logic to handle these. The goal of this block as after running, the repo is clean, and you can then pull into it.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results output
(let ((merge-p nil))
  (loop for (X Y FROM TO LINE) in (parse-git-status)
	do
	(cond
	 ;; untracked files get added and committed.
	 ((and (string= X "?")
	       (string= Y "?"))
	  (shell-command (format "git add %s" FROM))
	  (shell-command
	   (format "git commit %s \"adding %s.\""
		   FROM FROM)))

	 ;; user rename
	 ((and (string= X "R")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO)))

	 ;; rename and modify
	 ((and (string= X "R")
	       (string= Y "M"))
	  ;; commit the rename
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO))
	  (shell-command (format "git commit %s -m \"changes in %s\"" TO TO)))

	 ;; added file
	 ((and (string= X "A")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m  \"Adding %s\"" FROM FROM)))

	 ;; deleted file
	 ((and (string= X " ")
	       (string= Y "D"))
	  (shell-command (format "git commit %s -m \"Deleting %s\"" FROM FROM)))

	 ;; modified file
	 ((or (string= X "M")
	      (string= Y "M"))
          (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"changes in %s\"" FROM FROM)))

	 ;; merge conflict, we just add the file
	 ;; we do not commit here because you cannot partially commit.
	 ;; after the loop, we do the commit if merge-p is t
	 ((or (string= X "U")
	      (string= Y "U"))
	  (setq merge-p t)
	  (shell-command (format "git add %s" FROM)))

	 ;; catch everything else
	 (t
	  (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"%s\"" FROM LINE))
	  (message "%s not handled gracefully\n" LINE))))
  ;;
  (when merge-p
    (shell-command "git commit -m \"accepting merge\"")))
#+END_SRC
#+RESULTS:


#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| M |   | empty | nil | M  empty |



* Showing that Emacs is working


#+name: my-code
#+BEGIN_SRC python
import numpy
print 5
#+END_SRC

#+RESULTS: my-code
: 5

#+RESULTS:
: 5

This does not work, because there is no way to update the reporter while the code block is running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (let ((pr (make-progress-reporter "Running")))
    ad-do-it
    (progress-reporter-done pr)))
#+END_SRC


Here we create a buffer that indicates what is running
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((code-block (org-element-property :name (org-element-at-point)))
        (LN (line-number-at-pos)))

    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*My Babel*")
    (if code-block
	(insert (format "Running %s\n" code-block))
      (insert (format "Running block at line %s\n" LN)))
    (insert "Started at: " (current-time-string) "\n")
    (other-window 1)
    ad-do-it
    (kill-buffer "*My Babel*")
    (delete-other-windows)))
#+END_SRC

#+BEGIN_SRC python
import time
time.sleep(5)
print 5
#+END_SRC

#+RESULTS:
: 5



Here we change the color of the codeblocks when they are running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (set-face-attribute 'org-block-background nil :background "LightSteelBlue")
  ad-do-it
  (set-face-attribute 'org-block-background nil :background "gray")
(message "Done with code block"))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

Try using an overlay
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((ol (make-overlay (org-element-property :begin (org-element-at-point))
			  (org-element-property :end (org-element-at-point)))))

    (overlay-put ol 'face '(foreground-color . "blue"))

    ad-do-it

    (delete-overlay ol)))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

* Checking if processes are done

#+BEGIN_SRC emacs-lisp
(setq my-process (start-process-shell-command "slp" "*sleep*" "sleep 30"))
#+END_SRC

#+RESULTS:
: #<process slp>

#+BEGIN_SRC emacs-lisp
(process-live-p my-process)
#+END_SRC

#+RESULTS:


Now we try for a set of processes.

#+BEGIN_SRC emacs-lisp
(setq my-processes
      (mapcar
       (lambda (x)
	 (start-process-shell-command "slp" "*sleep*"
				      (format "sleep %s" (random 10))))
       '(1 2)))
#+END_SRC

#+RESULTS:
| slp | slp<1> |

And now check if they are all done.

#+BEGIN_SRC emacs-lisp :results raw
(mapcar (lambda (process) (process-live-p process)) my-processes)
#+END_SRC

#+RESULTS:
((run open listen connect stop) (run open listen connect stop))

This will tell us if any process is still alive.

#+BEGIN_SRC emacs-lisp :results raw
(-any-p 'process-live-p  my-processes))
#+END_SRC

#+RESULTS:
nil
nil
t
t

* Insert a timestamp that is one week older than the last timestamp found
Someone on the maillist asked how to insert a new timestamp that is one week newer than the last timestamp found in the buffer. Here is an exploration of doing that.
** week 1 (<2014-08-25 Mon>)

** week 2 (<2014-09-01 Mon 13:00>)

** Getting the last timestamp

Here we assume that the last element from org-element-map is the last timestamp found. We get the raw value of that timestamp, insert it, and then use interactive commands to change the timestamp.
#+BEGIN_SRC emacs-lisp
(defun insert-ts+1w ()
  "Insert a timestamp at point that is one week later than the
last timestamp found in the buffer."
  (interactive)
  (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
			      (lambda (timestamp)
				(org-element-property :raw-value timestamp)))))))
    (insert last-ts)
    (backward-char 2)
    (org-timestamp-change +7 'day)
    ))
#+END_SRC


This is the result I got from running the command I wrote above. <2014-09-08 Mon 13:00>. It worked!
* insert pages in org-ref

if you use C-c C-l, you can use completion to enter the bibtex key, and then type the page in the description. That is handy if you do not need to search for the entry.

#+BEGIN_SRC emacs-lisp
(defun cite-with-pages (key page)
  (interactive
   (list
    (car (reftex-citation t))
    (read-from-minibuffer "page: ")))
  (insert (format "[[cite:%s][page %s]]" key page)))
#+END_SRC

[[cite:armiento-2014-high][page 34]]


bibliography:../../bibliography/references.bib

* Insert formatted text
We can insert propertized strings, e.g. with different colors like this.
#+BEGIN_SRC emacs-lisp

(with-temp-buffer
  (rename-buffer "test")
  (insert "a "
	  (propertize "mail client"
		      'font-lock-face
		      '(:foreground "blue" :background "white" :underline t))
	  " b "
	  (propertize "smtp" 'font-lock-face '(:foreground "red"))
	  " "
	  (propertize "smtp" 'font-lock-face '(:foreground "forestgreen")))
  (goto-char (point-min))
  (display-buffer (current-buffer))
  (org-mode)
  ;; this just pauses long enough to see the results
  (completing-read "what? " '(1 2 3)))
#+END_SRC

#+RESULTS:
: 1

* Selectively writing out code blocks in org-mode

I have a set of notes for two software packages that contain code examples for each package. I want to selectively extract the code blocks. This post examines a way I could do that. I am going to "tag" each code block with a header. Apparently this is ok, and org-mode ignores the unknown header argument!

#+BEGIN_SRC python :tag package1
print "For use with package1"
#+END_SRC

#+RESULTS:
: For use with package1

#+BEGIN_SRC python :tag package2
print "For use with package2"
#+END_SRC

#+RESULTS:
: For use with package2

Apparently, the :tag header argument is stored in the :parameters property as a string.

#+BEGIN_SRC emacs-lisp :results raw
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element) (org-element-property :parameters element)))
#+END_SRC
#+RESULTS:
(:tag package1 :tag package2 :results raw)

So, we just need to map the source blocks, and perform some action on the ones matching the block we want. Here is one example.

#+BEGIN_SRC emacs-lisp
(org-element-map (org-element-parse-buffer) 'src-block
  (lambda (element)
    (let ((tag (org-element-property :parameters element)))
      (cond
       ((null tag) "no parameters")
       ((string-match ":tag\\s-*package1" tag)
	(format "match p1. code:\n%s" (org-element-property :value element)))
       ((string-match ":tag\\s-*package2" tag)
	(format "match p2. code:\n%s" (org-element-property :value element)))
       (t (format "\"%s\"" tag))))))
#+END_SRC

#+RESULTS:
| match p1. code:\nprint "For use with package1"\n | match p2. code:\nprint "For use with package2"\n | ":results raw" | no parameters |


* Do you have an ssh pubkey?

#+BEGIN_SRC emacs-lisp
(file-exists-p (expand-file-name "~/.ssh/id_rsa.pub"))
#+END_SRC

#+RESULTS:
: t

Make a key with no password in test.pub
#+BEGIN_SRC sh
ssh-keygen -f test -N ""
#+END_SRC

* Write and read json in emacs

If you know your data type, you can get a json representation like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/06-364.log"))))
  (json-encode-alist data))
#+END_SRC

#+RESULTS:
: {"org-course":"c:\/Users\/jkitchin\/Dropbox\/blogofile-jkitchin.github.com\/_blog\/06-364.log"}

You write a file like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "data.json"
  (let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")
		("06625" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com"))))
    (insert (json-encode-alist data))))
#+END_SRC

#+RESULTS:

Now to read it:

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdar (json-read-file "data.json"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com

We also need to conveniently set and change data. We can use setf for this. setf is a generalized version of setq that can take a "place" to set a value to. A "place" can be defined by a cdr, or car, for example. Here is a working example.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((data '(("org-course" . (("userid" . "jkitchin")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")))
	      ("06625" . (("userid" . "somestudent")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com")))))
      (course))
  (setq course (cdr (assoc "org-course" data))) ;; settings for a course

  (setf (cdr (assoc "root" course)) "blog")
data)

#+END_SRC

#+RESULTS:
((org-course (userid . jkitchin) (root . blog)) (06625 (userid . somestudent) (root . c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com)))



* automatic inlining a plot in org-mode with python

It has always bothered me that I have to manually put links to figures in after my code blocks, or I have to custom print org syntax. here is a way to get org to do it.
#+BEGIN_SRC python :file test.png
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.savefig('silly-plot.png')

import os
os.system('cat silly-plot.png')
#+END_SRC

#+RESULTS:
[[file:test.png]]

It is not better if you have add the code at the end to output the image.


#+BEGIN_SRC python :results value :return s
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.savefig('silly-plot.png')

s = '[[./silly-plot.png]]'
#+END_SRC

#+RESULTS:
| ./silly-plot.png |

* org-rubric functions

prototype idea to create a rubric function

#+BEGIN_SRC emacs-lisp
(defun ta-rubric-hwk (technical-grade presentation-grade typography-grade)
  (interactive "nTechnical Grade: \nnPresentation Grade: \nnTypography Grade: ")
  (let
      ((t-weight 0.7) ; weight of technical grade
       (p-weight 0.2) ; weight of presentation grade
       (y-weight 0.1) ; weight of typography grade
       (grade))
    (setq grade (+
		 (* t-weight technical-grade)
		 (* p-weight presentation-grade)
		 (* y-weight typography-grade)))
    (end-of-buffer)
    (insert "\n"
	    (format "#+TECHNICAL_GRADE: %s\n" technical-grade)
	    (format "#+PRESENTATION_GRADE: %s\n" presentation-grade)
	    (format "#+TYPOGRAPHY_GRADE: %s\n" typography-grade)
	    (format "#+GRADE: %s" grade))))
#+END_SRC

#+RESULTS:
: ta-rubric-hwk

Maybe I can add a rubric keyword to assignments so that the right rubric function is called.
* Use org-agenda to select multiple items

This is a hacky way to use the org-contacts agenda to get multiple email addresses from a selection. We remap the return key function to call our function that maps over the selected list and gets the emails from it, and finally undoes the remapping before quitting the agenda. It feels a little hacky because you have to communicate through global variable, and the agenda call is not blocking, so the code carries on. I am not sure how to fix that.

#+BEGIN_SRC emacs-lisp
(defun get-marked ()
 (interactive)
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries)
       *done* t)
 ;; remap key
 (define-key org-agenda-mode-map [remap org-agenda-switch-to] nil)
 (org-agenda-quit))

(defun doit ()
  (interactive)
  (setq *marked-entries* nil
        *done* nil) ; make sure this is empty
  ;;remap so return exits and runs our function above
  (define-key org-agenda-mode-map [remap org-agenda-switch-to] 'get-marked)
  (org-contacts "kit")

  *marked-entries*)
#+END_SRC

This works ok. You can define a function that acts upon the marked entries.
#+BEGIN_SRC emacs-lisp
(defun email-marked ()
 (setq *marked-entries*
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries))
  (compose-mail)
  (message-goto-to)
  (insert (mapconcat 'identity *marked-entries* ",")))

  (org-contacts "kit")
#+END_SRC

* Completion in emacs commands using ido

These are some examples of using ido to provide completion in interactive commands. You just need a list of options, which can be calculated if desired, and the ido-completing-read function. You use these in the interactive function.

** string completion

#+BEGIN_SRC emacs-lisp
(defun email-1 (address)
  (interactive
   (list
    (ido-completing-read
     "Email: "     ; prompt
     '("em1" "em2" "em3") ; choices
     nil ; predicate; ignored, here for compatibility with completing-read
     t ; require match
     )))
  (message "you picked %s" address))
#+END_SRC

#+RESULTS:
: email-1

It is pretty easy to get two arguments.
#+BEGIN_SRC emacs-lisp
(defun email-2 (address label)
  (interactive (list (ido-completing-read "Email: " '("em1" "em2" "em3"))
		     (ido-completing-read "label: " '("important" "easy"))))
  (message "you picked %s with a label of %s" address label))
#+END_SRC

#+RESULTS:
: email-2

** select directories

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun pick-dir (dir)
  (interactive
   (list
    (ido-completing-read
     "Dir: "
     (remove-if-not
      'file-directory-p
      ;; list directories, except for . and ..
      (directory-files default-directory nil "[^.{1,2}]")))))
 (message "you picked this dir: %s" dir))

#+END_SRC

#+RESULTS:
: pick-dir




* put properties on strings

(put-text-property


#+BEGIN_SRC emacs-lisp
   (let ((s "Alex"))
      (put-text-property 0 (length s) 'font-lock-face '(:foreground "blue" :background "white" :underline t) s)
      (message-box s))
#+END_SRC

#+RESULTS:
: Alex

   (let ((s "Alex"))
      (put-text-property 0 (length s) 'face 'diary s)
      (insert s))Alex

finish
#+BEGIN_SRC emacs-lisp
(defun func (a b)
 (interactive (list '("a" "b") '(1 2)))
 (message "%s %s" a b))

#+END_SRC
* TODO get sha1 of a file

use this to make reproducible temp images for org-show.

(secure-hash 'sha1 (with-temp-buffer (insert-file-contents "tst.png") (buffer-string)))


* Running commands in emacs and showing what they do

I sometimes need to script shell commands into emacs functions. Recently, I needed to see the output, to see what was going wrong. This code sort of does that.

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "git status")
(eshell-send-input)
#+END_SRC

#+RESULTS:
: #<marker at 361206 in blog.org>

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "ls")
(eshell-send-input)
(insert "echo $?")
(eshell-send-input)
#+END_SRC

#+RESULTS:

* Running git commands that are interactive

** commands that freeze emacs because of ssh
Vanilla git calls vanilla ssh, which appears to hang anytime you get prompted for /anything/. The following all seems to hang, and you have to kill the ssh process to get control back.
#+BEGIN_SRC emacs-lisp
(shell-command "git clone bad@techela.cheme.cmu.edu:none")
#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(shell-command "git --no-pager clone bad@techela.cheme.cmu.edu:none")
#+END_SRC

#+RESULTS:
: 128

#+BEGIN_SRC emacs-lisp

(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none")

#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(with-timeout (1)
(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none"))

#+END_SRC


Let's try that in Python. This also freezes
#+BEGIN_SRC python
import subprocess
print subprocess.call(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], shell=True)
#+END_SRC

#+RESULTS:
: 128

** Solution, is ssh batch mode
The key is modifying the ssh command so that it runs in batch mode. You have to create a custom shell script that runs ssh in batch mode, then set GIT_SSH as an environment variable to use it.

Here is the working script.
#+BEGIN_SRC sh :tangle techela_ssh
#!/bin/sh
exec ssh -o "BatchMode yes" "$@"
#end
#+END_SRC

This will not hang.
#+BEGIN_SRC sh
./techela_ssh bad@techela.cheme.cmu.edu
#+END_SRC

#+RESULTS:

Running in sh
#+BEGIN_SRC sh
rm -fr none # rm old dir
GIT_SSH='c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh' git clone bad@techela.cheme.cmu.edu:none
#+END_SRC

#+RESULTS:


Running in Python
#+BEGIN_SRC python
import subprocess, os
my_env = os.environ.copy()
my_env['GIT_SSH'] = 'c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh'
p = subprocess.Popen(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], env=my_env)
print p.communicate()
#+END_SRC

#+RESULTS:
: (None, None)


And finally, running in emacs-lisp
#+BEGIN_SRC emacs-lisp
(let ((process-environment (cons "GIT_SSH=c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh" process-environment)))
  (shell-command-to-string "git clone bad@techela.cheme.cmu.edu:none"))
#+END_SRC

#+RESULTS:
: Cloning into 'none'...
: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
: fatal: Could not read from remote repository.
:
: Please make sure you have the correct access rights
: and the repository exists.

Finally, it appears I have a solution for this.





* Running the whole course through emacs and org-mode

I can write a command that retrieves a repo and opens it. and submits it to the server.

M-x oc-get label
This will check for label, and clone it if needed

#+BEGIN_SRC emacs-lisp
(defun oc-get (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
    (format "git clone gitolite@git-it.cheme.cmu.edu:%s" repo))))

(oc-get "hwk1")
#+END_SRC

#+RESULTS:
: git clone gitolite@git-it.cheme.cmu.edu:06-625-jkitchin-hwk1

We need to be able to update a repo. This will be tricky I think, because if students have made changes, this will not work without merges. It may be possible to commit their changes first, and then just deal with merges, but I think that will be confusing.

#+BEGIN_SRC emacs-lisp
(defun oc-update (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
   (oc-get label)) ;; first get it.

 (let (default-directory repo)
   (format "git pull"))))

#+END_SRC

M-x oc-turn-in

add everything in the directory,  commit it, and push the repo. It looks something like this:

#+BEGIN_SRC emacs-lisp
(defun oc-turn-in ()
  "Run this with the assignment open or in assignment directory"
  (interactive)
  ;; should check that we are in a git repo.

  (shell-command "git add *")
  (shell-command "git commit -am \"done\"")
  (shell-command "git push"))
#+END_SRC

What happens if students delete files?

see http://stackoverflow.com/questions/3258243/git-check-if-pull-needed for some ways to test if pull is needed.

* Getting system information and storing it in an org-mode Drawer



#+BEGIN_SRC emacs-lisp
(system-name)
#+END_SRC

#+RESULTS:
: KITCHINX61TABLE

#+BEGIN_SRC emacs-lisp
(princ system-configuration)
#+END_SRC

#+RESULTS:
: i386-mingw-nt6.1.7601


#+BEGIN_SRC emacs-lisp
(princ system-type)
#+END_SRC

#+RESULTS:
: windows-nt


#+BEGIN_SRC emacs-lisp
(shell-command-to-string ifconfig-program)
#+END_SRC

#+RESULTS:
#+begin_example

Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :
#+end_example

System info function
#+BEGIN_SRC emacs-lisp
(defun insert-system-info-drawer ()
 (interactive)
 (end-of-buffer)
 (insert "\n\n")
 (org-insert-drawer nil "LOGBOOK")
 (insert (format "Name: %s\n" user-full-name))
 (insert (format "Email: %s\n" user-mail-address))
 (insert "System name: " (system-name))
 (insert (format "\n%s" system-type))
 (insert (shell-command-to-string ifconfig-program)))
#+END_SRC

#+RESULTS:
: insert-system-info-drawer
:

cite:armiento-2014-high

:LOGBOOK:
John Kitchin
jkitchin@andrew.cmu.edu
System name: KITCHINX61TABLEwindows-nt
Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . :
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . :
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . :

:END:

* Making a bunch of words invisible

(org-map-entries (lambda ()
                   (let ((level (org-entry-get (point) "level"))
                          (symbol-level))
                     (when level
                       (setq symbol-level (intern level))
                       (org-mark-subtree)
                       (overlay-put (make-overlay (point) (mark))
                                    'invisible
                                    symbol-level)
                       ;; make regions with symbol-level invisible
                       (add-to-invisibility-spec `(,symbol-level))))))
#+BEGIN_SRC emacs-lisp
(while (re-search-forward ":slide:" nil t)
(overlay-put (make-overlay (match-beginning 0) (match-end 0))
                                    'invisible
                                    'slide))

(add-to-invisibility-spec 'slide)
#+END_SRC
 :slide: in the text


Later when you want them back,

#+BEGIN_SRC emacs-lisp :results silent
(remove-from-invisibility-spec 'slide)
#+END_SRC

We also may want to have slide numbers, and an ability to jump to a slide.

Let us start by getting a list of slides. Our list will be cons cells with a slide number and marker. That will give us the

#+BEGIN_SRC emacs-lisp
(let ((slides '()) (n 0))
  (org-map-entries
   (lambda ()
     (when (string-match-p ":slide:" (or (nth 5 (org-heading-components)) ""))
       (setq n (+ n 1))
       (add-to-list 'slides (cons n (set-marker (make-marker) (point))) t))))
(goto-char (cdr (assoc 2 slides)))
slides)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1580 in blog.org>) | (2 . #<marker at 1603 in blog.org>) |

** subheading :slide:

** next one :slide:


* Inherited properties
example of getting an inherited property, in this case an email address
** student 1
   :PROPERTIES:
   :END:
*** lesson 1
    :PROPERTIES:
    :SENT-ON:  Sun Jun  8 20:43:16 2014
    :TO:       John Kitchin <jkitchin@andrew.cmu.edu>
    :END:
we just turn on inheritance in the property get function.
#+BEGIN_SRC emacs-lisp
(org-entry-get (point) "TO" t)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1693 in blog.org>) | (2 . #<marker at 1716 in blog.org>) |

check out https://github.com/jwiegley/emacs-async/blob/master/async.el
for asynchronous things.

* Calculating months since a date

To calculate the number of months between two dates, we parse the dates to get the year for each date, and the month for each date. Then we calculate the number of months as:

\[12 * (year2 - year1) + (month2 - month1)\]

To get the year,

#+BEGIN_SRC emacs-lisp
(nth 5 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 2014

Now the month:
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 5

Note this subtlety
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat>")))
#+END_SRC

#+RESULTS:
: 2

It appears that since no time is specified, this gets parsed as the 28th of Feb? Maybe that is a limitation of the date format in Emacs?
#+BEGIN_SRC emacs-lisp
(decode-time (date-to-time "<2014-03-01 Sat>"))
#+END_SRC

#+RESULTS:
| 0 | 0 | 19 | 28 | 2 | 2014 | 5 | nil | -18000 |

We get the right value if we specify the time.

#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat 00:01>")))
#+END_SRC

#+RESULTS:
: 3

And now for the number of months between two times

#+BEGIN_SRC emacs-lisp
(let* ((d1  (decode-time (date-to-time "2014-03-01 00:01")))
       (d2 (decode-time (date-to-time "2014-05-31  00:01")))
       (y1 (nth 5 d1))
       (y2 (nth 5 d2))
       (m1 (nth 4 d1))
       (m2 (nth 4 d2)))
  (+ (* 12 (- y2 y1)) (- m2  m1)))
#+END_SRC

#+RESULTS:
: 2


* Converting bbdb to org-contacts

#+BEGIN_SRC emacs-lisp :results output
(let ((b (find-file "../../kitchingroup/jmax/user/bbdb"))
      (count 0) (entry)(fname)(lname)(email))
  (find-file "contacts-bbdb.org")
  (erase-buffer)
  (insert "* setup")
  (while (and (< count 5) (setq entry (read b)))
    (setq fname (elt entry 0)
	  lname (elt entry 1)
	  email (car (elt entry 7)))
    (org-insert-heading-after-current)
    (insert (format "%s, %s\n" lname fname))
    (org-entry-put (point) "FIRSTNAME" fname)
    (org-entry-put (point) "LASTNAME" lname)
    (org-entry-put (point) "EMAIL" email))
  (save-buffer))
#+END_SRC

#+RESULTS:
#+begin_example
[Sarah Abdullah nil nil nil nil nil (sarah@cmu.edu) ((creation-date . 2014-03-17 01:00:18 +0000) (timestamp . 2014-03-17 01:00:18 +0000)) nil]
Sarah
Abdullah
sarah@cmu.edu
[Abdulwahab A. Abdulwahab nil nil nil nil nil (aabdulwa@andrew.cmu.edu) ((creation-date . 2014-03-17 00:54:29 +0000) (timestamp . 2014-03-17 00:54:29 +0000)) nil]
Abdulwahab A.
Abdulwahab
aabdulwa@andrew.cmu.edu
[Tanima Abedin nil nil nil nil nil (t.j.abedin@gmail.com) ((creation-date . 2014-03-17 01:00:19 +0000) (timestamp . 2014-03-17 01:00:19 +0000)) nil]
Tanima
Abedin
t.j.abedin@gmail.com
[Frank Abild-Pedersen nil nil nil nil nil (abild@slac.stanford.edu) ((creation-date . 2014-03-17 01:00:13 +0000) (timestamp . 2014-03-17 01:00:13 +0000)) nil]
Frank
Abild-Pedersen
abild@slac.stanford.edu
[Natalie Day Abrams nil nil nil nil nil (nda@andrew.cmu.edu) ((creation-date . 2014-03-17 01:00:16 +0000) (timestamp . 2014-03-17 01:00:16 +0000)) nil]
Natalie Day
Abrams
nda@andrew.cmu.edu
#+end_example


* a simple logging library for emacs
python has a great logging module. I would like this kind of capability.

(log-info "something %s" variable)
(log-debug "something %s" variable)

you set a =*log-level*= somewhere in your code to determine which messages get logged. Each log function has a corresponding trigger level, and if your =*log-level*= is greater than or equal to the trigger it will log to Messages.

#+BEGIN_SRC emacs-lisp
(setq *log-level* 10
      ,*log-info* 10
      ,*log-debug* 50)

(defun log-info (message &rest args)
  "print message formatted with args"
  (when (>= *log-level* *log-info*) ; *log-level* greater than this level print
    (message "log-info: %s" (apply #'format message args))))

(log-info "test %s %s" 5 "done")
#+END_SRC

#+RESULTS:
: log-info: test 5 done

this is not that sophisticated, it might be nice to have introspection, line numbers, functions, etc...

* Updating a bibtex entry using its doi
  :PROPERTIES:
  :categories: bibtex
  :END:
The next step is to use this to update an entry. Presumably ASAP articles will have their metadata updated in the future. It would be great to be able to run a command on an entry and update it. To do that, we need a convenient function to set a bibtex field. There is a function to get a field, but not to set a field. This next block is the closest thing I have come up with that sets a field

#+BEGIN_SRC emacs-lisp
(defun bibtex-set-field (field value)
  "set field to value in bibtex file. create field if it does not exist"
  (interactive "sfield: \nsvalue: ")
  (bibtex-beginning-of-entry)
  (let ((found))
    (if (setq found (bibtex-search-forward-field field t))
	;; we found a field
	(progn
	  (goto-char (car (cdr found)))
	  (when value
	    (bibtex-kill-field)
	    (bibtex-make-field field)
	    (backward-char)
	    (insert value)))
      ;; make a new field
      (message "new field being made")
      (bibtex-beginning-of-entry)
      (forward-line) (beginning-of-line)
      (bibtex-next-field nil)
      (forward-char)
      (bibtex-make-field field)
      (backward-char)
      (insert value))))
#+END_SRC

#+RESULTS:
: bibtex-set-field

Now, we want a function to update a bibtex entry. The function will get the doi from the entry, then retrieve the json data, and then update each field. We need to get the keys in the json results, and then map each key to a field in a bibtex entry. Here we go.

#+BEGIN_SRC emacs-lisp
(require 'json)

;; adapted from https://github.com/mon-key/mon-systems-cl/blob/master/plist.lisp
(defun plist-get-keys (plist)
   "return keys in a plist"
  (loop
   for key in results by #'cddr collect key))

(defun update-bibtex-entry-from-doi (doi)
  "update fields in a bibtex entry from the doi."
  (interactive (list (or (bibtex-autokey-get-field "doi") (read-string "DOI: "))))
  (let* ((url-request-method "GET")
	(url-mime-accept-string "application/citeproc+json")
	(json-object-type 'plist)
	(results (with-current-buffer
		    (url-retrieve-synchronously
		     (concat "http://dx.doi.org/" doi))
		  (json-read-from-string
		   (buffer-substring url-http-end-of-headers (point-max)))))
	(type (plist-get results :type))
	(author (mapconcat
		(lambda (x) (concat (plist-get x :given)
				    " " (plist-get x :family)))
		(plist-get results :author) " and "))
	(title (plist-get results :title))
	(journal (plist-get results :container-title))
	(year (format "%s"
		       (elt
			(elt
			 (plist-get
			  (plist-get results :issued) :date-parts) 0) 0)))

	(volume (plist-get results :volume))
	(number (or (plist-get results :issue) ""))
	(pages (or (plist-get results :page) ""))
	(month (format "%s"
			(elt
			 (elt
			  (plist-get
			   (plist-get results :issued) :date-parts) 0) 1)))
	(url (or (plist-get results :URL) ""))
	(doi (plist-get results :DOI))
	(annote (format "%s" results)))

    ;; map the json fields to bibtex fields
    (setq mapping '((:author . (bibtex-set-field "author" author))
		    (:title . (bibtex-set-field "title" title))
		    (:container-title . (bibtex-set-field "journal" journal))
		    (:issued . (progn
				 (bibtex-set-field "year" year)
				 (bibtex-set-field "month" month)))
		    (:volume . (bibtex-set-field "volume" volume))
		    (:issue . (bibtex-set-field "issue" issue))
		    (:page . (bibtex-set-field "pages" pages))
		    (:DOI . (bibtex-set-field "doi" doi))
		    (:URL . (bibtex-set-field "url" url))))

    ;; now we have code to run for each entry. we map over them and evaluate the code
    (mapcar
     (lambda (key)
       (eval (cdr (assoc key mapping))))
     (plist-get-keys results)))

  ; reclean entry, but keep existing key. check if it exists
  (if (bibtex-key-in-head)
      (org-ref-clean-bibtex-entry t)
    (org-ref-clean-bibtex-entry)))
#+END_SRC

#+RESULTS:
: update-bibtex-entry-from-doi


* Formatting citation links

#+BEGIN_SRC emacs-lisp
(setq s "pre text::post text")
(cond
  ((string-match "::" s)
   (format "[%s][%s]" (car (setq results (split-string s "::"))) (cadr results)))
  (t (format "[%s]" s)))

#+END_SRC

#+RESULTS:
: [pre text][:post text]

#+BEGIN_SRC emacs-lisp
(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite" (when desc (format "[%s]" desc)) "{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))

(org-ref-cite-link-format "cite" "pre text::post text" 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text::post text]{cite}


* Functional definition of functions
In org-ref, I have a need to define a lot of link types that are all variations of the same kind, but with different names. I do not want to make a unique function for each link, because that involves a lot of cut and paste code.

I want to use something like mapcar on a list to define these links.

#+BEGIN_SRC emacs-lisp
(setq links '("test1" "test2"))

(defun define-link (link)
  (interactive)
  (eval-expression `(org-add-link-type ,link
 (lambda (x) (message "you clicked on %s" x))
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<",link">%s</",link">)" path))
    ((eq format 'latex)
     (concat "\\" ,link "{" keyword "}")))))))

(mapcar 'define-link links)
#+END_SRC

#+RESULTS:
| (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                             | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))         | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                            | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword))))) | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword)))))                                                                                                                                                                                         | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))                                                                                                                                                                                                                                                                                                                                                                                                                          | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures))))) | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | (mhe org-mhe-open nil)     | (irc org-irc-visit nil) | (info org-info-open nil) | (gnus org-gnus-open nil) | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)                  | (bbdb org-bbdb-open org-bbdb-export) | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword)))))  | (file+emacs org-open-file-with-emacs nil)                                                                                                                                                               | (file+sys org-open-file-with-system nil)  |                                          |
| (test2 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test2 >%s</ test2 >) path)) ((eq format (quote latex)) (concat \ test2 { keyword }))))) | (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                                                                                              | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))       | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))           | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword)))))                                                                                                                                                                     | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword))))) | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))    | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil) | (mhe org-mhe-open nil)  | (irc org-irc-visit nil)  | (info org-info-open nil) | (gnus org-gnus-open nil)                      | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)         | (bbdb org-bbdb-open org-bbdb-export)                                                                                                                                                                     | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword))))) | (file+emacs org-open-file-with-emacs nil) | (file+sys org-open-file-with-system nil) |



test1:wat

test2:yes



#+LATEX_CLASS: article
#+OPTIONS: author:nil toc:nil
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{subfigure}

* Side by side figures in org-mode

adapted from http://www.johndcook.com/blog/2009/01/14/how-to-display-side-by-side-figurs-in-latex/


Now you can reference Figure \ref{fig12}, or Figure ref:fig:a or Figure ref:fig:b.

#+caption: Left graph \label{fig:a}
[[./images/cos-plot.png]]





\begin{figure}
  \subfigure[Left graph \label{fig:a}]
    {\includegraphics[width=3in]{images/cos-plot.png}}
\enskip % horizontal spacking. tex.stackexchange.com/questions/41476/lengths-and-when-to-use-them
  \subfigure[Right graph. \label{fig:b}]
    {\includegraphics[width=3in]{images/eos-uncertainty.png}}
\caption{Text pertaining to both graphs,\ref{fig:a}and \ref{fig:b}. \label{fig12}}
\end{figure}

* Sorting the fields of a bibtex entry with emacs-lisp

We need two lists. The list that defines the order I want, and the rest of them.

#+BEGIN_SRC emacs-lisp :results value
(find-file "sort.bib")
(goto-char (point-min))

(defun org-ref-sort-bibtex-entry ()
  "sort fields of entry in standard order and downcase them"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((master '("author" "title" "journal" "volume" "issue" "pages" "year" "doi" "url"))
	 (entry (bibtex-parse-entry))
	 (entry-fields)
	 (other-fields)
	 (type (cdr (assoc "=type=" entry)))
	 (key (cdr (assoc "=key=" entry))))

    ;; these are the fields we want to order that are in this entry
    (setq entry-fields (mapcar (lambda (x) (car x)) entry))
    ;; we do not want to reenter these fields
    (setq entry-fields (remove "=key=" entry-fields))
    (setq entry-fields (remove "=type=" entry-fields))

    ;;these are the other fields in the entry
    (setq other-fields (remove-if-not (lambda(x) (not (member x master))) entry-fields))

    (cond
     ;; right now we only resort articles
     ((string= type "article")
      (bibtex-kill-entry)
      (insert
       (concat "@article{" key ",\n"
	       (mapconcat
		(lambda (field)
		  (when (member field entry-fields)
		    (format "%s = %s," (downcase field) (cdr (assoc field entry))))) master "\n")
	       (mapconcat
		(lambda (field)
		  (format "%s = %s," (downcase field) (cdr (assoc field entry)))) other-fields "\n")
	       "\n}"))
      (bibtex-clean-entry)
       ))))

(org-ref-sort-bibtex-entry)
#+END_SRC

#+RESULTS:
#+begin_example
@article{conesa-2010-relev-disper,
author = {Conesa, Jose\'{e} C.},
title = {The Relevance of Dispersion Interactions for the
                  Stability of Oxide Phases},
journal = {The Journal of Physical Chemistry C},
volume = 114,

pages = {22718-22726},
year = 2010,

pdf = {[[file:bibtex-pdfs/conesa-2010-relev-disper.pdf]]},
org-notes = {[[file:~/Dropbox/bibliography/notes.org::conesa-2010-relev-disper]]},
number = 51,
doi = {10.1021/jp109105g},
url = {http://pubs.acs.org/doi/abs/10.1021/jp109105g},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/jp109105g},
}
#+end_example




* Querying the ase-db
  :PROPERTIES:
  :categories: ase, database
  :date:     2014/04/24 09:33:44
  :updated:  2014/04/24 09:33:44
  :END:
I am examining how to query the ase-db, and this post looks at how to find results that do not contain a particular atom. The solution is based on a email from the mailing list (http://listserv.fysik.dtu.dk/pipermail/ase-developers/2014-April/002097.html).

We begin by making a test database. This will only contain some atoms objects with different stoichiometries. We also add keywords for the stoichiometry, because the queries will be developed directly in SQL, which cannot read the numpy arrays stored in the tables.

#+BEGIN_SRC python
import os
if os.path.exists('abc.db'): os.unlink('abc.db')

from ase import Atoms
from ase.db import connect
c = connect('abc.db')

c.write(Atoms('Fe'), ['Fe'])
c.write(Atoms('Al'), ['Al'])
c.write(Atoms('Ni'), ['Ni'])
c.write(Atoms('FeNi'), ['FeNi'])
c.write(Atoms('FeAl'), ['FeAl'])
c.write(Atoms('NiAl'), ['NiAl'])
c.write(Atoms('FeNiAl'), ['FeNiAl'])
#+END_SRC
#+RESULTS:

Now, let us see the contents to be sure what is in there.

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|pbc|keywords|   mass
:  1|19s|jkitchin|Fe     |000|Fe      | 55.847
:  2|19s|jkitchin|Al     |000|Al      | 26.982
:  3|19s|jkitchin|Ni     |000|Ni      | 58.693
:  4|19s|jkitchin|FeNi   |000|FeNi    |114.540
:  5|19s|jkitchin|AlFe   |000|FeAl    | 82.829
:  6|19s|jkitchin|AlNi   |000|NiAl    | 85.675
:  7|19s|jkitchin|AlFeNi |000|FeNiAl  |141.522


Now, suppose I want to find entries that do not contain Ni. We can find the entries that do contain Ni like this.

#+begin_src sqlite :db abc.db :list
SELECT systems.data, species.id FROM species
inner join systems
on systems.id = species.id WHERE species.Z == 28;
#+end_src

#+RESULTS:
: {"keywords": ["Ni"], "data": {}, "key_value_pairs": {}}|3
: {"keywords": ["FeNi"], "data": {}, "key_value_pairs": {}}|4
: {"keywords": ["NiAl"], "data": {}, "key_value_pairs": {}}|6
: {"keywords": ["FeNiAl"], "data": {}, "key_value_pairs": {}}|7

You can see there is a Ni in each found entry. Now, we select the ids from the systems table that do not exist in that list.

#+begin_src sqlite :db abc.db :list
select id, data from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28);
#+end_src

#+RESULTS:
: 1|{"keywords": ["Fe"], "data": {}, "key_value_pairs": {}}
: 2|{"keywords": ["Al"], "data": {}, "key_value_pairs": {}}
: 5|{"keywords": ["FeAl"], "data": {}, "key_value_pairs": {}}

And you can see none of these entries contain Ni.


#+BEGIN_SRC python
from ase.db import connect
from ase.db.core import dict2atoms

c = connect('abc.db')
con = c._connect()
cur = con.cursor()
for row in  cur.execute('''select * from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28)'''):
    print dict2atoms(c.row_to_dict(row))
#+END_SRC
#+RESULTS:
: Atoms(symbols='Fe', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='Al', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='FeAl', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])

[[./O_sv]]

[[./O_sv][test dir]]



* Using Matlab in org-mode
  :PROPERTIES:
  :categories: matlab
  :END:
Most of my work in org-mode uses python, or emacs-lisp. One thing that would make org-mode more readily adopted is if we could use Matlab too. Unfortunately, this is not currently possible on Windows. We need a tty shell.

#+BEGIN_SRC matlab :results value
u = cmu.units;

5*u.kg % a mass
5*u.lb % another mass
6*u.m/u.s  % a velocity

ans = 1*u.m + 10*u.cm % this is ok, 1.1 m
% 1*u.m + 1*u.s  % this is not ok
#+END_SRC

#+RESULTS:

* Parsing a bibtex file into a data structure

I need to parse a bibtex file and get a data structure I can use later. I want an a-list of (key . plist), where the plist will contain data about each bibtex entry, such as the file the key is in, and the entry string.

The idea is to do this once, to avoid re-searching a file all the time. Here is how I would use this idea.

#+BEGIN_SRC emacs-lisp
(setq results '())

(defun parse-bibtex-file (file)
  "parse bibtex file and add to data structure"
  (with-temp-buffer
    (insert-file-contents file)
    (bibtex-map-entries
     (lambda (key start end)
       (add-to-list 'results
		    `(,key . (:entry ,(buffer-substring start end)
				     :file ,file))
		    t) ;; this appends to the end
     ))))

(let ((bibfiles '("../../bibliography/references.bib" "../../bibliography/kitchin.bib")))
  (mapcar 'parse-bibtex-file bibfiles))



;; now see what we got
(plist-get
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':entry)

(plist-get
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':file)
#+END_SRC

#+RESULTS:
: ../../bibliography/references.bib




* set UUID in heading
  :PROPERTIES:
  :UUID:     ff7c16e8-a5b0-49da-a239-8cf7c6a2a211
  :END:

#+BEGIN_SRC emacs-lisp
(require 'org-id)

(add-hook 'org-insert-heading-hook
	  #'(lambda ()
	      (org-entry-put (point) "UUID" (org-id-uuid))))
#+END_SRC

#+RESULTS:





* An org-table rubric
I had an idea to insert a table that represents a rubric into an org-file

The table would compute the overall grade.

|              | weight | Emerging (1,2) | Developing (3,4)   | Mastery (5,6)      | grade |
|--------------+--------+----------------+--------------------+--------------------+-------|
| content      |    0.1 | Text rambles   | articulate ideas   | clear and concise  |     1 |
| organization |    0.2 | unorganized    | not well organized | logical            |     2 |
| mechanics    |    0.3 | many errors    | a few per page     | no errors          |     4 |
| figures      |    0.1 | inappropriate  | flawed             | proper             |     5 |
| style        |    0.2 | inappropriate  | informal, jargon   | neat               |     6 |
| format       |    0.2 | not followed   | somewhat followed  | conforms to format |     7 |
|--------------+--------+----------------+--------------------+--------------------+-------|
|              |      0 |                |                    | Total              |       |
#+TBLFM: B2=vsum(@1..@5)


You would create the table in advance as a snippet, and you could insert it. Maybe the table would have a name.

* A pyparsing example
#+BEGIN_SRC python
#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolXXX class instances, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
# Updated 2013-Sep-14 - improved Python 2/3 cross-compatibility
#
from pyparsing import operatorPrecedence, opAssoc, Keyword, Word, alphas

# define classes to be built at parse time, as each matching
# expression type is parsed
class BoolOperand(object):
    def __init__(self,t):
        self.label = t[0]
        self.value = eval(t[0])
    def __bool__(self):
        return self.value
    def __str__(self):
        return self.label
    __repr__ = __str__
    __nonzero__ = __bool__

class BoolBinOp(object):
    def __init__(self,t):
        self.args = t[0][0::2]
    def __str__(self):
        sep = " %s " % self.reprsymbol
        return "(" + sep.join(map(str,self.args)) + ")"
    def __bool__(self):
        return self.evalop(bool(a) for a in self.args)
    __nonzero__ = __bool__
    __repr__ = __str__

class BoolAnd(BoolBinOp):
    reprsymbol = '&'
    evalop = all

class BoolOr(BoolBinOp):
    reprsymbol = '|'
    evalop = any

class BoolNot(object):
    def __init__(self,t):
        self.arg = t[0][1]
    def __bool__(self):
        v = bool(self.arg)
        return not v
    def __str__(self):
        return "~" + str(self.arg)
    __repr__ = __str__
    __nonzero__ = __bool__

TRUE = Keyword("True")
FALSE = Keyword("False")
boolOperand = TRUE | FALSE | Word(alphas,max=1)
boolOperand.setParseAction(BoolOperand)

# define expression, based on expression operand and
# list of operations in precedence order
boolExpr = operatorPrecedence( boolOperand,
    [
    ("not", 1, opAssoc.RIGHT, BoolNot),
    ("and", 2, opAssoc.LEFT,  BoolAnd),
    ("or",  2, opAssoc.LEFT,  BoolOr),
    ])


if __name__ == "__main__":
    p = True
    q = False
    r = True
    tests = [("p", True),
             ("q", False),
             ("p and q", False),
             ("p and not q", True),
             ("not not p", True),
             ("not(p and q)", True),
             ("q or not p and r", False),
             ("q or not p or not r", False),
             ("q or not (p and r)", False),
             ("p or q or r", True),
             ("p or q or r and False", True),
             ("(p or q or r) and False", False),
            ]

    print("p =", p)
    print("q =", q)
    print("r =", r)
    print()
    for t,expected in tests:
        res = boolExpr.parseString(t)[0]
        success = "PASS" if bool(res) == expected else "FAIL"
        print (t,'\n', res, '=', bool(res),'\n', success, '\n')



#+END_SRC
#+RESULTS:
#+begin_example
('p =', True)
('q =', False)
('r =', True)
()
('p', '\n', p, '=', True, '\n', 'PASS', '\n')
('q', '\n', q, '=', False, '\n', 'PASS', '\n')
('p and q', '\n', (p & q), '=', False, '\n', 'PASS', '\n')
('p and not q', '\n', (p & ~q), '=', True, '\n', 'PASS', '\n')
('not not p', '\n', ~~p, '=', True, '\n', 'PASS', '\n')
('not(p and q)', '\n', ~(p & q), '=', True, '\n', 'PASS', '\n')
('q or not p and r', '\n', (q | (~p & r)), '=', False, '\n', 'PASS', '\n')
('q or not p or not r', '\n', (q | ~p | ~r), '=', False, '\n', 'PASS', '\n')
('q or not (p and r)', '\n', (q | ~(p & r)), '=', False, '\n', 'PASS', '\n')
('p or q or r', '\n', (p | q | r), '=', True, '\n', 'PASS', '\n')
('p or q or r and False', '\n', (p | q | (r & False)), '=', True, '\n', 'PASS', '\n')
('(p or q or r) and False', '\n', ((p | q | r) & False), '=', False, '\n', 'PASS', '\n')
#+end_example

* Is my cursor on a link


#+BEGIN_SRC emacs-lisp
(defun label-p ()
 "determine if the cursor is on a label link. return the path if so, nil otherwise"
  (interactive)
  (let ((object (org-element-context)))
    (message "%s" (when
	(and (equal (org-element-type object) 'link)
	     (equal (org-element-property :type object) "label"))
      (org-element-property :path object)))))
#+END_SRC


label:test1
   label:test

[[file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at%20org-any-link-re)][file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at org-any-link-re)]]



* miscellaneous links

see http://draketo.de/light/english/emacs/convert-ris-citations-bibtex-bibutils

http://draketo.de/english/emacs/writing-papers-in-org-mode-acpd


* Advising org-ctrl-c-ctrl-c
  :PROPERTIES:
  :categories: org-mode,emacs
  :END:
I use a lot of equations in org-mode, and I like to use the LaTeX overlays (C-c C-x C-l (org-preview-latex-fragment)). I also use a lot of code blocks in my org-documents, and I like to run them during lectures, which I do with C-c C-c. However, this also removes the overlays from my equations, causing two irritations: 1) the code did not run when I thought it would, and I have to press C-c C-c again, 2) the equations that the code implements disappears so then I have C-c C-x C-l to get them back.  A lot of extra key strokes. The issue is one line in org.el at line 20222: (org-remove-latex-fragment-image-overlays).

I have been thinking about how to change that behavior. I do not want to patch my org-mode, because I do not want to deal with future updates. The simplest idea is to just redefine that function in my init files, with the offending line commented out. Here it is.

#+BEGIN_SRC emacs-lisp
(defun org-ctrl-c-ctrl-c (&optional arg)
  "Set tags in headline, or update according to changed information at point.

This command does many different things, depending on context:

- If a function in `org-ctrl-c-ctrl-c-hook' recognizes this location,
  this is what we do.

- If the cursor is on a statistics cookie, update it.

- If the cursor is in a headline, prompt for tags and insert them
  into the current line, aligned to `org-tags-column'.  When called
  with prefix arg, realign all tags in the current buffer.

- If the cursor is in one of the special #+KEYWORD lines, this
  triggers scanning the buffer for these lines and updating the
  information.

- If the cursor is inside a table, realign the table.  This command
  works even if the automatic table editor has been turned off.

- If the cursor is on a #+TBLFM line, re-apply the formulas to
  the entire table.

- If the cursor is at a footnote reference or definition, jump to
  the corresponding definition or references, respectively.

- If the cursor is a the beginning of a dynamic block, update it.

- If the current buffer is a capture buffer, close note and file it.

- If the cursor is on a <<<target>>>, update radio targets and
  corresponding links in this buffer.

- If the cursor is on a numbered item in a plain list, renumber the
  ordered list.

- If the cursor is on a checkbox, toggle it.

- If the cursor is on a code block, evaluate it.  The variable
  `org-confirm-babel-evaluate' can be used to control prompting
  before code block evaluation, by default every code block
  evaluation requires confirmation.  Code block evaluation can be
  inhibited by setting `org-babel-no-eval-on-ctrl-c-ctrl-c'."
  (interactive "P")
  (cond
   ((or (and (boundp 'org-clock-overlays) org-clock-overlays)
	org-occur-highlights
	org-latex-fragment-image-overlays)
    (and (boundp 'org-clock-overlays) (org-clock-remove-overlays))
    (org-remove-occur-highlights)
    ;; commented out by jkitchin 2014-03-01 to avoid removing latex images
    ;; on running code blocks.
    ;(org-remove-latex-fragment-image-overlays)
    (message "Temporary highlights/overlays removed from current buffer"))
   ((and (local-variable-p 'org-finish-function (current-buffer))
	 (fboundp org-finish-function))
    (funcall org-finish-function))
   ((run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-hook))
   (t
    (let* ((context (org-element-context)) (type (org-element-type context)))
      ;; Test if point is within a blank line.
      (if (save-excursion (beginning-of-line) (looking-at "[ \t]*$"))
	  (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	      (user-error "C-c C-c can do nothing useful at this location"))
	(case type
	  ;; When at a link, act according to the parent instead.
	  (link (setq context (org-element-property :parent context))
		(setq type (org-element-type context)))
	  ;; Unsupported object types: check parent element instead.
	  ((bold code entity export-snippet inline-babel-call inline-src-block
		 italic latex-fragment line-break macro strike-through subscript
		 superscript underline verbatim)
	   (while (and (setq context (org-element-property :parent context))
		       (not (memq (setq type (org-element-type context))
				  '(paragraph verse-block table-cell)))))))
	;; For convenience: at the first line of a paragraph on the
	;; same line as an item, apply function on that item instead.
	(when (eq type 'paragraph)
	  (let ((parent (org-element-property :parent context)))
	    (when (and (eq (org-element-type parent) 'item)
		       (= (point-at-bol) (org-element-property :begin parent)))
	      (setq context parent type 'item))))
	;; Act according to type of element or object at point.
	(case type
	  (clock (org-clock-update-time-maybe))
	  (dynamic-block
	   (save-excursion
	     (goto-char (org-element-property :post-affiliated context))
	     (org-update-dblock)))
	  (footnote-definition
	   (goto-char (org-element-property :post-affiliated context))
	   (call-interactively 'org-footnote-action))
	  (footnote-reference (call-interactively 'org-footnote-action))
	  ((headline inlinetask)
	   (save-excursion (goto-char (org-element-property :begin context))
			   (call-interactively 'org-set-tags)))
	  (item
	   ;; At an item: a double C-u set checkbox to "[-]"
	   ;; unconditionally, whereas a single one will toggle its
	   ;; presence.  Without an universal argument, if the item
	   ;; has a checkbox, toggle it.  Otherwise repair the list.
	   (let* ((box (org-element-property :checkbox context))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (parents (org-list-parents-alist struct))
		  (prevs (org-list-prevs-alist struct))
		  (orderedp (org-not-nil (org-entry-get nil "ORDERED"))))
	     (org-list-set-checkbox
	      (org-element-property :begin context) struct
	      (cond ((equal arg '(16)) "[-]")
		    ((and (not box) (equal arg '(4))) "[ ]")
		    ((or (not box) (equal arg '(4))) nil)
		    ((eq box 'on) "[ ]")
		    (t "[X]")))
	     ;; Mimic `org-list-write-struct' but with grabbing
	     ;; a return value from `org-list-struct-fix-box'.
	     (org-list-struct-fix-ind struct parents 2)
	     (org-list-struct-fix-item-end struct)
	     (org-list-struct-fix-bul struct prevs)
	     (org-list-struct-fix-ind struct parents)
	     (let ((block-item
		    (org-list-struct-fix-box struct parents prevs orderedp)))
	       (if (and box (equal struct old-struct))
		   (if (equal arg '(16))
		       (message "Checkboxes already reset")
		     (user-error "Cannot toggle this checkbox: %s"
				 (if (eq box 'on)
				     "all subitems checked"
				   "unchecked subitems")))
		 (org-list-struct-apply-struct struct old-struct)
		 (org-update-checkbox-count-maybe))
	       (when block-item
		 (message "Checkboxes were removed due to empty box at line %d"
			  (org-current-line block-item))))))
	  (keyword
	   (let ((org-inhibit-startup-visibility-stuff t)
		 (org-startup-align-all-tables nil))
	     (when (boundp 'org-table-coordinate-overlays)
	       (mapc 'delete-overlay org-table-coordinate-overlays)
	       (setq org-table-coordinate-overlays nil))
	     (org-save-outline-visibility 'use-markers (org-mode-restart)))
	   (message "Local setup has been refreshed"))
	  (plain-list
	   ;; At a plain list, with a double C-u argument, set
	   ;; checkboxes of each item to "[-]", whereas a single one
	   ;; will toggle their presence according to the state of the
	   ;; first item in the list.  Without an argument, repair the
	   ;; list.
	   (let* ((begin (org-element-property :contents-begin context))
		  (beginm (move-marker (make-marker) begin))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (first-box (save-excursion
			       (goto-char begin)
			       (looking-at org-list-full-item-re)
			       (match-string-no-properties 3)))
		  (new-box (cond ((equal arg '(16)) "[-]")
				 ((equal arg '(4)) (unless first-box "[ ]"))
				 ((equal first-box "[X]") "[ ]")
				 (t "[X]"))))
	     (cond
	      (arg
	       (mapc (lambda (pos) (org-list-set-checkbox pos struct new-box))
		     (org-list-get-all-items
		      begin struct (org-list-prevs-alist struct))))
	      ((and first-box (eq (point) begin))
	       ;; For convenience, when point is at bol on the first
	       ;; item of the list and no argument is provided, simply
	       ;; toggle checkbox of that item, if any.
	       (org-list-set-checkbox begin struct new-box)))
	     (org-list-write-struct
	      struct (org-list-parents-alist struct) old-struct)
	     (org-update-checkbox-count-maybe)
	     (save-excursion (goto-char beginm) (org-list-send-list 'maybe))))
	  ((property-drawer node-property)
	   (call-interactively 'org-property-action))
	  ((radio-target target)
	   (call-interactively 'org-update-radio-target-regexp))
	  (statistics-cookie
	   (call-interactively 'org-update-statistics-cookies))
	  ((table table-cell table-row)
	   ;; At a table, recalculate every field and align it.  Also
	   ;; send the table if necessary.  If the table has
	   ;; a `table.el' type, just give up.  At a table row or
	   ;; cell, maybe recalculate line but always align table.
	   (if (eq (org-element-property :type context) 'table.el)
	       (message "Use C-c ' to edit table.el tables")
	     (let ((org-enable-table-editor t))
	       (if (or (eq type 'table)
		       ;; Check if point is at a TBLFM line.
		       (and (eq type 'table-row)
			    (= (point) (org-element-property :end context))))
		   (save-excursion
		     (if (org-at-TBLFM-p)
			 (progn (require 'org-table)
				(org-table-calc-current-TBLFM))
		       (goto-char (org-element-property :contents-begin context))
		       (org-call-with-arg 'org-table-recalculate (or arg t))
		       (orgtbl-send-table 'maybe)))
		 (org-table-maybe-eval-formula)
		 (cond (arg (call-interactively 'org-table-recalculate))
		       ((org-table-maybe-recalculate-line))
		       (t (org-table-align)))))))
	  (timestamp (org-timestamp-change 0 'day))
	  (otherwise
	   (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	       (user-error
		"C-c C-c can do nothing useful at this location")))))))))
#+END_SRC


$x^2$

* Making sure you have a notes entry for each bibtex entry
As I mentioned [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf/][here]], I like to have a notes entry for each bibtex entry in an org-mode file. There are a couple of reasons for that:
1. I can tag the org-mode entries to help me find entries later
2. I can organize the org-mode entries by topic, including using links to entries when they belong in multiple places.
3. I can mark the entry as TODO to make it easy to find unfiled entries
4. I can keep typed notes in these entries.

It is usually part of my workflow to create these entries when I enter the bibtex entry, but occasionally I do not get to that. As part of the regular maintenance of my bibtex file, I like to find entries with no notes entry, and make them.

* non-ascii characters
“ "
” "

β  \beta
° $^{\circ}$
ÇŽ \v{a}
’ '
Ã© \'{e}
Ã± \~{n}
Ã­ \'{i}
Ã£ \~{a}
š \v{s}
δ \delta




* TODO A gradebook app for emacs
  :PROPERTIES:
  :categories: emacs-lisp
  :END:
The goal is to create an emacs library to compute grades from a table in org-mode.

All grades are stored in a table with this structure.

#+tblname: gradebook
| first name | last name | email       | Hwk 1 | Hwk2 | exam1 | project 1 |
|            |           |             | 10    | 10   | 60    | 20        |
|------------+-----------+-------------+-------+------+-------+-----------|
| Jane       | Doe       | jd@cmu.edu  | A     | A    | B     | B         |
| John       | Dillinger | jdi@cmu.edu | B     | B/C  | A     | C         |
| jill       | wutz      | jw@cmu.edu  | D     | D    | R     | R         |

The grading system works like this:

1. Each assignment is worth a certain number of points (in row2).
2. Each assignment for a student is given a letter grade that indicates the quality and correctness of the work.
3. Each letter grade corresponds to a point multiplier:

| A++ |  1.0 |
| A+  | 0.95 |
| A   |  0.9 |
| A-  | 0.85 |
| A/B |  0.8 |
| B+  | 0.75 |
| B   |  0.7 |
| B-  | 0.65 |
| C/B |  0.6 |
| C+  | 0.55 |
| C   |  0.5 |
| C-  | 0.45 |
| C/D |  0.4 |
| D+  | 0.35 |
| D   |  0.3 |
| D-  | 0.25 |
| D/R |  0.2 |
| R+  | 0.15 |
| R   |  0.1 |
| R-  | 0.05 |
| R-- |  0.0 |

4. The number of points earned for an assignment is the point multiplier for the letter grade times the number of points for that assignment.
5. The overall grade is computed as sum(multiplier*points)/sum(points).
6. The overall letter grade is determined by the fraction of overall points received, mapped back on to the letter grade scale.

For example, in the table above, Jane Doe's grade is:

#+BEGIN_SRC emacs-lisp :results value
(let* ((multipliers '(0.9 0.9 0.7 0.7))
       (points '(10 10 60 20))
       (earned-points (mapcar* (lambda (a b) (* a b)) multipliers points))
       (total-earned-points (apply '+ earned-points))
       (total-points (apply '+ points)))
  (/ total-earned-points total-points))
#+END_SRC
#+RESULTS:
: 0.74

Which corresponds to an overall grade of B.

The goal here is to write emacs-lisp code to compute the overall grade of each student and convert it to an overall letter grade and write a little report.

We start by defining a variable to hold the multipliers. We will use an association list. We will prefix every variable and function with =gb/= to indicate it is part of our gradebook code.

#+BEGIN_SRC emacs-lisp
(defvar gb/MULTIPLIERS
  '(("A++" . 1.0)
    ("A+"   . 0.95)
    ("A"    . 0.9)
    ("A-"   . 0.85)
    ("A/B"  . 0.8)
    ("B+"   . 0.75)
    ("B"    . 0.7)
    ("B-"   . 0.65)
    ("B/C"  . 0.6)
    ("C+"   . 0.55)
    ("C"    . 0.5)
    ("C-"   . 0.45)
    ("C/D"  . 0.4)
    ("D+"   . 0.35)
    ("D"    . 0.3)
    ("D-"   . 0.25)
    ("D/R"  . 0.2)
    ("R+"   . 0.15)
    ("R"    . 0.1)
    ("R-"   . 0.05)
    ("R--"  . 0.0))
  "Numeric multipliers for letter grades")
#+END_SRC

#+RESULTS:

Here are two examples of using the gb/MULTIPLIER variable. It is an association list, so the multipler we want is the =cdr= of what the letter is associated with. We take the =cdr= of the return value, which is the numeric multiplier

#+BEGIN_SRC emacs-lisp :results value
(cdr (assoc "A" gb/MULTIPLIERS))
#+END_SRC

#+RESULTS:
: 0.9

We are going to write a series of functions that will compute the overall grade for each student.

A function we will need is to move the cursor into the table. Here is a function that will do that. This function moves the cursor to the beginning of the buffer, searches forward to find a line starting with a #+tblname: "name", and then moves the cursor to the next line which is in the table.

#+BEGIN_SRC emacs-lisp
(defun gb/goto-table (tblname)
  "move cursor into the table labeled tblname"
  (interactive)
  (goto-char (point-min))
  (search-forward-regexp (format "^#\\+tblname:\s+%s" tblname))
  (next-line))
#+END_SRC

#+RESULTS:

We use the function to move the cursor into the table, and then extract all the contents out.  We wrap the function call inside =save-excursion= so that the cursor gets put back where we want it. In this snippet, we use the (org-table-to-lisp) function to convert the table to a lisp structure which we can do further analysis on.

#+BEGIN_SRC emacs-lisp :results value verbatim
;; http://orgmode.org/worg/org-api/org-table-api.html
(require 'org-table) ; needed for access to org-table api

(defun gb/get-gradebook-lisp ()
  (interactive)
  (save-excursion
    (gb/goto-table "gradebook")
    (org-table-to-lisp)))

(gb/get-gradebook-lisp)
#+END_SRC
#+RESULTS:
: (("first name" "last name" "email" "Hwk 1" "Hwk2" "exam1" "project 1") ("" "" "" "10" "10" "60" "20") hline ("Jane" "Doe" "jd@cmu.edu" "A" "A" "B" "B") ("John" "Dillinger" "jdi@cmu.edu" "B" "B/C" "A" "C") ("jill" "wutz" "jw@cmu.edu" "D" "D" "R" "R"))

This is handy. Now we can think about processing the lisp data. Let us get the assignment names, and point values and save them in variables. The assignment names are in the first row, and start in column 3.

#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row1 (car (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENTS (mapcar 'identity (nthcdr 3 row1))))

gb/ASSIGNMENTS
#+END_SRC

#+RESULTS:
: ("Hwk 1" "Hwk2" "exam1" "project 1")

And now the point values, and total points.
#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row2 (cadr (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENT-POINTS (mapcar 'string-to-number (nthcdr 3 row2)))
 (setq gb/TOTAL-POINTS (apply '+ gb/ASSIGNMENT-POINTS)))

(format "ASSIGNMENT-POINTS=%s TOTAL-POINTS=%s" gb/ASSIGNMENT-POINTS gb/TOTAL-POINTS)
#+END_SRC

#+RESULTS:
: "ASSIGNMENT-POINTS=(10 10 60 20) TOTAL-POINTS=100"

So far, so good. Now, we need to get the letter grades for each student, and turn them into point multipliers.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-multiplier (LG)
  "return numeric multiplier for a letter grade"
  (interactive)
  (cdr (assoc (upcase LG) gb/MULTIPLIERS)))

(defun gb/get-multipliers(LGS)
  "apply get-multiplier to a list of letter grades"
  (interactive)
  (mapcar 'gb/get-multiplier LGS))

(defun gb/get-all-student-multipliers ()
  (mapcar 'gb/get-multipliers
          (mapcar (lambda (x)
                    (nthcdr 3 x))
                  (cdddr (gb/get-gradebook-lisp)))))

(gb/get-all-student-multipliers)
#+END_SRC

#+RESULTS:
: ((0.9 0.9 0.7 0.7) (0.7 0.6 0.9 0.5) (0.3 0.3 0.1 0.1))


Finally, we need the product of each multiplier with the gb/ASSIGNMENT-POINTS. This needs some care; some grades may be nil, which we cannot multiply. For now we neglect this detail.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-earned-points (multipliers)
  (mapcar* (lambda (a  b) (* a b)) multipliers gb/ASSIGNMENT-POINTS))

(defun gb/get-all-earned-points ()
  "returns total points earned by each student"
  (mapcar 'gb/get-earned-points  (gb/get-all-student-multipliers)))

(gb/get-all-earned-points)
#+END_SRC

#+RESULTS:
: ((9.0 9.0 42.0 14.0) (7.0 6.0 54.0 10.0) (3.0 3.0 6.0 2.0))

Next, we need to sum all the points and divide by the total points to get the overall numeric grade.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-all-numeric-grades ()
(mapcar (lambda (x)
          (/ (apply '+ x) gb/TOTAL-POINTS))
          (gb/get-all-earned-points)))

(gb/get-all-numeric-grades)
#+END_SRC

#+RESULTS:
: (0.74 0.77 0.14)

And finally, convert the numeric grades to letter grades. This involves finding the highest letter grade multiplier that the overall grade is larger than.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-final-letter-grade (grade)
 (dolist (pair gb/MULTIPLIERS letter-grade)
   (if (< (cdr pair) grade)
       (progn
         (setq letter-grade (car pair))
         (return letter-grade)))))

(mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))
#+END_SRC

#+RESULTS:
: ("B" "B+" "R")

That looks good. Now, let's make a final report of the results.

#+BEGIN_SRC emacs-lisp :results value
(let ((emails (mapcar '(lambda (x) (nth 2 x)) (cdddr (gb/get-gradebook-lisp))))
      (first-names (mapcar '(lambda (x) (nth 0 x)) (cdddr (gb/get-gradebook-lisp))))
      (last-names (mapcar '(lambda (x) (nth 1 x)) (cdddr (gb/get-gradebook-lisp))))
      (final-grades (mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))))
(mapcar* (lambda (fn ln em fg)
           `(,fn ,ln ,em ,fg))
         first-names
         last-names
         emails
         final-grades))
#+END_SRC

#+RESULTS:
| Jane | Doe       | jd@cmu.edu  | B  |
| John | Dillinger | jdi@cmu.edu | B+ |
| jill | wutz      | jw@cmu.edu  | R  |

** Summary
This is a pretty functional bit of code for computing final grades of a fixed format gradebook. It is missing some features. For example, it would not work well if any grades are missing, or if the gradebook is incomplete.

* TODO Testing units
#+BEGIN_SRC python
from pycse.units import units

u = units()

a = 5 * u.kJ
print repr(a)

b = u.kJ**2# * (1.0 / u.kJ)
print repr(b)
c = (1.0 / u.kJ)
print repr(c)

print repr(b*c)
print a.AS((1.0 / u.kJ) * u.kJ**2)
#print a.as_units(u.m)

#print '{0:1.3e}'.format(a)
#print '{0:f kJ}'.format(a)
#+END_SRC

#+RESULTS:
: Unit(5000.0, exponents=[ 2 -2  1  0  0  0  0], label=kJ)
: Unit(1000000.0, exponents=[ 4 -4  2  0  0  0  0], label=kJ^2)
: Unit(0.001, exponents=[-2  2 -1  0  0  0  0], label=kJ^-1)
: Unit(1000.0, exponents=[ 2 -2  1  0  0  0  0], label=(kJ^2)*(kJ^-1))
: 5.0 * (kJ^-1)*(kJ^2)



#+BEGIN_SRC python
from pycse.units import *
from pycse.umath import quad


u = units()
k = 0.23 * 1 / u.min
Cao = 2 * u.mol / u.L
V = 1 * u.L

Nao = Cao * V

def integrand(Na):
    return 1 / (k * Na)

t, terr = quad(integrand, 0.5 * Nao, Nao)
print t
#+END_SRC

#+RESULTS:
: 180.821003624 * s

* TODO Overloading subclass methods

#+BEGIN_SRC python
import numpy as np

class A(np.ndarray):

    def __new__(cls, input_array, label=None):
        # Input array is an already formed ndarray instance
        # We first cast to be our class type
        obj = np.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.label = label
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        if obj is None: return
        self.label = getattr(obj, 'label', None)

    def __array_wrap__(self, out_arr, context=None):
        return np.ndarray.__array_wrap__(self, out_arr, context)

    def __str__(self):
        return 'A({0}, label={1!s})'.format(np.array(self), self.label)


a = A(2)
print a

print a * 2
print np.float(2) * a
print np.float32(2) * a
print np.float64(2) * a
print np.__version__

#+END_SRC

#+RESULTS:
: A(2, label=None)
: A(4, label=None)
: A(4.0, label=None)
: A(4.0, label=None)
: 4.0
: 1.6.1
: 1.6.1
* TODO Testing out a new python units package
  :PROPERTIES:
  :categories: units
  :END:

#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()

distance = 1.0 * u.meter

dd = distance / (1*u.cm)
print 'dd = ',dd
print dd.magnitude, dd.dimensionality
print dd.to('dimensionless')
print
print 5 * dd * u.cm
print 'float = ',float(dd)
import numpy as np
print np.log(dd)


E = 10 * u.kJ/u.mol
R = 2 * u.cal/u.mol/u.K
T = 300 * u.K

print E/R/T
#+END_SRC

#+RESULTS:
: dd =  1.0 meter / centimeter
: 1.0 dimensionless

: 100.0 dimensionless
:
: 5.0 meter
: float =  100.0
: 4.60517018599
: 0.0166666666667 kilojoule / cal



#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()


from scipy.optimize import fsolve
Fa0 = 3.0                 # mol/min
Fa = Fa0 * (1.0 - 0.8)    # mol/min
G = Fa / Fa0

def objective(D):
    return 1 - G - D * G

Dsol, = fsolve(objective, 1.0)


nu = 1 * u.L / u.min
k = 0.34 * 1 / u.hr

# V = D * nu / k
print Dsol * nu / k   # this prints oddly because the units are not simplified
print (Dsol * nu / k).to(u.L)

#+END_SRC

#+RESULTS:
: 11.7647058824 hour * liter / minute
: 705.882352941 liter

* TODO erf and erfc for switching functions
In a [[http://jkitchin.github.io/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/][previous post]] I examined a way to switch between discontinuous functions smoothly using a sigmoid function. The [[http://en.wikipedia.org/wiki/Error_function][error function]] has similar properties to the sigmoid function we used previously, and the complementary error function (erfc) is defined as 1 - erf. So, these are two functions we could use to smoothly transition from one function to another.


#+BEGIN_SRC python
import numpy as np
from scipy.special import erf, erfc

xspan = np.linspace(-5, 5)

import matplotlib.pyplot as plt

plt.plot(xspan, 0.5 * (1 + erf(xspan)), xspan, 0.5 * erfc(xspan))
plt.legend(['erf', 'erfc'])
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
from scipy.special import erf, erfc

def fF_laminar(Re):
    return 16.0 / Re

def fF_turbulent_unvectorized(Re):
    # Nikuradse correlation for turbulent flow
    # 1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)
    # we have to solve this equation to get f
    def func(f):
        return 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    return f

# this enables us to pass vectors to the function and get vectors as
# solutions
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)

# Now we plot the correlations.

Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label='laminar')
plt.plot(Re2, f2, label='turbulent')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()


def fanning_friction_factor(Re):
    alpha = 20
    f =  0.5 * erfc(alpha*(Re-3000))* fF_laminar(Re) + 0.5 * (1 + erf(alpha*(Re-3000))) * fF_turbulent(Re)
    return f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

# add data to figure 1
plt.figure(1)
plt.plot(Re,f, label='smooth transition')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
* TODO Penalizing digital assignments that are turned in late

This semester I have experimented with using box.com to have students turn in assignments. The assignments often have deadlines. For homeworks, we were soft on this, and there was often time between the deadline and when assignments were "collected" for grading. As long as the assignments were available by the time we collected them, we gave students credit for the assignments. Still, some students turned in assignments after that, and we did not have a good strategy for dealing with that.

A new wrinkle came about when I started using box.com to give quizzes and exams. I learned how to make students collaborators on a folder for the duration of the quiz/exam, and then to turn off their ability to upload at the end of the quiz. The first time I ran this, students were unprepared for the amount of time it could take to upload, and a good fraction failed to turn in their quiz. They were /very/ unhappy. I tried modifying the approach to give them a visual timer, with a warning, and a buffer time to enable uploads. That helped, but some were still unable to upload in time. This puts you in an uncomfortable position of telling students they get no credit, or dealing with emails from them of their assignments after they are due, and then figuring out an appropriate penalty. The students are stressed out because they are worried about their grades, and they don't think it is fair. Even if they are deservedly so, worried, stressed out students aren't learning.

Now, I recognize these students should have turned it in when told to, and if this were a paper exam, there is a hard deadline of me walking out the door with the exams. Digitally turned in assignments do not have this kind of behavior. A way to reduce the overall stress around this is that rather than shutting off access to the upload, we should simply use an appropriate late penalty. That way, students get to turn in their work, which is psychologically less stressful, and they are appropriately penalized for being late.

Now, why is this difficult? It turns out it is not that easy to tell when a file is uploaded or modified on box.com. You can do it through the box.com api, but the timestamp comes in an unfamiliar form. Second, late is a difference in time.  The local time on a computer is not the same as the time on the box.com servers, so we cannot (or should not) use that difference to determine lateness.

#+BEGIN_SRC python
from box_course.box import *
import json

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

print json.dumps(jf, sort_keys=True, indent=4)
#+END_SRC

#+RESULTS:
#+begin_example
{
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
    "created_at": "2013-12-08T06:31:46-08:00",
    "created_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "description": "",
    "etag": "0",
    "id": "12178719122",
    "item_status": "active",
    "modified_at": "2013-12-08T06:31:47-08:00",
    "modified_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "name": "reference.txt",
    "owned_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "parent": {
        "etag": "0",
        "id": "1364917348",
        "name": "test",
        "sequence_id": "0",
        "type": "folder"
    },
    "path_collection": {
        "entries": [
            {
                "etag": null,
                "id": "0",
                "name": "All Files",
                "sequence_id": null,
                "type": "folder"
            },
            {
                "etag": "1",
                "id": "1328895168",
                "name": "group-course",
                "sequence_id": "1",
                "type": "folder"
            },
            {
                "etag": "0",
                "id": "1364917348",
                "name": "test",
                "sequence_id": "0",
                "type": "folder"
            }
        ],
        "total_count": 3
    },
    "purged_at": null,
    "sequence_id": "0",
    "sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "shared_link": null,
    "size": 0,
    "trashed_at": null,
    "type": "file"
}
#+end_example


I think the relevant information is:
#+BEGIN_EXAMPLE
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
#+END_EXAMPLE

These timestamps are described [[https://www.ietf.org/rfc/rfc3339.txt][here]]. These timestamps are related to utc time, and can be converted to local time like this:

#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

def utc_to_local(timestamp):
    utc = parser.parse(timestamp)
    to_zone = tz.gettz('America/New_York')
    return utc.astimezone(to_zone)

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

from dateutil import parser
dc = jf['content_created_at']
print utc_to_local(dc)
#+END_SRC

#+RESULTS:
: 2013-12-08 09:31:46-05:00

In fact, I did create that file around 9:31am on 12/8. The =-05:00= is related t the offset of our local time with utc.

Now, the key idea in calculating lateness is that I have a reference time on box.com now, by virtue of having created reference.txt at the beginning of the assignment. I created two assignment files, assignment1.txt and assignment2.txt that I uploaded about 30 seconds, and one minute after the reference.txt was created. Below, I calculate the amount of time elapsed between the reference file and assignment files.


#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
jf = get_file_information(j['id'])
t0 = jf['content_modified_at']

j1 = get_item('group-course/test/assignment1.txt')
jf1 = get_file_information(j1['id'])
t1 = jf1['content_modified_at']

j2 = get_item('group-course/test/assignment2.txt')
jf2 = get_file_information(j2['id'])
t2 = jf2['content_modified_at']

p2 = parser.parse(t2)
p1 = parser.parse(t1)
p0 = parser.parse(t0)

d1 = p1 - p0
d2 = p2 - p0

print d1.total_seconds()
print d2.total_seconds()
#+END_SRC

#+RESULTS:
: 25.0
: 63.0

So, now we have a quantitative way to measure lateness. It is not a speedy method, since you have to make several box.com api calls, but, we can say how late it is, and since we use a reference file created on box.com at the beginning of the assignment, we take out the local time issue. The reference file could be created at the end of the assignment to mark when it is done.

Now about the penalty function. This is arbitrary, but should be a function that decays from 100% credit to some lower level of credit that is appropriate. For a homework, you might choose 50% as a floor, with some hours of decay time, whereas for a quiz/exam, it should be minutes of decay time down to 0%. Linear decay is the simplest. Let us say we want the credit to go from 100% to 50% over a 5 minute span. It would look like this:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

@np.vectorize
def penalty(t):
    if t < (5 * 60):
        p = 1.0 - (1.0 - 0.5) / (5 * 60) * t
    else:
        p = 0.5
    return p

t = np.linspace(0, 600, 100)
p = penalty(t)

plt.plot(t, p)
plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-penalty.png')
#+END_SRC

#+RESULTS:

[[./images/example-penalty.png]]

There are many options for a smooth decrease. Let us examine this gaussian function. We define a function that decays in the normal distribution sense, and allows you to set upper and lower bounds. To go from 1.0 to 0.5 we use this code:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

def penalty(t, mu=0.0, sigma=5, ub=1.0, lb = 0.0):
    return (ub - lb) * np.exp(-(t-mu)**2 / (2 * sigma**2)) + lb

t = np.linspace(0, 30)
plt.plot(t, penalty(t, lb=0.5))

plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-gaussian-penalty.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/example-gaussian-penalty.png]]

You can see that after about 15 minutes (3 * sigma), the penalty will be


I think this would help reduce stress in the classroom, and make it more systematic to apply lateness penalties to assignments. I still have not worked out precisely how to integrate this into a grading workflow, since you need to run a script to get the penalties for each assignment, and then multiply the grade by it to get the penalized grade. You could grade normally, and have the script create a late file in the directory which is only used in calculating the overall grade.

* TODO Exporting LaTeX manuscripts from org-mode
  :PROPERTIES:
  :categories: org-mode
  :END:
We have been using org-mode to write manuscripts for submission to journals for publication. Our typical workflow is writing in org-mode, and then using a custom export function to turn the document into LaTeX, and then compiling to pdf via pdflatex. This /mostly/ works great, except for the following two issues:

1. We use BibTex for references, and most journals want us to replace the \bibliography{} lines with the contents of the .bbl file so it is self-contained.
2. We use png files in the org file so they show up in emacs. However, most journals want eps files, and we have to manually remove the .png extension from the LaTeX file so it will build on the journal site (which does not use pdflatex).

I am exploring some code that would automate those things.

** Replacing the bibliography line
Starting with item one, we need to get the contents of the bbl file, and then replace the bibliography line with that. The .bbl file is typically named after the tex file, which is named after the org file. So, if the org-file is blog.org, the tex file would be blog.tex, and the corresponding bbl file would be blog.bbl.

#+BEGIN_SRC emacs-lisp
; derive bbl filename from org file
(concat (file-name-sans-extension (file-name-nondirectory (buffer-file-name))) ".bbl")
#+END_SRC

An alternative approach is to replace text using a regexp.
#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name)))
#+END_SRC

Now, we need a way to get the contents of the bbl file. This works:
#+BEGIN_SRC emacs-lisp
(let* ((bbl-file (replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name))))
       (contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string))))
  (princ contents))
#+END_SRC

#+RESULTS:
: You got the contents of blog.bbl!

Finally, we should replace the bibliography string in the tex file with the contents of the bbl file. This block seems to do that. I think as long as the bibliography line does not span more than one line, and that there is not more than one of them this should work fine.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (bbl-file (replace-regexp-in-string "org$" "bbl" org-file))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (bbl-contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string)))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string "\\\\bibliography{.*}" bbl-contents tex-contents))))
#+END_SRC

#+RESULTS:

A work flow here would be to run a code block that exports the org-file to LaTeX, then run the code block above to insert the bbl file.

** Removing the image extensions
We put the .png extension in the figure links in org-mode so that org-mode will show the images in the buffer. That is convenient for writing. It is also fine if one uses pdflatex to compile the resulting LaTeX source. Some journals, however, use latex to build the document, and latex does not support png files; encapsulated postscript is preferrable for latex.

Luckily, you do not have to specify a file extension to latex, it will automatically look for the right extension (.eps for latex, .pdf or .png for pdflatex). So, we just need to strip the extension off of the image paths. Here is a regular expression and code block that seems to do this correctly.

#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"
 "\includegraphics{./images/test.png}


\\includegraphics{image/with/no/extension}
other latex

\\includegraphics[width=2in]{images/figure2.png}

\\includegraphics[width=3in]{./images/bulkmodulus-volume.png}
")
#+END_SRC

#+RESULTS:
: includegraphics{./images/test}
:
:
: \includegraphics{image/with/no/extension}
: other latex
:
: \includegraphics[width=2in]{images/figure2}
:
: \includegraphics[width=3in]{./images/bulkmodulus-volume}


We can combine this with the previous work on replacing the bibliography to replace all the extensions like this.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}\.].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"  tex-contents))))
#+END_SRC

#+RESULTS:

** Putting this together
What we want to create is a function we could use to create the manuscript. There would be a function like this for different journals and/or publishers. For instance, APS journals use revtex, while ACS journals use achemso. There could be one publisher function that takes some options for the specific journal.

#+BEGIN_SRC emacs-lisp

#+END_SRC
* TODO textify html

#+BEGIN_EXAMPLE
	<title>Philip Herron: Cython Book</title>	<guid>http://redbrain.co.uk/?p=147</guid>	<link>http://redbrain.co.uk/cython-book/</link>		<description><p>Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. <a href="http://bit.ly/195ahQs">http://bit.ly/195ahQs</a></p> <p><a href="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"><img class="aligncenter size-full wp-image-148" alt="photo" src="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg" width="640" height="480" /></a>The code can be found: <a href="https://github.com/redbrain/cython-book">https://github.com/redbrain/cython-book</a></p></description>		<pubDate>Tue, 10 Dec 2013 14:45:08 +0000</pubDate>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun ph (start end) (interactive "r")
 (setq output (libxml-parse-html-region start end)))
#+END_SRC

(cdr '(a nil b))


#+BEGIN_SRC emacs-lisp :results output
(setq phtml
'(html nil
      (head nil
            (title nil "Philip Herron: Cython Book")
            (guid nil "http://redbrain.co.uk/?p=147")
            (link nil))
      (body nil
            (p nil "http://redbrain.co.uk/cython-book/		"
               (description nil
                            (p nil "Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. "
                               (a
                                ((href . "http://bit.ly/195ahQs"))
                                "http://bit.ly/195ahQs"))
                            " "
                            (p nil
                               (a
                                ((href . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"))
                                (img
                                 ((class . "aligncenter size-full wp-image-148")
                                  (alt . "photo")
                                  (src . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg")
                                  (width . "640")
                                  (height . "480"))))
                               "The code can be found: "
                               (a
                                ((href . "https://github.com/redbrain/cython-book"))
                                "https://github.com/redbrain/cython-book")))
               (pubdate nil "Tue, 10 Dec 2013 14:45:08 +0000")))))


;; (defun print-elements-recursively (list)
;;        "Print each element of LIST on a line of its own.
;;      Uses recursion."
;;        (when list                            ; do-again-test
;;              (print (car list))              ; body
;;              (if (listp (cdr list)) (print-elements-recursively (cdr list)))
;;              (print-elements-recursively     ; recursive call
;;               (cdr list))))                  ; next-step-expression

;(print-elements-recursively phtml)

(defun print-list (lst)
 (when lst
   (if (atom (car lst))
     (print (car lst)) (print-list (cdr lst)))))


(print-list phtml)
#+END_SRC

#+RESULTS:






** another approach

<p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
[[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>

(defun ph (r1 r2) (interactive "r") (setq html (buffer-substring r1 r2)))
#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1]]"  html)
#+END_SRC

#+RESULTS:
: <p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA]]
: </div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
: [[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>


http://www.mkyong.com/regular-expressions/how-to-extract-html-links-with-regular-expression/

these worked in re-builder (C-c C-w) then c-y to get them

"<p>\\(.+?\\)</p>" \\1 is the stuff between them


#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]"  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>")
#+END_SRC

#+RESULTS:
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]



(url-file-local-copy "http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA")

[[./tst.png]]


** downloading images

#+BEGIN_SRC emacs-lisp :results raw
(defun download-src (arg)
  (format "[[%s][image]]" (save-match-data
                            (url-file-local-copy
                             (replace-regexp-in-string
                              "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"
                              "\\1"
                              arg)))))

(princ (replace-regexp-in-string "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>" #'download-src  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA">[[c:/Users/jkitchin/AppData/Local/Temp/url8408MBa][image]]</a>


** replacing <a>
#+BEGIN_SRC emacs-lisp :results raw
(princ (replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]" "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
[[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]

** some regexs
"<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>"  \\1 is the href \\2 is the target

"<img\\([^>]+\\)></img>"

"<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"  \\1 is the src
* TODO Copy a bibtex entry with some formatting

#+BEGIN_SRC emacs-lisp
(defun formatted ()
  "copy entry to formatted string"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((bibtex-expand-strings t)
         (entry (bibtex-parse-entry t))
         (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
         (year  (reftex-get-bib-field "year" entry))
         (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
         (key (reftex-get-bib-field "=key=" entry))
         (journal (reftex-get-bib-field "journal" entry))
         (volume (reftex-get-bib-field "volume" entry))
         (issue (reftex-get-bib-field "issue" entry))
         (pages (reftex-get-bib-field "pages" entry))
         (doi (reftex-get-bib-field "doi" entry))
         (output))
    (setq output (concat (when author author) ", "
                         (when title title) ", "
                         (when journal journal) ", "
                         (when volume volume)
                         (if issue (format "(%s), " issue) ", ")
                         (when pages pages) ", "
                         (when year (format "(%s)." year))
                         (when doi (format " http://dx.doi.org/%s" doi))))
    (kill-new output)))

#+END_SRC

Abild-Pedersen, F. and Greeley, J. and Studt, F. and  Rossmeisl, J. and Munter, T. R. and Moses, P. G. and  Sk\'ulason, E. and Bligaard, T. and N\o{}rskov,  J. K., Scaling Properties of Adsorption Energies for  Hydrogen-Containing Molecules on Transition-Metal  Surfaces, Phys. Rev. Lett., 99(1),016105, (2007). http://dx.doi.org/10.1103/PhysRevLett.99.016105
* TODO Email buffer after time out

(timer-duration "0.5 min")


#+BEGIN_SRC emacs-lisp
(run-at-time 5 nil
             (lambda (args)
(princ "uuuu")
               (let ((body (buffer-string)))
                 (mail)
                 (mail-to)
                 (insert "jkitchin@andrew.cmu.edu")
                 (mail-subject)
                 (insert "exam")
                 (mail-text)
                 (insert body)
                 (mail-send-and-exit))))
#+END_SRC

#+RESULTS:


(run-at-time 5 nil
             (lambda (args) (insert "done")))

"09:40pm" 10

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defvar jao-totd-timer (run-at-time "12:00am" (* 30 1) 'totd))
(cancel-timer jao-totd-timer)


(defun jao-cancel-totd
  (interactive)
  (cancel-timer jao-totd-timer))

(defun td ()
  (interactive)
  (with-output-to-temp-buffer "*my-timer*"
  (insert "done")))

(defvar jao-totd-timer (run-at-time "12:00am" 1 'td))
(cancel-timer jao-totd-timer)



* DONE Putting link references to lines of code in a source block
  CLOSED: [2014-04-22 Tue 20:59]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/04/22 20:59:30
  :updated:  2014/04/22 20:59:30
  :END:
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
http://orgmode.org/manual/Literal-examples.html#Literal-examples

The following code block has some references in it that we can refer to later:
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC


In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]] jumps to point-min.

To make this work with python we have to make a slight change to the reference format in the header.

#+BEGIN_EXAMPLE
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC
#+END_EXAMPLE

#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 3
: 4


In line [[(for)]] we initialize the loop, and in line [[(body)]] we run it.


* Storing INCAR parameters in a yaml file

#+BEGIN_SRC python
import yaml
document = r'''
encut:
  type: float
  units: eV
  description:  "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$   The number of plane waves differs for each k-point, leading to a superior beahviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations." '''

print yaml.load(document)
#+END_SRC

#+RESULTS:


There doesn't appear to be an emacs yaml reader. This is a dead end for now. Also, it is not clear that yaml is flexible enough to contain the markup.

* Storing INCAR parameters in a json file

I am exploring a way to list all the INCAR parameters for VASP in a file format that would allow me to generate the list of keywords in Python /and/ provide documentation in Emacs. Right now these keywords exist in a set of lists in ase.calculators.vasp, with some comments that indicate what they are. However, the only way to access the comments is via the source code. There is no way to show them to the user via a help command. Furthermore, most of the keywords are built in VASP keywords, but some are ase specific. For the VASP keywords, one can search the internet for them, which often brings up the VASP documentation, but sometimes that is slow. For the ase keywords, which implement convenience, one has to read the source. It would be nice to avoid all these issues, and provide documentation that is accessible in an editor too, e.g. in Emacs.

Here we explore doing all of this in a json file. There are json parsers for python and emacs, so it seems possible.

Here is an example of what the json file might look like. The encut documentation is adapted from the VASP documentation

#+BEGIN_SRC text :tangle incar.json
{
    "ispin": {
        "description": "turn spin polarization on (2) or off (1)",
        "default": 1,
        "allowed_values": [
            1,
            2
        ],
        "units": null,
        "type": "int",
        "long_description": "The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. "
    },
    "encut": {
        "units": "eV",
        "type": "float",
        "description": "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. "
    }
}
#+END_SRC

Now, we parse it with Python.
#+BEGIN_SRC python
import json

with open('incar.json') as f:
    data = json.loads(f.read())

print data

print data.keys()
#+END_SRC

#+RESULTS:
: {u'ispin': {u'description': u'turn spin polarization on (2) or off (1)', u'default': 1, u'allowed_values': [1, 2], u'units': None, u'type': u'int', u'long_description': u'The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. '}, u'encut': {u'units': u'eV', u'type': u'float', u'description': u'Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. '}}
: [u'ispin', u'encut']

That is easy enough. We only have to remember that the strings are read in a unicode. It is similarly easy in Emacs.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(let ((my-json (json-read-from-string (with-temp-buffer
					(insert-file-contents "incar.json")
					(buffer-string)))))
  (princ my-json)
  (princ "\n")
  (princ (mapcar (lambda (x) (car x)) my-json)))
#+END_SRC

#+RESULTS:
: ((encut (description . Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$
:
: The number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. ) (type . float) (units . eV)) (ispin (long_description . The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. ) (type . int) (units) (allowed_values . [1 2]) (default . 1) (description . turn spin polarization on (2) or off (1))))
: (encut ispin)

This looks pretty promising. I could have a json file that describes the keywords, provides documentation of the keywords, etc... In python I would use that file to generate the lists that vasp.py uses for each type of keyword, and to provide help functions in python. I could also do that in Emacs too.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc 'description (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help 'ispin))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

It might be confusing for a while that you use symbols instead of strings here. That is changeable with the json-object-type and json-key-type variable which can make them into strings. Here is an example.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((json-key-type 'string)
	 (my-json (json-read-from-string (with-temp-buffer
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc "description" (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help "ispin"))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

This seems like a promising approach to provide flexible documentation to the keywords.

* Set a headline to DONE
  CLOSED: [2014-01-27 Mon 13:50]

#+BEGIN_SRC emacs-lisp
(org-narrow-to-subtree)
(goto-char (point-min)) ; beginning of buffer
(org-todo 'done)
(widen)
#+END_SRC

#+RESULTS:

* Using org-mode files as databases

Below are subheadings that contain data, properties and tags. Here, we use this entry as a database to summarize data.

#+BEGIN_SRC emacs-lisp
(let* ((total-units 0)
      (units)
      (course)
      (courses (org-map-entries (lambda ()
				  (setq units (string-to-number (org-entry-get (point) "UNITS"))
					total-units (+ total-units units)
					course (nth 4 (org-heading-components)))
				  `(,course  ,units ,(org-entry-get (point) "SEMESTER")))
				"chemistry|biology|physics|math" 'tree nil)))
  (add-to-list 'courses `(nil "Total units"  ,total-units) t))
#+END_SRC

#+RESULTS:
| 09-105 |           9 |  1 |
| 09-106 |           9 |  2 |
| 33-105 |          12 |  1 |
| 33-106 |          12 |  3 |
| 21-120 |           9 |  1 |
| 21-122 |           9 |  2 |
| 21-259 |           9 |  3 |
| 03-232 |           9 |  5 |
|    nil | Total units | 78 |





How about classes with less than 12 units?

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil)
#+END_SRC

#+RESULTS:
| Using org-mode files as databases | nil |
|                            09-105 |   9 |
|                            09-106 |   9 |
|                            21-120 |   9 |
|                            21-122 |   9 |
|                            21-259 |   9 |
|                            03-232 |   9 |

I am surprised by the nil entry above. I would have thought an entry with out a property should not be counted. That suggests some list pruning is in order. There is a remove-if-not macro in the cl (common-lisp) library.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(remove-if-not
  (lambda (arg) (nth 1 arg))
    (org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil))
#+END_SRC

#+RESULTS:
| 09-105 | 9 |
| 09-106 | 9 |
| 21-120 | 9 |
| 21-122 | 9 |
| 21-259 | 9 |
| 03-232 | 9 |

** 09-105							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 09-106							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 33-105							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
** 33-106							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 3
   :END:
** 21-120							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 21-122							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 21-259							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 3
   :END:
** 03-232							    :biology:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 5
   :END:
** 06-100							:engineering:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
* A widget based quiz in Emacs
  :PROPERTIES:
  :categories: emacs
  :END:

I have been interested in making quizzes in Emacs. Quizzes that
students would take, and somehow submit. One issue with an org-mode
quiz is the totally free-form; everything can be edited. Enter the
[[https://www.gnu.org/software/emacs/manual/html_mono/widget.html][widget]] library in Emacs. Below is an illustrative example of making a
quiz, adapted from [[https://www.gnu.org/software/emacs/manual/html_mono/widget.html#Programming-Example][here]]. I also adapted some code from [[http://stackoverflow.com/questions/13590811/how-i-can-get-values-of-all-widgets-in-current-widget-minor-mode-buffer-in-emacs][here]] to get a
list of widgets in a buffer, how they are tagged, and their values.

#+BEGIN_SRC emacs-lisp
(require 'widget)

(eval-when-compile
  (require 'wid-edit))

(require 'cl)
(defun get-widgets ()
  "return a list of widget tags and values from the buffer"
  (mapcar (lambda (x)
	      `(,(widget-get x :tag) ,(widget-value x)))
	  (save-excursion
	    (goto-char (point-min))
	    (loop while (not (eobp))
		  for new = (widget-at)
		  and old = nil then new
		  when (and new (not (eq new old))) collect new
		  do (goto-char (next-overlay-change (point)))))))

(defun submit-quiz (&rest ignore)
  "email results from quiz"
  (interactive)
  (let ((widgets (get-widgets)))
    (mail)
    (mail-to)
    (insert "jkitchin@andrew.cmu.edu")
    (mail-subject)
    (insert "quiz1")
    (mail-text)
    (insert (format "%s" widgets))
;    (insert quiz)
    (mail-send-and-exit)))

(defun quiz1 ()
  "create a simple quiz"
  (interactive)
  (switch-to-buffer "*Quiz 1*")
  (kill-all-local-variables)
  (let ((inhibit-read-only t))
    (erase-buffer))
  (remove-overlays)
  (widget-insert "You will take a quiz.\n\n")
  (widget-create 'editable-field
		 :size 13
                 :tag "quiz1-name"
		 :format "Name: %v ")

  (widget-insert "\n\nCheck all true statements:\n")
  (widget-create 'checkbox :tag "p1-a" nil)
  (widget-insert " 2+2 = 4\n")
  (widget-create 'checkbox :tag "p1-b" nil)
  (widget-insert " 3*3=8\n")
  (widget-create 'checkbox :tag "p1-c" nil)
  (widget-insert " widgets are cool.\n")

  (widget-insert " \n\nSelect the best answer. \\sqrt{64} = \n\n")
  (widget-create 'radio-button-choice
		 :tag "p2" :value nil
		 '(item "2")
                 '(item "4")
		 '(item "8"))

  (widget-insert "\n\nWrite a long essay.\n")
  (widget-create 'editable-field
                  :format "Text: %v "
                  :tag "p3-essay"
                  :size 20)

  (widget-insert "\n")
  (widget-create 'push-button
		 :notify #'submit-quiz
		 "Submit")
  (widget-insert " ")
  (widget-create 'push-button
		 :notify (lambda (&rest ignore) (kill-buffer))
		 "Quit")

  (use-local-map widget-keymap)
  (widget-setup))
#+END_SRC

#+RESULTS:
: quiz1

Now, we just run [[elisp:(quiz1)]] and we get a "form" to fill out.

On my computer, I get this after I fill it out:

[[./images/quiz1.png]]


After I press submit, this gets emailed to me:

[[./images/quiz1-answers.png]]

It is obviously not perfect, since it did not capture the radio
buttons in a useful way, and it collected the Submit and Quit buttons,
since they are widgets. Those can probably all be fixed with better
code, or maybe more specific code.

It is not too simple to write a quiz like this, but with some
practice, and best practice development, it might be pretty
straightforward after a while. The benefits are a more tightly
controlled quiz environment. Submission may still be tricky, since at
least in this case I rely on Emacs being setup for email. Other
methods might work too, e.g. an http POST, or saving a file to a shared
location.

See these links too:
- http://www.emacswiki.org/emacs/widget-demo.el

* Using macro expansions in org-mode

#+EMAIL: jkitchin@andrew.cmu.edu

#+RANDOM-KEYWORD: interesting

#+MACRO: my-animal-macro  a $1 has $2

Send me mail at {{{email}}}. My response will be {{{random-keyword}}}. Finally, you may be interested to know that {{{my-animal-macro(zebra,stripes)}}}.

* Converting Endnote libraries to bibtex files
  :PROPERTIES:
  :categories: bibtex
  :END:
I have had a need lately to convert Endnote libraries into bibtex files. Endnote has a BibTeX-Export style that will export your library. One issue with that style is it expects you to have a label in each entry. If you are a normal Endnote user, you do not have labels on any entry. There is no need for them. I also found that for entries with no label, there is no comma in the entry header, which causes Emacs to think the entry is syntactically incorrect. I fixed up the style to prevent that from happening. You can get a copy of the style [[C:\Users\jkitchin\Documents\EndNote\Styles\BibTeX-Export-kitchin.ens][here]].

Now, if you load that style, you can export a library to a
file. Endnote insists on making it a text file. We need to rename the
file, then we need to create keys for each entry. Normally, I would do
that with =bibtex-clean-entry=, which mostly works by hand. However, the bibtex entries are not correct yet, because they have no keys. We will add simple numeric keys, and then map over each entry to add proper keys.

#
#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser
from bibtexparser.customization import convert_to_unicode
import textwrap

def format_bibtex_entry(entry):
    # field, format, wrap or not
    field_order = [(u'author', '{{{0}}},\n', True),
                   (u'title', '{{{0}}},\n', True),
                   (u'journal','"{0}",\n', True),
                   (u'volume','{{{0}}},\n', True),
                   (u'number', '{{{0}}},\n', True),
                   (u'pages', '{{{0}}},\n', True),
                   (u'year', '{0},\n', True),
                   (u'doi','{{{0}}},\n', False),
                   (u'url','{{\url{{{0}}}}},\n', False),
                   (u'link','{{\url{{{0}}}}},\n', False)]

    keys = set(entry.keys())

    extra_fields = keys.difference([f[0] for f in field_order])
    # we do not want these in our entry
    extra_fields.remove('type')
    extra_fields.remove('id')

    # Now build up our entry string
    s = '@{type}{{{id},\n'.format(type=entry['type'].upper(),
                                  id=entry['id'])

    for field, fmt, wrap in field_order:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = fmt.format(entry[field])
            s3 = '{0:17s}{1}'.format(s1, s2)
            if wrap:
                # fill seems to remove trailing '\n'
                s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    for field in extra_fields:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = entry[field]
            s3 = '{0:17s}{{{1}}}'.format(s1, s2)
            s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    s += '}\n\n'
    return s


import os
if os.path.exists('ternary-alloys-exported.bib'):
    os.unlink('ternary-alloys-exported.bib')

# get the entries
with open('ternary-alloys.bib', 'r') as bibfile:
    bp = BibTexParser(bibfile)
    entries = bp.get_entry_list()


for i, entry in enumerate(entries):
    # set key to a simple number
    entry['id'] = i
    with open('ternary-alloys-exported.bib', 'a') as f:
        f.write(format_bibtex_entry(entry))
#+END_SRC

#+RESULTS:


Ok, finally, our goal is consistency with Emacs. Now the entries are syntactically correct, and we can clean each entry. This block runs through each entry and replaces the numeric key with a key formatted our way. Unfortunately you still have to press enter for each entry.

#+BEGIN_SRC emacs-lisp
(find-file "ternary-alloys-exported.bib")
(bibtex-map-entries (lambda (entry start end)
(condition-case ex
    (bibtex-clean-entry t nil)
  ('error (message (format "Caught exception: [%s]" ex))))))
#+END_SRC

#+RESULTS:


[[./ternary-alloys-exported.bib]]



* Introspecting the variables in a python script

I want to build an emacs command that views an atoms, or prints a summary of a calculator in a code block. The idea is to get the python code in the block, run it in an interpreter, then view the atoms or print the calculator.

The reason I want to try this is that I often want a quick view of the atoms, but I do not want to import the module, write in the view line, and then comment them out.

#+BEGIN_SRC emacs-lisp
(defun get-source ()
  "mark region of source block"
  (interactive)
  (let ((case-fold-search nil)
	(start)
	(end))
    (re-search-backward "^#\\+BEGIN_SRC")
    (forward-line)
    (setq start (point))

    (re-search-forward "^#\\+END_SRC")
    (previous-line)
    (end-of-line)
    (setq end (point))
    ;(message-box "%s %s %s" start end (buffer-substring start end))
    (buffer-substring start end)))

(defun print-calculator ()
  "print any calculators found in *jasp-calculator*"
  (interactive)
  (python-shell-internal-send-string (concat (get-source) "\n"))

  (switch-to-buffer "*jasp-calculator*")
  (erase-buffer)
  (insert (python-shell-internal-send-string "
for k,v in globals().items():
    if isinstance(v, ase.calculators.vasp.Vasp):
        print v
")))

(defun view-atoms ()
  (interactive)
  "view any Atoms objects found"
  (python-shell-internal-send-string (concat (get-source) "\n"))
  (insert (python-shell-internal-send-string "
from ase.visualize import view

for k,v in globals().items():
    if isinstance(v, ase.atoms.Atoms):
        view(v)
")))

#+END_SRC

#+RESULTS:
: view-atoms

#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

atoms = Atoms([Atom('O',[5, 5, 5], magmom=1)],
             cell=(6, 6, 6))

with jasp('O_sv',
          encut=300,
          xc='PBE',
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={'O':'_sv'}, # specifies O_sv potential
          atoms=atoms) as calc:
    print type(calc)
    print calc.__class__
    atoms.get_potential_energy()
#end
#+END_SRC

#+RESULTS:
: <type 'instance'>
: ase.calculators.vasp.Vasp
* Footnotes

[fn:1] Box Sync 4 renames your sync directory from "~/Documents/My Box Files" to "~/Box Sync".

[fn:2] You will have to read the raw org-source to see how the code-block arguments look.

[fn:3] It is true there are packages like FiPy (http://www.ctcms.nist.gov/fipy/) for PDEs, and scikits for BVPS, (http://scikits.appspot.com/bvp1lg, http://scikits.appspot.com/bvp_solver). But these are not easily installed on all platforms, and typically require some developer experience in compiling.

[fn:4] I know I can pretty conveniently collapse a code block by pressing tab on the header. Sometimes that is not enough.

[fn:5] It is not much harder, C-s will let you search for the named block. I do not know if there are nice convenient navigation commands for this.
