* Showing what data went into a code block on export
Sometimes I define variables in the header of a code block and then use the code to analyze the data. In org-mode this is super, and you can read the file and easily see what is going on. 

When you export the file, however, the information is lost, and in the exported result you cannot see what data went into a code block, or figure out where it is from. 

Today we design an export filter to remedy this. 

#+tblname: tbl-data
| x | y |
|---+---|
| 1 | 1 |
| 2 | 4 |
| 3 | 9 |

#+BEGIN_SRC python :var data=tbl-data 
print data
#+END_SRC

#+RESULTS:
: [[1, 1], [2, 4], [3, 9]]

We are going to define a derived LaTeX backend to do this for us. This idea is based on the code shown in http://orgmode.org/manual/Advanced-configuration.html. 

#+BEGIN_SRC emacs-lisp
(defun my-src-block (src-block contents info)
  (message "start-block\n\n%s\n\nend-block" info)
  (concat "<pre>"
   (format "[language: %s]" (org-element-property :language src-block))
   (format "\nparameters: %s" (org-element-property :parameters src-block))
   "</pre><br>"
    (org-export-format-code-default src-block info)))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((src-block . my-src-block)))

(org-export-to-file 'my-html "custom-src-table-export.html")
(browse-url "custom-src-table-export.html")
#+END_SRC
#+RESULTS:
: #<process open custom-src-table-export.html>

** filter							   :noexport:

#+BEGIN_SRC emacs-lisp
(defun ox-mrkup-filter-table (text back-end info)
  (message "%s %s %s" text back-end info)
  (concat "Filtered: \n" text)
   )

(defun ox-mrkup-filter-src-block (text back-end info)
  (message "%s %s %s" text back-end info)
  (concat "Filtered: \n" text)
   )

(let ((org-export-filter-table-functions '(ox-mrkup-filter-table))
      (org-export-filter-src-block-functions '(ox-mrkup-filter-src-block))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only t)
      (ext-plist '()))
  (browse-url
  (org-html-export-to-html async subtreep visible-only body-only ext-plist)))

#+END_SRC
#+RESULTS:
: #<process open ./blog.html>



* Getting information about named tables in exported org-files
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/09/21 14:34:50
  :updated:  2014/09/21 14:34:50
  :END:
I have found that the names of tables typically get lost when you export an org-file to another format like html or pdf. Since we may use named tables as data sources, it can become unclear in the exported file what has happened, or which table data came from. In this post, we examine how to include the name of a table in exported html. Here are two named tables =tbl-1= and =tbl-2= that will form the beginning of our effort. 

#+tblname: tbl-1
| x | y |
|---+---|
| 1 | 2 |
| 2 | 3 |

Another table, so we have something to work with later.

#+name: tbl-2
| a |
|---|
| 5 |
| 3 |


Org-buffers get parsed into nested lists, with properties usually in plists. It will be convenient to get a list of the keys for an element, so we can tell what information we have on each element. Some code for this can be found here: http://www.emacswiki.org/emacs/mon-plist-utils.el. Rather than use that recursive approach, here we just loop through the plist and accumulate the keys.

#+name: elisp-keys
#+BEGIN_SRC emacs-lisp
(defun plist-get-keys (plist)
  (interactive)
  (let ((keys))
    (while (car plist)
      (add-to-list 'keys (car plist) t)
      (setq plist (cddr plist)))
    keys))

; example of use
(plist-get-keys '(:a 1 :b 3 :parent '(another plist)))
#+END_SRC

#+RESULTS: elisp-keys
| :a | :b | :parent |


Now, when we parse a buffer for elements, we get a nested lisp data structure, and the best I can tell is we need the cadr of that list to get to the relevant plist of properties. So, here, we map over the tables, and see what properties are available.


#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (plist-get-keys (cadr element))))
#+END_SRC

#+RESULTS:
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :results | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :caption | :parent  |         |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :name    | :caption | :parent |
| :begin | :end | :type | :tblfm | :contents-begin | :contents-end | :value | :post-blank | :post-affiliated | :results | :parent  |         |

Depending on when you run the codeblock above (i.e. I ran it at different stages of development of this document, so some tables after this point are shown), you see different results; some of the tables are RESULTS from code blocks with no names, and two tables have a caption.  

Let us now map over the tables and see if they have names. We add an unnamed table, and a named table, both with captions.
 
#+Caption: an unnamed table of category counts.
| category | count |
|----------+-------|
| emacs    | 4     |
| orgmode  | 3     | 

#+name: python-table
#+Caption: an named table of category counts on python.
| category | count |
|----------+-------|
| Python   |     4 |
| pep8     |     3 |

Here we get the names of the tables. Only three tables have names, and several are unnamed.
  
#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (plist-get (cadr element) :name)))
#+END_SRC
#+RESULTS:
| tbl-1 | tbl-2 | python-table |


If you think that is a little awkward, I agree. Here is probably a better way to get that information using features in org-mode..

#+BEGIN_SRC emacs-lisp
(org-element-map
    (org-element-parse-buffer) 'table
  (lambda (element)  (org-element-property :name element)))
#+END_SRC
#+RESULTS:
| tbl-1 | tbl-2 | python-table |


I had thought we could use a [[http://orgmode.org/manual/Advanced-configuration.html][filter]] to add the name to each table. The issue with filtering is that we get the transcoded text directly, and no practical way to get back to the element it came from (at least none I could find). I have previously used filters (e.g. for [[http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][changing links on export]]) for something like this, but it involved parsing the document once, then exporting, and iterating through the results to change the output. I want to do something different here, and fix the issue on the export. 

That requires us to derive a new backend for export, with our new function for formatting. This will give us access to the actual table element, and we can use the original transcoding function to get most of the table, and our own code to modify that before it is exported.

Basically, we just want to add an HTML anchor to the table with some text to indicate the table name. With the anchor we can then link to it elsewhere like this:

#+BEGIN_HTML
 <a href="#tbl-2"> See tbl-2</a>
#+END_HTML

We just define a function that satisfies the transcoding function signature (element contents info), and if our element has a :name property, we will prepend it onto the usual table output for html. We will go ahead and code in some conditional code for different backends, although for now only handle the html backend.

#+BEGIN_SRC emacs-lisp
(defun my-table-format (table contents info)
  (let ((tblname (org-element-property :name table)))    
    (cond
     ((eq (elt (plist-get info :back-end) 2) 'html)  
      (concat
       (when tblname
	 (format "<br>TBLNAME: <a name=\"%s\"></a>%s<br>" tblname tblname))
       (org-html-table table contents info))))))

(org-export-define-derived-backend 'my-html 'html
  :translate-alist '((table . my-table-format)))


(browse-url (org-export-to-file 'my-html "custom-src-table-export.html"))
#+END_SRC

#+RESULTS:
: #<process open custom-src-table-export.html>

That seems to do it. You may need to see [[./custom-src-table-export.html]] to see the newly annotated tables, since they probably do not show up in the blog post.
* org-mode and Perl

https://metacpan.org/pod/GD::Graph#EXAMPLES

#+BEGIN_SRC perl
load GD::Graph;
@data = (
  ["1st","2nd","3rd","4th","5th","6th","7th", "8th", "9th"],
  [    1,    2,    5,    6,    3,  1.5,    1,     3,     4],
  [ sort { $a <=> $b } (1, 2, 5, 6, 3, 1.5, 1, 3, 4) ]
);

my $graph = GD::Graph::chart->new(400, 300);

$graph->set(
    x_label           => 'X Label',
    y_label           => 'Y label',
    title             => 'Some simple graph',
    y_max_value       => 8,
    y_tick_number     => 8,
    y_label_skip      => 2
) or die $graph->error;

my $gd = $graph->plot(\@data) or die $graph->error;
#+END_SRC

#+RESULTS:


* DONE A git status Emacs modeline
  CLOSED: [2014-09-19 Fri 09:36]
  :PROPERTIES:
  :categories: emacs,git
  :date:     2014/09/19 09:36:21
  :updated:  2014/09/19 09:36:21
  :END:
I am using git more and more in Emacs, and I would like a way to know the status of the git repo I am working in by looking at the modeline. I know about [[https://github.com/magit/magit][magit]], and other git modes, but none of them provide something as easy as useful as say [[https://github.com/magicmonty/bash-git-prompt][bash-git-prompt]] in the bash shell, which is to say I do not want to run a command to see the status (I might as well be in the shell then). Part of this need comes from a project with hundreds of git repos in it, and I want convenient status when I open any one of them.

Here, I want to emulate the bash-git-prompt feature in the Emacs modeline where it will show you when you are in a git repo, and then some basic information like what branch you are on, the number of untracked, modified files, and the commit status with respect to a remote. First, we only want this when we are in a git repo. We can check for that like this. The command in this block returns a string that starts with fatal when not in a git repo.

#+BEGIN_SRC emacs-lisp
(not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir")))
#+END_SRC

#+RESULTS:
: t

Let us wrap that in a nice function so we can use it later..
#+BEGIN_SRC emacs-lisp
(defun in-git-p ()
  (not (string-match "^fatal" (shell-command-to-string "git rev-parse --git-dir"))))

(in-git-p)
#+END_SRC

#+RESULTS:
: t

Next, we would like to know how many untracked, modified and other (e.g. unmerged, deleted, etc...) files we have. We can get this from  =git status --porcelain=. I am going to set these to be red if they are not zero, so they stand out, and be green otherwise. We will also store a list of each file type so we can make a tooltip on the counter to see what is there.

#+BEGIN_SRC emacs-lisp
(defun git-parse-status ()
  (interactive)
  (let ((U 0)   ; untracked files
	(M 0)   ; modified files
	(O 0)   ; other files
	(U-files "")
	(M-files "")
	(O-files ""))
    (dolist (line (split-string
		   (shell-command-to-string "git status --porcelain")
		   "\n"))
      (cond

       ;; ignore empty line at end
       ((string= "" line) nil)

       ((string-match "^\\?\\?" line)
	(setq U (+ 1 U))
	(setq U-files (concat U-files "\n" line)))

       ((string-match "^ M" line)
	(setq M (+ 1 M))
	(setq M-files (concat M-files "\n" line))
	)

       (t
        (message "detected other in %s" line)
	(setq O (+ 1 O))
	(setq O-files (concat O-files "\n" line)))))
      
    ;; construct propertized string
    (concat
     "("
     (propertize 
      (format "M:%d" M)
      'face (list ':foreground (if (> M 0)
				   "red"
				 "forest green"))
      'help-echo M-files)
     "|"
     (propertize 
      (format "U:%d" U)
      'face (list ':foreground (if (> U 0)
				   "red"
				 "forest green"))
      'help-echo U-files)
     "|"
     (propertize 
      (format "O:%d" O)
      'face (list ':foreground (if (> O 0)
				   "red"
				 "forest green"))
      'help-echo O-files)		    
      ") ")))

(git-parse-status)
#+END_SRC

#+RESULTS:
: (M:1|U:2|O:0) 

Finally, let us get the branch we are on, and the commits with respect to a remote. We can do that like this. We use some unicode characters to indicate what direction things go, e.g. an up arrow to indicate you need to push, and a down arrow to indicate you should pull.

#+BEGIN_SRC emacs-lisp
(defun git-remote-status ()
  (interactive)
  (let* (;; get the branch we are on.
	 (branch (s-trim
		  (shell-command-to-string
		   "git rev-parse --abbrev-ref HEAD")))
	 ;; get the remote the branch points to.
	 (remote (s-trim
		  (shell-command-to-string
		   (format "git config branch.%s.remote" branch))))
         (remote-branch (s-trim
			 (shell-command-to-string
			  "git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)")))
	 (commits (split-string
		   (s-trim
		    (shell-command-to-string
		     (format
		      "git rev-list --count --left-right HEAD...%s"
		      remote-branch)))))
	 (local (nth 0 commits))
	 (remotes (nth 1 commits)))
    (concat
     "["
     (propertize
      (format "%s" branch)
      'face (list :foreground "magenta"))
     "|"
     (format "↑%s|↓%s" local remotes)
     "]"))) 

(git-remote-status)
#+END_SRC

#+RESULTS:
: [source|↑0|↓0]

Now, we can finally put this together in a little minor mode. We add an element to the mode-line-format variable that evaluates those functions. When we turn off the minor mode, we remove the element from the modeline.

#+BEGIN_SRC emacs-lisp
(define-minor-mode git-mode
  "minor mode to put git repo status in modeline"
  nil nil nil
  (let ((git-modeline '(:eval (if (not (in-git-p))
				  ""
				(concat 
				 (git-remote-status)
				 (git-parse-status))))))
    (if git-mode
	;; put in modeline
	(push git-modeline mode-line-format)
      ;; remove from modeline
      (setq mode-line-format
	    (-remove (lambda (x)
		       (equal x git-modeline)) 					
		     mode-line-format)))))
#+END_SRC

#+RESULTS:

This leads to a modeline that looks like this (when my mouse is hovered over the M):

[[./images/git-modeline.png]]

This seems to have some performance issue, since pretty much everytime I type a key, it updates the modeline, and runs git. That is too often. Let us redefine the mode here so we have a minimum time between updates, say 15 seconds. We will store the last time updated, and the last value of the mode-line. Then each time the modeline updates, if the time since the last update is greater than our interval, then we will run the git commands. Otherwise, we just use the old modeline value.

#+BEGIN_SRC emacs-lisp
(defvar git-modeline-last-update (float-time) "Last time we updated")
(defvar git-modeline-update-interval 15 "Minimum time between update in seconds")
(defvar git-modeline "" "Last value of the modeline")

(define-minor-mode git-mode
  "minor mode to put git repo status in modeline"
  nil nil nil
  (let ((git-modeline '(:eval (if
				  (> (- (float-time) git-modeline-last-update)
				     git-modeline-update-interval)
				  ;; we are updating				  
				  (setq git-modeline
					(if (not (in-git-p))
					    ""					 
					  (setq  git-modeline-last-update (float-time))
					  (concat 
					   (git-remote-status)
					   (git-parse-status))))
				
			      ;; use last value of the modeline
			      git-modeline))))
    (if git-mode
	;; put in modeline
	(push git-modeline mode-line-format)
      ;; remove from modeline
      (setq mode-line-format
	    (-remove (lambda (x)
		       (equal x git-modeline)) 					
		     mode-line-format)))))
#+END_SRC

#+RESULTS:

That does it I think. I don't have any performance issues here now. I have not tested this super thoroughly on many git repos, but it seems to be pretty consistent and correct so far. The remote status code is where there is the most probability for issues. I still do not know that part of git very well.  I wonder if there is a more elegant solution than this, perhaps an idle timer. I notice a little lag in updating the data when I switch to another git repo. That might be a little confusing one day.


Otherwise, this seems like a pretty nice solution so far. There are still some things that would be nice to see on here. For example, a pop-up menu on the modeline to switch branches, push or pull, and with actions for the files, e.g. add/commit, etc... Those do not seem to hard to 
* Scripting git
I am running a project where I need to script git to "do the right thing" non-interactively. The project involves students creating assignments, and then turning them in. They create the assignments in Emacs+org-mode, and then "turn in" the assignment by running a menu command that commits their work to a git repository, and then pushes it to my server. Some emacs-lisp code does all this magic. Most of the time. 

Occasionally, students have had trouble when it comes time to update their graded assignments. These assignments have been pulled from the server by me, graded, and pushed back. I did not anticipate that students would continue changing their local repos after turning the work in, and this causes issues when they try to pull the results back. 

Here I document how to make this process a bit more robust. Basically, we need to make sure the local repo is clean before we pull, then we need to check if there were merge conflicts. Since the conflicts are probably notes the students took, we will be conservative and just accept the merge markers in the text so they do not lose their notes.

What we need to do is check the output of "git status --porcelain" and do an appropriate action for each file. The output of this command is one line per file that requires some action. Basically we can have untracked files, which should just be added and committed. The reason for this is that if I create a file with the same name, it will be a conflict for git to overwrite their existing file. There could be added or modified files, renamed files, deleted files  updated but unmerged, and some other possibilities too.

The "git status --porcelain" command gives a two letter status code for each file that is not "clean". The first letter is the status of the index, and the second letter is the status of the work-tree, unless there is a merge conflict, and then they are the status of the file on each side of the merge.

#+BEGIN_EXAMPLE
       o   ' ' = unmodified

       o    M = modified

       o    A = added

       o    D = deleted

       o    R = renamed

       o    C = copied

       o    U = updated but unmerged

       Ignored files are not listed, unless --ignored option is in effect, in
       which case XY are !!.

           X          Y     Meaning
           -------------------------------------------------
                     [MD]   not updated
           M        [ MD]   updated in index
           A        [ MD]   added to index
           D         [ M]   deleted from index
           R        [ MD]   renamed in index
           C        [ MD]   copied in index
           [MARC]           index and work tree matches
           [ MARC]     M    work tree changed since index
           [ MARC]     D    deleted in work tree
           -------------------------------------------------
           D           D    unmerged, both deleted
           A           U    unmerged, added by us
           U           D    unmerged, deleted by them
           U           A    unmerged, added by them
           D           U    unmerged, deleted by us
           A           A    unmerged, both added
           U           U    unmerged, both modified
           -------------------------------------------------
           ?           ?    untracked
           !           !    ignored
           -------------------------------------------------
#+END_EXAMPLE 

The man page recommends we use the -z option for parsing which ends strings with a null character.
#+BEGIN_SRC sh :dir ~/Desktop/A
git status --porcelain
#+END_SRC

#+RESULTS:
: R  f1 -> f1-rname
:  D f2
: ?? f2-rname


It seems like we need to parse the porcelain command, get X, and Y, and depending on what those are, we have a set of cond statements to act appropriately.


Here is a function to parse a line of porcelain output.
#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results raw
(defun parse-line (line)
  (let* ((X (substring line 0 1))
	 (Y (substring line 1 2))
	 (PATHS (split-string (substring line 3)))
	 (PATH1 (nth 0 PATHS))
         ; for a rename there will be PATH1 -> PATH2
	 (PATH2 (if (= 3 (length PATHS)) (nth 2 PATHS) nil)))
    (list X Y PATH1 PATH2 line)))

(defun parse-git-status ()
 (interactive)
(loop for line in (split-string
		  (shell-command-to-string "git status --porcelain") "\n")
      when (not (string= "" line)) collect (parse-line line))) 
#+END_SRC

Now we check out the results.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A 
(parse-git-status)
#+END_SRC

#+RESULTS:
| R |   | f1       | f1-rname | R  f1 -> f1-rname |
|   | D | f2       | nil      | D f2              |
| ? | ? | f2-rname | nil      | ?? f2-rname       |

That function gives us a list of X, Y, FROM, and TO, and the original string.

Now, we can start building the logic to handle these. The goal of this block as after running, the repo is clean, and you can then pull into it.

#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A :results output
(let ((merge-p nil))
  (loop for (X Y FROM TO LINE) in (parse-git-status)
	do
	(cond
	 ;; untracked files get added and committed.
	 ((and (string= X "?")
	       (string= Y "?"))
	  (shell-command (format "git add %s" FROM))
	  (shell-command
	   (format "git commit %s \"adding %s.\""
		   FROM FROM)))
	 
	 ;; user rename
	 ((and (string= X "R")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO)))
	 
	 ;; rename and modify
	 ((and (string= X "R")
	       (string= Y "M"))
	  ;; commit the rename
	  (shell-command (format "git commit %s -m \"rename %s to %s\"" FROM FROM TO))
	  (shell-command (format "git commit %s -m \"changes in %s\"" TO TO)))
	 
	 ;; added file
	 ((and (string= X "A")
	       (string= Y " "))
	  (shell-command (format "git commit %s -m  \"Adding %s\"" FROM FROM)))
	 
	 ;; deleted file
	 ((and (string= X " ")
	       (string= Y "D"))
	  (shell-command (format "git commit %s -m \"Deleting %s\"" FROM FROM)))
	 
	 ;; modified file
	 ((or (string= X "M")
	      (string= Y "M"))
          (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"changes in %s\"" FROM FROM)))

	 ;; merge conflict, we just add the file
	 ;; we do not commit here because you cannot partially commit.
	 ;; after the loop, we do the commit if merge-p is t
	 ((or (string= X "U")
	      (string= Y "U"))
	  (setq merge-p t)
	  (shell-command (format "git add %s" FROM)))
      
	 ;; catch everything else
	 (t
	  (shell-command (format "git add %s" FROM))
	  (shell-command (format "git commit %s -m \"%s\"" FROM LINE))
	  (message "%s not handled gracefully\n" LINE))))
  ;;
  (when merge-p    
    (shell-command "git commit -m \"accepting merge\"")))
#+END_SRC
#+RESULTS:


#+BEGIN_SRC emacs-lisp :dir ~/Desktop/A
(parse-git-status)
#+END_SRC

#+RESULTS:
| M |   | empty | nil | M  empty |



* DONE Colorized text in Emacs
  CLOSED: [2014-09-14 Sun 14:23]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/09/14 14:23:05
  :updated:  2014/09/14 14:33:32
  :END:

As I continue investigating Emacs + org-mode as a platform for creating applications, it has come up a few times that it would be useful to display colored text. For example, in a summary report of a git repo, you might want to see some information in red, e.g. if you have uncommitted changes, and some information in green, e.g. the repo is clean and consistent with a remote.

We can set colors on a string in Emacs like this:

#+BEGIN_SRC emacs-lisp
(propertize "Red Text" 'font-lock-face '(:foreground "red"))
#+END_SRC

The only tricky part is that we need to insert the text into a font-locked buffer to see it. That is also a tad tricky to illustrate in a code block, so here is a way to try it:

#+BEGIN_SRC emacs-lisp
(re-search-forward "-> ")
(insert
  (propertize "Red Text" 'font-lock-face '(:foreground "red")))
#+END_SRC

#+RESULTS:

-> Red Text

The red text does not show in the HTML post, so this is a screenshot of what it looks like in my buffer:

[[./images/red-text.png]]

Now, here is how we might use this in a summary report. Say we have a git repo, and we want to know various facts about it. We can get information about tracked/ untracked and modified files like this:

#+BEGIN_SRC sh
git status --porcelain
#+END_SRC
#+RESULTS:
:  M _blog/blog.html
:  M _blog/blog.org
: A  _blog/images/red-text.png

This shows we have two tracked, but modified files, and on added but not committed file. We can use this code to show if we have any untracked files.

#+BEGIN_SRC emacs-lisp
(let ((n 0) s)
  (dolist (line (split-string
		 (shell-command-to-string "git status --porcelain")
		 "\n"))
    (when (string-match "^\\?\\?" line)
      (setq n (+ 1 n))))
  (if (> n 0)
      (setq s (propertize (format "%s untracked files" n)
			  'font-lock-face '(:foreground "red")))
    (setq s (propertize "No untracked files" 
			'font-lock-face '(:foreground "forest green"))))
  (re-search-forward "->")
  (insert s))
#+END_SRC

#+RESULTS:

->No untracked files

In HTML (i.e. the blog post) you cannot really see the green text, so here is a screenshot illustrating it.
[[./images/git-untracked-files.png]]

Similarly, we can check for modified files. We add a wrinkle and add a tooltip like text that shows the output of the git command.

#+BEGIN_SRC emacs-lisp
(let ((n 0)
      (output (shell-command-to-string "git status --porcelain"))
      s)
  (dolist (line (split-string
		 output
		 "\n"))
    (when (string-match "^ M" line)
      (setq n (+ 1 n))))
  (if (> n 0)
      (setq s (propertize (format "%s modified files" n)
                          'help-echo output
			  'font-lock-face '(:foreground "red")))
    (setq s (propertize "No modified files" 
			'font-lock-face '(:foreground "forest green"))))
  (re-search-forward "-> ")
  (insert s))
#+END_SRC

#+RESULTS:

-> 2 modified files

That looks like this in emacs:

 [[./images/git-modified.png]]


That is the main idea in this post. You can create strings with properties, and use code to determine what they e.g. what color the text is, etc... There are lots of properties listed at http://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html that might be helpful in an application. Here are some previous posts that examined similar ideas.

- Read-only text http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/

- Tool tips: http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/

- Invisible text (this is not exactly a property, but it is similar)
http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-emacs/
* DONE Make some org-sections read-only
  CLOSED: [2014-09-13 Sat 13:50]
  :PROPERTIES:
  :categories: emacs,orgmode
  :date:     2014/09/13 13:50:49
  :updated:  2014/09/13 13:50:49
  :END:
There are times where I want an org-file to be /partly/ read-only. For example, there might be instructions that should not be modified. In this post we consider how to implement that. For now, we only want an org-section to be read-only, and we will designate those sections by a tag read_only. Then, the idea is that a hook function would be run when the org-file is loaded, and mark regions of text as read-only before the user can do anything.

In Emacs, you can mark a section of text, and set it to have a property of read-only. So, we can just map over the entries, and any heading that is tagged as read_only can be made read-only!

Here we set the first few characters of this buffer to be read-only.
#+BEGIN_SRC emacs-lisp
(add-text-properties 1 8 '(read-only t))
#+END_SRC

#+RESULTS:

Emacs is semi-serious about what read-only means. You cannot even change properties of read-only text, unless you set inhibit-read-only as a variable.

#+BEGIN_SRC emacs-lisp
(let ((inhibit-read-only t))
 (remove-text-properties 1 8 '(read-only t)))
#+END_SRC

#+RESULTS:
: t

Now, we can map over the entries in this buffer, and set any heading tagged read_only to actually be that way like this.

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let* ((element (org-element-at-point))
			  (begin (org-element-property :begin element))
			  (end (org-element-property :end element)))
		     (add-text-properties begin end '(read-only t))))
		 "read_only")
#+END_SRC

#+RESULTS:
| t |

To get this to work when org-mode is turned on, we just wrap it in a function, add the function to a hook, and a function to undo the read-only behavior. I found that if I use the end reported by org-element-at-point, it includes the first character of the next section, we take one away from the end to avoid that.

#+BEGIN_SRC emacs-lisp
(defun org-mark-readonly ()
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
	    (begin (org-element-property :begin element))
	    (end (org-element-property :end element)))
       (add-text-properties begin (- end 1) '(read-only t))))
   "read_only")
 (message "Made readonly!"))


(defun org-remove-readonly ()
  (interactive)
  (org-map-entries
   (lambda ()
     (let* ((element (org-element-at-point))
	    (begin (org-element-property :begin element))
	    (end (org-element-property :end element))
	    (inhibit-read-only t))
	 (remove-text-properties begin (- end 1) '(read-only t))))
     "read_only"))

(add-hook 'org-mode-hook 'org-mark-readonly) 
#+END_SRC

That seem to be all there is. After executing the code above, when I open this file, the next section is read-only! I can use the other function to remove that if I need to edit it. Score one for Emacs + org-mode!

** Read-only section 						  :read_only:

This text is so important, it should be read-only.

** Editable section

You can do what you want here. Like add text.

  
* DONE Randomize a list in Emacs
  CLOSED: [2014-09-06 Sat 10:08]
  :PROPERTIES:
  :categories: emacs_lisp
  :date:     2014/09/06 10:08:04
  :updated:  2014/09/06 15:11:50
  :END:

I have an application where I have a list of userids, and I want to randomize the order of the list. Today, I explore some ways to do that. The first idea is to simply mimic the algorithm in Python's random.shuffle algorithm.

#+BEGIN_SRC python
    def shuffle(self, x, random=None):
        """x, random=random.random -> shuffle list x in place; return None.

        Optional arg random is a 0-argument function returning a random
        float in [0.0, 1.0); by default, the standard random.random.

        """

        if random is None:
            random = self.random
        _int = int
        for i in reversed(xrange(1, len(x))):
            # pick an element in x[:i+1] with which to exchange x[i]
            j = _int(random() * (i+1))
            x[i], x[j] = x[j], x[i]
#+END_SRC

It looks like we loop through the elements, and swap them at random.

We have a similar feature for xrange in emacs-lisp:

#+BEGIN_SRC emacs-lisp
(number-sequence 1 5)
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 | 4 | 5 |

Note that number-sequence includes the last value, unlike xrange. And for reverse:

#+BEGIN_SRC emacs-lisp
(reverse (number-sequence 1 5))
#+END_SRC

#+RESULTS:
| 5 | 4 | 3 | 2 | 1 |

Of course, we can select random numbers:
#+BEGIN_SRC emacs-lisp
(random 5) ; random between 0 and 5
#+END_SRC

#+RESULTS:
: 4

Last, we need to work out how to swap to elements. It looks like this will swap elements 2 and 3. We store element 3 temporarily, set 3 to 2, and then set 2 to the temporarily stored value of 3.
#+BEGIN_SRC emacs-lisp
(let* ((L '(1 2 3 4))
       (tmp (nth 3 L)))
  (setf (nth 3 L) (nth 2 L))
  (setf (nth 2 L) tmp)
L)
#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 3 |

So, now we can shuffle our list.

#+BEGIN_SRC emacs-lisp
(setq userids '(user1 user2 user3 user4 user5 user6))

(defun swap (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (nth el1 LIST)))
    (setf (nth el1 LIST) (nth el2 LIST))
    (setf (nth el2 LIST) tmp)))

;; now run the loop
(loop for i in (reverse (number-sequence 1 (1- (length userids))))
      do (let ((j (random (+ i 1))))
	   (swap userids i j)))

userids
#+END_SRC

#+RESULTS:
| user4 | user6 | user3 | user2 | user1 | user5 |

The order has certainly changed. It is a little difficult to tell how randomized it actually is, but what is important for my application is that the order is different each time I use it. It looks like this will accomplish that objective. I think this basically implements the algorithm in the Python random.shuffle code. That code does something a little differently. It generates a random float between 0-1, multiplies it by i + 1, and converts the result to an integer. We directly get an integer in the range of 0 to i + 1. I think the result is practically the same.

Finally, let us wrap the whole thing up in a nice neat function for future use. We will use elt instead of nth so it works for arrays too.

#+BEGIN_SRC emacs-lisp
(defun swap (LIST el1 el2)
  "in LIST swap indices EL1 and EL2 in place"
  (let ((tmp (elt LIST el1)))
    (setf (elt LIST el1) (elt LIST el2))
    (setf (elt LIST el2) tmp)))


(defun shuffle (LIST)
  "Shuffle the elements in LIST.
shuffling is done in place."
  (loop for i in (reverse (number-sequence 1 (1- (length LIST))))
	do (let ((j (random (+ i 1))))
	     (swap LIST i j)))
  LIST)
#+END_SRC

#+RESULTS:
: shuffle

Example usage for a list:
#+BEGIN_SRC emacs-lisp
(shuffle '(user1 user2 user3 user4 user5 user6))
#+END_SRC

#+RESULTS:
| user4 | user2 | user3 | user5 | user6 | user1 | 

And for a vector:
#+BEGIN_SRC emacs-lisp
(shuffle [user1 user2 user3 user4 user5 user6])
#+END_SRC  

#+RESULTS:
: [user3 user2 user6 user4 user5 user1]

** Addendum
Artur at http://endlessparentheses.com suggested one can use psetf to swap values. Thanks for the tip, I was not aware of that cool function. It evaluates the values first, then sets them, so there is no need for a temporary storage of a value! Here is an example usage. We could rewrite our swap function like this if we wanted.

#+BEGIN_SRC emacs-lisp
(let ((LIST '(1 2 3 4 5)))
  (psetf (elt LIST 2) (elt LIST 1)
	 (elt LIST 1) (elt LIST 2))
LIST) 
#+END_SRC

#+RESULTS:
| 1 | 3 | 2 | 4 | 5 |


* DONE Using Mac gestures in Emacs
  CLOSED: [2014-08-31 Sun 10:20]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/08/31 10:20:46
  :updated:  2014/08/31 10:20:46
  :END:

I recently got a MacBook Air, and I have been exploring what you can do with it and Emacs. The Mac trackpad has some interesting gestures that are useful in Emacs. For example, you can scroll the buffer by moving two fingers up or down the trackpad. Or tap the trackpad with two fingers to get the equivalent of a right click. I was curious what other gestures could be used effectively in Emacs. Emacs does not capture all of the trackpad gestures, but it does capture the two finger swipe left and right as a triple-wheel-left or right key. We can use that to switch buffers. Normally one uses C-x leftarrow or right arrow to do that, but with the trackpack we can use a gesture!

The gesture triggers a triple-wheel key, which we can bind to an function. This code does that.

#+BEGIN_SRC emacs-lisp
(global-set-key [triple-wheel-left] 'previous-buffer)
(global-set-key [triple-wheel-right] 'next-buffer)
#+END_SRC
#+RESULTS:
: next-buffer

This scrolls through buffers blazingly fast! Almost unusably fast. If you move very slow, you can get some control and switch one buffer at a time. Interestingly, I see these messages while gesturing slowly:

#+BEGIN_EXAMPLE
<wheel-left> is undefined
<double-wheel-left> is undefined
<wheel-right> is undefined
<double-wheel-right> is undefined
<wheel-right> is undefined [2 times]
<double-wheel-right> is undefined
#+END_EXAMPLE

We need a custom function that has some kind of delay to slow down the buffer switching. Here is an idea. We will store a value in a global variable, and only switch buffers when it is true. After we switch the buffer we set the variable to nil, and activate a timer to reset the variable to t after a short delay. say one second. Here it is.

#+BEGIN_SRC emacs-lisp
(defvar *my-previous-buffer* t
  "can we switch?")

(defun my-previous-buffer ()
  (interactive)
  (message "custom prev: *my-previous-buffer*=%s" *my-previous-buffer*)
  (when *my-previous-buffer*
    (previous-buffer)
    (setq *my-previous-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
			       (setq *my-previous-buffer* t)))))

(defvar *my-next-buffer* t
  "can we switch?")

(defun my-next-buffer ()
  (interactive)
  (message "custom prev: *my-next-buffer*=%s" *my-next-buffer*)
  (when *my-next-buffer*
    (next-buffer)
    (setq *my-next-buffer* nil)
    (run-at-time "1 sec" nil (lambda ()
			       (setq *my-next-buffer* t)))))

(global-set-key [triple-wheel-right] 'my-previous-buffer)
(global-set-key [triple-wheel-left] 'my-next-buffer)
#+END_SRC

#+RESULTS:
: my-next-buffer

Note I reversed the left/right order. It seems that swiping left triggers the triple-wheel-right key. Go figure. Anyway, this makes the gesture actually usable, as it only changes one buffer at a time, with a short delay before you can change the buffer again. It is not a groundbreaking addition to Emacs, but it satisfied a curiousity itch for the day for me.


* Showing that Emacs is working


#+name: my-code
#+BEGIN_SRC python
import numpy
print 5
#+END_SRC

#+RESULTS: my-code
: 5

#+RESULTS:
: 5

This does not work, because there is no way to update the reporter while the code block is running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (let ((pr (make-progress-reporter "Running")))
    ad-do-it
    (progress-reporter-done pr)))
#+END_SRC


Here we create a buffer that indicates what is running
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((code-block (org-element-property :name (org-element-at-point)))
        (LN (line-number-at-pos)))

    (split-window-below)
    (other-window 1)
    (switch-to-buffer "*My Babel*")
    (if code-block
	(insert (format "Running %s\n" code-block))
      (insert (format "Running block at line %s\n" LN)))
    (insert "Started at: " (current-time-string) "\n")
    (other-window 1)
    ad-do-it
    (kill-buffer "*My Babel*")
    (delete-other-windows)))
#+END_SRC

#+BEGIN_SRC python
import time
time.sleep(5)
print 5
#+END_SRC

#+RESULTS:
: 5



Here we change the color of the codeblocks when they are running.
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  (set-face-attribute 'org-block-background nil :background "LightSteelBlue")
  ad-do-it
  (set-face-attribute 'org-block-background nil :background "gray")
(message "Done with code block"))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

Try using an overlay
#+BEGIN_SRC emacs-lisp
(defadvice org-babel-execute-src-block (around progress nil activate)
  "create a buffer indicating what is running"
  (let ((ol (make-overlay (org-element-property :begin (org-element-at-point))
			  (org-element-property :end (org-element-at-point)))))

    (overlay-put ol 'face '(foreground-color . "blue"))

    ad-do-it

    (delete-overlay ol)))
#+END_SRC

#+RESULTS:
: org-babel-execute-src-block

* Checking if processes are done

#+BEGIN_SRC emacs-lisp
(setq my-process (start-process-shell-command "slp" "*sleep*" "sleep 30"))
#+END_SRC

#+RESULTS:
: #<process slp>

#+BEGIN_SRC emacs-lisp
(process-live-p my-process)
#+END_SRC

#+RESULTS:


Now we try for a set of processes.

#+BEGIN_SRC emacs-lisp
(setq my-processes
      (mapcar
       (lambda (x)
	 (start-process-shell-command "slp" "*sleep*"
				      (format "sleep %s" (random 10))))
       '(1 2)))
#+END_SRC

#+RESULTS:
| slp | slp<1> |

And now check if they are all done.

#+BEGIN_SRC emacs-lisp :results raw
(mapcar (lambda (process) (process-live-p process)) my-processes)
#+END_SRC

#+RESULTS:
((run open listen connect stop) (run open listen connect stop))

This will tell us if any process is still alive.

#+BEGIN_SRC emacs-lisp :results raw
(-any-p 'process-live-p  my-processes))
#+END_SRC

#+RESULTS:
nil
nil
t
t


* Using Pymacs
 [[https://github.com/pinard/Pymacs][Pymacs]] is a project that aims to integrate Python into Emacs, and vice versa. In this post, I am going to examine the Python into Emacs integration. I cloned the git repository, ran make install, and setup my init.el file like this, as suggested in the manual.

#+BEGIN_EXAMPLE
(add-to-list 'load-path (expand-file-name "Pymacs" starter-kit-dir))
(require 'pymacs)
(autoload 'pymacs-apply "pymacs")
(autoload 'pymacs-call "pymacs")
(autoload 'pymacs-eval "pymacs" nil t)
(autoload 'pymacs-exec "pymacs" nil t)
(autoload 'pymacs-load "pymacs" nil t)
(autoload 'pymacs-autoload "pymacs")
#+END_EXAMPLE

Pymacs provides some mapping of Python modules to emacs-lisp functions. You load modules in emacs-lisp, and then a dash-mangled version of the Python functions are available, /in emacs lisp/. Here is an example. We will load numpy, and find the maximum element of an array. For comparison, here is the Python script.

#+BEGIN_SRC python
import numpy as np
print np.max(np.array([[1, 1], [2, 4]]))
#+END_SRC

#+RESULTS:
: 4

Now, the corresponding emacs version using Pymacs.

#+BEGIN_SRC emacs-lisp
(pymacs-load "numpy" "np-")
(np-max (np-array '((1 1) (2 4))))
#+END_SRC

#+RESULTS:
: 4

Neat! The dot notation is basically replaced with dash notation, and we use a lisp list as the argument. Otherwise, this looks almost identical. Now, let us consider something more complicated, and get the determinant of the array. We add a PREFIX to the load statement for numpy.linalg similar to what we would do in Python:

#+BEGIN_SRC python
import numpy as np
import numpy.linalg as la
print la.det(np.array([[1, 1], [2, 4]]))
#+END_SRC

#+RESULTS:
: 2.0

And in emacs-lisp:

#+BEGIN_SRC emacs-lisp
(pymacs-load "numpy" "np-")
(pymacs-load "numpy.linalg" "la-")
(la-det (np-array '((1 1) (2 4))))
#+END_SRC

#+RESULTS:
: 2.0

I am not sure what this offers over just having a Python block present in org-mode though. Maybe it is more useful in emacs-lisp libraries where you want to bring in some numerical analysis.

It may not be possible to do everything. For example, It is not clear how to pass functions through either side. For example, this does not work for fsolve, although it seems like it should. 

#+BEGIN_SRC emacs-lisp
(pymacs-load "scipy.optimize" "so-")

(defun objective (x)
  (- x 5))

(so-fsolve 'objective 3)
#+END_SRC

#+BEGIN_SRC python
from scipy.optimize import fsolve
def objective(x):
    return x - 5

print fsolve(objective, 3)
#+END_SRC

#+RESULTS:
: [ 5.]

* DONE Storing solutions to homework problems in an org-file with encrypted headlines
  CLOSED: [2014-08-19 Tue 09:30]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/19 09:30:27
  :updated:  2014/08/19 09:30:27
  :END:
I have been creating homework problems in org-files, which I distribute to students. A recurring dilemma I have had is where do you put the solution? If you put it in a separate file, there is not an elegant way to keep them connected, so if you end up changing the problem, it is easy to forget to update the solution.

Recently I learned about org-crypt. This allows you to encrypt the content of a heading. All you have to do is tag a heading with :crypt:, and when you save the file it will encrypt the contents of the heading. In this example, we try that out. We will use symmetric encryption, which just uses a password. Here is the setup for your init.el file.

#+BEGIN_SRC emacs-lisp
(require 'org-crypt)
(org-crypt-use-before-save-magic)
(setq org-tags-exclude-from-inheritance (quote ("crypt")))
;;  set to nil to use symmetric encryption.
(setq org-crypt-key nil)
#+END_SRC

#+RESULTS:

Now, for the question. What is the Answer to the Ultimate Question of Life, The Universe, and Everything? 


The solution is encrypted below. Note, all you have to do is tag the headline with crypt, and when you save the file, you will be prompted for a passphrase and to confirm the passphrase (I used the passphrase 1234). To decrypt the solution, run elisp:org-decrypt-entries. You may get a warning that autosave can cause leakage, and a request to disable it for this buffer. You can do that. Then, You will be prompted for a passphrase for symmetric encryption. Enter 1234, and you should be rewarded with the solution!

This could be a good way to keep solutions and problems together, as long as you can remember the passphrase! The passphrase would obviously have to be different for each problem (or one passphrase would open all solutions), and unguessable for this to be useful. Once again, Emacs can help you out. We just need to remember one secret passphrase, and then compute a cryptographic hash that we could use for the encrypting passphrase. We could then just concatenate our secret key onto some unchanging property of the problem that will not change, and generate a secret password. Like this for example.

#+BEGIN_SRC emacs-lisp
(let ((my-secret-key "1234"))
  (format "This problem passphrase is %s." (secure-hash 'md5 (concat my-secret-key (org-get-heading t t)))))
#+END_SRC

#+RESULTS:
: This problem passphrase is 68ea5a0eefc31d34ee5d562891e4dcb7.

For this to work, you must keep your secret key absolutely secret, or someone could generate the passwords for each assignment. Also, you must make sure the property of the problem you use never changes, or you will not be able to generate a usable passphrase again! The property could be a filename, or problem label. All that really matters is that it not change, since the solution is stored in encrypted form. It might make sense to write the problem passphrase to a file, as long as the file is not accessible to students, and it is somehow always kept up to date.

Some other notes:
1. org-mode seems to save the passphrase somewhere, so when you save the file after decrypting it, the headline is automatically reencrypted with the same password.
2. If you remove the crypt tag, the file is saved in plain text
3. This seems to rely on GnuPG being installed on your computer.

** Solution							      :crypt:
-----BEGIN PGP MESSAGE-----
Version: GnuPG v1

jA0EAwMC+AOmtRnbOY1gyZddPkzbHlSfApI4u29D3n05rwScSnx2jlmT8dPP6xES
DWGfnByJhtHC/IhbmmECPH4F88lT8RsY8Ng6RmZjGsUJDXZzLBv3CITAgwx4sXz0
hq0dv4HvlW4OUNBoM6HzflMhJO/YlYHf00H94nzZ9T++mW+foHLMSiJ3XdglWMIA
EwIz2uBmwEnsOLQ4M5W3lTBmet9iVKsT
=Zo7c
-----END PGP MESSAGE-----


* DONE Find the most recent timestamp that is not in the future
  CLOSED: [2014-08-17 Sun 09:42]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/17 09:42:44
  :updated:  2014/08/17 09:42:44
  :END:
In a previous post, we looked at a way to jump to a timestamp ([[http://kitchingroup.cheme.cmu.edu/blog/2014/08/14/Jump-to-most-recent-timestamp-in-an-org-document][post]]). A limitation of that post was that our definition of "most recent" included timestamps in the future. Here we further constrain the definition to mean the most recent that is not in the future. 

We will do that by getting the list of timestamps, then filtering out future ones.

Here is a list of time-stamps
1. [2014-08-17 Sun]
2. <2014-08-17 Sun 08:23>
3. <2014-08-17 Sun 09:23> 
4. [2014-08-18 Mon]
5. [2014-08-17 Sun 13:00]
6. [2014-08-16 Sat 13:00]

Here is the code that filters out future timestamps. As I write this it is <2014-08-17 Sun 08:31>.

#+BEGIN_SRC emacs-lisp :results raw
(let ((now (with-temp-buffer
             ;; sachac suggested this way to get a timestamp of "now"
	     (org-insert-time-stamp (org-read-date t t ".") t)
	     (buffer-string))))
  (remove-if (lambda (entry) (org-time> (car entry) now))
	     (cl-sort
	      (org-element-map (org-element-parse-buffer) 'timestamp
		(lambda (timestamp)
		  (cons (org-element-property :raw-value timestamp) (org-element-property :begin timestamp))))
	      'org-time> :key 'car)))
#+END_SRC

#+RESULTS:
((<2014-08-17 Sun 08:31> . 811) (<2014-08-17 Sun 08:23> . 613) ([2014-08-17 Sun] . 593) ([2014-08-16 Sat 13:00] . 712))


You can see that only past timestamps show up in the list, and they are sorted with the most recent timestamp. The =remove-if= function is in 'cl, which is loaded in my init files. You may have to require that if you don't load it in your init files.
* Insert a timestamp that is one week older than the last timestamp found
Someone on the maillist asked how to insert a new timestamp that is one week newer than the last timestamp found in the buffer. Here is an exploration of doing that. 
** week 1 (<2014-08-25 Mon>)

** week 2 (<2014-09-01 Mon 13:00>)

** Getting the last timestamp

Here we assume that the last element from org-element-map is the last timestamp found. We get the raw value of that timestamp, insert it, and then use interactive commands to change the timestamp.
#+BEGIN_SRC emacs-lisp 
(defun insert-ts+1w ()
  "Insert a timestamp at point that is one week later than the
last timestamp found in the buffer."
  (interactive)
  (let ((last-ts (car (last (org-element-map (org-element-parse-buffer) 'timestamp
			      (lambda (timestamp)
				(org-element-property :raw-value timestamp)))))))
    (insert last-ts)
    (backward-char 2)
    (org-timestamp-change +7 'day)
    ))
#+END_SRC


This is the result I got from running the command I wrote above. <2014-09-08 Mon 13:00>. It worked!
* DONE Jump to most recent timestamp in an org document
  CLOSED: [2014-08-14 Thu 11:45]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/14 11:45:42
  :updated:  2014/08/14 11:45:42
  :END:
Timestamps serve many purposes in an org document: deadlines, scheduled time, record of time, etc... Depending on the document, you may have organized a set of tasks logically, but you are completing them in some other order. Here, we examine how to jump to the most recent timestamp. 

Here is an example of an inactive (will not cause an agenda entry) timestamp [2014-08-07 Thu] and an active timestamp <2014-08-13 Wed>. You can also have times in the timestamps, e.g. <2014-08-14 Thu 13:00> or <2014-08-14 Thu 14:00>. There may be a timestamp that is in the future [2014-08-15 Fri].

We may have some headlines with a due date.

** Headline with duedate
   DEADLINE: <2014-08-17 Sun>

** Analyzing the timestamps in this file
We can get a sorted list of the time-stamps like this.

#+BEGIN_SRC emacs-lisp
(sort (org-element-map (org-element-parse-buffer) 'timestamp
	(lambda (timestamp)
	  (org-element-property :raw-value timestamp))) 'org-time>)
#+END_SRC

#+RESULTS:
| [2014-08-15 Fri] | <2014-08-14 Thu 14:00> | <2014-08-14 Thu 13:00> | <2014-08-13 Wed> | [2014-08-07 Thu] |

Interestingly, the deadline timestamp does not appear in this list! I am not sure why it doesn't show up.

Unfortunately, having those time stamps in this buffer will complicate further analysis, because org-mode will parse them too. What we need to do next is figure out a way to sort with the positions, so we can jump to it.

Side bar: How to sort a cons list based on the first element of each cons cell? Here are two examples.

#+BEGIN_SRC emacs-lisp :results raw
(cl-sort '((3 . "a") (2 . "b") (1 . "c")) '> :key 'car)
#+END_SRC

#+RESULTS:
((3 . a) (2 . b) (1 . c))


#+BEGIN_SRC emacs-lisp :results raw
(sort '((3 . "a") (2 . "b") (1 . "c"))
      (lambda (a b)
	(> (car a) (car b))))
#+END_SRC

#+RESULTS:
((3 . a) (2 . b) (1 . c))


So, we just build up a sorted cons-list of timestamps and their beginning characters, then pop the top entry off and jump to it. Here is the code. Running this jumps directly to the most recent (which could be in the future) timestamp.

#+BEGIN_SRC emacs-lisp :results raw
(let ((timestamps (cl-sort
		   (org-element-map (org-element-parse-buffer) 'timestamp
		     (lambda (timestamp)
		       `(,(org-element-property :raw-value timestamp) . ,(org-element-property :begin timestamp))))
		   'org-time> :key 'car)))
  (goto-char
   (cdr
    (pop timestamps))))
#+END_SRC

There are some limitations here:
1. Only free timestamps are shown, timestamps associated with deadlines and scheduling do not appear to be considered here. You would need to map over the headlines and check for deadlines to get these I think.
2. The code block above finds the timestamp with the highest time value, which may be in the future. It is an interesting exercise to think about how to find the most recent timestamp that is not in the future.
* DONE What we are using org-mode for
  CLOSED: [2014-08-08 Fri 14:00]
  :PROPERTIES:
  :categories: orgmode
  :date:     2014/08/08 13:59:59
  :updated:  2014/08/08 13:59:59
  :END:
About four years ago I picked up Emacs again, because of org-mode. It started as an experiment to see if org-mode might be a solution to managing my growing list of obligations. Since then I have learned alot about org-mode. I was feeling reflective today, so here I describe a few of the things we are doing with it now, besides just organizing my obligations! I have found org-mode useful for many other things.

** This blog
Every entry of this blog is written in org-mode and exported to an HTML file (https://github.com/jkitchin/jmax/blob/master/user/blogofile.el) that is compiled by blogofile (http://www.blogofile.com/). Thanks to some emacs-lisp code, each post has the raw org-file linked to it so you can see exactly how the page was made.

** Writing large technical documents/books
I used org-mode to write my book on modeling materials properties using density functional theory (http://kitchingroup.cheme.cmu.edu/dft-book). This book has over 100 Python code examples that are integrated with the narrative text, including equations, figures and references.

I also used org-mode to write "Python computations in Science and Engineering" (http://kitchingroup.cheme.cmu.edu/pycse), which shows that Python can be used extensively for solving scientific and engineering problems.

These "books" are not published in any traditional way; their value is in the org-format where the code is executable.

** Writing scientific publications

The following papers from our group were written in org-mode. The supporting information files all contain embedded org-files with all of the code used to generate figures and analysis, as well as the data to make the papers reproducible and reusable. These papers include both experimental and computational work.

1. Spencer D. Miller, Vladimir V. Pushkarev, Andrew J. Gellman and John R. Kitchin, Simulating Temperature Programmed Desorption of Oxygen on Pt(111) Using DFT Derived Coverage Dependent Desorption Barriers, Topics In Catalysis, 57(1), 106-117 (2013). http://link.springer.com/article/10.1007%2Fs11244-013-0166-3

2. Alex Hallenbeck and John R. Kitchin, Effects of O_2 and SO_2 on the Capture Capacity of a Primary-Amine Based Polymeric CO2 Sorbent, I&ECR, 52 (31), 10788-10794 (2013). http://dx.doi.org/10.1021/ie400582a. 

3. Mehta, Prateek; Salvador, Paul; Kitchin, John, Identifying Potential BO_2 Oxide Polymorphs for Epitaxial Growth Candidates", ACS Applied Materials and Interfaces, 6(5), 3630-3639 (2014). http://pubs.acs.org/doi/full/10.1021/am4059149.

4. Zhongnan Xu and John R Kitchin, Relating the Electronic Structure and Reactivity of the 3d Transition Metal Monoxide Surfaces, Catalysis Communications, 52, 60-64 (2014),        http://dx.doi.org/10.1016/j.catcom.2013.10.028. 

We have several more papers in progress that are being written in org-mode. We just export the LaTeX manuscript (https://github.com/jkitchin/jmax/blob/master/ox-manuscript.el) and submit it. My students now use org-mode to produce reports for their PhD qualifying exams, MS project reports, and other internal reports I ask them to write. I have used it for writing internal memos and reports for the Department. I occasionally use it to write technical emails.

** Writing software

I have used org-mode in three serious software development efforts. So far, all of them have been in emacs-lisp.

1. org-ref is an extension of org-mode that provides deeply integrated citation and referencing in org-mode documents using bibtex as the reference database. The software is written in emacs-lisp, in an org-file, and the source code is tangled out of it. See https://github.com/jkitchin/jmax/blob/master/org/org-ref.org. The code is about 1700 lines long.

2. doi-utils is a smaller package that allows you to download bibtex entries and pdfs from a DOI. See https://github.com/jkitchin/jmax/blob/master/org/doi-utils.org

3. org-show is an emacs-lisp package for using org-files to give presentations. See  https://github.com/jkitchin/jmax/blob/master/org/org-show.org. 

This literate programming approach to writing software is interesting. You can document via narrative text what the software does, and how it works, sometimes as you write the code. I have not used org-mode to write a large Python project yet. I am considering it.

** Giving presentations

For some examples of using org-show, see:
  a. Org-mode is awesome  https://www.youtube.com/watch?v=fgizHHd7nOo
  b. Using org-ref https://www.youtube.com/watch?v=JyvpSVl4_dg
  c. The org-show show https://www.youtube.com/watch?v=JZ8RK-R9O_g
  d. Scipy 2014: Python in teaching https://www.youtube.com/watch?v=IsSMs-4GlT8
  e. Scipy 2013: reproducible research talk in Beamer generated from org-mode  https://www.youtube.com/watch?v=1-dUkyn_fZA

Presenting from org-mode takes some adjustment, but it really lets you strip something down to what is important, with few distractions!

** Teaching classes

The book on dft that I wrote has been used in a graduate course several times. The last time I taught it we actually used the org-file directly in class during lecture, and I had students turn in their assignments with org-mode. That was done on a computer cluster I administer, so everyone had the emacs/org-mode setup I created.

This fall I am teaching a graduate MS course in chemical reaction engineering. It will be taught from org-mode. All the notes are in org-mode, all the assignments are in org-mode. Emacs will communicate with a git-server I run that will provide authenticated delivery of course materials and assignments. Grading is all done through org-mode, with the grades stored directly in the assignment files. The source code behind this effort is located for now at https://github.com/jkitchin/jmax/tree/master/techela. There is no course website; students will run M-x techela, select their course, and the syllabus.org file will be updated and shown, with org-links to get assignments, open lecture notes, etc... The students will do all this on their own laptop, with a preinstalled version of https://github.com/jkitchin/jmax, Enthought Canopy Python, git, ssh and TeXLive.

I am needless to say, very excited to try it!

** Managing obligations
And of course, I still use org-mode to manage my daily job responsibilities as a professor:
1. Running a research group of ~10 PhD and MS students, managing grants, paper deadlines,... I share org-files with my students through Dropbox to keep some activities coordinated.
2. Teaching classes
3. Department, college, university committee duties
4. Preparing for professional meetings
5. Conference organization
6. Keeping track of personal things
7. etc...

I just counted the lines of the files in my org-agenda: 

#+BEGIN_SRC sh
wc -l ~/Dropbox/org-mode/*.org
#+END_SRC

#+RESULTS:
#+begin_example
    346 /c/Users/jkitchin/Dropbox/org-mode/abet.org
     28 /c/Users/jkitchin/Dropbox/org-mode/advising.org
    854 /c/Users/jkitchin/Dropbox/org-mode/cheme-undergrad-committee.org
    745 /c/Users/jkitchin/Dropbox/org-mode/committees.org
  11187 /c/Users/jkitchin/Dropbox/org-mode/contacts.org
    451 /c/Users/jkitchin/Dropbox/org-mode/department.org
      2 /c/Users/jkitchin/Dropbox/org-mode/email+gnus.org
     91 /c/Users/jkitchin/Dropbox/org-mode/email.org
    611 /c/Users/jkitchin/Dropbox/org-mode/gilgamesh.org
     91 /c/Users/jkitchin/Dropbox/org-mode/gnus.org
      6 /c/Users/jkitchin/Dropbox/org-mode/group.org
    749 /c/Users/jkitchin/Dropbox/org-mode/journal.org
    274 /c/Users/jkitchin/Dropbox/org-mode/lab.org
    352 /c/Users/jkitchin/Dropbox/org-mode/manuscripts.org
    117 /c/Users/jkitchin/Dropbox/org-mode/master.org
   1239 /c/Users/jkitchin/Dropbox/org-mode/meetings.org
    513 /c/Users/jkitchin/Dropbox/org-mode/notes.org
    118 /c/Users/jkitchin/Dropbox/org-mode/org-course.org
    182 /c/Users/jkitchin/Dropbox/org-mode/personal.org
    485 /c/Users/jkitchin/Dropbox/org-mode/prj-doe-early-career.org
    109 /c/Users/jkitchin/Dropbox/org-mode/prj-exxon.org
     25 /c/Users/jkitchin/Dropbox/org-mode/prj-gcep-project.org
     15 /c/Users/jkitchin/Dropbox/org-mode/prj-simonseed.org
     83 /c/Users/jkitchin/Dropbox/org-mode/prj-task-191.org
      8 /c/Users/jkitchin/Dropbox/org-mode/prj-task-203.org
    349 /c/Users/jkitchin/Dropbox/org-mode/prj-task-97-mat.org
    238 /c/Users/jkitchin/Dropbox/org-mode/proposals.org
    378 /c/Users/jkitchin/Dropbox/org-mode/research.org
      7 /c/Users/jkitchin/Dropbox/org-mode/researcher-ids.org
    110 /c/Users/jkitchin/Dropbox/org-mode/reviews.org
    619 /c/Users/jkitchin/Dropbox/org-mode/software.org
    629 /c/Users/jkitchin/Dropbox/org-mode/tasks.org
      2 /c/Users/jkitchin/Dropbox/org-mode/taxes.org
  21013 total
#+end_example

hmm... that contacts file is big. My agenda might speed up if I move it out. It is not so slow that it bothers me though. That happens when you dump gmail contacts to org-contacts. That is even after cleaning up all the obviously bad entries!

** Summary
There is hardly an area in my work not touched by org-mode these days! 

* insert pages in org-ref

if you use C-c C-l, you can use completion to enter the bibtex key, and then type the page in the description. That is handy if you do not need to search for the entry.

#+BEGIN_SRC emacs-lisp
(defun cite-with-pages (key page)
  (interactive
   (list
    (car (reftex-citation t))
    (read-from-minibuffer "page: ")))
  (insert (format "[[cite:%s][page %s]]" key page)))
#+END_SRC

[[cite:armiento-2014-high][page 34]]


bibliography:../../bibliography/references.bib

* Insert formatted text
We can insert propertized strings, e.g. with different colors like this.
#+BEGIN_SRC emacs-lisp

(with-temp-buffer
  (rename-buffer "test")
  (insert "a "
	  (propertize "mail client"
		      'font-lock-face
		      '(:foreground "blue" :background "white" :underline t))
	  " b "
	  (propertize "smtp" 'font-lock-face '(:foreground "red"))
	  " "
	  (propertize "smtp" 'font-lock-face '(:foreground "forestgreen")))
  (goto-char (point-min))
  (display-buffer (current-buffer))
  (org-mode)
  ;; this just pauses long enough to see the results
  (completing-read "what? " '(1 2 3)))
#+END_SRC

#+RESULTS:
: 1

* Selectively writing out code blocks in org-mode

I have a set of notes for two software packages that contain code examples for each package. I want to selectively extract the code blocks. This post examines a way I could do that. I am going to "tag" each code block with a header. Apparently this is ok, and org-mode ignores the unknown header argument!

#+BEGIN_SRC python :tag package1
print "For use with package1"
#+END_SRC

#+RESULTS:
: For use with package1

#+BEGIN_SRC python :tag package2
print "For use with package2"
#+END_SRC

#+RESULTS:
: For use with package2

Apparently, the :tag header argument is stored in the :parameters property as a string.

#+BEGIN_SRC emacs-lisp :results raw
(org-element-map (org-element-parse-buffer) 'src-block 
  (lambda (element) (org-element-property :parameters element)))
#+END_SRC
#+RESULTS:
(:tag package1 :tag package2 :results raw)

So, we just need to map the source blocks, and perform some action on the ones matching the block we want. Here is one example.

#+BEGIN_SRC emacs-lisp 
(org-element-map (org-element-parse-buffer) 'src-block 
  (lambda (element)
    (let ((tag (org-element-property :parameters element)))
      (cond
       ((null tag) "no parameters")
       ((string-match ":tag\\s-*package1" tag)
	(format "match p1. code:\n%s" (org-element-property :value element)))
       ((string-match ":tag\\s-*package2" tag)
	(format "match p2. code:\n%s" (org-element-property :value element)))
       (t (format "\"%s\"" tag))))))
#+END_SRC

#+RESULTS:
| match p1. code:\nprint "For use with package1"\n | match p2. code:\nprint "For use with package2"\n | ":results raw" | no parameters |


* Do you have an ssh pubkey?

#+BEGIN_SRC emacs-lisp
(file-exists-p (expand-file-name "~/.ssh/id_rsa.pub"))
#+END_SRC

#+RESULTS:
: t

Make a key with no password in test.pub
#+BEGIN_SRC sh
ssh-keygen -f test -N ""
#+END_SRC

* Write and read json in emacs

If you know your data type, you can get a json representation like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/06-364.log"))))
  (json-encode-alist data))
#+END_SRC

#+RESULTS:
: {"org-course":"c:\/Users\/jkitchin\/Dropbox\/blogofile-jkitchin.github.com\/_blog\/06-364.log"}

You write a file like this:
#+BEGIN_SRC emacs-lisp
(require 'json)

(with-temp-file "data.json"
  (let ((data '((org-course . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")
		("06625" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com"))))
    (insert (json-encode-alist data))))
#+END_SRC

#+RESULTS:

Now to read it:

#+BEGIN_SRC emacs-lisp
(require 'json)
(cdar (json-read-file "data.json"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com

We also need to conveniently set and change data. We can use setf for this. setf is a generalized version of setq that can take a "place" to set a value to. A "place" can be defined by a cdr, or car, for example. Here is a working example.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((data '(("org-course" . (("userid" . "jkitchin")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/")))
	      ("06625" . (("userid" . "somestudent")("root" . "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com")))))
      (course))
  (setq course (cdr (assoc "org-course" data))) ;; settings for a course

  (setf (cdr (assoc "root" course)) "blog")
data)

#+END_SRC

#+RESULTS:
((org-course (userid . jkitchin) (root . blog)) (06625 (userid . somestudent) (root . c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com)))


* DONE Org-mode is awesome
  CLOSED: [2014-07-12 Sat 16:12]
  :PROPERTIES:
  :categories: org
  :date:     2014/07/12 16:12:48
  :updated:  2014/07/14 16:31:42
  :END:

I made a video on Youtube (https://www.youtube.com/watch?v=fgizHHd7nOo) demonstrating how we use Emacs and org-mode. The source for that file can be found [[file:why-org-mode.org][here]].

There are some other good org-mode videos out there. Here are few:

- [[https://www.youtube.com/watch?v%3DoJTwQvgfgMM][Emacs Org-mode - a system for note-taking and project planning]] (Carsten Dominik)
- [[https://www.youtube.com/watch?v%3D6W82EdwQhxU][Hack Emacs - An Overview of Org Mode]]
- [[https://www.youtube.com/watch?v%3DnsGYet02bEk][Hack Emacs - Org Mode In Depth: Managing Structure]]
- [[http:www.youtube.com/watch?v%3D1-dUkyn_fZA][Emacs + org-mode + python in reproducible research; SciPy 2013 Presentation]] 
- [[http:www.youtube.com/watch?v%3DJyvpSVl4_dg][Using org-ref]]
- [[http://vimeo.com/99167082][Emacs Org-mode Bibtex Screencast]]

* automatic inlining a plot in org-mode with python

It has always bothered me that I have to manually put links to figures in after my code blocks, or I have to custom print org syntax. here is a way to get org to do it.
#+BEGIN_SRC python :file test.png
import matplotlib.pyplot as plt
plt.plot([1,2,3,4])
plt.savefig('silly-plot.png')

import os
os.system('cat silly-plot.png')
#+END_SRC

#+RESULTS:
[[file:test.png]]

It is not better.


* org-rubric functions

prototype idea to create a rubric function

#+BEGIN_SRC emacs-lisp
(defun ta-rubric-hwk (technical-grade presentation-grade typography-grade)
  (interactive "nTechnical Grade: \nnPresentation Grade: \nnTypography Grade: ")
  (let
      ((t-weight 0.7) ; weight of technical grade
       (p-weight 0.2) ; weight of presentation grade
       (y-weight 0.1) ; weight of typography grade
       (grade))
    (setq grade (+
		 (* t-weight technical-grade)
		 (* p-weight presentation-grade)
		 (* y-weight typography-grade)))
    (end-of-buffer)
    (insert "\n"
	    (format "#+TECHNICAL_GRADE: %s\n" technical-grade)
	    (format "#+PRESENTATION_GRADE: %s\n" presentation-grade)
	    (format "#+TYPOGRAPHY_GRADE: %s\n" typography-grade)
	    (format "#+GRADE: %s" grade))))		
#+END_SRC

#+RESULTS:
: ta-rubric-hwk

Maybe I can add a rubric keyword to assignments so that the right rubric function is called.
* Use org-agenda to select multiple items

This is a hacky way to use the org-contacts agenda to get multiple email addresses from a selection. We remap the return key function to call our function that maps over the selected list and gets the emails from it, and finally undoes the remapping before quitting the agenda. It feels a little hacky because you have to communicate through global variable, and the agenda call is not blocking, so the code carries on. I am not sure how to fix that.

#+BEGIN_SRC emacs-lisp
(defun get-marked ()
 (interactive)
 (setq *marked-entries*  
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries)
       *done* t)
 ;; remap key
 (define-key org-agenda-mode-map [remap org-agenda-switch-to] nil)
 (org-agenda-quit))

(defun doit ()
  (interactive)
  (setq *marked-entries* nil
        *done* nil) ; make sure this is empty
  ;;remap so return exits and runs our function above
  (define-key org-agenda-mode-map [remap org-agenda-switch-to] 'get-marked)
  (org-contacts "kit")
  
  *marked-entries*)
#+END_SRC

This works ok. You can define a function that acts upon the marked entries.
#+BEGIN_SRC emacs-lisp
(defun email-marked ()
 (setq *marked-entries*  
       (mapcar (lambda (m)
		 (set-buffer (marker-buffer m))
		 (goto-char (marker-position m))
		 (org-entry-get (point) "EMAIL"))
	       org-agenda-bulk-marked-entries))
  (compose-mail)
  (message-goto-to)
  (insert (mapconcat 'identity *marked-entries* ",")))

  (org-contacts "kit")
#+END_SRC

* Completion in emacs commands using ido

These are some examples of using ido to provide completion in interactive commands. You just need a list of options, which can be calculated if desired, and the ido-completing-read function. You use these in the interactive function. 

** string completion

#+BEGIN_SRC emacs-lisp
(defun email-1 (address)
  (interactive
   (list
    (ido-completing-read
     "Email: "     ; prompt
     '("em1" "em2" "em3") ; choices
     nil ; predicate; ignored, here for compatibility with completing-read
     t ; require match
     )))
  (message "you picked %s" address))
#+END_SRC

#+RESULTS:
: email-1

It is pretty easy to get two arguments.
#+BEGIN_SRC emacs-lisp
(defun email-2 (address label)
  (interactive (list (ido-completing-read "Email: " '("em1" "em2" "em3"))
		     (ido-completing-read "label: " '("important" "easy"))))
  (message "you picked %s with a label of %s" address label))
#+END_SRC

#+RESULTS:
: email-2

** select directories

#+BEGIN_SRC emacs-lisp
(require 'cl)

(defun pick-dir (dir)
  (interactive
   (list
    (ido-completing-read
     "Dir: "
     (remove-if-not
      'file-directory-p
      ;; list directories, except for . and ..
      (directory-files default-directory nil "[^.{1,2}]")))))
 (message "you picked this dir: %s" dir))

#+END_SRC

#+RESULTS:
: pick-dir




* put properties on strings

(put-text-property


#+BEGIN_SRC emacs-lisp
   (let ((s "Alex"))
      (put-text-property 0 (length s) 'font-lock-face '(:foreground "blue" :background "white" :underline t) s)
      (message-box s))
#+END_SRC

#+RESULTS:
: Alex

   (let ((s "Alex"))
      (put-text-property 0 (length s) 'face 'diary s)
      (insert s))Alex

finish
#+BEGIN_SRC emacs-lisp
(defun func (a b)
 (interactive (list '("a" "b") '(1 2)))
 (message "%s %s" a b))
	      
#+END_SRC
* TODO get sha1 of a file

use this to make reproducible temp images for org-show.

(secure-hash 'sha1 (with-temp-buffer (insert-file-contents "tst.png") (buffer-string)))


* Running commands in emacs and showing what they do

I sometimes need to script shell commands into emacs functions. Recently, I needed to see the output, to see what was going wrong. This code sort of does that. 

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "git status")
(eshell-send-input)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC emacs-lisp
(eshell)
(end-of-buffer)
(insert "ls")
(eshell-send-input)
(insert "echo $?")
(eshell-send-input)
#+END_SRC

#+RESULTS:

* Running git commands that are interactive

** commands that freeze emacs because of ssh
Vanilla git calls vanilla ssh, which appears to hang anytime you get prompted for /anything/. The following all seems to hang, and you have to kill the ssh process to get control back.
#+BEGIN_SRC emacs-lisp
(shell-command "git clone bad@techela.cheme.cmu.edu:none")
#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(shell-command "git --no-pager clone bad@techela.cheme.cmu.edu:none")
#+END_SRC

#+RESULTS:
: 128

#+BEGIN_SRC emacs-lisp

(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none")

#+END_SRC
#+RESULTS:
: 128


#+BEGIN_SRC emacs-lisp
(with-timeout (1)
(call-process "git" nil "*git*" nil "--no-pager" "clone" "bad@techela.cheme.cmu.edu:none"))

#+END_SRC


Let's try that in Python. This also freezes
#+BEGIN_SRC python
import subprocess
print subprocess.call(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], shell=True)
#+END_SRC

#+RESULTS:
: 128

** Solution, is ssh batch mode
The key is modifying the ssh command so that it runs in batch mode. You have to create a custom shell script that runs ssh in batch mode, then set GIT_SSH as an environment variable to use it.

Here is the working script.
#+BEGIN_SRC sh :tangle techela_ssh
#!/bin/sh
exec ssh -o "BatchMode yes" "$@"
#end
#+END_SRC

This will not hang.
#+BEGIN_SRC sh
./techela_ssh bad@techela.cheme.cmu.edu
#+END_SRC

#+RESULTS:

Running in sh
#+BEGIN_SRC sh
rm -fr none # rm old dir
GIT_SSH='c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh' git clone bad@techela.cheme.cmu.edu:none
#+END_SRC

#+RESULTS:


Running in Python
#+BEGIN_SRC python
import subprocess, os
my_env = os.environ.copy()
my_env['GIT_SSH'] = 'c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh'
p = subprocess.Popen(["git" ,"--no-pager", "clone", "bad@techela.cheme.cmu.edu:none"], env=my_env)
print p.communicate()
#+END_SRC

#+RESULTS:
: (None, None)


And finally, running in emacs-lisp
#+BEGIN_SRC emacs-lisp
(let ((process-environment (cons "GIT_SSH=c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/techela_ssh" process-environment)))
  (shell-command-to-string "git clone bad@techela.cheme.cmu.edu:none"))
#+END_SRC

#+RESULTS:
: Cloning into 'none'...
: Permission denied (publickey,gssapi-keyex,gssapi-with-mic,password).
: fatal: Could not read from remote repository.
: 
: Please make sure you have the correct access rights
: and the repository exists.

Finally, it appears I have a solution for this.



* Saving state to a file in Emacs

I want to be able to save state data to a file from emacs, and read it in later. The application is saving a list of strings that changes, and I want to have the list of strings later.

#+BEGIN_SRC emacs-lisp
(setq assignments '("one"))
(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| one |

Now, to read it back,
#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
 (read (current-buffer)))
#+END_SRC

#+RESULTS:
| one |

#+BEGIN_SRC emacs-lisp
(add-to-list 'assignments "two")

(with-temp-file "state.el"
  (print assignments (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

#+BEGIN_SRC emacs-lisp
(with-current-buffer (find-file "state.el")
  (read (current-buffer)))
#+END_SRC

#+RESULTS:
| two | one |

** Saving an alist

#+BEGIN_SRC emacs-lisp
(with-temp-file "state-alist.el"
  (prin1 '(("title" . "the title")
           ("author" . "John Kitchin")
           ("email" . "jkitchin@cmu.edu")) (current-buffer)))
#+END_SRC

#+RESULTS:
| (title . the title) | (author . John Kitchin) | (email . jkitchin@cmu.edu) |

#+BEGIN_SRC emacs-lisp
(cdr (assoc "email"
	 (with-temp-buffer (insert-file-contents "state-alist.el")
	   (read (current-buffer)))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu

** A plist

#+BEGIN_SRC emacs-lisp
(with-temp-file "state-plist.el"
  (prin1 '(:title   "the title"
		 :author  "John Kitchin"
		 :email   "jkitchin@cmu.edu") (current-buffer)))
#+END_SRC

#+RESULTS:
| :title | the title | :author | John Kitchin | :email | jkitchin@cmu.edu |

#+BEGIN_SRC emacs-lisp
(plist-get (with-temp-buffer
	       (insert-file-contents "state-plist.el")
	     (read (current-buffer))) :author)
#+END_SRC

#+RESULTS:
: John Kitchin

** Saving a hash table
#+BEGIN_SRC emacs-lisp
(setq my-hash (make-hash-table :test 'equal))

(puthash "title" "the title" my-hash)
(puthash "author" "John Kitchin" my-hash)
(puthash "email" "jkitchin@cmu.edu" my-hash)

(with-temp-file "state-hash.el"
  (prin1 my-hash (current-buffer)))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test equal rehash-size 1.5 rehash-threshold 0.8 data ("title" "the title" "author" "John Kitchin" "email" "jkitchin@cmu.edu"))

#+BEGIN_SRC emacs-lisp
(gethash "email"
	 (with-temp-buffer (insert-file-contents "state-hash.el")
	   (read (current-buffer))))
#+END_SRC

#+RESULTS:
: jkitchin@cmu.edu



* Running the whole course through emacs and org-mode

I can write a command that retrieves a repo and opens it. and submits it to the server.

M-x oc-get label
This will check for label, and clone it if needed

#+BEGIN_SRC emacs-lisp
(defun oc-get (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
    (format "git clone gitolite@git-it.cheme.cmu.edu:%s" repo))))

(oc-get "hwk1")
#+END_SRC

#+RESULTS:
: git clone gitolite@git-it.cheme.cmu.edu:06-625-jkitchin-hwk1

We need to be able to update a repo. This will be tricky I think, because if students have made changes, this will not work without merges. It may be possible to commit their changes first, and then just deal with merges, but I think that will be confusing.

#+BEGIN_SRC emacs-lisp
(defun oc-update (label)
 (interactive)
 (let* ((oc-andrewid "jkitchin")
	(oc-course "06-625")
	(repo (format "%s-%s-%s" oc-course oc-andrewid label)))
 (unless (file-exists-p repo)
   ;; this is the command we need to run
   (oc-get label)) ;; first get it.

 (let (default-directory repo)
   (format "git pull"))))

#+END_SRC

M-x oc-turn-in 

add everything in the directory,  commit it, and push the repo. It looks something like this:

#+BEGIN_SRC emacs-lisp
(defun oc-turn-in ()
  "Run this with the assignment open or in assignment directory"
  (interactive)
  ;; should check that we are in a git repo.

  (shell-command "git add *")
  (shell-command "git commit -am \"done\"")
  (shell-command "git push"))
#+END_SRC

What happens if students delete files? 

see http://stackoverflow.com/questions/3258243/git-check-if-pull-needed for some ways to test if pull is needed.

* Getting system information and storing it in an org-mode Drawer



#+BEGIN_SRC emacs-lisp
(system-name)
#+END_SRC

#+RESULTS:
: KITCHINX61TABLE

#+BEGIN_SRC emacs-lisp
(princ system-configuration)
#+END_SRC

#+RESULTS:
: i386-mingw-nt6.1.7601


#+BEGIN_SRC emacs-lisp
(princ system-type)
#+END_SRC

#+RESULTS:
: windows-nt


#+BEGIN_SRC emacs-lisp
(shell-command-to-string ifconfig-program)
#+END_SRC

#+RESULTS:
#+begin_example

Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . : 
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : 

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . : 
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : 
#+end_example

System info function
#+BEGIN_SRC emacs-lisp
(defun insert-system-info-drawer ()
 (interactive)
 (end-of-buffer)
 (insert "\n\n")
 (org-insert-drawer nil "LOGBOOK")
 (insert (format "Name: %s\n" user-full-name))
 (insert (format "Email: %s\n" user-mail-address))
 (insert "System name: " (system-name))
 (insert (format "\n%s" system-type))
 (insert (shell-command-to-string ifconfig-program)))
#+END_SRC

#+RESULTS:
: insert-system-info-drawer
: 

cite:armiento-2014-high

:LOGBOOK:
John Kitchin
jkitchin@andrew.cmu.edu
System name: KITCHINX61TABLEwindows-nt
Windows IP Configuration


Ethernet adapter Local Area Connection:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : cmu.edu

Wireless LAN adapter Wireless Network Connection:

   Connection-specific DNS Suffix  . : 
   Link-local IPv6 Address . . . . . : fe80::39b7:a08c:c0bb:61b5%11
   IPv4 Address. . . . . . . . . . . : 192.168.1.39
   Subnet Mask . . . . . . . . . . . : 255.255.255.0
   Default Gateway . . . . . . . . . : 192.168.1.1

Tunnel adapter isatap.cmu.edu:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : 

Tunnel adapter Teredo Tunneling Pseudo-Interface:

   Connection-specific DNS Suffix  . : 
   IPv6 Address. . . . . . . . . . . : 2001:0:9d38:6ab8:14d4:395d:3f57:fed8
   Link-local IPv6 Address . . . . . : fe80::14d4:395d:3f57:fed8%15
   Default Gateway . . . . . . . . . : ::

Tunnel adapter isatap.{E84DC336-F738-46DD-A1E9-4C744E0840F7}:

   Media State . . . . . . . . . . . : Media disconnected
   Connection-specific DNS Suffix  . : 

:END:

* DONE Another parsing of links for citations with pre and post text. 
  CLOSED: [2014-06-26 Thu 20:16]
  :PROPERTIES:
  :categories: emacs,org-mode,org-ref
  :date:     2014/06/26 20:16:43
  :updated:  2014/06/26 20:16:43
  :END:

Some LaTeX citations look like \cite[pretext][post text]{key}. Here I explore parsing a link like [[cite:(pre text)(post text)key]]. Note you cannot use [] inside the link, as it breaks the link syntax. Also, these links must be wrapped in =[[]]= because of the parentheses and spaces in the parentheses. This is a very different approach than used [[http://kitchingroup.cheme.cmu.edu/blog/2014/05/19/Exporting-citations-with-biblatex/][here]] which used the description of the link to define the pre and post text. The disadvantage of that approach is that the key is hidden, whereas in this approach it is not; you can see the key and pre/post text.

The basic strategy will be to use a regexp to parse the link path. The regexp below is pretty hairy, but basically it looks for optional text in () and uses numbered groups to store what is found. Then, we use what we found to construct the LaTeX syntax. We redefine the function in org-ref that gets the key for clicking, and we redefine the cite format function. The result is that we retain the click functionality that shows us what the key refers to.

#+BEGIN_SRC emacs-lisp
(defun org-ref-parse-key (s)
  "return pretext, posttext and bibtex key from a string like \"(pre text)(post text)bibtexkey\""
  (string-match "\\(?1:(\\(?2:[^)]*\\))\\)?\\(?3:(\\(?4:[^]]*\\))\\)?\\(?5:.*\\)" s)
  ;; return pretext postext key
  (list (match-string 2 s) (match-string 4 s) (match-string 5 s)))

(defun org-ref-get-bibtex-key-and-file (&optional key)
  "returns the bibtex key and file that it is in. If no key is provided, get one under point"
 (interactive)
 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       (file))
   (unless key
     ;; get the key
     (setq key (nth 2 (org-ref-parse-key (org-ref-get-bibtex-key-under-cursor)))))
   (setq file     (catch 'result
		    (loop for file in org-ref-bibliography-files do
			  (if (org-ref-key-in-file-p key (file-truename file)) 
			      (throw 'result file)))))
   (cons key file)))

(defun org-ref-format-cite (keyword desc format)
   (cond
    ((eq format 'latex)
     (let* ((results (org-ref-parse-key keyword))
	    (pretext (nth 0 results))
	    (posttext (nth 1 results))
	    (key (nth 2 results)))
       (concat "\\cite" 
	       (when pretext (format "[%s]" pretext))
	       (when posttext (format "[%s]" posttext))
	       (format "{%s}" key))))))
#+END_SRC

#+RESULTS:
: org-ref-format-cite

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "(pre text)(post text)key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text][post text]{key}

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "(pre text)key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text]{key}

#+BEGIN_SRC emacs-lisp
(org-ref-format-cite "key" nil 'latex)
#+END_SRC

#+RESULTS:
: \cite{key}

It looks like they all work! Let us test the links: cite:mehta-2014-ident-poten, [[cite:(pre text)mehta-2014-ident-poten]] and [[cite:(pre text)(post text)biskup-2014-insul-ferrom-films]]. a multiple citation cite:mehta-2014-ident-poten,thompson-2014-co2-react,calle-vallejo-2013-number.

This seems to work from an export point of view. You can not mix multiple citations with this syntax, and I did not define the html export above. Otherwise, it looks like this might be a reasonable addition to org-ref.

* Making a bunch of words invisible

(org-map-entries (lambda () 
                   (let ((level (org-entry-get (point) "level"))
                          (symbol-level))
                     (when level
                       (setq symbol-level (intern level))
                       (org-mark-subtree)                 
                       (overlay-put (make-overlay (point) (mark))
                                    'invisible 
                                    symbol-level)
                       ;; make regions with symbol-level invisible
                       (add-to-invisibility-spec `(,symbol-level))))))
#+BEGIN_SRC emacs-lisp
(while (re-search-forward ":slide:" nil t)
(overlay-put (make-overlay (match-beginning 0) (match-end 0))
                                    'invisible 
                                    'slide))

(add-to-invisibility-spec 'slide)
#+END_SRC
 :slide: in the text


Later when you want them back,

#+BEGIN_SRC emacs-lisp :results silent
(remove-from-invisibility-spec 'slide)
#+END_SRC

We also may want to have slide numbers, and an ability to jump to a slide.

Let us start by getting a list of slides. Our list will be cons cells with a slide number and marker. That will give us the 

#+BEGIN_SRC emacs-lisp
(let ((slides '()) (n 0))
  (org-map-entries
   (lambda ()
     (when (string-match-p ":slide:" (or (nth 5 (org-heading-components)) ""))
       (setq n (+ n 1))
       (add-to-list 'slides (cons n (set-marker (make-marker) (point))) t))))
(goto-char (cdr (assoc 2 slides)))
slides)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1580 in blog.org>) | (2 . #<marker at 1603 in blog.org>) |

** subheading :slide:

** next one :slide:


* Inherited properties
example of getting an inherited property, in this case an email address
** student 1
   :PROPERTIES:
   :END:
*** lesson 1
    :PROPERTIES:
    :SENT-ON:  Sun Jun  8 20:43:16 2014
    :TO:       John Kitchin <jkitchin@andrew.cmu.edu>
    :END:
we just turn on inheritance in the property get function.
#+BEGIN_SRC emacs-lisp
(org-entry-get (point) "TO" t)
#+END_SRC

#+RESULTS:
| (1 . #<marker at 1693 in blog.org>) | (2 . #<marker at 1716 in blog.org>) |

check out https://github.com/jwiegley/emacs-async/blob/master/async.el
for asynchronous things.

* Setting up gnus for email
I have used gmail for a long time. There is a lot I like about it. Email for me is information that comes to me that I need to read, handle in some way, and then move on to the next thing. I do not store things in email, and I do not file or tag emails; I rely on gmail's search ability to find email if I ever need to (which I find is very rare). I aim for a zero-inbox with email, because that means there is nothing there I need to handle.

My typical workflow is to open my inbox, and read the new mails. If I can delete them immediately, I do that. If I can respond immediately, I do that and archive the email. If I need some time to reply, I store a link to the email in my todo list with a deadline (in org-mode, of course), and archive the email. If it will only be a day or so until I can reply, I sometimes leave it in my inbox and reply later. This works pretty well, and I usually have less than one screen of emails at any given time.

I have wanted to read email in emacs for a long time, because it would streamline the storing of links to emails, and I would not have to switch between firefox and emacs to do that. It would also make writing emails simpler for me. I already use gnus to read some newsgroups, so I want to also start reading email in it. gnus has some different ideas about mail, so I am trying to learn how to make it do what I want. By default, gnus only shows unread messages. I need it to show me all the messages in the inbox.

I also want some communication between gnus and gmail. If I delete a mail in gnus, I want it deleted in gmail. If I archive it in gnus, I want it archived in gmail. And, I want the send+archive behavior I like in gmail to work in gnus.

| open email               | RET     |
| reply                    |         |
| reply-all                |         |
| forward                  |         |
| send                     | C-c C-c |
| send and archive         |         |
| delete mail              |         |
| archive mail             |         |
| mark unread              | M-u     |
| capture mail in org-mode | C-c c e |


** Sending email

[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-send-and-exit%20(&optional%20arg)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-send-and-exit (&optional arg)]]

It looks like you can define these actions
message-exit-actions [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defvar%20message-exit-actions%20nil][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defvar message-exit-actions nil]]

(defvar message-exit-actions nil
  "A list of actions to be performed upon exiting after sending a message.")

This looks like a list of functions that are called with no argument after the message is sent. see [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-do-actions%20(actions)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-do-actions (actions)]]

see [[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/simple.el::(defun%20compose-mail%20(&optional%20to%20subject%20other-headers%20continue][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/simple.el::(defun compose-mail (&optional to subject other-headers continue]] to see how to specify actions from compose-mail.

maybe it is possible to temporarily define a function to run. see http://www.gnu.org/software/emacs/manual/html_node/message/Message-Actions.html

[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-add-action%20(action%20&rest%20types)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-add-action (action &rest types)]]
[[file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun%20message-delete-action%20(action%20&rest%20types)][file:~/Dropbox/kitchingroup/jmax/emacs-24.3/lisp/gnus/message.el::(defun message-delete-action (action &rest types)]]
we need a temporary action! something like: http://www.chemie.fu-berlin.de/chemnet/use/info/elisp/elisp_13.html

  (apply 'message-add-action 'gt (list 'exit))
#+BEGIN_SRC emacs-lisp
(defmacro with-temp-message-action (action types &rest body)
  "temporarily have action for a message. 
action is the same as the message-add-action definition
types is a list of 'exit 'postpone 'kill
body is the code to use in the temporary definition.
"
  (apply 'message-add-action action types)
  ,@body
  (apply 'message-delete action types))

(with-temp-message-action 'gt '(list 'exit)
			  (message "we workd"))
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun gt () (message "whoo"))
(add-to-list 'message-exit-actions 'gt)

(compose-mail "jkitchin@cmu.edu" "test")
#+END_SRC

#+RESULTS:
: t

we also have message-sent-hookand message-send-hook

let us try a variation with that:

#+BEGIN_SRC emacs-lisp
(defun org-contacts-gnus-article-to-get-marker ()
  "Return a marker for a contact based on From."
  (let* ((address (mail-extract-address-components
         (or (mail-fetch-field "To") "")))
         (name (car address))
         (email (cadr address)))
    (when email
    (cadar (or (org-contacts-filter
                nil
		nil
                (cons org-contacts-email-property (concat "\\b" (regexp-quote email) "\\b")))
               (when name
                 (org-contacts-filter
                  (concat "^" name "$"))))))))


(defun org-contacts-gnus-store-last-sent-mail ()
  "Store a link between mails and contacts.

This function should be called from `message-send-hook'."
(interactive)
  (let ((marker (org-contacts-gnus-article-to-get-marker)))
    (when marker
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)          
	  (org-set-property "LAST_SENT_MAIL" (current-time-string)))))))

(add-hook 'message-send-hook 'org-contacts-gnus-store-last-sent-mail)
#+END_SRC

#+RESULTS:
| org-contacts-gnus-store-last-sent-mail |

* extracting an org-contact from a gnus message
** getting it in the From field

try to get name from mail
#+BEGIN_SRC emacs-lisp
(defun gne ()
  (interactive)
  (if (org-contacts-gnus-article-from-get-marker)
      (message "you have that contact")
    (message "%s" (org-contacts-gnus-get-name-email))))
#+END_SRC

#+RESULTS:
: gne

try sticking entry in. you run this from a gnus article. should this happen automatically? we should 
#+BEGIN_SRC emacs-lisp
(defun hare ()
  (interactive)
(let ((org-contacts-files '("test-contacts.org")))
  
  (let* ((r (org-contacts-gnus-get-name-email))
	 (name (nth 0 r))
	 (email (nth 1 r)))
    (find-file "test-contacts.org")
    (end-of-buffer)
    (insert (format "\n* %s" name))
    (org-entry-put (point) "EMAIL" email)
    (org-entry-put (point) "CREATED" (current-time-string))
    (save-buffer))))
#+END_SRC

#+RESULTS:
: hare

#+BEGIN_SRC emacs-lisp

#+END_SRC

* getting emails in org-contacts by tags
#+BEGIN_SRC emacs-lisp
(find-file "contacts-bbdb.org")
(let ((todo-only nil))
  (org-scan-tags
   (lambda ()
     (org-entry-get (point) "EMAIL")) ; action
  (cdr (org-make-tags-matcher "group-ms")) ; matcher
nil))
#+END_SRC

#+RESULTS:
| jboes@cmu.edu | mehakc@andrew.cmu.edu | mcurnan@andrew.cmu.edu | qingqif@andrew.cmu.edu | ahallenb@andrew.cmu.edu | jdmichae@andrew.cmu.edu | zhongnanxu@cmu.edu |


#+BEGIN_SRC emacs-lisp :results raw
(find-file "contacts-bbdb.org")
(let ((todo-only nil))
   (cdr (org-make-tags-matcher "group-phd")))
#+END_SRC

#+RESULTS:
(and (progn (setq org-cached-props nil) (and (not (member phd tags-list)) (member group tags-list))) t)


#+BEGIN_SRC emacs-lisp
(defun insert-emails-from-tags (tags)
  (interactive "sTags: ")
  (insert
   (save-window-excursion
     (find-file "contacts-bbdb.org")
     (mapconcat
      'identity
      (let ((todo-only nil))
	(org-scan-tags
	 (lambda ()
	   (org-entry-get (point) "EMAIL")) ; action
	 (cdr (org-make-tags-matcher tags)) ; matcher
	 nil)) ", "))))
#+END_SRC

#+RESULTS:
: add-emails-from-tags

ngovinda@andrew.cmu.edu,meihengl@andrew.cmu.edu,wenqiny@andrew.cmu.edu

#+BEGIN_SRC emacs-lisp
(insert-emails-from-tags "{^co.*}") ;no return
#+END_SRC

#+RESULTS:
#+BEGIN_SRC emacs-lisp
(insert-emails-from-tags "FIRSTNAME=\"John\"") ; no matches
#+END_SRC

#+RESULTS:


* Calculating months since a date

To calculate the number of months between two dates, we parse the dates to get the year for each date, and the month for each date. Then we calculate the number of months as:

\[12 * (year2 - year1) + (month2 - month1)\]

To get the year,

#+BEGIN_SRC emacs-lisp
(nth 5 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC 

#+RESULTS:
: 2014

Now the month:
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-05-31 Sat>")))
#+END_SRC

#+RESULTS:
: 5

Note this subtlety
#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat>")))
#+END_SRC

#+RESULTS:
: 2

It appears that since no time is specified, this gets parsed as the 28th of Feb? Maybe that is a limitation of the date format in Emacs?
#+BEGIN_SRC emacs-lisp
(decode-time (date-to-time "<2014-03-01 Sat>"))
#+END_SRC

#+RESULTS:
| 0 | 0 | 19 | 28 | 2 | 2014 | 5 | nil | -18000 |

We get the right value if we specify the time.

#+BEGIN_SRC emacs-lisp
(nth 4 (decode-time (date-to-time "<2014-03-01 Sat 00:01>")))
#+END_SRC

#+RESULTS:
: 3

And now for the number of months between two times

#+BEGIN_SRC emacs-lisp 
(let* ((d1  (decode-time (date-to-time "2014-03-01 00:01")))
       (d2 (decode-time (date-to-time "2014-05-31  00:01")))
       (y1 (nth 5 d1))
       (y2 (nth 5 d2))
       (m1 (nth 4 d1))
       (m2 (nth 4 d2)))
  (+ (* 12 (- y2 y1)) (- m2  m1)))
#+END_SRC

#+RESULTS:
: 2


* Converting bbdb to org-contacts

#+BEGIN_SRC emacs-lisp :results output
(let ((b (find-file "../../kitchingroup/jmax/user/bbdb"))
      (count 0) (entry)(fname)(lname)(email))
  (find-file "contacts-bbdb.org")
  (erase-buffer)
  (insert "* setup")
  (while (and (< count 5) (setq entry (read b))) 
    (setq fname (elt entry 0)
	  lname (elt entry 1)
	  email (car (elt entry 7)))
    (org-insert-heading-after-current)
    (insert (format "%s, %s\n" lname fname))
    (org-entry-put (point) "FIRSTNAME" fname)
    (org-entry-put (point) "LASTNAME" lname)
    (org-entry-put (point) "EMAIL" email))
  (save-buffer))
#+END_SRC

#+RESULTS:
#+begin_example
[Sarah Abdullah nil nil nil nil nil (sarah@cmu.edu) ((creation-date . 2014-03-17 01:00:18 +0000) (timestamp . 2014-03-17 01:00:18 +0000)) nil] 
Sarah 
Abdullah 
sarah@cmu.edu 
[Abdulwahab A. Abdulwahab nil nil nil nil nil (aabdulwa@andrew.cmu.edu) ((creation-date . 2014-03-17 00:54:29 +0000) (timestamp . 2014-03-17 00:54:29 +0000)) nil] 
Abdulwahab A. 
Abdulwahab 
aabdulwa@andrew.cmu.edu 
[Tanima Abedin nil nil nil nil nil (t.j.abedin@gmail.com) ((creation-date . 2014-03-17 01:00:19 +0000) (timestamp . 2014-03-17 01:00:19 +0000)) nil] 
Tanima 
Abedin 
t.j.abedin@gmail.com 
[Frank Abild-Pedersen nil nil nil nil nil (abild@slac.stanford.edu) ((creation-date . 2014-03-17 01:00:13 +0000) (timestamp . 2014-03-17 01:00:13 +0000)) nil] 
Frank 
Abild-Pedersen 
abild@slac.stanford.edu 
[Natalie Day Abrams nil nil nil nil nil (nda@andrew.cmu.edu) ((creation-date . 2014-03-17 01:00:16 +0000) (timestamp . 2014-03-17 01:00:16 +0000)) nil] 
Natalie Day 
Abrams 
nda@andrew.cmu.edu 
#+end_example


* a simple logging library for emacs
python has a great logging module. I would like this kind of capability.

(log-info "something %s" variable)
(log-debug "something %s" variable)

you set a log level somewhere.

#+BEGIN_SRC emacs-lisp
(setq *log-level* 0
      *log-info* 10)

(defun log-info (message &rest args)
  "print message formatted with args"
  (when (> *log-level* *log-info*) ; *log-level* greater than this level print
    (message "log-info: %s" (apply #'format message args))))

(log-info "test %s %s" 5 "done")
#+END_SRC

#+RESULTS:

this is not that sophisticated, it might be nice to have introspection, line numbers, functions, etc...

* DONE Using org-files like el-files
  CLOSED: [2014-06-24 Tue 21:32]
  :PROPERTIES:
  :categories: emacs,org-mode
  :date:     2014/06/24 21:32:58
  :updated:  2014/06/24 21:34:15
  :END:
I wrote some emacs-lisp code in org-mode, and load them with org-babel-load-file. I thought it would be nice if there was load path for org-files, similar to the one for lisp files. Here I document what it might look like.

We need a load path to search for the org-file.
#+BEGIN_SRC emacs-lisp
(setq org-load-path '("~/Dropbox/kitchingroup/jmax/"))
#+END_SRC

#+RESULTS:
| ~/Dropbox/kitchingroup/jmax/ |

Next, we need the function to do the loading. We need to find the org-file, and then load it.



#+BEGIN_SRC emacs-lisp 
(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (org-babel-load-file path)))


(org-require 'org-ref) 
#+END_SRC

#+RESULTS:
: Loaded ~/Dropbox/kitchingroup/jmax/org-ref.el

That looks pretty simple. You do need write access to the location where the org-file is though. Let us look at a version that copies the file to a temporary directory. For some reason, I am not able to use org-babel-load-file with this. But, it does look like I can tangle the file, and assuming (big assumption) that the file tangles to a regularly named .el file, this seems to work too.

#+BEGIN_SRC emacs-lisp 
(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
        (el-file (concat (symbol-name orgfile) ".el"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (copy-file path temporary-file-directory t)

  (org-babel-tangle-file (concat temporary-file-directory (file-name-nondirectory path)))
  (load-file (concat temporary-file-directory el-file))
))

(org-require 'org-ref) 
#+END_SRC

#+RESULTS:
: t

This actually seems pretty reasonable. I have not thought about complications but for simple cases, e.g. single org-file, it looks ok.


* DONE Better integration of org-mode and email
  CLOSED: [2014-06-08 Sun 20:57]
  :PROPERTIES:
  :categories: email,org-mode
  :date:     2014/06/08 20:57:53
  :updated:  2014/06/08 20:57:53
  :END:
I like to email org-mode headings and content to people. It would be nice to have some records of when a heading was sent, and to whom. We store this information in a heading. It is pretty easy to write a simple function that emails a selected region.

#+BEGIN_SRC emacs-lisp
(defun email-region (start end)
  "Send region as the body of an email."
  (interactive "r")
  (let ((content (buffer-substring start end)))
    (compose-mail)
    (message-goto-body)
    (insert content)
    (message-goto-to)))
#+END_SRC

that function is not glamorous, and you still have to fill in the email fields, and unless you use gnus and org-contacts, the only record keeping is through the email provider. 

What I would like is to send a whole heading in an email. The headline should be the subject, and if there are TO, CC or BCC properties, those should be used. If there is /no TO/, then I want to grab the TO from the email after you enter it and store it as a property. You should be able to set OTHER-HEADERS as a property (this is just for fun. There is no practical reason for this yet). After you send the email, it should record in the heading when it was sent.

It turned out that is a relatively tall order. While it is easy to setup the email if you have everything in place, it is tricky to get the information on TO and the time sent /after/ the email is sent. Past lispers had a lot of ideas to make this possible, and a day of digging got me to the answer. You can specify some "action" functions that get called at various times, e.g. after sending, and a return action when the compose window is done. Unfortunately, I could not figure out any way to do things except to communicate through some global variables.

So here is the code that lets me send org-headings, with the TO, CC, BCC properties, and that records when I sent the email after it is sent.

#+BEGIN_SRC emacs-lisp
(defvar *email-heading-point* nil
  "global variable to store point in for returning")

(defvar *email-to-addresses* nil
  "global variable to store to address in email")

(defun email-heading-return ()
  "after returning from compose do this"
  (switch-to-buffer (marker-buffer  *email-heading-point*))
  (goto-char (marker-position  *email-heading-point*))
  (setq *email-heading-point* nil)
  (org-set-property "SENT-ON" (current-time-string))
  ;; reset this incase you added new ones
  (org-set-property "TO" *email-to-addresses*)
  )

(defun email-send-action ()
  "send action for compose-mail"
  (setq *email-to-addresses* (mail-fetch-field "To")))

(defun email-heading ()
  "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
OTHER-HEADERS is an alist specifying additional
header fields.  Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

save when it was sent as s SENT property. this is overwritten on
subsequent sends. could save them all in a logbook?
"
  (interactive)
  ; store location.
  (setq *email-heading-point* (set-marker (make-marker) (point)))
  (org-mark-subtree)
  (let ((content (buffer-substring (point) (mark)))
	(TO (org-entry-get (point) "TO" t))
	(CC (org-entry-get (point) "CC" t))
	(BCC (org-entry-get (point) "BCC" t))
	(SUBJECT (nth 4 (org-heading-components)))
	(OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
	(continue nil)
	(switch-function nil)
	(yank-action nil)
	(send-actions '((email-send-action . nil)))
	(return-action '(email-heading-return)))
    
    (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
    (message-goto-body)
    (insert content)
    (when CC
      (message-goto-cc)
      (insert CC))
    (when BCC
      (message-goto-bcc)
      (insert BCC))
    (if TO
	(message-goto-body)
      (message-goto-to))       
    ))
#+END_SRC

This works pretty well for me. Since I normally use this to send tasks to people, it keeps the task organized where I want it, and I can embed an org-id in the email so if the person replies to it telling me the task is done, I can easily navigate to the task to mark it off. Pretty handy.

* DONE Finding emails from tags from org-contacts database
  CLOSED: [2014-06-05 Thu 14:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/06/05 14:42:21
  :updated:  2014/06/05 14:42:21
  :END:

Org-mode has a contacts manager called org-contacts. If you set it up, you can use it to insert email addresses using a tag in message-mode. Out of the box though, it only works on one tag. You cannot do something like +group-phd to get entries tagged group but not tagged phd. Here we develop a function to do that for us. 

We could use the org-files and map the headings to do this, but org-contacts has already done this and has a database we can use instead. We get the database from org-contacts-filter. Here is the first entry.

#+BEGIN_SRC emacs-lisp :results raw
(car (org-contacts-filter))
#+END_SRC

#+RESULTS:
(Chris Jones #<marker at 1 in contacts.org> ((FILE . c:/Users/jkitchin/Dropbox/org-mode/contacts.org) (TAGS . :co2:) (ALLTAGS . :co2:) (BLOCKED . ) (COMPANY . Georgia Tech, Chemical Engineering) (EMAIL . Christopher.Jones@chbe.gatech.edu) (CATEGORY . contacts)))

It looks like we have (name marker (cons cells)) for each entry. We can get the tags associated with that entry like this.

We can get the tags for an entry with this code:
#+BEGIN_SRC emacs-lisp
(let ((entry (car (org-contacts-filter))))
  (cdr (assoc "TAGS" (nth 2 entry))))
#+END_SRC

#+RESULTS:
: :co2:

We will use some code for org tags. Notably, from a tags expression, we can automatically generate code that tells us if we have a match. Here we generate the code to test for a match on "+co2-group".

#+BEGIN_SRC emacs-lisp :results raw
(let ((todo-only nil))
  (cdr (org-make-tags-matcher "+co2-group")))
#+END_SRC

#+RESULTS:
(and (progn (setq org-cached-props nil) (and (not (member group tags-list)) (member co2 tags-list))) t)

Note we will have to bind tags-list before we eval this.

So to use it, we need to split the tags from an org-contacts entry into a list of strings. It appears each entry just has the tag string, so we split the substring (skipping first and last characters) by ":" to get the list. We do that here, and test if a list of tags containing "co2" is matched by the expression "co2-junior".

#+BEGIN_SRC emacs-lisp
(let* ((tags-list (split-string (substring ":co2:" 1 -1) ":"))
       (todo-only nil))
  (eval (cdr (org-make-tags-matcher "co2-junior"))))
#+END_SRC

#+RESULTS:
: t

It is. So, now we just need to loop through the database, and collect entries that match.

#+BEGIN_SRC emacs-lisp
(defun insert-emails-from-tags (tag-expression)
  "insert emails from org-contacts that match the tags expression. For example:
group-phd will match entries tagged with group but not with phd."
  (interactive "sTags: ")
  (insert
   (mapconcat 'identity
	      (loop for contact in (org-contacts-filter)
		    for contact-name = (car contact)
		    for email = (org-contacts-strip-link (car (org-contacts-split-property
							       (or
								(cdr (assoc-string org-contacts-email-property
										   (caddr contact)))
								""))))
		    for tags = (cdr (assoc "TAGS" (nth 2 contact)))
		    for tags-list = (if tags
					(split-string (substring (cdr (assoc "TAGS" (nth 2 contact))) 1 -1) ":")
				      '())
		    if (let ((todo-only nil))
			 (eval (cdr (org-make-tags-matcher tag-expression))))
		    
		    collect (org-contacts-format-email contact-name email))
	      ",")))
#+END_SRC

This is not quite completion in message-mode, but it is good enough. You put your cursor in the To field, and run that command, enter the tag expression, and you will get your emails!

* DONE Automatic downloading of a pdf from a journal site
  CLOSED: [2014-05-23 Fri 11:44]
  :PROPERTIES:
  :categories: bibtex,emacs
  :date:     2014/05/23 11:44:11
  :updated:  2014/05/23 11:44:11
  :END:
Many bibliography software packages can automatically download a pdf for you. In this post, we explore how that can be done from emacs. The principle idea is that the pdf is obtained from a url, and that you can calculate the url by some method. Then you can download the file. 

For example, consider this article in Phys. Rev. Lett. http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105. There is a link to get the pdf for this article at http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105. It is not difficult to construct that url; you just replace =/abstract/= with =/pdf/=.

The trick is how to get the first url. We have previously seen that we can construct a bibtex entry from a doi. In fact, we can use the doi to get the url above. If you visit http://dx.doi.org/10.1103/PhysRevLett.99.016105, you will be redirected to the url. It so happens that you can use code to get the redirected url. In emacs-lisp it is a little convoluted; you have to use url-retrieve, and provide a callback that sets the redirect. Here is an example. It appears you need to run this block twice to get the right variable setting. That seems like some kind of error in what I have set up, but I cannot figure out why.

#+BEGIN_SRC emacs-lisp :results output
(defvar *doi-utils-redirect*)

(defun callback (&optional status)
 (when status ;  is nil if there none
   (setq *doi-utils-redirect* (plist-get status :redirect))))

(url-retrieve 
  "http://dx.doi.org/10.1103/PhysRevLett.99.016105"
  'callback)

(print *doi-utils-redirect*)   
#+END_SRC

#+RESULTS:
: 
: "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105"

From there, creating the pdf url is as simple as

#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "prl/abstract" "prl/pdf" "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105")
#+END_SRC

#+RESULTS:
: http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105

And finally we download the file with

#+BEGIN_SRC emacs-lisp
(url-copy-file "http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105" "PhysRevLett.99.016105.pdf" nil)
#+END_SRC

#+RESULTS:
: t

So that is the gist of automating pdf downloads. You do these steps:
1. Get the DOI
2. Get the url that the DOI redirects to
3. Calculate the link to the pdf
4. Download the pdf

Each publisher does something a little bit different, so you have to work this out for each one. I have worked alot of them out at https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el. That file is a work in progress, but it is a project I intend to use on a regular basis.


* DONE Converting a doi to a bibtex entry
  CLOSED: [2014-05-22 Thu 16:22]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/05/22 16:22:31
  :updated:  2014/05/22 16:22:31
  :END:
Many citation management packages allow you to download a bibliography entry from a doi. I want to be able to do that in emacs. I found this [[http://homepages.see.leeds.ac.uk/~eeaol/notes/2013/02/doi-metadata/][page]] that shows it is possible to get metadata about a doi with an http request, and from that data, we can create a bibtex entry. So, here is the basic code for getting metadata about a doi. We specify that we want json code, and then use [[http://edward.oconnor.cx/2006/03/json.el][json.el]] to view the results.

We temporarily set a few url-* variables with affect the url-retrieve results. And we rely on url-http-end-of-headers which tells us the end of the headers that get returned, so we can use the remaining text as the data.

#+BEGIN_SRC emacs-lisp :results raw
(require 'json)

(let ((url-request-method "GET") 
      (url-mime-accept-string "application/citeproc+json")
      (json-object-type 'plist)
      (results))
  (setq results 
	(with-current-buffer (url-retrieve-synchronously "http://dx.doi.org/10.1016/S0022-0248(97)00279-0")
	  (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))))
#+END_SRC

#+RESULTS:
(:volume 181 :indexed (:timestamp 1389218884442 :date-parts [[2014 1 8]]) :publisher Elsevier BV :source CrossRef :URL http://dx.doi.org/10.1016/S0022-0248(97)00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts [[2013 12 3]]) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix http://id.crossref.org/prefix/10.1016 :score 1.0 :issued (:date-parts [[1997 11]]) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])

That data is now sufficient for us to consider constructing a bibtex entry. For an article, a prototypical entry looks like:

#+BEGIN_EXAMPLE
@Article{,
  author = 	 {},
  title = 	 {},
  journal = 	 {},
  year = 	 {},
  OPTkey = 	 {},
  OPTvolume = 	 {},
  OPTnumber = 	 {},
  OPTpages = 	 {},
  OPTmonth = 	 {},
  OPTnote = 	 {},
  OPTannote = 	 {}
}
#+END_EXAMPLE

Let us create a function that takes a doi and constructs a bibtex entry. I do not use all the metadata, so I just store the json data in the annote field. Maybe I should use another field for that, but annote seems ok since I do not use if for anything. I am going to use a template expansion function I developed earlier to make the bibtex entry template easier to write and read. Here is the code.

#+BEGIN_SRC emacs-lisp 
(require 'json)

(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
                            (lambda (arg)
                              (let ((sexp (substring arg 2 -1)))
                                (format "%s" (eval (read sexp))))) s))

(defun doi-to-bibtex-article (doi)
 "insert a bibtex entry for doi at point"
 (interactive "sDOI: ")
 (let ((url-request-method "GET") 
       (url-mime-accept-string "application/citeproc+json")
       (json-object-type 'plist)
       type
       results
       author
       title
       journal
       year
       volume
       number
       pages
       month
       url json-data)
   
   (setq results 
	 (with-current-buffer
	     (url-retrieve-synchronously
	      (concat "http://dx.doi.org/" doi))
	 (json-read-from-string (buffer-substring url-http-end-of-headers (point-max))))
         type (plist-get results :type)
	 author (mapconcat (lambda (x) (concat (plist-get x :given) " " (plist-get x :family)))
		     (plist-get results :author) " and ")
	 title (plist-get results :title)
	 journal (plist-get results :container-title)
	 volume (plist-get results :volume)
	 issue (plist-get results :issue)
	 year (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 0)
	 month (elt (elt (plist-get (plist-get results :issued) :date-parts) 0) 1)
	 pages (plist-get results :page)
	 doi (plist-get results :DOI)
	 url (plist-get results :URL)
	 json-data (format "%s" results))

   (when (string= type "journal-article")

     (expand-template "@article{,
  author = 	 {%{author}},
  title = 	 {%{title}},
  journal = 	 {%{journal}},
  year = 	 {%{year}},
  volume = 	 {%{volume}},
  number = 	 {%{issue}},
  pages = 	 {%{pages}},
  doi =          {%{doi}},
  url =          {%{url}},
  month = 	 {%{month}},
  json = 	 {%{json-data}}
}"))))
   
(doi-to-bibtex-article "10.1016/s0022-0248(97)00279-0")
#+END_SRC

#+RESULTS:
#+begin_example
@article{,
  author = 	 {Jaan Aarik and Aleks Aidla and Väino Sammelselg and Teet Uustare},
  title = 	 {Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process},
  journal = 	 {Journal of Crystal Growth},
  year = 	 {1997},
  volume = 	 {181},
  number = 	 {3},
  pages = 	 {259-264},
  doi =          {10.1016/s0022-0248(97)00279-0},
  url =          {http://dx.doi.org/10.1016/s0022-0248(97)00279-0},
  month = 	 {11},
  json = 	 {(:volume 181 :indexed (:timestamp 1389218884442 :date-parts [[2014 1 8]]) :publisher Elsevier BV :source CrossRef :URL http://dx.doi.org/10.1016/s0022-0248(97)00279-0 :ISSN [0022-0248] :DOI 10.1016/s0022-0248(97)00279-0 :type journal-article :title Effect of growth conditions on formation of TiO2-II thin films in atomic layer deposition process :issue 3 :deposited (:timestamp 1386028800000 :date-parts [[2013 12 3]]) :page 259-264 :reference-count nil :container-title Journal of Crystal Growth :author [(:given Jaan :family Aarik) (:given Aleks :family Aidla) (:given Väino :family Sammelselg) (:given Teet :family Uustare)] :prefix http://id.crossref.org/prefix/10.1016 :score 1.0 :issued (:date-parts [[1997 11]]) :subject [Condensed Matter Physics Inorganic Chemistry Materials Chemistry] :subtitle [])}
}
#+end_example

That looks excellent. Note there are some non-ascii characters in it, which would have to be fixed. Let us try it on an ASAP article.

#+BEGIN_SRC emacs-lisp
(doi-to-bibtex-article "10.1021/ie403744u")
#+END_SRC

#+RESULTS:
#+begin_example
@article{,
  author = 	 {José A. Delgado and V. I. Águeda and M. A. Uguina and J. L. Sotelo and P. Brea and Carlos A. Grande},
  title = 	 { Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation },
  journal = 	 {Industrial & Engineering Chemistry Research},
  year = 	 {2014},
  volume = 	 {nil},
  number = 	 {nil},
  pages = 	 {140117091024005},
  doi =          {10.1021/ie403744u},
  url =          {http://dx.doi.org/10.1021/ie403744u},
  month = 	 {1},
  json = 	 {(:indexed (:timestamp 1392935578089 :date-parts [[2014 2 20]]) :publisher American Chemical Society (ACS) :source CrossRef :URL http://dx.doi.org/10.1021/ie403744u :ISSN [0888-5885 1520-5045] :DOI 10.1021/ie403744u :type journal-article :title  Adsorption and Diffusion of H 2 , CO, CH 4 , and CO 2 in BPL Activated Carbon and 13X Zeolite: Evaluation of Performance in Pressure Swing Adsorption Hydrogen Purification by Simulation  :deposited (:timestamp 1389916800000 :date-parts [[2014 1 17]]) :page 140117091024005 :reference-count nil :container-title Industrial & Engineering Chemistry Research :author [(:given José A. :family Delgado) (:given V. I. :family Águeda) (:given M. A. :family Uguina) (:given J. L. :family Sotelo) (:given P. :family Brea) (:given Carlos A. :family Grande)] :prefix http://id.crossref.org/prefix/10.1021 :score 1.0 :issued (:date-parts [[2014 1 17]]) :subject [Chemistry(all) Industrial and Manufacturing Engineering Chemical Engineering(all)] :subtitle [])}
}
#+end_example

You see that nil is put in for missing entries. That is probably ok. There is an & in the journal that needs to be cleaned up, but that is easily done with org-ref-clean-bibtex-entry. In summary, this looks like a very convenient way to get bibtex entries inside emacs. I should probably have the function insert that string to a buffer at point, but that is not difficult to do.

* Updating a bibtex entry using its doi
  :PROPERTIES:
  :categories: bibtex
  :END:
The next step is to use this to update an entry. Presumably ASAP articles will have their metadata updated in the future. It would be great to be able to run a command on an entry and update it. To do that, we need a convenient function to set a bibtex field. There is a function to get a field, but not to set a field. This next block is the closest thing I have come up with that sets a field

#+BEGIN_SRC emacs-lisp
(defun bibtex-set-field (field value)
  "set field to value in bibtex file. create field if it does not exist"
  (interactive "sfield: \nsvalue: ")
  (bibtex-beginning-of-entry)
  (let ((found))
    (if (setq found (bibtex-search-forward-field field t))
	;; we found a field
	(progn
	  (goto-char (car (cdr found)))
	  (when value
	    (bibtex-kill-field)
	    (bibtex-make-field field)
	    (backward-char)
	    (insert value)))
      ;; make a new field
      (message "new field being made")
      (bibtex-beginning-of-entry)
      (forward-line) (beginning-of-line)
      (bibtex-next-field nil)
      (forward-char)
      (bibtex-make-field field)
      (backward-char)
      (insert value))))
#+END_SRC

#+RESULTS:
: bibtex-set-field

Now, we want a function to update a bibtex entry. The function will get the doi from the entry, then retrieve the json data, and then update each field. We need to get the keys in the json results, and then map each key to a field in a bibtex entry. Here we go.

#+BEGIN_SRC emacs-lisp
(require 'json)

;; adapted from https://github.com/mon-key/mon-systems-cl/blob/master/plist.lisp
(defun plist-get-keys (plist)
   "return keys in a plist"
  (loop
   for key in results by #'cddr collect key))

(defun update-bibtex-entry-from-doi (doi)
  "update fields in a bibtex entry from the doi."
  (interactive (list (or (bibtex-autokey-get-field "doi") (read-string "DOI: "))))
  (let* ((url-request-method "GET") 
	(url-mime-accept-string "application/citeproc+json")
	(json-object-type 'plist)
	(results (with-current-buffer
		    (url-retrieve-synchronously
		     (concat "http://dx.doi.org/" doi))
		  (json-read-from-string
		   (buffer-substring url-http-end-of-headers (point-max)))))
	(type (plist-get results :type))
	(author (mapconcat
		(lambda (x) (concat (plist-get x :given)
				    " " (plist-get x :family)))
		(plist-get results :author) " and "))
	(title (plist-get results :title))
	(journal (plist-get results :container-title))
	(year (format "%s"
		       (elt
			(elt
			 (plist-get
			  (plist-get results :issued) :date-parts) 0) 0)))
	
	(volume (plist-get results :volume))
	(number (or (plist-get results :issue) ""))
	(pages (or (plist-get results :page) ""))
	(month (format "%s"
			(elt
			 (elt
			  (plist-get
			   (plist-get results :issued) :date-parts) 0) 1)))
	(url (or (plist-get results :URL) ""))
	(doi (plist-get results :DOI))
	(annote (format "%s" results)))
    
    ;; map the json fields to bibtex fields
    (setq mapping '((:author . (bibtex-set-field "author" author))
		    (:title . (bibtex-set-field "title" title))
		    (:container-title . (bibtex-set-field "journal" journal))
		    (:issued . (progn
				 (bibtex-set-field "year" year)
				 (bibtex-set-field "month" month)))
		    (:volume . (bibtex-set-field "volume" volume))
		    (:issue . (bibtex-set-field "issue" issue))
		    (:page . (bibtex-set-field "pages" pages))
		    (:DOI . (bibtex-set-field "doi" doi))
		    (:URL . (bibtex-set-field "url" url))))

    ;; now we have code to run for each entry. we map over them and evaluate the code
    (mapcar
     (lambda (key)
       (eval (cdr (assoc key mapping))))
     (plist-get-keys results)))
  
  ; reclean entry, but keep existing key. check if it exists
  (if (bibtex-key-in-head)
      (org-ref-clean-bibtex-entry t)
    (org-ref-clean-bibtex-entry)))
#+END_SRC

#+RESULTS:
: update-bibtex-entry-from-doi

* DONE Sorting citation links by year
  CLOSED: [2014-05-21 Wed 09:57]
  :PROPERTIES:
  :categories: bibtex
  :date:     2014/05/21 09:57:48
  :updated:  2014/05/21 09:57:48
  :END:

When there are several citations grouped together, I like them sorted by year. For example, I do not like this cite:liu-2014-spect-studies,mcalpin-2010-epr-eviden,kanan-2009-cobal,lutterman-2009-self-healin,kanan-2008-in-situ. I prefer cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies. It is just a preference, but it seems appropriate to cite things in chronological order. 

It is actually a little tedious to sort this by hand though. Hence, today we examine some tools to automate the sorting. The idea is to make a function that will get the keys, sort them by year, and then replace the link with the sorted text.

Let us try some sorting. We will construct a set of cons cells with a year and key, sort that list by year, and then concatenate the keys. Here is an example of the sorting. The years will come as strings from the bibtex file.

#+BEGIN_SRC emacs-lisp
(setq data '(("2014" . "key1") ("2012" . "key2")("2016" . "key3")))
(setq data 
	(cl-sort data (lambda (x y) (< (string-to-int (car x)) (string-to-int (car y))))))
(mapconcat (lambda (x) (cdr x)) data ",")
#+END_SRC

#+RESULTS:
: key2,key1,key3

That is easy enough. Now, a function to get the year, and then the function to sort a link. 

#+BEGIN_SRC emacs-lisp
(defun org-ref-get-citation-year (key)
  "get the year of an entry with key"
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file key))
	 (bibfile (cdr results))
	 (cb (current-buffer)))
    (message "---------%s %s" key bibfile)
    (set-buffer (find-file-noselect bibfile))
    (bibtex-search-entry key nil 0)
    (prog1 (reftex-get-bib-field "year" (bibtex-parse-entry t))
      (set-buffer cb))))

(defun org-ref-sort-citation-link ()
 "replace link at point with sorted link by year"
 (interactive)
 (let* ((object (org-element-context))	 
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
	keys years data)
  (setq keys (org-ref-split-and-strip-string link-string))
  (setq years (mapcar 'org-ref-get-citation-year keys)) 
  (setq data (mapcar* (lambda (a b) `(,a . ,b)) years keys))
  (setq data (cl-sort data (lambda (x y) (< (string-to-int (car x)) (string-to-int (car y))))))
  ;; now get the keys separated by commas
  (setq keys (mapconcat (lambda (x) (cdr x)) data ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
))

#+END_SRC

Now, you put your cursor on a link, run M-x org-ref-sort-citation-link, and the magic happens  cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies! It would also be nice to have some arrow commands so you could do something like manually reorder them with S-right arrow or something like in the calendar, but that will be another day. It looks like there are hooks for org-shiftright-hook and org-shiftleft-hook that might be able to make this happen.

* DONE org-shift hooks for ordering citations
  CLOSED: [2014-05-21 Wed 11:11]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/05/21 11:11:56
  :updated:  2014/05/21 11:37:40
  :END:
I wrote a function that sorts citations by year, but there might be a reason to order them some other way. Here we develop a method to use shift-arrow keys to do the ordering. We will need to write a function that gets the citations in a link, gets the key under point, and then swap with neighboring keys depending on the arrow pressed. It is trivial to get the key under point (org-ref-get-bibtex-key-under-cursor), and we saw before it is easy to get the keys in a link. Let us examine swapping elements of a list here. This is an old algorithm, we store the first value, replace it with the second value, and then set the second value.

#+BEGIN_SRC emacs-lisp
(defun org-ref-swap-keys (i j keys)
 "swap the keys in a list with index i and j"
 (let ((tempi (nth i keys)))
   (setf (nth i keys) (nth j keys))
   (setf (nth j keys) tempi))
  keys)

(org-ref-swap-keys 2 3 '(1 2 3 4))
#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 3 |

So, we need to get the keys in the link at point, the key at point, the index of the key at point, and then we can swap them, and reconstruct the link. Here is the function that does this, and that adds the hooks.

#+BEGIN_SRC emacs-lisp
(defun org-ref-swap-citation-link (direction)
 "move citation at point in direction +1 is to the right, -1 to the left"
 (interactive)
 (let* ((object (org-element-context))	 
        (type (org-element-property :type object))
	(begin (org-element-property :begin object))
	(end (org-element-property :end object))
	(link-string (org-element-property :path object))
        (key (org-ref-get-bibtex-key-under-cursor))
	(keys (org-ref-split-and-strip-string link-string))
        (i (index key keys)) point) ;; defined in org-ref
   (if (> direction 0) ;; shift right
     (org-ref-swap-keys i (+ i 1) keys)
     (org-ref-swap-keys i (- i 1) keys))	
  (setq keys (mapconcat 'identity keys ","))
  ;; and replace the link with the sorted keys
  (cl--set-buffer-substring begin end (concat type ":" keys))
  ;; now go forward to key so we can move with the key
  (re-search-forward key) 
  (goto-char (match-beginning 0))))

(add-hook 'org-shiftright-hook (lambda () (org-ref-swap-citation-link 1)))
(add-hook 'org-shiftleft-hook (lambda () (org-ref-swap-citation-link -1)))
#+END_SRC

#+RESULTS:
| lambda | nil | (org-ref-swap-citation-link -1) |

cite:kanan-2008-in-situ,kanan-2009-cobal,lutterman-2009-self-healin,mcalpin-2010-epr-eviden,liu-2014-spect-studies! 

That is it! Wow, not hard at all. Check out this video of the code in action: http://screencast.com/t/YmgA0fnZ1Ogl
 

* Formatting citation links

#+BEGIN_SRC emacs-lisp
(setq s "pre text::post text")
(cond
  ((string-match "::" s)
   (format "[%s][%s]" (car (setq results (split-string s "::"))) (cadr results)))
  (t (format "[%s]" s)))

#+END_SRC

#+RESULTS:
: [pre text][:post text]

#+BEGIN_SRC emacs-lisp
(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite" (when desc (format "[%s]" desc)) "{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))

(org-ref-cite-link-format "cite" "pre text::post text" 'latex)
#+END_SRC

#+RESULTS:
: \cite[pre text::post text]{cite}

* DONE Autogenerating functions in emacs-lisp
  CLOSED: [2014-05-12 Mon 18:05]
  :PROPERTIES:
  :categories: emacs, emacs-lisp
  :date:     2014/05/12 18:05:45
  :updated:  2014/05/12 18:05:54
  :END:

I have a need to generate a lot of similar functions, and I do not want to cut and paste the code. I want to generate the functions with code. This seems to be what macros are for in emacs lisp. 

As a prototype example, we will make functions that raise a number to a power. We want functions like power-3 and power-4 that raise numbers to the third and fourth powers. We will define functions like this for the numbers 0-9.

Here we define the macro. i do not want to get into the nitty gritty details of macro definitions here.

#+BEGIN_SRC emacs-lisp
(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(make-power-n 4)

(power-4 4)
#+END_SRC

#+RESULTS:
: 256

Now we use the macro and mapcar on it onto a list of numbers. We have to eval the macro in the mapcar lambda function.

#+BEGIN_SRC emacs-lisp
(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(mapcar (lambda (x) (eval `(make-power-n ,x))) '(0 1 2 3 4 5 6 7 8 9))
 
;; example of a few functions
(list (power-0 3) (power-1 3) (power-2 3))
#+END_SRC

#+RESULTS:
| 1 | 3 | 9 |


It works! We created 10 functions in a little bit of code. 



* Functional definition of functions
In org-ref, I have a need to define a lot of link types that are all variations of the same kind, but with different names. I do not want to make a unique function for each link, because that involves a lot of cut and paste code.

I want to use something like mapcar on a list to define these links.

#+BEGIN_SRC emacs-lisp
(setq links '("test1" "test2"))

(defun define-link (link)
  (interactive)
  (eval-expression `(org-add-link-type ,link
 (lambda (x) (message "you clicked on %s" x))
 ;; formatting
 (lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<",link">%s</",link">)" path))
    ((eq format 'latex)
     (concat "\\" ,link "{" keyword "}")))))))

(mapcar 'define-link links)
#+END_SRC

#+RESULTS:
| (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                             | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))         | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                            | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword))))) | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword)))))                                                                                                                                                                                         | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))                                                                                                                                                                                                                                                                                                                                                                                                                          | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures))))) | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | (mhe org-mhe-open nil)     | (irc org-irc-visit nil) | (info org-info-open nil) | (gnus org-gnus-open nil) | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)                  | (bbdb org-bbdb-open org-bbdb-export) | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword)))))  | (file+emacs org-open-file-with-emacs nil)                                                                                                                                                               | (file+sys org-open-file-with-system nil)  |                                          |
| (test2 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test2 >%s</ test2 >) path)) ((eq format (quote latex)) (concat \ test2 { keyword }))))) | (test1 (lambda (x) (message you clicked on %s x)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (< test1 >%s</ test1 >) path)) ((eq format (quote latex)) (concat \ test1 { keyword }))))) | (citetext nil (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citetext{ path })))))                                                                                                              | (nocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \nocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (citeyear org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeyear{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))       | (citeauthor* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citeauthor org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citeauthor{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citep org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citep{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))   | (citet* org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet*{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (citet org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<cite>%s</cite>) path)) ((eq format (quote latex)) (concat \citet{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))           | (citealp org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<citealp>%s</citealp>) path)) ((eq format (quote latex)) (concat \citealp{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) })))))     | (autocite org-ref-cite-onclick-minibuffer-menu (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<autocite>%s</autocite>) path)) ((eq format (quote latex)) (concat \autocite{ (mapconcat (function (lambda (key) key)) (org-ref-split-and-strip-string keyword) ,) }))))) | (cite org-ref-cite-onclick-minibuffer-menu org-ref-cite-link-format)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | (eqref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (goto-char (point-min)) (if (or (re-search-forward (format label:%s label) nil t) (re-search-forward (format \label{%s} label) nil t) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<eqref>%s</eqref>) path)) ((eq format (quote latex)) (format \eqref{%s} keyword)))))                                                                                                                                                                     | (ref (lambda (label) on clicking goto the label. Navigate back with C-c & (org-mark-ring-push) (if (or (progn (goto-char (point-min)) (re-search-forward (format label:%s\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format \label{%s} label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+label:\s-*\(%s\)\b label) nil t)) (progn (goto-char (point-min)) (re-search-forward (format ^#\+tblname:\s-*\(%s\)\b label) nil t))) nil (org-mark-ring-goto) (error %s not found label)) (message go back with (org-mark-ring-goto) `C-c &`)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<ref>%s</ref>) path)) ((eq format (quote latex)) (format \ref{%s} keyword))))) | (label (lambda (label) on clicking count the number of label tags used in the buffer. A number greater than one means multiple labels! (message (format %s occurences (+ (count-matches (format label:%s\b label) (point-min) (point-max) t) (count-matches (format \label{%s}\b label) (point-min) (point-max) t) (count-matches (format #\+label:%s\b label) (point-min) (point-max) t))))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format (<label>%s</label>) path)) ((eq format (quote latex)) (format \label{%s} keyword))))) | (list-of-tables org-ref-list-of-tables (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoftables)))))    | (list-of-figures org-ref-list-of-figures (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \listoffigures)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | (addbibresource (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-addbibresource)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for addbibresource bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \addbibresource{%s} (replace-regexp-in-string \.bib  keyword)))))) | (bibliographystyle (lambda (arg) (message Nothing implemented for clicking here.)) (lambda (keyword desc format) (cond ((eq format (quote latex)) (format \bibliographystyle{%s} keyword)))))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | (bibliography (lambda (link-string) (let* ((bibfile) (object (org-element-context)) (link-string-beginning) (link-string-end)) (save-excursion (goto-char (org-element-property :begin object)) (search-forward link-string nil nil 1) (setq link-string-beginning (match-beginning 0)) (setq link-string-end (match-end 0))) (set (make-local-variable (quote reftex-default-bibliography)) (split-string (org-element-property :path object) ,)) (save-excursion (if (search-forward , link-string-end 1 1) (setq key-end (- (match-end 0) 1)) (setq key-end (point)))) (save-excursion (if (search-backward , link-string-beginning 1 1) (setq key-beginning (+ (match-beginning 0) 1)) (setq key-beginning (point)))) (setq bibfile (org-ref-strip-string (buffer-substring key-beginning key-end))) (message found %s for bibliography bibfile) (find-file bibfile))) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \bibliography{%s} (replace-regexp-in-string \.bib  keyword)))))) | (rmail org-rmail-open nil) | (mhe org-mhe-open nil)  | (irc org-irc-visit nil)  | (info org-info-open nil) | (gnus org-gnus-open nil)                      | (docview org-docview-open org-docview-export) | (bibtex org-bibtex-open nil)         | (bbdb org-bbdb-open org-bbdb-export)                                                                                                                                                                     | (index (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format %s \index{%s} keyword keyword))))) | (attachfile (lambda (link-string) (org-open-file link-string)) (lambda (keyword desc format) (cond ((eq format (quote html)) (format )) ((eq format (quote latex)) (format \attachfile{%s} keyword))))) | (file+emacs org-open-file-with-emacs nil) | (file+sys org-open-file-with-system nil) |



test1:wat 

test2:yes   



#+LATEX_CLASS: article
#+OPTIONS: author:nil toc:nil
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{subfigure}

* Side by side figures in org-mode

adapted from http://www.johndcook.com/blog/2009/01/14/how-to-display-side-by-side-figurs-in-latex/


Now you can reference Figure \ref{fig12}, or Figure ref:fig:a or Figure ref:fig:b.

#+caption: Left graph \label{fig:a}
[[./images/cos-plot.png]]





\begin{figure}
  \subfigure[Left graph \label{fig:a}]
    {\includegraphics[width=3in]{images/cos-plot.png}}
\enskip % horizontal spacking. tex.stackexchange.com/questions/41476/lengths-and-when-to-use-them
  \subfigure[Right graph. \label{fig:b}]
    {\includegraphics[width=3in]{images/eos-uncertainty.png}}
\caption{Text pertaining to both graphs,\ref{fig:a}and \ref{fig:b}. \label{fig12}} 
\end{figure}

* Sorting the fields of a bibtex entry with emacs-lisp

We need two lists. The list that defines the order I want, and the rest of them.

#+BEGIN_SRC emacs-lisp :results value 
(find-file "sort.bib")
(goto-char (point-min))

(defun org-ref-sort-bibtex-entry ()
  "sort fields of entry in standard order and downcase them"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((master '("author" "title" "journal" "volume" "issue" "pages" "year" "doi" "url"))
	 (entry (bibtex-parse-entry))
	 (entry-fields)
	 (other-fields)
	 (type (cdr (assoc "=type=" entry)))
	 (key (cdr (assoc "=key=" entry))))

    ;; these are the fields we want to order that are in this entry
    (setq entry-fields (mapcar (lambda (x) (car x)) entry))
    ;; we do not want to reenter these fields
    (setq entry-fields (remove "=key=" entry-fields))
    (setq entry-fields (remove "=type=" entry-fields))

    ;;these are the other fields in the entry
    (setq other-fields (remove-if-not (lambda(x) (not (member x master))) entry-fields))

    (cond
     ;; right now we only resort articles
     ((string= type "article")
      (bibtex-kill-entry)
      (insert
       (concat "@article{" key ",\n" 
	       (mapconcat  
		(lambda (field) 
		  (when (member field entry-fields)
		    (format "%s = %s," (downcase field) (cdr (assoc field entry))))) master "\n")
	       (mapconcat 
		(lambda (field) 
		  (format "%s = %s," (downcase field) (cdr (assoc field entry)))) other-fields "\n")
	       "\n}"))
      (bibtex-clean-entry)
       ))))

(org-ref-sort-bibtex-entry)
#+END_SRC

#+RESULTS:
#+begin_example
@article{conesa-2010-relev-disper,
author = {Conesa, Jose\'{e} C.},
title = {The Relevance of Dispersion Interactions for the
                  Stability of Oxide Phases},
journal = {The Journal of Physical Chemistry C},
volume = 114,

pages = {22718-22726},
year = 2010,

pdf = {[[file:bibtex-pdfs/conesa-2010-relev-disper.pdf]]},
org-notes = {[[file:~/Dropbox/bibliography/notes.org::conesa-2010-relev-disper]]},
number = 51,
doi = {10.1021/jp109105g},
url = {http://pubs.acs.org/doi/abs/10.1021/jp109105g},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/jp109105g},
}
#+end_example




* Cleaning a bibtex entry

#+BEGIN_SRC emacs-lisp
(defun org-ref-clean-bibtex-entry()
  "clean and replace the key in a bibtex function"
  (interactive)
  (bibtex-beginning-of-entry)

  ;; check for empty pages, and put eid or article id in its place
  (let ((entry (bibtex-parse-entry))
	(pages (bibtex-autokey-get-field "pages"))
	(eid (bibtex-autokey-get-field "eid")))

    ;; fix pages if they are empty
    (cond
     ((string= "-" pages)
      (when eid	  
	(bibtex-beginning-of-entry)
	;; this seems like a clunky way to set the pages field.But I
	;; cannot find a better way.
	(goto-char (car (cdr (bibtex-search-forward-field "pages" t))))
	(bibtex-kill-field)
	(bibtex-make-field "pages")
	(backward-char)
	(insert eid))))

    ;; generate a key, and if it duplicates an existing key, edit it.
    (let ((key (bibtex-generate-autokey)))

      ;; first we delete the existing key
      (bibtex-beginning-of-entry)
      (re-search-forward bibtex-entry-maybe-empty-head)
      (if (match-beginning bibtex-key-in-head)
	  (delete-region (match-beginning bibtex-key-in-head)
			 (match-end bibtex-key-in-head)))
      ;; check if the key is in the buffer
      (when (save-excursion
	      (bibtex-search-entry key))
	  (setq key (bibtex-read-key "Duplicate Key found, edit: " key)))

      (insert key)
      (kill-new key)) ;; save key for pasting	    

    (bibtex-fill-entry)  ; this realigns the entry
    (bibtex-clean-entry) ; we do not replace our key
    
    ;; check for non-ascii characters
    (occur "[^[:ascii:]]")

    ;; one day reorder and downcase the fields
    ;; I can get all the fields like this
    ;; (bibtex-parse-entry t)
    ))
#+END_SRC

cite:daza-2014-carbon-dioxid

* DONE Finding missing citation entries in an org-file
  CLOSED: [2014-04-29 Tue 10:37]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/29 10:37:51
  :updated:  2014/05/21 11:00:19
  :END:

Today we consider how to find citations in a document that have no corresponding entries in a bibtex file. There are a couple of pieces to this which we work out in stages below. First, we specify the bibtex file using a bibliography link defined in jorg-bib.el. 


bibliography:bib1.bib,bib2.bib

jorg-bib provides a function that gives us the relevant bibliography files found in this file.

#+BEGIN_SRC emacs-lisp
(cite-find-bibliography)
#+END_SRC

#+RESULTS:
| bib1.bib | bib2.bib |

We can get a list of keys in these files 

#+BEGIN_SRC emacs-lisp
(let ((bibtex-files (cite-find-bibliography)))
(bibtex-global-key-alist))
#+END_SRC

#+RESULTS:
| (adams-1993-orien-imagin . t) | (aarik-1997-effec-tio2 . t) | (aruga-1985-struc-iron . t) |


Now, here are some citations that we want to include in this document.

cite:aruga-1985-struc-iron,aarik-1997-effec-tio2

Here is a citation that is not in the bibtex file cite:kitchin-2016-nobel-lecture


To find out if any of these are missing, we need a list of the citation keys in this document. We first get all the content from the cite links.  We parse the buffer, and for each cite link, we get the path of the link, which contains our keys.

#+BEGIN_SRC emacs-lisp 
(let ((parsetree (org-element-parse-buffer)))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (plist-get plist ':path))))))        
#+END_SRC
#+RESULTS:
| aruga-1985-struc-iron,aarik-1997-effec-tio2 | kitchin-2016-nobel-lecture |

That is almost what we need, but we need to separate the keys that are joined by commas. That function already exists in jorg-bib as cite-split-keys. We need to make a slight variation to get a list of all the entries, since the cite-split-keys returns a list of entries for each link. Here is on approach to that. b

#+BEGIN_SRC emacs-lisp 
(let ((parsetree (org-element-parse-buffer))
      (results '()))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (setq results (append results (cite-split-keys (plist-get plist ':path))))))))
results)  
#+END_SRC

#+RESULTS:
| aruga-1985-struc-iron | aarik-1997-effec-tio2 | kitchin-2016-nobel-lecture |

Ok, now we just need to check each entry of that list against the list of entries in the bibtex files, and highlight any that are not good. We use an index function below to tell us if an element is in a list. This index function works for strings. We use the strange remove-if-not function, which requires something like triple negative logic to get the list of keys that are not in the bibtex files.

#+BEGIN_SRC emacs-lisp :results output
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (parsetree (org-element-parse-buffer))
       (cited-keys))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (setq cited-keys (append cited-keys (cite-split-keys (plist-get plist ':path))))))))

(princ (remove-if-not (lambda (arg) (not (index arg bibtex-keys))) cited-keys))
)
#+END_SRC

#+RESULTS:
: (kitchin-2016-nobel-lecture)


The only improvement from here would be if this generated a temporary buffer with clickable links to find that bad entry! Let us take a different approach here, and print this to a temporary buffer of clickable links. 

#+BEGIN_SRC emacs-lisp :results value raw 
(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (bad-citations '()))

  (org-element-map (org-element-parse-buffer) 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (dolist (key (cite-split-keys (plist-get plist ':path)) )
	    (when (not (index key bibtex-keys))
	      (setq bad-citations (append bad-citations
			    `(,(format "%s [[elisp:(progn (find-file \"%s\")(goto-char %s))][not found here]]\n"
		      key (buffer-file-name)(plist-get plist ':begin)))))
			    ))))))

(mapconcat 'identity bad-citations ""))
#+END_SRC

#+RESULTS:
kitchin-2016-nobel-lecture [[elisp:(progn (find-file "/home-research/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 1052))][not found here]]

That is likely to come in handy. I have put a variation of this code in jorb-bib, in the function called jorg-bib-find-bad-citations.

* DONE A popup menu for citation links in org-mode
  CLOSED: [2014-04-28 Mon 10:13]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/28 10:13:17
  :updated:  2014/04/28 10:13:17
  :END:

I have been exploring ways to get more information out of links in org-mode. I have considered [[http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/][popups]], and [[http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/][right-clicking]]. Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.

Here is the function. We use https://github.com/auto-complete/popup-el, and some code from https://github.com/jkitchin/jmax/blob/master/jorg-bib.el.

#+BEGIN_SRC emacs-lisp :results silent
(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string) 
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu* 
	    (list (popup-make-item (if 
				       (progn
					 (let ((cb (current-buffer)) result)					
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)					  
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item 
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")       
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")   
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))
       
      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")   
       (find-file bibfile)
       (bibtex-search-entry key)       
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))	
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)  
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(<cite>%s</cite>)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
#+END_SRC


cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2


bibliography:../../bibliography/references.bib,bib.bib



Here you can see an example of a menu where I have the PDF:

[[./images/cite-menu-1.png]]

Here is an example menu of a key with no entry:
[[./images/cite-menu-2.png]]

And, and entry with no PDF:
[[./images/cite-menu-3.png]]

Here is the simple citation:

[[./images/cite-menu-4.png]]

And a reference from the other bibliography:

[[./images/cite-menu-5.png]]

Not bad! I will probably replace the cite link in jorg-bib with something like this.






* DONE A better insert citation function for org-mode
  CLOSED: [2014-04-27 Sun 14:40]
  :PROPERTIES:
  :categories: org-mode,bibtex
  :date:     2014/04/27 14:40:45
  :updated:  2014/04/27 14:40:45
  :END:

I have setup a reftex citation format that inserts a cite link using reftex like this.

#+BEGIN_SRC emacs-lisp
(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
#+END_SRC

I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.

#+BEGIN_SRC emacs-lisp
(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
#+END_SRC

That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem. 

#+BEGIN_SRC emacs-lisp
(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    (if (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
#+END_SRC

That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!

* Querying the ase-db
  :PROPERTIES:
  :categories: ase, database
  :date:     2014/04/24 09:33:44
  :updated:  2014/04/24 09:33:44
  :END:
I am examining how to query the ase-db, and this post looks at how to find results that do not contain a particular atom. The solution is based on a email from the mailing list (http://listserv.fysik.dtu.dk/pipermail/ase-developers/2014-April/002097.html). 

We begin by making a test database. This will only contain some atoms objects with different stoichiometries. We also add keywords for the stoichiometry, because the queries will be developed directly in SQL, which cannot read the numpy arrays stored in the tables.

#+BEGIN_SRC python
import os
if os.path.exists('abc.db'): os.unlink('abc.db')

from ase import Atoms
from ase.db import connect
c = connect('abc.db')

c.write(Atoms('Fe'), ['Fe'])
c.write(Atoms('Al'), ['Al'])
c.write(Atoms('Ni'), ['Ni'])
c.write(Atoms('FeNi'), ['FeNi'])
c.write(Atoms('FeAl'), ['FeAl'])
c.write(Atoms('NiAl'), ['NiAl'])
c.write(Atoms('FeNiAl'), ['FeNiAl'])
#+END_SRC
#+RESULTS:

Now, let us see the contents to be sure what is in there.

#+BEGIN_SRC sh
ase-db abc.db
#+END_SRC

#+RESULTS:
: id|age|user    |formula|pbc|keywords|   mass
:  1|19s|jkitchin|Fe     |000|Fe      | 55.847
:  2|19s|jkitchin|Al     |000|Al      | 26.982
:  3|19s|jkitchin|Ni     |000|Ni      | 58.693
:  4|19s|jkitchin|FeNi   |000|FeNi    |114.540
:  5|19s|jkitchin|AlFe   |000|FeAl    | 82.829
:  6|19s|jkitchin|AlNi   |000|NiAl    | 85.675
:  7|19s|jkitchin|AlFeNi |000|FeNiAl  |141.522


Now, suppose I want to find entries that do not contain Ni. We can find the entries that do contain Ni like this.
 
#+begin_src sqlite :db abc.db :list
SELECT systems.data, species.id FROM species 
inner join systems
on systems.id = species.id WHERE species.Z == 28;
#+end_src 

#+RESULTS:
: {"keywords": ["Ni"], "data": {}, "key_value_pairs": {}}|3
: {"keywords": ["FeNi"], "data": {}, "key_value_pairs": {}}|4
: {"keywords": ["NiAl"], "data": {}, "key_value_pairs": {}}|6
: {"keywords": ["FeNiAl"], "data": {}, "key_value_pairs": {}}|7

You can see there is a Ni in each found entry. Now, we select the ids from the systems table that do not exist in that list.

#+begin_src sqlite :db abc.db :list
select id, data from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28);
#+end_src 

#+RESULTS:
: 1|{"keywords": ["Fe"], "data": {}, "key_value_pairs": {}}
: 2|{"keywords": ["Al"], "data": {}, "key_value_pairs": {}}
: 5|{"keywords": ["FeAl"], "data": {}, "key_value_pairs": {}}

And you can see none of these entries contain Ni.


#+BEGIN_SRC python
from ase.db import connect
from ase.db.core import dict2atoms

c = connect('abc.db')
con = c._connect()
cur = con.cursor()
for row in  cur.execute('''select * from  systems
 where
   NOT EXISTS (SELECT id FROM species WHERE species.id = systems.id and species.Z == 28)'''):
    print dict2atoms(c.row_to_dict(row))
#+END_SRC
#+RESULTS:
: Atoms(symbols='Fe', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='Al', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])
: Atoms(symbols='FeAl', positions=..., cell=[1.0, 1.0, 1.0], pbc=[False, False, False])

[[./O_sv]]

[[./O_sv][test dir]]



* latex snippets

Sometimes you just need raw latex inline. Here is a chemical formula @@latex:\ce{ABO_{3-\delta}}@@ that is inline.


* Using Matlab in org-mode
  :PROPERTIES:
  :categories: matlab
  :END:
Most of my work in org-mode uses python, or emacs-lisp. One thing that would make org-mode more readily adopted is if we could use Matlab too. Unfortunately, this is not currently possible on Windows. We need a tty shell.

#+BEGIN_SRC matlab :results value
u = cmu.units;

5*u.kg % a mass
5*u.lb % another mass
6*u.m/u.s  % a velocity

ans = 1*u.m + 10*u.cm % this is ok, 1.1 m
% 1*u.m + 1*u.s  % this is not ok
#+END_SRC

#+RESULTS:

* Parsing a bibtex file into a data structure

I need to parse a bibtex file and get a data structure I can use later. I want an a-list of (key . plist), where the plist will contain data about each bibtex entry, such as the file the key is in, and the entry string.

The idea is to do this once, to avoid re-searching a file all the time. Here is how I would use this idea.

#+BEGIN_SRC emacs-lisp
(setq results '())

(defun parse-bibtex-file (file) 
  "parse bibtex file and add to data structure"
  (with-temp-buffer
    (insert-file-contents file)
    (bibtex-map-entries
     (lambda (key start end)
       (add-to-list 'results 
		    `(,key . (:entry ,(buffer-substring start end)
				     :file ,file)) 
		    t) ;; this appends to the end
     ))))

(let ((bibfiles '("../../bibliography/references.bib" "../../bibliography/kitchin.bib")))
  (mapcar 'parse-bibtex-file bibfiles))

 

;; now see what we got
(plist-get 
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':entry)

(plist-get 
  (cdr (assoc  "mehta-2014-ident-poten" results))
  ':file)
#+END_SRC

#+RESULTS:
: ../../bibliography/references.bib



* DONE Popup tips on bibtex links in org-mode
  CLOSED: [2014-04-12 Sat 14:15]
  :PROPERTIES:
  :date:     2014/04/12 14:15:45
  :updated:  2014/04/12 14:15:45
  :END:

I want to explore using popup tips to display richer information about org-mode links. The idea is to have something like a tooltip that displays the bibtex entry when you hover over it, or click on it. 

https://github.com/auto-complete/popup-el/blob/master/popup.el

Here is a canonical example of a popup.

#+BEGIN_SRC emacs-lisp
(popup-tip "Hello, World!")
#+END_SRC

#+RESULTS:
: t

[[./images/hello-world-popup.png]]

All I need to do is figure out a simple way to get the bibtex entry as a string, and pop it up when a link is clicked on.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (link-string) 
   (popup-tip link-string))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "<pre>%s:%s</pre>" keyword desc)))))
#+END_SRC
#+RESULTS:
| lambda | (link-string)         | (popup-tip link-string)                                                  |
| lambda | (keyword desc format) | (cond ((eq format (quote html)) (format <pre>%s:%s</pre> keyword desc))) |

Now we give it a try.   test:show-me-the-popup   

[[./images/test-link-popup.png]]

That looks good.

Ok, the penultimate step will be to lookup a bibtex entry, and show the entry in a popup. We will hardcode the path to the bibtex file. 

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (bibtex-key)
   (let ((entry (with-temp-buffer
		  (insert-file-contents "~/Dropbox/bibliography/references.bib")
		  (goto-char (point-min))
		  (re-search-forward bibtex-key)
		  (bibtex-narrow-to-entry)
		  (buffer-string))))
     (popup-tip entry))))
#+END_SRC

#+RESULTS:
| lambda | (bibtex-key) | (let ((cb (current-buffer)) (entry (with-temp-buffer (insert-file-contents ~/Dropbox/bibliography/references.bib) (goto-char (point-min)) (re-search-forward bibtex-key) (bibtex-narrow-to-entry) (buffer-string)))) (popup-tip entry)) |


test:mehta-2014-ident-poten 

And here is what appears for me:
[[./images/bibtex-popup-entry.png]]

The final step is to connect this to an [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Idle-Timers.html][idle timer]]. We want a popup to occur when our mouse is idle. I am setting this up to run one time, after 5 seconds of idleness.

#+BEGIN_SRC emacs-lisp
(run-with-idle-timer 5 nil (lambda () (popup-tip "You are being idle")))
#+END_SRC
#+RESULTS:
: [nil 0 5 0 nil (lambda nil (popup-tip "You are being idle")) nil idle 0]

[[./images/idle-timer-popup.png]]

So, we need to setup an idle timer that runs on some interval. When the cursor is on the right kind of link, we want to get a popup. I adapted the following code from http://www.emacswiki.org/emacs/IdleTimers.

#+BEGIN_SRC emacs-lisp
;; variable for the timer object
(defvar idle-timer-bibtex-timer nil)

;; callback function 
(defun idle-timer-bibtex-callback ()
  "displays a popup of the bibtex entry in a test link"
  (interactive)
  (let ((object (org-element-context)))    
    (when (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "test"))
      (let* ((bibtex-key (org-element-property :path object))
	     (entry (with-temp-buffer
		      (insert-file-contents "~/Dropbox/bibliography/references.bib")
		      (goto-char (point-min))
		      (re-search-forward bibtex-key)
		      (bibtex-narrow-to-entry)
		      (buffer-string))))
	(popup-tip entry)))))

;; start functions
(defun idle-timer-bibtex-start ()
  (interactive)
  (when (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer
          (run-with-timer 1 1 #'idle-timer-bibtex-callback)))

;; stop function
(defun idle-timer-bibtex-stop ()
  (interactive)
  (when (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer nil))

(idle-timer-bibtex-start)
#+END_SRC
#+RESULTS:
: idle-timer-bibtex-stop


test:kitchin-2008-alloy

Now, whenever the cursor is on the link, and there is an idle of about a sec, I get a popup window of the bibtex entry. It looks like this:

[[./images/bibtex-popup2.png]]

There are still some limitations to this code. It does not handle multiple citations in a link (like the cite links I normally use do). That will take a little work to fixup. I cannot figure out how to get mouse-over tooltips; this only works when the cursor is on the link.  I do not know what the optimal timer setting is. This one runs every second. I do not see any issues in performance with that. Another issue might be making the timer a file local variable. It would be nice if the timer quit running when the file was closed. I do not know how easy that would be to implement, or if there should be one timer running for org-mode. Finally, this code is hard-coded to use my reference file. For a real module, we would probably provide some customization to choose other bibtex files. Overall though, this might be a handy way to quickly peruse the citations in an org-file.


[[./O_sv]]
* set UUID in heading
  :PROPERTIES:
  :UUID:     ff7c16e8-a5b0-49da-a239-8cf7c6a2a211
  :END:

#+BEGIN_SRC emacs-lisp
(require 'org-id)

(add-hook 'org-insert-heading-hook 
	  #'(lambda () 
	      (org-entry-put (point) "UUID" (org-id-uuid))))		 
#+END_SRC

#+RESULTS:




 
* An org-table rubric
I had an idea to insert a table that represents a rubric into an org-file

The table would compute the overall grade.

|              | weight | Emerging (1,2) | Developing (3,4)   | Mastery (5,6)      | grade |
|--------------+--------+----------------+--------------------+--------------------+-------|
| content      |    0.1 | Text rambles   | articulate ideas   | clear and concise  |     1 |
| organization |    0.2 | unorganized    | not well organized | logical            |     2 |
| mechanics    |    0.3 | many errors    | a few per page     | no errors          |     4 |
| figures      |    0.1 | inappropriate  | flawed             | proper             |     5 |
| style        |    0.2 | inappropriate  | informal, jargon   | neat               |     6 |
| format       |    0.2 | not followed   | somewhat followed  | conforms to format |     7 |
|--------------+--------+----------------+--------------------+--------------------+-------|
|              |      0 |                |                    | Total              |       |
#+TBLFM: B2=vsum(@1..@5)


You would create the table in advance as a snippet, and you could insert it. Maybe the table would have a name.

* DONE Scheduling tasks on a rotating semester basis
  CLOSED: [2014-04-03 Thu 19:29]
  :PROPERTIES:
  :categories: python
  :date:     2014/04/03 19:29:34
  :updated:  2014/04/03 19:29:35
  :END:

Let us say we have a list of tasks labeled task a through k. We want to schedule these tasks on a rotating basis, so that some tasks are done in even years and some tasks are done in odd years. Within those years, some tasks are done in the Fall, and some are done in the spring. This post explores how to code those tasks so we can figure out which tasks should be done in some part of some year. 

We break the problem down like this. A year is an even year if =mod(year,2)=0=, and it is odd if =mod(year,2)=1=. So for a year, we have a bit of information. Now, since there are two times of the year we will do the tasks, we can assign this as another bit, e.g. =FALL=0=, and =SPRING=1=. Now, we have the following possibilities:

| year | time period | binary code | decimal number |
|------+-------------+-------------+----------------|
| 2013 | Fall        |          10 |              2 |
| 2014 | Spring      |          01 |              1 |
| 2014 | Fall        |          00 |              0 |
| 2015 | Spring      |          11 |              3 |

And then the cycle will repeat. So, if we code each task with an integer of 0, 1, 2 or 3, we can say in a given year and time period whether a task should be completed. If =2 * mod(year, 2) + period_code= is equal to the code on the task, then it should be executed.

Now, we need to start the task sequence. Let us say we start in the Fall of 2013. That is an odd year, so =year % 2 = 1=, and we use a tag  of =0= to represent the Fall semester, giving an overall binary code of =10= which is equal to 2, so all tasks labeled 2 should be executed. 

We will assign the codes to each task by enumerating a string of letters, and giving the task a code of mod(letter index, 4). That will loop through the tasks assigning codes of 0, 1, 2 or 3 to each task. 

So to schedule these we will loop through a list of years, calculate the code for each year and time perid, and then filter the list of tasks with that code.

#+BEGIN_SRC python
tasks = [(letter, i % 4) for i,letter in enumerate('abcdefghijk')]

print 'tasks = ',tasks

SEMESTERS = (('FALL',0), ('SPRING',1))

for year in [2013, 2014, 2015, 2016, 2017, 2018]:
    for semester,i in SEMESTERS:
        N = 2 * (year % 2) + i
        print '{0} {1:8s}: {2}'.format(year, semester,
                                    [x[0] for x in 
                                     filter(lambda x: x[1]==N,
                                            tasks)])
#+END_SRC

#+RESULTS:
#+begin_example
tasks =  [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 0), ('f', 1), ('g', 2), ('h', 3), ('i', 0), ('j', 1), ('k', 2)]
2013 FALL    : ['c', 'g', 'k']
2013 SPRING  : ['d', 'h']
2014 FALL    : ['a', 'e', 'i']
2014 SPRING  : ['b', 'f', 'j']
2015 FALL    : ['c', 'g', 'k']
2015 SPRING  : ['d', 'h']
2016 FALL    : ['a', 'e', 'i']
2016 SPRING  : ['b', 'f', 'j']
2017 FALL    : ['c', 'g', 'k']
2017 SPRING  : ['d', 'h']
2018 FALL    : ['a', 'e', 'i']
2018 SPRING  : ['b', 'f', 'j']
#+end_example

This leads to each task being completed every other year. We could also write a function and filter by list comprehension.

#+BEGIN_SRC python
tasks = [(letter, i % 4) for i,letter in enumerate('abcdefghijk')]

FALL = 0
SPRING = 1

def execute_p(year, semester, task):
    'year is an integer, semester is 0 for fall, 1 for spring, task is a tuple of (label,code)'
    N = 2 * (year % 2) + semester
    return task[1] == N

YEAR, SEMESTER = 2018, FALL
print '{0} {1:8s}: {2}'.format(YEAR, 
                               'FALL' if SEMESTER==0 else 'SPRING',
                               [task[0]  for task in tasks
                                if execute_p(2018, FALL, task)])
#+END_SRC

#+RESULTS:
: 2018 FALL    : ['a', 'e', 'i']

Now, at any point in the future you can tell what tasks should be done!

* DONE Using pyparsing for search  queries with tags
  CLOSED: [2014-03-31 Mon 13:21]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/31 13:21:16
  :updated:  2014/03/31 13:21:16
  :END:

A few times I  have wanted  to use  a more natural search string like "A and pw and 350 and not  kpt". The trouble  is figuring out how to parse that string and turn it  into search code. There  may  be nested logic,  e.g. "(A xor B)  and  (pw and (200 or 300))". This means we have  to recursively parse  the sstring. Rather  than invent this from  scratch, we  use pyparsing which is designed for that. There is   some code in "Getting started with pyparsing" that provides an example on parsing search strings. I want to see how I can turn the parsed output into search code. Here, we parse the search string and generate something that looks like lisp code. 

** Parsing simple string and generating lisp

We define  a  hiearchy of classes that codifythe operators, and which print representations of the logic. The grammar we implement is basically words or  strings separatedd by logic operators.

#+BEGIN_SRC python
from pyparsing import *

class UnaryOperation(object):
    'takes one operand,e.g. not'
    def __init__(self, tokens):
        self.op, self.operands = tokens[0]

class BinaryOperation(object):
    'takes two or more operands, e.g. and, or'
    def __init__(self, tokens):
        self.op = tokens[0][1]
        self.operands = tokens[0][0::2]

class SearchAnd(BinaryOperation):
    def __repr__(self):
        return '(AND {0})'.format(' '.join(str(oper) for oper in self.operands))
        
class SearchOr(BinaryOperation):
    def __repr__(self):
        return '(OR {0})'.format(' '.join(str(oper) for oper in self.operands))

class SearchNot(UnaryOperation):
    def __repr__(self):
        return '(NOT {0})'.format(self.operands)

class SearchTerm(object):
    'represents a termthat is being searched. here just a word'                         
    def __init__(self, tokens):
        self.term = tokens[0]

    def __repr__(self):
        return self.term

# the grammar
and_ = CaselessLiteral("and")
or_ = CaselessLiteral("or")
not_ = CaselessLiteral("not")

searchTerm = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

searchExpr = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])


print searchExpr.parseString('not kpt')[0]
print searchExpr.parseString('not (kpt and eos)')[0]
print searchExpr.parseString('wood and blue or red')[0]
print searchExpr.parseString('wood and blue and heavy or red')[0]
#+END_SRC

#+RESULTS:
: (NOT kpt)
: (NOT (AND kpt eos))
: (OR (AND wood blue) red)
: (OR (AND wood blue heavy) red)

That works pretty well, and does not seem overly complicated to me. There is a lot of class definition, but that would presumably get buried in a module as a one time investment, and some function interface would look like this: =search('wood and blue or red')=.

Now, let us try python notation. 

** Parsing a search string to generate python set notations
I will use a similar idea as I used before with TAGS. We will use set operations with the binary logical operators to do the actual searching. Finally, we wrap the code in a little function to search a dictionary we previously made.

#+BEGIN_SRC python
from pyparsing import *

class UnaryOperation(object):
    def __init__(self, tokens):
        self.op, self.operands = tokens[0]

class BinaryOperation(object):
    def __init__(self, tokens):
        self.op = tokens[0][1]
        self.operands = tokens[0][0::2]

class SearchAnd(BinaryOperation):
    def __repr__(self):
        return '(' + ' & '.join(['{}'.format(oper) for oper in self.operands]) + ')'
        
class SearchOr(BinaryOperation):
    def __repr__(self):
        return '(' + ' | '.join(['{}'.format(oper) for oper in self.operands]) +')'

class SearchXor(BinaryOperation):
    def __repr__(self):
        return '(' + ' ^ '.join(['{}'.format(oper) for oper in self.operands]) + ')'

class SearchNot(UnaryOperation):
    def __repr__(self):
        return 'TAGS[\'all\'] - {}'.format(self.operands)

class SearchTerm(object):
    def __init__(self, tokens):
        self.term = tokens[0]

    def __repr__(self):
        'instead of just the  term, we represent it as TAGS[term]'
        return 'TAGS[\'{0}\']'.format(self.term)

# the grammar
and_ = CaselessLiteral("and")
or_ = CaselessLiteral("or")
xor_ = CaselessLiteral("xor")
not_ = CaselessLiteral("not")

searchTerm = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

searchExpr = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (xor_, 2, opAssoc.LEFT, SearchXor),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])

print searchExpr.parseString('not kpt')[0]
print searchExpr.parseString('not (kpt and eos)')[0]
print searchExpr.parseString('kpt or not eos)')[0]
print searchExpr.parseString('wood and blue or red')[0]
print searchExpr.parseString('wood and blue xor red')[0]

# check it out on tags.
def search_tags(srch):
    'function to  search the TAGS  file'
    import pickle

    with open('TAGS.pkl', 'r') as f:
        TAGS = pickle.loads(f.read())
    
    s = searchExpr.parseString(srch)[0]
    return eval(str(s))
print search_tags('pw and A and not 300')
#+END_SRC

#+RESULTS:
: TAGS['all'] - TAGS['kpt']
: TAGS['all'] - (TAGS['kpt'] & TAGS['eos'])
: (TAGS['kpt'] | TAGS['all'] - TAGS['eos'])
: ((TAGS['wood'] & TAGS['blue']) | TAGS['red'])
: ((TAGS['wood'] & TAGS['blue']) ^ TAGS['red'])
: set(['tags\\A\\pw\\350', 'tags\\A\\pw', 'tags\\A\\pw\\200', 'tags\\A\\pw\\400', 'tags\\A\\pw\\250'])

That is pretty nice. It looks like a nice syntax for queries. One day I will try incorporating this into a database application.

* A pyparsing example
#+BEGIN_SRC python
#
# simpleBool.py
#
# Example of defining a boolean logic parser using
# the operatorGrammar helper method in pyparsing.
#
# In this example, parse actions associated with each
# operator expression will "compile" the expression
# into BoolXXX class instances, which can then
# later be evaluated for their boolean value.
#
# Copyright 2006, by Paul McGuire
# Updated 2013-Sep-14 - improved Python 2/3 cross-compatibility
#
from pyparsing import operatorPrecedence, opAssoc, Keyword, Word, alphas

# define classes to be built at parse time, as each matching
# expression type is parsed
class BoolOperand(object):
    def __init__(self,t):
        self.label = t[0]
        self.value = eval(t[0])
    def __bool__(self):
        return self.value
    def __str__(self):
        return self.label
    __repr__ = __str__
    __nonzero__ = __bool__

class BoolBinOp(object):
    def __init__(self,t):
        self.args = t[0][0::2]
    def __str__(self):
        sep = " %s " % self.reprsymbol
        return "(" + sep.join(map(str,self.args)) + ")"
    def __bool__(self):
        return self.evalop(bool(a) for a in self.args)
    __nonzero__ = __bool__
    __repr__ = __str__

class BoolAnd(BoolBinOp):
    reprsymbol = '&'
    evalop = all

class BoolOr(BoolBinOp):
    reprsymbol = '|'
    evalop = any

class BoolNot(object):
    def __init__(self,t):
        self.arg = t[0][1]
    def __bool__(self):
        v = bool(self.arg)
        return not v
    def __str__(self):
        return "~" + str(self.arg)
    __repr__ = __str__
    __nonzero__ = __bool__

TRUE = Keyword("True")
FALSE = Keyword("False")
boolOperand = TRUE | FALSE | Word(alphas,max=1)
boolOperand.setParseAction(BoolOperand)

# define expression, based on expression operand and
# list of operations in precedence order
boolExpr = operatorPrecedence( boolOperand,
    [
    ("not", 1, opAssoc.RIGHT, BoolNot),
    ("and", 2, opAssoc.LEFT,  BoolAnd),
    ("or",  2, opAssoc.LEFT,  BoolOr),
    ])


if __name__ == "__main__":
    p = True
    q = False
    r = True
    tests = [("p", True),
             ("q", False),
             ("p and q", False),
             ("p and not q", True),
             ("not not p", True),
             ("not(p and q)", True),
             ("q or not p and r", False),
             ("q or not p or not r", False),
             ("q or not (p and r)", False),
             ("p or q or r", True),
             ("p or q or r and False", True),
             ("(p or q or r) and False", False),
            ]

    print("p =", p)
    print("q =", q)
    print("r =", r)
    print()
    for t,expected in tests:
        res = boolExpr.parseString(t)[0]
        success = "PASS" if bool(res) == expected else "FAIL"
        print (t,'\n', res, '=', bool(res),'\n', success, '\n')



#+END_SRC
#+RESULTS:
#+begin_example
('p =', True)
('q =', False)
('r =', True)
()
('p', '\n', p, '=', True, '\n', 'PASS', '\n')
('q', '\n', q, '=', False, '\n', 'PASS', '\n')
('p and q', '\n', (p & q), '=', False, '\n', 'PASS', '\n')
('p and not q', '\n', (p & ~q), '=', True, '\n', 'PASS', '\n')
('not not p', '\n', ~~p, '=', True, '\n', 'PASS', '\n')
('not(p and q)', '\n', ~(p & q), '=', True, '\n', 'PASS', '\n')
('q or not p and r', '\n', (q | (~p & r)), '=', False, '\n', 'PASS', '\n')
('q or not p or not r', '\n', (q | ~p | ~r), '=', False, '\n', 'PASS', '\n')
('q or not (p and r)', '\n', (q | ~(p & r)), '=', False, '\n', 'PASS', '\n')
('p or q or r', '\n', (p | q | r), '=', True, '\n', 'PASS', '\n')
('p or q or r and False', '\n', (p | q | (r & False)), '=', True, '\n', 'PASS', '\n')
('(p or q or r) and False', '\n', ((p | q | r) & False), '=', False, '\n', 'PASS', '\n')
#+end_example

* DONE Searching for directories by tags
  CLOSED: [2014-03-29 Sat 17:41]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/29 17:41:08
  :updated:  2014/03/30 12:02:43
  :END:

Today I explore searching for directories by using tags. We will create a TAGS table by first walking through the directories and tagging each directory with all of the relative path components. Then, we will use set algebra to identify specific directories.

First, let us make a directory setup to use. We will nest some calculations that might be typical. These will be nested directories that might contain planewave (pw) and k-points (kpts) convergence and equation of state (eos) directories, with the sets of calculations inside those. The idea then is that the directory components will form at least some of the tags.

#+BEGIN_SRC python
import os

os.mkdir('tags')

for cmpd in ['A', 'B', 'C', 'D']:
    for c in ['pw', 'kpts', 'eos']:
        os.makedirs(os.path.join('tags', cmpd, c))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in [1, 2, 3, 4, 5]:
        os.makedirs(os.path.join('tags', cmpd, 'eos', str(run)))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in [200, 250, 300, 350, 400]:
        os.makedirs(os.path.join('tags', cmpd, 'pw', str(run)))

for cmpd in ['A', 'B', 'C', 'D']:
    for run in ['2x2x2', '4x4x4', '8x8x8']:
        os.makedirs(os.path.join('tags', cmpd, 'kpts', str(run)))
#+END_SRC

#+RESULTS:

Let us just double check what this directory tree looks like for one compound A.
#+BEGIN_SRC sh
ls tags/A/*
#+END_SRC

#+RESULTS:
#+begin_example
tags/A/eos:
1
2
3
4
5

tags/A/kpts:
2x2x2
4x4x4
8x8x8

tags/A/pw:
200
250
300
350
400
#+end_example

Now, we will walk through the directories, and split the path components to create a TAGS structure. I will store these as sets within a dictionary. We will save the structure in a pickle file to reuse it later.

#+BEGIN_SRC python
import os
import pickle

TAGS = {}
TAGS['all'] = set()

for root, dirs, files in os.walk('tags'):
    base, tail = os.path.split(root)
    TAGS['all'].add(root)
    while base:
        if tail in TAGS:
            TAGS[tail].add(root)
        else:
            TAGS[tail] = set([root])
        base, tail = os.path.split(base)

with open('TAGS.pkl', 'w') as f:
    f.write(pickle.dumps(TAGS))

print TAGS.keys()
#+END_SRC

#+RESULTS:
: ['A', '1', 'all', 'B', '250', 'pw', '2x2x2', '300', 'C', '400', 'kpts', '8x8x8', 'eos', '3', '2', '5', '4', '350', '200', '4x4x4', 'D']

Now we have a lot of keys that tag each directory. Each tag is a set of directories, and we can do set algebra to get specific results. For example, we can find a result by appropriate differences, intersections and unions of the sets. An advantage of this approach is that order of the tags is not relevant (unlike the path, where each component must be in the right order).

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['A'].intersection(TAGS['pw']).intersection(TAGS['300'])
print TAGS['300'].intersection(TAGS['pw']).intersection(TAGS['A'])
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300'])
: set(['tags\\A\\pw\\300'])

The syntax here is a tad heavy because of the chained dot notation operations. You can also use the logical operators like this:

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# 300 and pw and A
print TAGS['300'] & TAGS['pw'] & TAGS['A']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300'])


We can get a set of calculations, for example an equation of state like this:
#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# 300 and pw and A
print TAGS['A'] & TAGS['eos']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\eos', 'tags\\A\\eos\\5', 'tags\\A\\eos\\4', 'tags\\A\\eos\\1', 'tags\\A\\eos\\3', 'tags\\A\\eos\\2'])

Now, let us construct some more complex queries. With sets we use intersections for =and= and we construct unions of queries that are like an or. We examine different notations to see which one is better.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# find calculation 3 in eos for B and C
print (TAGS['3']
       .intersection(TAGS['eos'])
       .intersection(TAGS['B'])
       .union
       (TAGS['3']
        .intersection(TAGS['eos'])
        .intersection(TAGS['C'])))

# this notation makes more sense to me. ^ = or
print TAGS['3'] & TAGS['eos'] & (TAGS['B'] ^ TAGS['C'])
#+END_SRC

#+RESULTS:
: set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
: set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])

You can see the two approaches give the same results. The logical operator syntax is more concise and (I think) more readable. Let us consider a query with "not". We can use a difference operator for that. We subtract all the paths with tag "B" from the set containing "4x4x4", which will give us paths tagged with "4x4x4" but not "B".

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# find calculation 4x4x4 but not B
print (TAGS['4x4x4'].difference(TAGS['B']))

# this makes more sense 4x4x4 but not B, 
# i.e. subtract paths tagged B from those tagged 4x4x4
print TAGS['4x4x4'] -  TAGS['B']
#+END_SRC

#+RESULTS:
: set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
: set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])


Note it is not so obvious how to get results not tagged with "A". We need to subtract the tagged calculations from some set. 

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['all'] - TAGS['A']  # not A
#+END_SRC

#+RESULTS:
: set(['tags\\D\\kpts', 'tags\\D\\pw\\200', 'tags\\D\\pw\\350', 'tags\\D\\pw\\250', 'tags\\D\\kpts\\8x8x8', 'tags\\C\\eos', 'tags\\D\\eos\\2', 'tags\\D\\eos\\3', 'tags\\D\\eos\\4', 'tags\\D\\eos\\5', 'tags\\B\\kpts\\2x2x2', 'tags\\C\\kpts\\4x4x4', 'tags\\C\\eos\\3', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1', 'tags\\C\\kpts\\8x8x8', 'tags\\C\\eos\\5', 'tags\\C\\eos\\4', 'tags\\B\\kpts', 'tags\\C\\pw\\200', 'tags\\B\\eos\\2', 'tags\\B\\pw\\350', 'tags\\B\\eos\\1', 'tags\\B\\kpts\\8x8x8', 'tags\\C\\pw\\300', 'tags\\B\\eos\\4', 'tags\\B\\eos\\5', 'tags\\C\\kpts', 'tags\\D\\pw\\300', 'tags\\B\\kpts\\4x4x4', 'tags\\C\\kpts\\2x2x2', 'tags\\D\\kpts\\4x4x4', 'tags\\B\\pw\\250', 'tags', 'tags\\D\\pw\\400', 'tags\\D\\eos', 'tags\\C\\pw\\400', 'tags\\D\\kpts\\2x2x2', 'tags\\D\\pw', 'tags\\C\\pw\\250', 'tags\\C\\pw\\350', 'tags\\C\\pw', 'tags\\D\\eos\\1', 'tags\\B\\pw\\400', 'tags\\B\\pw', 'tags\\B\\eos', 'tags\\B\\pw\\300', 'tags\\B\\eos\\3', 'tags\\C', 'tags\\B', 'tags\\D', 'tags\\B\\pw\\200'])

We can also look at "or". This is done with the =union= function, which is the set of elements in either set. The logical operator is =|=.

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

print TAGS['1'].union(TAGS['2'])
print TAGS['1'] | TAGS['2']        # 1 or 2
#+END_SRC

#+RESULTS:
: set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
: set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])

There is an =xor= operator too. xor is not the same as or, it means =A xor B= means "A or B but not both". The =symmetric_difference= function gives this behavior. The logical operator is =^=. 

#+BEGIN_SRC python
import pickle

with open('TAGS.pkl', 'r') as f:
    TAGS = pickle.loads(f.read())

# I think this is like the xor, A or 2 but not both
print TAGS['A'].symmetric_difference(TAGS['2']), '\n'
print TAGS['A'] ^ TAGS['2']
#+END_SRC

#+RESULTS:
: set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200']) 
: 
: set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])



To summarize, this is one approach to using tags with the technical infrastructure of the set. The advantage is flexibility, that you do not need to know the full path to a result, provided you know the set of tags that refers to it. You can use the tags in any order.

There are many alternative approaches to implementing this idea. One could create a sqlite table and do SQL queries. You could also store lists in the dictionary, and use python code to find the matches. The syntax here is varied. Using the functional approach, the syntax gets heavy with all the dot notation. With the logical operators, the syntax is a little lighter. 


* DONE Literate programming in python with org-mode and noweb
  CLOSED: [2014-03-27 Thu 10:47]
  :PROPERTIES:
  :categories: org-mode,python
  :date:     2014/03/27 10:46:55
  :updated:  2014/03/27 11:07:15
  :END:
This post examines a different approach to literate programming with org-mode that uses [[http://www.cs.tufts.edu/~nr/noweb/][noweb]]. I have adapted an example from http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html which has some pretty cool ideas in it. 

The gist of using noweb is that in your source blocks you have labels like =<<imports>>=, that refer to other named code blocks that get substituted in place of the label. In the example below, we put labels for a code block of imports, for a function definition, a class definition, and a main function. This code block will get tangled to [[./main.py]]. The noweb expansion happens at export, so here is the literal code block:
#+BEGIN_EXAMPLE
#+BEGIN_SRC python :noweb yes :tangle main.py
<<imports>>

<<some-func>>

<<class-dfn>>

<<main-func>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC
#+END_EXAMPLE

You may want to just check out the org-mode source link at the bottom of the post to see all the details.

#+BEGIN_SRC python :noweb yes :tangle main.py
<<imports>>

<<some-func>>

<<class-dfn>>

<<main-func>>

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC

** imports
Now, we define a block that gives us the imports. We do not have to use any tangle headers here because noweb will put it in where it belongs.

#+NAME: imports
#+BEGIN_SRC python
import sys
import numpy as np
import matplotlib.pyplot as plt

from argparse import ArgumentParser
#+END_SRC

** utility function
Now we define a function we will want imported from the main file. 

#+NAME: some-func
#+BEGIN_SRC python
def utility_func(arg=None):
    return 'you called a utility function with this arg: {0}'.format(arg)
#+END_SRC

** class definition
Finally, let us define a class. Note we use noweb here too, and we get the indentation correct!

#+NAME: class-dfn
#+BEGIN_SRC python :noweb yes
class HelloWorld(object):
    def __init__(self, who):
        self.who = who

    def __call__(self):
        return 'Hello {0}'.format(self.who)

    <<some-other-func>>
#+END_SRC

*** some class function
Now, let us make the some-other-func. This block is not indented, but with the noweb syntax above, it seems to get correctly indented. Amazing.

#+NAME: some-other-func
#+BEGIN_SRC python
def test(self):
    return True
#+END_SRC

** The main function

This is a typical function that could be used to make your module into a script, and is only run when the module is used as a script.. 

#+NAME: main-func
#+BEGIN_SRC python
def main():
    parser = ArgumentParser(description="Say hi")
    parser.add_argument("-w", "--who", 
                        type=str,
                        default="world",
                        help="Who to say hello to")
    args = parser.parse_args()
  
    who = args.who
  
    greeter = HelloWorld(who)
    greeter()

    print 'test func = ', greeter.test()
  
    print utility_func()
    print utility_func(5)

    return 0
#+END_SRC

** Tangle and run the code

This link will extract the code to main.py: elisp:org-babel-tangle

We can run the code like this (linux):
#+NAME: bashrun-helloworld
#+BEGIN_SRC sh :results output
python main.py --w John 2>&1
true
#+END_SRC
#+RESULTS: bashrun-helloworld
: test func =  True
: you called a utility function with this arg: None
: you called a utility function with this arg: 5

or this (windows, which as no sh)

#+BEGIN_SRC python
from main import *

main()
#+END_SRC

#+RESULTS:
: test func =  True
: you called a utility function with this arg: None
: you called a utility function with this arg: 5

** Summary thoughts
The use of noweb syntax is pretty cool. I have not done anything serious with it, but it looks like you could pretty easily create a sophisticated python module this way that is documented in org-mode. 
* DONE Deleting multiple elements of a list
  CLOSED: [2014-03-25 Tue 18:40]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/25 18:40:34
  :updated:  2014/03/25 18:40:34
  :END:

Today someone asked about deleting multiple elements from a list (actually it was about deleting multiple atoms from an ase.Atoms object, but some principles here apply. I will address that actual question later.).

Deleting multiple items from a list is not directly possible in one command in Python. There are a few approaches to accomplishing something like it. Which one is best depends on your objective. 

One problem is when you delete an item, the indices of every item after it also changes. One strategy then is to delete the elements in descending order, i.e. delete the largest indices first. That way, you do not change the indices of the smaller indices, so you can still delete them. We can sort them in reverse order like this:

#+BEGIN_SRC python
a = [1, 2, 5, 6, 7]

ind2remove = [1, 3]

for i in sorted(ind2remove, reverse=True): 
    del a[i]

print a
#+END_SRC

#+RESULTS:
: [1, 5, 7]

An alternative approach is to make a new list that only has the elements you want using list comprehension. For example:

#+BEGIN_SRC python
a = [1, 2, 5, 6, 7]

ind2remove = [1, 3]

a = [x for i,x in enumerate(a) if i not in ind2remove]

print a
#+END_SRC

#+RESULTS:
: [1, 5, 7]

With numpy arrays you can delete multiple elements like this:

#+BEGIN_SRC python
import numpy as np

a = np.array([1, 2, 5, 6, 7])

ind2remove = [1, 3]

print np.delete(a, ind2remove)
print a
#+END_SRC

#+RESULTS:
: [1 5 7]
: [1 2 5 6 7]

The delete command makes a new object; the original list is unchanged. Numpy arrays are technically immutable, so the only way to do this is to make a copy. Another way is to use a boolean mask that only selects the indices where the mask is True, and not where they are False.

#+BEGIN_SRC python
import numpy as np

a = np.array([1, 2, 5, 6, 7])

ind2remove = [1, 3]

mask = np.ones(len(a), dtype=bool) 
mask[ind2remove] = False
print a[mask]
print a
#+END_SRC

#+RESULTS:
: [1 5 7]
: [1 2 5 6 7]

There might be other ways to do this too. These examples are nearly indistinguishable for small lists. For very large lists (I guess 1000's of elements), you may find one method more efficient than the others. 

* DONE Make a list of org-files in all the subdirectories of the current working directory
  CLOSED: [2014-03-23 Sun 15:36]
  :PROPERTIES:
  :categories: org-mode,emacs,recursive
  :date:     2014/03/23 15:36:56
  :updated:  2014/03/23 15:36:56
  :END:

It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents. 

Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called =literate= in my computer.

#+BEGIN_SRC emacs-lisp
;; list contents of the directory
(let ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files "literate" abspath match nosort))
#+END_SRC

#+RESULTS:
| makefile-main | Makefile | main.o | main.f90 | main | literate.org | hello.f90 | circle.o | circle.mod | circle.f90 | circle-area.png | archive | a.out | .. | . |

Note the presence of =.= and =..=. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.

#+BEGIN_SRC emacs-lisp
;; remove . and ..
(let ((abspath nil)
      (match nil)
      (nosort t))
  (remove "." 
	  (remove ".." 
		  (directory-files "literate" abspath match nosort))))
#+END_SRC

#+RESULTS:
| makefile-main | Makefile | main.o | main.f90 | main | literate.org | hello.f90 | circle.o | circle.mod | circle.f90 | circle-area.png | archive | a.out |

Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".

#+BEGIN_SRC emacs-lisp :results output
;; print types of files in the directory
(let ((root "literate")
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (lambda (x)
	    (cond
	     ((file-directory-p (expand-file-name x root))
	      (print (format "%s is a directory" x)))
	     ((file-regular-p (expand-file-name x root))
	      (print (format "%s is a regular file" x)))))
	  (remove "." 
		  (remove ".." 
			  (directory-files root abspath match nosort)))))
#+END_SRC

#+RESULTS:
#+begin_example

"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
#+end_example

Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code. 

#+BEGIN_SRC emacs-lisp
(defun os-walk (root)
  "recursively walks through directories getting list of absolute paths of files"
  (let ((files '()) ; empty list to store results
	(current-list (directory-files root t)))
    ;;process current-list
    (while current-list
      (let ((fn (car current-list))) ; get next entry
	(cond 
	 ;; regular files
	 ((file-regular-p fn)
	  (add-to-list 'files fn))
	 ;; directories
	 ((and
	   (file-directory-p fn)
	   ;; ignore . and ..
	   (not (string-equal ".." (substring fn -2)))
	   (not (string-equal "." (substring fn -1))))
	  ;; we have to recurse into this directory
	  (setq files (append files (os-walk fn))))
	)
      ;; cut list down by an element
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk "literate")
#+END_SRC

#+RESULTS:
| c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/makefile-main | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main.o | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/main | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/literate.org | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/hello.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.o | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.mod | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle.f90 | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/circle-area.png | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/a.out | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/Makefile | c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/archive/empty-text-file.txt |

Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.

#+BEGIN_SRC emacs-lisp :results output org raw
(defun os-walk (root)
  (let ((files '()) ;empty list to store results
	(current-list (directory-files root t)))
    ;;process current-list
    (while current-list
      (let ((fn (car current-list))) ; get next entry
	(cond 
	 ;; regular files
	 ((file-regular-p fn)
	  (add-to-list 'files fn))
	 ;; directories
	 ((and
	   (file-directory-p fn)
	   ;; ignore . and ..
	   (not (string-equal ".." (substring fn -2)))
	   (not (string-equal "." (substring fn -1))))
	  ;; we have to recurse into this directory
	  (setq files (append files (os-walk fn))))
	)
      ;; cut list down by an element
      (setq current-list (cdr current-list)))
      )
    files))

(require 'cl)

(mapcar 
 (lambda (x) (princ (format "[[%s][%s]]\n" x (file-relative-name x "."))))
 (remove-if-not 
  (lambda (x) (string= (file-name-extension x) "org"))
  (os-walk "literate")))
#+END_SRC

#+RESULTS:
[[c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/literate/literate.org][literate/literate.org]]


That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files. 




* DONE Finding VASP calculations in a directory tree
  CLOSED: [2014-03-20 Thu 20:09]
  :PROPERTIES:
  :categories: python,vasp
  :date:     2014/03/20 20:09:26
  :updated:  2014/03/20 20:09:26
  :END:

The goal in this post is to work out a way to find all the directories in some root directory that contain VASP calculations. This is a precursor to doing something with those directories, e.g. creating a summary file, adding entries to a database, doing some analysis, etc... For fun, we will just calculate the total elapsed time in the calculations.

What is challenging about this problem is that the calculations are often nested in a variety of different subdirectories, and we do not always know the structure. We need to recursively descend into those directories to check if they contain VASP calculations. 

We will use a function that returns True or False to tell us if a particular directory is a VASP calculation or not. We can tell that because a completed VASP calculation has specific files in it, and specific content in those files. Notably, there is an OUTCAR file that contains the text "General timing and accounting informations for this job:" near the end of the file.

We will also use [[http://docs.python.org/2/library/os.html#os.walk][os.walk]] as the way to recursively descend into the root directory.

#+BEGIN_SRC python
import os
from jasp import *

def vasp_p(directory):
    'returns True if a finished OUTCAR file exists in the current directory, else False'
    outcar = os.path.join(directory, 'OUTCAR')
    if os.path.exists(outcar):
        with open(outcar, 'r') as f:
            contents = f.read()
            if 'General timing and accounting informations for this job:' in contents:
                return True
    return False
            
        
total_time = 0

for root, dirs, files in os.walk('/home-research/jkitchin/research/rutile-atat'):
    for d in dirs:
        # compute absolute path to each directory in the current root
        absd = os.path.join(root, d)
        if vasp_p(absd):
            # we found a vasp directory, so we can do something in it. 
            # here we get the elapsed time from the calculation
            with jasp(absd) as calc:
                total_time += calc.get_elapsed_time()

print 'Total computational time on this project is {0:1.0f} minutes.'.format(total_time / 60)
#+END_SRC

#+RESULTS:
: Total computational time on this project is 231 minutes.




* DONE Using tags searches on objects in python
  CLOSED: [2014-03-24 Mon 21:52]
  :PROPERTIES:
  :categories: python
  :date:     2014/03/24 21:52:13
  :updated:  2014/03/24 21:52:13
  :END:

I am exploring the possibility of using tags on python objects in conjunction with searches to find sets of objects. Here I want to explore some syntax and methods for doing that.

In org-mode there is a syntax like '+boss+urgent-project1' for =and= and =not= operators and 'A|B' for =or= operators. I think we need [[http://pyparsing.wikispaces.com/Examples][pyparsing]] to untangle this kind of syntax. See http://pyparsing.wikispaces.com/file/view/simpleBool.py for an example. Another alternative might be the natural language toolkit ([[http://www.nltk.org/][nltk]]). Before we dig into those, let us see some python ways of doing the logic.

Below we define some lists containing tags (strings). We 

#+BEGIN_SRC python
a = ['A', 'B', 'C']

b = ['A', 'B']

c = ['A', 'C']

d = [ 'B', 'C']

all_lists = [a, b, c, d]

# get functions with tags A and B
print 'A and B ',[x for x in all_lists if ('A' in x) & ('B' in x)]

# A not B
print 'A not B ',[x for x in all_lists if ('A' in x) & ('B' not in x)]

# B or C
print 'B or C ', [x for x in all_lists if ('B' in x) | ('C' in x)]

# B or C but not both
print 'B xor C ',[x for x in all_lists if ('B' in x) ^ ('C' in x)]
#+END_SRC

#+RESULTS:
: A and B  [['A', 'B', 'C'], ['A', 'B']]
: A not B  [['A', 'C']]
: B or C  [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['B', 'C']]
: B xor C  [['A', 'B'], ['A', 'C']]

Those are not too bad. Somehow I would have to get pyparsing to generate that syntax. That will take a lot of studying. There are some other ways to do this too. Let us try that out with itertools.

#+BEGIN_SRC python
a = ['A', 'B', 'C']

b = ['A', 'B']

c = ['A', 'C']

d = [ 'B', 'C']

all_lists = [a, b, c, d]

import itertools as it

# ifilter returns an iterator
print 'A and B ', list(it.ifilter(lambda x: ('A' in x) & ('B' in x), all_lists))

#+END_SRC

#+RESULTS:
: A and B  [['A', 'B', 'C'], ['A', 'B']]

I do not like this syntax better. The iterator is lazy, so we have to wrap it in a list to get the results.  Eventually, I want to do something like these:

#+BEGIN_EXAMPLE
filter('A and B', all_lists)
A or B
A xor B
not A and B
not(A and B)
#+END_EXAMPLE

I think that calls for pyparsing.  I think the syntax above is better (more readable) than this:

#+BEGIN_EXAMPLE
filter('A & B', all_lists)
A | B
A ^ B
~A & B
~(A & B)
#+END_EXAMPLE

It is not that obvious though how to get from that syntax to the code I illustrated above though.
* Importing google contacts into bbdb

I am giving bbdb a try in emacs. I installed it from ELPA, and I am not sure if it is version 2 or 3, but it seems to work ok. The main reason I want it is so I can use email address completion in emails from Emacs.

The first thing I had to do was add this to my init files. Apparently the icicle-bbdb-complete-name function is not defined, so this takes care of that.
#+BEGIN_SRC emacs-lisp
;; This is not defined in my bbdb/icicles installation. This lets me use tab-completion.
(defalias 'icicle-bbdb-complete-name 'bbdb-complete-mail)
#+END_SRC

Next, I wanted to get my google contacts into bbdb. I am only going to do this once, to get most of what I need in. In the future, I suppose I will just add new contacts manually.  So, first, I exported my google contacts to a csv file. Google does some crazy scraping, so there were nearly 4000 contacts in that list. Not all of them were emails. I used this little python script to write out the first 5 columns of that file to a new file, as long as there was something in the first column.

#+BEGIN_SRC python
import csv

with open('contacts.csv', 'rb') as csvfile:
    spamreader = csv.reader(csvfile, delimiter=',')

    with open('new-contacts.csv', 'w') as f:
        for row in spamreader:
            if row[0]:
                f.write(','.join(row[0:5])+'\n')
                print ','.join(row[0:5])
#+END_SRC

Then, I manually went through the file deleting many obviously bad entries. It was just shy of interesting to see what was in there. I renamed the first line to have heading names with no spaces in them. So, the csv file eventually looked like this:

#+BEGIN_EXAMPLE
fname,mname,lname,email1,email2
Jennifer,,blahlan,fda@andrew.cmu.edu,
#+END_EXAMPLE


From there, I found a csv elisp file (http://ulf.epplejasper.de/EmacsGeneralPurpose.html) that can import a csv file to a lisp data structure. So, I read in the csv file, and then applied a function to each entry that created a bbdb entry with the information in the csv entry like this:

#+BEGIN_SRC emacs-lisp
#+BEGIN_SRC emacs-lisp
(let* ((b (find-file "new-contacts.csv"))
       (bbdb-allow-duplicates t)
       (contents (csv-parse-buffer t b)))
  (mapcar (lambda (x)
	    (let* ((fname (cdr (nth 0 x)))
		   (mname (cdr (nth 1 x)))
		   (lname (cdr (nth 2 x)))
		   (email1 (cdr (nth 3 x)))
		   (name (format "%s %s %s" fname mname lname)))
	      (bbdb-create-internal name nil nil nil email1))) contents))
#+END_SRC

Setting =(bbdb-allow-duplicates t)= was probably a mistake, it would have been better to leave this a false, catch the errors, and continue. But, it is easy to find duplicates in bbdb, and then manually delete them. In the end, I have 2648 "contacts" in my bbdb

* Sending email in emacs
  :PROPERTIES:
  :categories: emacs,email
  :END:

I would like to be able to regularly send email from emacs (one day I would like to read it too). The reason for this is simply that I have a lot of information stored in files I often read in Emacs, and I want to be able to select that information and quickly email it to someone. I need this to work smoothly on Windows and Linux.

There are numerous blog posts on how to set this up, but many are out of date, or work on Linux only.  Here I am documenting what seems to work for me. In my emacs init files, I have this:


#+BEGIN_SRC text :tangle ~/.authinfo
machine smtp.andrew.cmu.edu login jkitchin port 587 password blahbity-blah
#+END_SRC

Note that this file has my actual password in it.

Now, I can type C-x m to start an email, or use one my functions to email a selection or org-heading, and the emails get sent.
- [X] home office
- [ ] home tablet
- [ ] office slate
- [ ] office linux
- [ ] office laptop

** take 1

Here I am following this post http://wideaperture.net/blog/?p=3343

#+BEGIN_SRC emacs-lisp
;;Configure Outbound Mail

;;Tell the program who you are

(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")

;;Tell Emacs to use GNUTLS instead of STARTTLS
;;to authenticate when sending mail.

(setq starttls-use-gnutls t)

;;Tell Emacs about your mail server and credentials

(setq send-mail-function 'smtpmail-send-it
      message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials
      '(("smtp.gmail.com" 587 nil nil))
      
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-debug-info t)
(require 'smtpmail)
#+END_SRC

(require 'gnutls)
(open-gnutls-stream "tls" "tls-buffer" "imap.aim.com" "imaps")

ftp://ftp.gnutls.org/gcrypt/gnutls/w32/

this needs a .authinfo file. it works on home-office computer, but not on home tablet.

#+BEGIN_SRC text
machine smtp.andrew.cmu.edu login jkitchin port 587 password jfkdlajfdkl;
machine cyrus.andrew.cmu.edu login jkitchin password fjdkslafjsdkals

#+END_SRC

** Using msmtp
this worked on my home tablet

http://www.emacswiki.org/emacs/GnusMSMTP

#+BEGIN_SRC emacs-lisp
;; This is needed to allow msmtp to do its magic:
(setq message-sendmail-f-is-evil 't)

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("--read-envelope-from"))

;; with Emacs 23.1, you have to set this explicitly (in MS Windows)
;; otherwise it tries to send through OS associated mail client
(setq message-send-mail-function 'message-send-mail-with-sendmail)
;; we substitute sendmail with msmtp
(setq sendmail-program "c:/Users/jkitchin/Desktop/GetGnuWin32/bin/msmtp.exe")
;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("-a" "gmail"))
;; you might want to set the following too
(setq mail-host-address "gmail.com")
(setq user-full-name "John Kitchin")
(setq user-mail-address "johnrkitchin@gmail.com")
#+END_SRC
#+RESULTS:
: johnrkitchin@gmail.com


It appears we have an msmtp installed from our git installation.


#+BEGIN_SRC sh
which msmtp
#+END_SRC

#+RESULTS:
: C:\Program Files (x86)\Git\bin\msmtp.EXE

We can check the version like this. 

#+BEGIN_SRC sh
msmtp --version
#+END_SRC

#+RESULTS:
#+begin_example
msmtp version 1.4.17
TLS/SSL library: OpenSSL
Authentication library: GNU SASL
Supported authentication methods:
plain cram-md5 digest-md5 external login 
IDN support: disabled
NLS: disabled
Keyring support: none
System configuration file name: C:\ProgramData\msmtprc.txt
User configuration file name: c:/Users/jkitchin/\msmtprc.txt

Copyright (C) 2008 Martin Lambers and others.
This is free software.  You may redistribute copies of it under the terms of
the GNU General Public License <http://www.gnu.org/licenses/gpl.html>.
There is NO WARRANTY, to the extent permitted by law.
#+end_example

It is not the most recent version. Next, create c:/Users/jkitchin/\msmtprc.txt with contents that look like this. I have two accounts that I could send email from, and they are listed here. 

#+BEGIN_SRC text
########################
account default
host smtp.andrew.cmu.edu
tls on
tls_certcheck off
auth on
from jkitchin@andrew.cmu.edu
user jkitchin
password tjkdjfkd
port 587
logfile c:\msmtplog.txt
########################
account gmail
host smtp.gmail.com
tls on
tls_certcheck off
auth on
from johnrkitchin@gmail.com
user johnrkitchin@gmail.com
password fjdklafd
port 587

logfile c:\msmtplog.txt
########################
#+END_SRC

Now we follow the suggestions at http://www.emacswiki.org/emacs/GnusMSMTP to configure emacs

#+BEGIN_SRC emacs-lisp
;; This is needed to allow msmtp to do its magic:
(setq message-sendmail-f-is-evil 't)

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("--read-envelope-from"))

(setq message-send-mail-function 'message-send-mail-with-sendmail)

;; we substitute sendmail with msmtp
(setq sendmail-program "C:/Program Files (x86)/Git/bin/msmtp.EXE")

;;need to tell msmtp which account we're using
(setq message-sendmail-extra-arguments '("-a" "andrew"))
#+END_SRC


* Is my cursor on a link


#+BEGIN_SRC emacs-lisp
(defun label-p ()
 "determine if the cursor is on a label link. return the path if so, nil otherwise"
  (interactive)
  (let ((object (org-element-context)))
    (message "%s" (when
	(and (equal (org-element-type object) 'link)
	     (equal (org-element-property :type object) "label"))
      (org-element-property :path object)))))
#+END_SRC


label:test1
   label:test
 
[[file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at%20org-any-link-re)][file:~/Dropbox/kitchingroup/jmax/org-mode/lisp/org.el::((looking-at org-any-link-re)]]


* DONE Using yasnippet to get completion in ref links
  CLOSED: [2014-03-08 Sat 07:55]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/08 07:55:54
  :updated:  2014/03/08 07:55:54
  :END:

This post illustrates an alternative approach to completion in creating ref links compared to the approach shown [[http://kitchingroup.cheme.cmu.edu/blog/2014/03/06/Using-completion-in-ref-links/][here]]. In this approach we use a dynamic yasnippet to do the completion. We start with similar code that I used before to get a list of labels from the buffer. I used a slightly different regexp to recognize links in this version.

label:code-example
#+BEGIN_SRC emacs-lisp
(defun get-labels ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\([a-zA-z0-9:-]*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      matches)))
#+END_SRC

#+RESULTS:
: get-labels

Let us see that in action:

#+BEGIN_SRC emacs-lisp
(get-labels)
#+END_SRC

#+RESULTS:
| code-example | \\ | code:ref-snippet | load-snippets |

I think the =\\= link is an artifact of the regexp in my get-labels code, and it would not appear in other examples. 

Now, we are going to create a yasnippet that uses the list returned from ~get-labels~ to provide your choices. See http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8 for some details. We will tangle this code block into a local snippets directory.

label:code:ref-snippet
#+BEGIN_SRC snippet :tangle snippets/org-mode/ref
# -*- mode: snippet -*-
# --
ref:${1:$$(yas-choose-value (get-labels))} $0
#+END_SRC

Now we load the snippets directory.

label:load-snippets
#+BEGIN_SRC emacs-lisp
(yas-load-directory "./snippets")
#+END_SRC

#+RESULTS:

Finally, we can type ref, press tab to complete it, and then select the label you want from a list. Here are some examples:

ref:code-example 

ref:code:ref-snippet 

That also works! I cannot decide if I like this better than the Emacs completion. yasnippet gives a popup menu, which is not as easy to navigate as the Emacs completion mechanism. It also requires a working yasnippet, which has not made it into my regular work flows too often. I think I like the Emacs completion better (which actually goes through Icicles since I have that installed). I like it better because I do not have to leave the keyboard or use the arrow buttons to choose a label. However, I do need to bind that function to some key to use it, or type in the command name. It turns out I do not use ref links too often, so it is not too burdensome.


* DONE Using completion in ref links
  CLOSED: [2014-03-06 Thu 19:11]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/06 19:11:07
  :updated:  2014/03/06 19:11:07
  :END:

I came across this interesting post on using completion in links: http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs. I like the idea, but the type-flow for is not how I usually insert links. For the method there to work, you have to enter a link with C-c C-l, partially enter the link type, press enter, and then partially enter the description, which can be completed with tab. That is a lot of typing to me, compared to what I usually do which is type the link in directly. That habit does not work too well in large documents, and always has the possibility of a typo in the link, which then does not work or export correctly.

Here I explore how to make a ref:label link using a function that provides all the options available as labels. The idea is to write a function that generates a list of labels in the buffer, which you can make a link to. Let us try an interactive function with a list of arguments. We are first going to generate a list of labels from the buffer. We use this code to get a list of labels in the buffer. You will get to choose which label you want a link to, and the function will insert it for you. Here it is:

label:code-example
#+BEGIN_SRC emacs-lisp
(defun get-labels ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((matches '()))
      (while (re-search-forward "label:\\(.*\\)" (point-max) t)
	(add-to-list 'matches (match-string-no-properties 1) t))
      matches)))

(defun org-insert-ref-link (&optional arg)
  (interactive (list (completing-read "label: " (get-labels))))
  (insert (format "ref:%s" arg)))
#+END_SRC

#+RESULTS:
: org-insert-ref-link

So, here you run the command with M-x org-insert-ref-link, press tab, and select the label you want to use. A link like this gets inserted in your buffer ref:code-example. This is pretty nice. It should reduce the number of ref link mistakes, and make it easier to find the labels in the whole buffer.



* miscellaneous links

see http://draketo.de/light/english/emacs/convert-ris-citations-bibtex-bibutils

http://draketo.de/english/emacs/writing-papers-in-org-mode-acpd


* DONE Creating a transportable zip-archive of an org-file 
  CLOSED: [2014-03-05 Wed 12:31]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/05 10:49:14
  :updated:  2014/03/05 12:31:34
  :END:

This post explores a method to save an org-buffer to a zip archive, with all the referencing files. The challenge is that you may want to share the org-file with someone, but the links break if you send them the file, and it is not that trivial to find all the links and change them, and to copy the files to a place where the new links work. 

The idea is to export the buffer to an org-file and process all the links to copy the files to a new directory, and change the links to point to these new files. For example, [[./blog.pdf]] would be copied to the temporary directory, given a unique name, and then relinked. The text below includes some examples of the links that need to be modified.

A figure looks like:

[[./images/cos-plot.png]]

Alternatively, we might use a [[./images/eos.png][link]] to a file. We do not want to change urls, such as this one: http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/. As in that example, we will create a list of all the links in the buffer, but only modify the links that are files. We can parse the buffer and get the links like this.

#+BEGIN_SRC emacs-lisp :results output
(let ((parsetree (org-element-parse-buffer))
      (counter 0))
  (org-element-map parsetree 'link
    (lambda (link) 
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
        (princ (format "%s %s: %s %s\n" 
		       counter 
		       (plist-get plist ':type) 
		       (plist-get plist :path) 
		       content))
        (setq counter (+ counter 1))))))
#+END_SRC
#+RESULTS:
: 0 file: ./blog.pdf nil
: 1 file: ./images/cos-plot.png nil
: 2 file: ./images/eos.png link
: 3 http: //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ nil

So, our overall strategy will be to create a new directory to store the new versions of the files in. Then, we will copy the files that links point to into that directory, and give them new unique names. We will rename the links to point to these new names. We do this because you may, for some reason have links to files with the same name but in different directories. We want to make sure we do not clobber the files by overwriting them. We use a simple method here, based on unique, temporary filenames. There are other ways to do it to, this way worked first. Finally, we will zip that new directory, and delete the new directory.


#+BEGIN_SRC emacs-lisp :results value raw
;; directory to save all exports in, using the current date
(setq org-archive (concat "org-archive-" (format-time-string "%Y-%m-%d" (current-time))))

;; delete directory and zip file if it exists
(when (file-exists-p (concat org-archive ".zip")) 
    (delete-file (concat org-archive ".zip") t))

(when (file-exists-p org-archive) 
    (delete-directory org-archive t))

;; make directory
(make-directory org-archive t)

;; get list of links, copy files and save names
(setq link-list (let ((parsetree (org-element-parse-buffer))
                     (counter 0))
                 (org-element-map parsetree 'link
                   (lambda (link) 
                     (let* ((type (nth 0 link))
                            (plist (nth 1 link))
                            (content (nth 2 link))
                            (path (plist-get plist :path))
                            (type (plist-get plist ':type))
                            (fname (car (last (split-string path "/"))))
			    (temporary-file-directory org-archive)
			    (new-file)
                            )     
                       (cond
                        ;; regular file with content
                        ((and (string= type "file")  content)
			 (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
							 (concat "." (file-name-extension fname))))
			 (with-temp-file new-file
			   (insert-file-contents path))
			 (format "[[./%s][%s]] " (file-name-nondirectory new-file) content))
                        ;; regular file with no content
                        ((and (string= type "file"))
			 (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
							 (concat "." (file-name-extension fname))))
			 (with-temp-file new-file
			   (insert-file-contents path))
			 (format "[[./%s]] " (file-name-nondirectory new-file)))
			(t nil)))))))

;; save current buffer name
(setq current-name (buffer-name))

;; create filter for links and export org buffer
(let ((counter 0))
  (defun ox-mrkup-filter-link (text back-end info)
    (let ((link (nth counter link-list)))
      (if (not (string= link "nil")) (setq output   (format "%s" link))
        (setq output (format "%s" text)))
      (setq counter (+ counter 1))
      output))

  (let ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-org-export-as-org)))

(switch-to-buffer "*Org ORG Export*")
(write-file (expand-file-name current-name org-archive))
(shell-command (concat "zip -R " org-archive ".zip  *"))
(rename-file (concat org-archive ".zip") (concat "../"org-archive ".zip"))
(kill-buffer)

(switch-to-buffer current-name)
(delete-directory org-archive t)  ;; get rid of temp-dir
#+END_SRC



This example works fine! The result is here: [[./org-archive-2014-03-05.zip]] This code would ideally be put into a function, and cleaned up a little so there are not global variables being set here and there. A subsequent function might make it easy to attach this file to an email. That code might look something like this:

#+BEGIN_SRC emacs-lisp
(mail)
(mail-to)
(insert "jkitchin@andrew.cmu.edu")
(mml-attach-file "./org-archive-2014-03-05.zip")
#+END_SRC

* DONE Getting a list of figures in an org-buffer
  CLOSED: [2014-03-02 Sun 10:03]
  :PROPERTIES:
  :date:     2014/03/02 10:03:00
  :updated:  2014/03/03 14:50:40
  :categories: org-mode
  :END:

Similar to the previous [[http://kitchingroup.cheme.cmu.edu/blog/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer/][example]] of getting a list of tables, here we examine getting a list of figures. Here are two figure links, one with a label, and one with a caption.

# figure with no caption
#+label: fig:cos
[[./images/cos-plot.png]]

#+caption: An equation of state. this is the caption of the figure.
[[./images/eos-uncertainty.png]]

#+attr_latex: :width 3in
#+caption: another figure
[[./images/implicit-uncertainty.png]]

We define a link that will parse the buffer, and create links in a new buffer to the figures. We define a figure as a  link with a :type of "file" that has a path that points to a file ending with png or pdf.  We will improve on the list of tables by making the buffer read-only, and making a local key binding to kill the buffer by pressing "q". Here is our attempted code. 

#+BEGIN_SRC emacs-lisp
;; http://www.emacswiki.org/emacs/ElispCookbook#toc4
(defun string/ends-with (s ending)
  "return non-nil if string S ends with ENDING."
  (cond ((>= (length s) (length ending))
	 (let ((elength (length ending)))
	   (string= (substring s (- 0 elength)) ending)))
	(t nil)))

(org-add-link-type 
 "list-of-figures"
 (lambda (link-string)
   (let* ((c-b (buffer-name))
          (counter 0)
          (list-of-figures 
           (org-element-map (org-element-parse-buffer) 'link
             (lambda (link) 
               "create a link for to the figure"
	       (when 
		   (and (string= (org-element-property :type link) "file")
			(string-match-p  
			 "[^.]*\\.\\(png\\|jpg\\)$"
			 (org-element-property :path link)))                   
		 (incf counter)
		 
		 (let* ((start (org-element-property :begin link))
			(parent (car (cdr (org-element-property :parent link))))
			(caption (caaar (plist-get parent :caption)))
			(name (plist-get parent :name)))
		   (if caption 
		       (format 
			"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n" 
			c-b start counter (or name "") caption)
		     (format 
		      "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n" 
		      c-b start counter (or name "")))))))))
	  (switch-to-buffer "*List of Figures*")
	  (org-mode)
	  (erase-buffer)
	  (insert (mapconcat 'identity list-of-figures ""))
	  (setq buffer-read-only t)
	  (use-local-map (copy-keymap org-mode-map))
	  (local-set-key "q" #'(lambda () (interactive) (kill-buffer)))))
   (lambda (keyword desc format)
     (cond
      ((eq format 'latex)
       (format "\\listoffigures")))))
#+END_SRC



This is a test to see if our function works for other image types.
[[./images/smiley.jpg]]

And a link to test it out: 

[[list-of-figures:clickme][List of Figures]]   

This works too. I am not sure I am getting the figure name and caption in a bulletproof way. They seem to be buried in the :parent of the element, which is a paragraph element. The caption seems to be buried in a few sets of parentheses, hence the use of =caaar= to get the caption out. I am not sure if the caption is always at that depth or not. As a proof of concept though, this is not too bad. 

* DONE Getting a list of tables in an org-buffer
  CLOSED: [2014-03-01 Sat 18:12]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/03/01 18:12:15
  :updated:  2014/03/02 08:02:52
  :END:

In a large document it might be nice to quickly get a list of tables. Preferrably by clicking on a link that generates the list, and exports appropriately, e.g. =listoftables= for LaTeX. A link like this:

[[list-of-tables:clickme][List of Tables]]

Before getting to the code that does what we need, let us make some tables. We make three different kinds of tables for fun. A named table, an unnamed table, and a table with a caption. 

#+tblname: first-table
| 1 | 2 |
| a | b |


# unnamed table
| t | y |
| 5 | 6 |


#+caption: column of numbers
#+tblname: tbl-with-caption
| 34 |
|  6 |
|  6 |


We would like a function that creates a buffer with a list of the tables, and links to them. We include the table name, and caption if there is one. We will create an org-buffer, and use org-links to the tables. Here is a link definition that will do that.

#+BEGIN_SRC emacs-lisp :results output raw
(org-add-link-type 
 "list-of-tables"
 (lambda (link-string)
   (let* ((c-b (buffer-name))
	  (counter 0)
	  (list-of-tables 
	   (org-element-map (org-element-parse-buffer 'element) 'table
	     (lambda (table) 
	       "create a link for to the table"
	       (incf counter)
	       (let ((start (org-element-property :begin table))
                     (name  (org-element-property :name table))
		     (caption (caaar (org-element-property :caption table))))
		 (if caption 
		     (format 
		      "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]] %s\n" 
		      c-b start counter (or name "") caption)
		   (format 
		    "[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]]\n" 
		    c-b start counter (or name ""))))))))
     (switch-to-buffer "*List of Tables*")
     (org-mode)
     (erase-buffer)
     (insert (mapconcat 'identity list-of-tables ""))))
 (lambda (keyword desc format)
   (cond
    ((eq format 'latex)
     (format "\\listoftables")))))
#+END_SRC

#+RESULTS:

A list of figures would only be a little trickier. You would map over the links, and find the file type links that have a select number of extensions, e.g. png, jpg, etc...

* Advising org-ctrl-c-ctrl-c
  :PROPERTIES:
  :categories: org-mode,emacs
  :END:
I use a lot of equations in org-mode, and I like to use the LaTeX overlays (C-c C-x C-l (org-preview-latex-fragment)). I also use a lot of code blocks in my org-documents, and I like to run them during lectures, which I do with C-c C-c. However, this also removes the overlays from my equations, causing two irritations: 1) the code did not run when I thought it would, and I have to press C-c C-c again, 2) the equations that the code implements disappears so then I have C-c C-x C-l to get them back.  A lot of extra key strokes. The issue is one line in org.el at line 20222: (org-remove-latex-fragment-image-overlays).

I have been thinking about how to change that behavior. I do not want to patch my org-mode, because I do not want to deal with future updates. The simplest idea is to just redefine that function in my init files, with the offending line commented out. Here it is.

#+BEGIN_SRC emacs-lisp
(defun org-ctrl-c-ctrl-c (&optional arg)
  "Set tags in headline, or update according to changed information at point.

This command does many different things, depending on context:

- If a function in `org-ctrl-c-ctrl-c-hook' recognizes this location,
  this is what we do.

- If the cursor is on a statistics cookie, update it.

- If the cursor is in a headline, prompt for tags and insert them
  into the current line, aligned to `org-tags-column'.  When called
  with prefix arg, realign all tags in the current buffer.

- If the cursor is in one of the special #+KEYWORD lines, this
  triggers scanning the buffer for these lines and updating the
  information.

- If the cursor is inside a table, realign the table.  This command
  works even if the automatic table editor has been turned off.

- If the cursor is on a #+TBLFM line, re-apply the formulas to
  the entire table.

- If the cursor is at a footnote reference or definition, jump to
  the corresponding definition or references, respectively.

- If the cursor is a the beginning of a dynamic block, update it.

- If the current buffer is a capture buffer, close note and file it.

- If the cursor is on a <<<target>>>, update radio targets and
  corresponding links in this buffer.

- If the cursor is on a numbered item in a plain list, renumber the
  ordered list.

- If the cursor is on a checkbox, toggle it.

- If the cursor is on a code block, evaluate it.  The variable
  `org-confirm-babel-evaluate' can be used to control prompting
  before code block evaluation, by default every code block
  evaluation requires confirmation.  Code block evaluation can be
  inhibited by setting `org-babel-no-eval-on-ctrl-c-ctrl-c'."
  (interactive "P")
  (cond
   ((or (and (boundp 'org-clock-overlays) org-clock-overlays)
	org-occur-highlights
	org-latex-fragment-image-overlays)
    (and (boundp 'org-clock-overlays) (org-clock-remove-overlays))
    (org-remove-occur-highlights)
    ;; commented out by jkitchin 2014-03-01 to avoid removing latex images 
    ;; on running code blocks.
    ;(org-remove-latex-fragment-image-overlays)
    (message "Temporary highlights/overlays removed from current buffer"))
   ((and (local-variable-p 'org-finish-function (current-buffer))
	 (fboundp org-finish-function))
    (funcall org-finish-function))
   ((run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-hook))
   (t
    (let* ((context (org-element-context)) (type (org-element-type context)))
      ;; Test if point is within a blank line.
      (if (save-excursion (beginning-of-line) (looking-at "[ \t]*$"))
	  (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	      (user-error "C-c C-c can do nothing useful at this location"))
	(case type
	  ;; When at a link, act according to the parent instead.
	  (link (setq context (org-element-property :parent context))
		(setq type (org-element-type context)))
	  ;; Unsupported object types: check parent element instead.
	  ((bold code entity export-snippet inline-babel-call inline-src-block
		 italic latex-fragment line-break macro strike-through subscript
		 superscript underline verbatim)
	   (while (and (setq context (org-element-property :parent context))
		       (not (memq (setq type (org-element-type context))
				  '(paragraph verse-block table-cell)))))))
	;; For convenience: at the first line of a paragraph on the
	;; same line as an item, apply function on that item instead.
	(when (eq type 'paragraph)
	  (let ((parent (org-element-property :parent context)))
	    (when (and (eq (org-element-type parent) 'item)
		       (= (point-at-bol) (org-element-property :begin parent)))
	      (setq context parent type 'item))))
	;; Act according to type of element or object at point.
	(case type
	  (clock (org-clock-update-time-maybe))
	  (dynamic-block
	   (save-excursion
	     (goto-char (org-element-property :post-affiliated context))
	     (org-update-dblock)))
	  (footnote-definition
	   (goto-char (org-element-property :post-affiliated context))
	   (call-interactively 'org-footnote-action))
	  (footnote-reference (call-interactively 'org-footnote-action))
	  ((headline inlinetask)
	   (save-excursion (goto-char (org-element-property :begin context))
			   (call-interactively 'org-set-tags)))
	  (item
	   ;; At an item: a double C-u set checkbox to "[-]"
	   ;; unconditionally, whereas a single one will toggle its
	   ;; presence.  Without an universal argument, if the item
	   ;; has a checkbox, toggle it.  Otherwise repair the list.
	   (let* ((box (org-element-property :checkbox context))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (parents (org-list-parents-alist struct))
		  (prevs (org-list-prevs-alist struct))
		  (orderedp (org-not-nil (org-entry-get nil "ORDERED"))))
	     (org-list-set-checkbox
	      (org-element-property :begin context) struct
	      (cond ((equal arg '(16)) "[-]")
		    ((and (not box) (equal arg '(4))) "[ ]")
		    ((or (not box) (equal arg '(4))) nil)
		    ((eq box 'on) "[ ]")
		    (t "[X]")))
	     ;; Mimic `org-list-write-struct' but with grabbing
	     ;; a return value from `org-list-struct-fix-box'.
	     (org-list-struct-fix-ind struct parents 2)
	     (org-list-struct-fix-item-end struct)
	     (org-list-struct-fix-bul struct prevs)
	     (org-list-struct-fix-ind struct parents)
	     (let ((block-item
		    (org-list-struct-fix-box struct parents prevs orderedp)))
	       (if (and box (equal struct old-struct))
		   (if (equal arg '(16))
		       (message "Checkboxes already reset")
		     (user-error "Cannot toggle this checkbox: %s"
				 (if (eq box 'on)
				     "all subitems checked"
				   "unchecked subitems")))
		 (org-list-struct-apply-struct struct old-struct)
		 (org-update-checkbox-count-maybe))
	       (when block-item
		 (message "Checkboxes were removed due to empty box at line %d"
			  (org-current-line block-item))))))
	  (keyword
	   (let ((org-inhibit-startup-visibility-stuff t)
		 (org-startup-align-all-tables nil))
	     (when (boundp 'org-table-coordinate-overlays)
	       (mapc 'delete-overlay org-table-coordinate-overlays)
	       (setq org-table-coordinate-overlays nil))
	     (org-save-outline-visibility 'use-markers (org-mode-restart)))
	   (message "Local setup has been refreshed"))
	  (plain-list
	   ;; At a plain list, with a double C-u argument, set
	   ;; checkboxes of each item to "[-]", whereas a single one
	   ;; will toggle their presence according to the state of the
	   ;; first item in the list.  Without an argument, repair the
	   ;; list.
	   (let* ((begin (org-element-property :contents-begin context))
		  (beginm (move-marker (make-marker) begin))
		  (struct (org-element-property :structure context))
		  (old-struct (copy-tree struct))
		  (first-box (save-excursion
			       (goto-char begin)
			       (looking-at org-list-full-item-re)
			       (match-string-no-properties 3)))
		  (new-box (cond ((equal arg '(16)) "[-]")
				 ((equal arg '(4)) (unless first-box "[ ]"))
				 ((equal first-box "[X]") "[ ]")
				 (t "[X]"))))
	     (cond
	      (arg
	       (mapc (lambda (pos) (org-list-set-checkbox pos struct new-box))
		     (org-list-get-all-items
		      begin struct (org-list-prevs-alist struct))))
	      ((and first-box (eq (point) begin))
	       ;; For convenience, when point is at bol on the first
	       ;; item of the list and no argument is provided, simply
	       ;; toggle checkbox of that item, if any.
	       (org-list-set-checkbox begin struct new-box)))
	     (org-list-write-struct
	      struct (org-list-parents-alist struct) old-struct)
	     (org-update-checkbox-count-maybe)
	     (save-excursion (goto-char beginm) (org-list-send-list 'maybe))))
	  ((property-drawer node-property)
	   (call-interactively 'org-property-action))
	  ((radio-target target)
	   (call-interactively 'org-update-radio-target-regexp))
	  (statistics-cookie
	   (call-interactively 'org-update-statistics-cookies))
	  ((table table-cell table-row)
	   ;; At a table, recalculate every field and align it.  Also
	   ;; send the table if necessary.  If the table has
	   ;; a `table.el' type, just give up.  At a table row or
	   ;; cell, maybe recalculate line but always align table.
	   (if (eq (org-element-property :type context) 'table.el)
	       (message "Use C-c ' to edit table.el tables")
	     (let ((org-enable-table-editor t))
	       (if (or (eq type 'table)
		       ;; Check if point is at a TBLFM line.
		       (and (eq type 'table-row)
			    (= (point) (org-element-property :end context))))
		   (save-excursion
		     (if (org-at-TBLFM-p)
			 (progn (require 'org-table)
				(org-table-calc-current-TBLFM))
		       (goto-char (org-element-property :contents-begin context))
		       (org-call-with-arg 'org-table-recalculate (or arg t))
		       (orgtbl-send-table 'maybe)))
		 (org-table-maybe-eval-formula)
		 (cond (arg (call-interactively 'org-table-recalculate))
		       ((org-table-maybe-recalculate-line))
		       (t (org-table-align)))))))
	  (timestamp (org-timestamp-change 0 'day))
	  (otherwise
	   (or (run-hook-with-args-until-success 'org-ctrl-c-ctrl-c-final-hook)
	       (user-error
		"C-c C-c can do nothing useful at this location")))))))))
#+END_SRC


$x^2$

* DONE Interesting online python sites
  CLOSED: [2014-01-27 Mon 13:51]
  :PROPERTIES:
  :categories: python
  :date:     2013/02/28 18:58:21
  :updated:  2013/02/28 19:01:33
  :permalink: http://jkitchin.github.com/blog/2013-02-28-interesting-online-python-sites/index.html
  :END:
I have come across some very interesting online, /interactive/ python sites recently.

- http://interactivepython.org has some interactive books with embedded python interpreters in the exercises.

- sympy actually has an [[http://live.sympy.org/][online shell]]! The [[http://docs.sympy.org/0.7.2/index.html][documentation]] has live examples in a shell you can use that is integrated with Sphinx.

Here are a few others I came across:
- https://www.pythonanywhere.com/try-ipython/ Ipython in your browser!
- http://www.trypython.org/#
- http://www.pythontutor.com/
- http://py-ide-online.appspot.com/

* DONE An index function for strings in emacs-lisp
  CLOSED: [2013-12-22 Sun 12:05]
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2013/03/05 19:28:30
  :updated:  2013/03/05 19:28:31
  :END:

I could not find an index function for strings in emacs-lisp. The =position= function seems to work for numbers, but not strings. Here is a version that works on strings.
#+BEGIN_SRC emacs-lisp :results value verbatim
(defun index (item list)
  "return index of item in list or nil"
  (let ((counter 0)
        (found nil))
    (dolist (listelement list counter)
      (if (string= item listelement)
        (progn
          (setq found t)
          (return counter)) ; exit the loop
        ;; else increment counter
        (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil)))
#+END_SRC

#+RESULTS:
: index

Here are some example uses:

#+BEGIN_SRC emacs-lisp :results value
(index "test" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: 1

#+BEGIN_SRC emacs-lisp :results value
(index "z" '("a" "b" "z"))
#+END_SRC

#+RESULTS:
: 2

#+BEGIN_SRC emacs-lisp :results value verbatim
(index "testy" '("a" "test" "y"))
#+END_SRC

#+RESULTS:
: nil

This raises an error because we use string=.

#+BEGIN_SRC emacs-lisp :results value verbatim
(index 1 '("a" "test" "y" 1))
#+END_SRC
* DONE Integrating the Fermi distribution to compute entropy
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: dft, integration, gotcha
  :date:     2013/03/06 09:39:42
  :updated:  2013/03/06 09:47:19
  :END:

The Fermi distribution is defined by $f(\epsilon) = \frac{1}{e^{(\epsilon - \mu)/(k T)} + 1}$. This function describes the occupation of energy levels at temperatures above absolute zero. We use this function to compute electronic entropy in a metal, which contains an integral of $\int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon$, where $n(\epsilon)$ is the electronic density of states. Here we plot the Fermi distribution function. It shows that well below the Fermi level the states are fully occupied, and well above the Fermi level, they are unoccupied. Near the Fermi level, the states go from occupied to unoccupied smoothly.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.linspace(-10, 10, 200)
plt.plot(espan, f(espan))
plt.ylim([-0.1, 1.1])
plt.savefig('images/fermi-entropy-integrand-1.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-1.png]]

Let us consider a simple density of states function, just a parabola. This could represent a s-band for example. We will use this function to explore the integral.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def f(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)
espan = np.linspace(-10, 10)

plt.plot(espan, dos(espan), label='Total dos')
plt.plot(espan, f(espan) * dos(espan), label='Occupied states')
plt.legend(loc='best')
plt.savefig('images/fermi-entropy-integrand-2.png')
#+END_SRC

#+RESULTS:

[[./images/fermi-entropy-integrand-2.png]]
Now, we consider the integral to compute the electronic entropy. The entropy is proportional to this integral.

\( \int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon \)

It looks straightforward to compute, but it turns out there is a wrinkle. Evaluating the integrand leads to =nan= elements because the ln(0) is -\infty.

#+BEGIN_SRC python
import numpy as np
mu = 0
k = 8.6e-5
T = 100

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.array([-20, -10, -5, 0.0, 5, 10])
f = fermi(espan)

print f * np.log(f)
print (1 - f) * np.log(1 - f)
#+END_SRC

#+RESULTS:
: [  0.00000000e+000   0.00000000e+000   0.00000000e+000  -3.46573590e-001
:   -1.85216532e-250               nan]
: [        nan         nan         nan -0.34657359  0.          0.        ]

In this case, these =nan= elements should be equal to zero (x ln(x) goes to zero as x goes to zero). So, we can just ignore those elements in the integral. Here is how to do that.

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt

mu = 0
k = 8.6e-5
T = 1000

def fermi(e):
    return 1.0 / (np.exp((e - mu)/(k*T)) + 1)

def dos(e):
    d = (np.ones(e.shape) - 0.03 * e**2)
    return d * (d > 0)

espan = np.linspace(-20, 10)
f = fermi(espan)
n = dos(espan)

g = n * (f * np.log(f) + (1 - f) * np.log(1 - f))

print np.trapz(espan, g) # nan because of the nan in the g vector
print g

plt.plot(espan, g)
plt.savefig('images/fermi-entropy-integrand-3.png')

# find the elements that are not nan
ind = np.logical_not(np.isnan(g))

# evaluate the integrand for only those points
print np.trapz(espan[ind], g[ind])
#+END_SRC

#+RESULTS:
#+begin_example
nan
[             nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
  -9.75109643e-14  -1.05987106e-10  -1.04640574e-07  -8.76265644e-05
  -4.92684641e-02  -2.91047740e-01  -7.75652579e-04  -1.00962241e-06
  -1.06972936e-09  -1.00527877e-12  -8.36436686e-16  -6.48930917e-19
  -4.37946336e-22  -2.23285389e-25  -1.88578082e-29   0.00000000e+00
   0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00
   0.00000000e+00   0.00000000e+00]
0.208886080897
#+end_example

[[./images/fermi-entropy-integrand-3.png]]

The integrand is pretty well behaved in the figure above. You do not see the full range of the x-axis, because the integrand evaluates to =nan= for very negative numbers. This causes the =trapz= function to return =nan= also. We can solve the problem by only integrating the parts that are not =nan=. We have to use numpy.logical_not to get an element-wise array of which elements are not =nan=. In this example, the integrand is not well sampled, so the area under that curve may not be very accurate.

* DONE Uncertainty in implicit functions
  CLOSED: [2013-12-22 Sun 12:04]
  :PROPERTIES:
  :categories: statistics
  :date:     2013/03/08 17:04:02
  :updated:  2013/03/14 15:34:19
  :END:
Suppose we have an equation $y = e^{a y}$ that we want to solve, where $a$ is a constant with some uncertainty. What is the uncertainty in the solution $y$?

Finding a solution is not difficult. The uncertainty in the solution, however, is not easy, since we do not have an explicit function to propagate errors through. Let us examine the solution first.
#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve

a = 0.20

def f(y):
    return y - np.exp(a * y)

sol, = fsolve(f, 1)
print sol
#+END_SRC

#+RESULTS:
: 1.2958555091

A way to estimate the uncertainty is by Monte Carlo simulation. We solve the equation many times, using values sampled from the uncertainty distribution. Here we assume that the $a$ parameter is normally distributed  with an average of 0.2 and a std deviation of 0.02. We solve the equation 10000 times for different values of $a$ sampled according to the normal distribution. That gives us a distribution of solutions that we can do statistical analysis of to get the average and std deviation.

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
N = 10000

A = np.random.normal(0.2, 0.02, size=N)

sol = np.zeros(A.shape)

for i, a in enumerate(A):
    s, = fsolve(lambda y:y - np.exp(a * y), 1)
    sol[i] = s

ybar = np.mean(sol)
s_y = np.std(sol)

print ybar, s_y, s_y / ybar

import matplotlib.pyplot as plt
count, bins, ignored = plt.hist(sol)
plt.savefig('images/implicit-uncertainty.png')
#+END_SRC

#+RESULTS:
: 1.29887470397 0.0465110111613 0.0358086973433

We get approximately the same answer, and you can see here the distribution of solution values is not quite normal. We compute the standard deviation anyway, and find the standard deviation is about 3.6%. It would be nice to have some analytical method to estimate this uncertainty. So far I have not figured that out.

This method could have relevance in estimating the uncertainty in the friction factor for turbulent flow ($Re > 2100$). In that case we have the implicit equation $\frac{1}{\sqrt{f_F}}=4.0 \log(Re \sqrt{f_F})-0.4$. Uncertainties in the Re number would lead to uncertainties in the friction factor. Whether those uncertainties are larger than the uncertainties from the original correlation would require some investigation.

* DONE Capturing stderr and exceptions from python in org-mode
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :categories: org-mode,python
  :date:     2013/09/27 19:37:05
  :updated:  2013/09/27 19:47:53
  :END:
I have used org-mode extensively to create examples of using python using the code blocks. For example to illustrate the difference between integer and float division you can do this:

#+BEGIN_SRC python
print 1 / 3
print 1.0 / 3.0
#+END_SRC

#+RESULTS:
: 0
: 0.333333333333

There are some limitations to showing output though. For example, the code blocks do not capture anything from stderr.

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:

And exceptions result in no output whatsoever. That is not helpful if you are trying to teach about exceptions!

I discovered a way around this. The key is using a python sandbox that redirects stdout, stderr and that captures anything sent to those channels. You can also capture any exceptions, and redirect them to a variable. Finally, you can construct the output anyway you see fit.

Below is the code that runs python code in a sandbox, with redirected outputs. I defined a function that temporarily redirects the output to stdout and stderr, so they can be captured. I execute the code wrapped in a try/except block to capture any exceptions that occur. Finally, I construct a string formatted in a way that lets you know what was on stdout, stderr, and what was an exception.

#+BEGIN_SRC python :tangle sandbox.py
#!/usr/bin/env python
from cStringIO import StringIO
import os, sys

def Sandbox(code):
    '''Given code as a string, execute it in a sandboxed python environment

    return the output, stderr, and any exception code
    '''
    old_stdout = sys.stdout
    old_stderr = sys.stderr
    redirected_output = sys.stdout = StringIO()
    redirected_error = sys.stderr = StringIO()

    ns_globals = {}
    ns_locals = {}
    out, err, exc = None, None, None

    try:
        exec(code, ns_globals, ns_locals)
    except:
        import traceback
        exc = traceback.format_exc()

    out = redirected_output.getvalue()
    err = redirected_error.getvalue()

    # reset outputs to the original values
    sys.stdout = old_stdout
    sys.stderr = old_stderr

    return out, err, exc


if __name__ == '__main__':
    content = sys.stdin.read()
    out, err, exc =  Sandbox(content)

    s = '''---stdout-----------------------------------------------------------
{0}
'''.format(out)

    if err:
        s += '''---stderr-----------------------------------------------------------
{0}
'''.format(err)

    if exc:
        s += '''---Exception--------------------------------------------------------
{0}
'''.format(exc)

    print s

#+END_SRC

To use this, we have to put this file (sandbox.py) in our PYTHONPATH. Then, we tell org-babel to run python using our new sandbox.py module. org-babel pipes the code in a src block to stdin of the python command, which will be intercepted by our sandbox module. If you put this in your init.el, or other customization location, then subsequent uses of python in org-mode will use your sandbox module. I usually only run this for a session as needed.

#+BEGIN_SRC emacs-lisp
(setq org-babel-python-command "python -m sandbox")
#+END_SRC

Now, when we use python, we can capture output to stderr!

#+BEGIN_SRC python
import sys

print >>sys.stderr, 'message to stderr'
#+END_SRC

#+RESULTS:
: ---stdout-----------------------------------------------------------
:
: ---stderr-----------------------------------------------------------
: message to stderr
:
:
And, we can capture exceptions!

#+BEGIN_SRC python
print 1 / 0
#+END_SRC

#+RESULTS:
#+begin_example
---stdout-----------------------------------------------------------

---Exception--------------------------------------------------------
Traceback (most recent call last):
  File "c:\Users\jkitchin\Dropbox\blogofile-jkitchin.github.com\_blog\sandbox.py", line 20, in Sandbox
    exec(code, ns_globals, ns_locals)
  File "<string>", line 1, in <module>
ZeroDivisionError: integer division or modulo by zero


#+end_example

There is a little obfuscation in the exception, since it technically occurs in the Sandbox, but this is better than getting no output whatsoever! I have not tested the sandbox.py code extensively, so I don't know if there will be things that do not work as expected. If you find any, please let me know!
* DONE Notice anything different
  CLOSED: [2013-12-22 Sun 12:03]
  :PROPERTIES:
  :date:     2013/09/29 11:07:00
  :updated:  2013/09/29 11:41:28
  :END:
Based on the last few posts on [[http://jkitchin.github.io/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/][making links to external files work in the blog]], and [[http://jkitchin.github.io/blog/2013/09/28/Customizing-export-of-code-blocks-in-HTML/][customizing code block export in HTML]], I have rewritten [[https://github.com/jkitchin/jmax/blob/prelude/blogofile.el][blogofile.el]] to more cleanly support the use of images and data files in my blog posts. Now, I should be able to include a data file (like this [[../../pycse/data/antoine_data.dat][one]]) in a post and you should be able to click on the link to open it after I publish the post in the usual way by pressing F10. That should process the post, construct URLs for all the links, including images, copy the relevant files to the blog directory, and generate the HTML file for blogofile to build. This is a little more robust than it used to be, as all files are stored in a directory named based on the post title, so there is less concern of using duplicate filenames for images and datafiles.

Here is a gratuitous image, just to see if it works ;)

#+CAPTION: test image
[[./images/heat-transfer-roots-1.png]]

Hopefully, there is nothing different on the outside! URLs to images are now in a different place, but that should not be apparent unless you read source code. The real difference is that now there are working links to data files! And it is easier for me to write my posts including them, with simple publishing.
* DONE Enabling right-clicks in org-mode links
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/10/21 19:58:52
  :updated:  2013/10/21 20:45:37
  :END:
Out of the box you can click on org-mode links to make the do things. On my machine, all clicks are equal, left mouse, middle mouse, and right mouse all act as a "click". I was curious about whether I could get different behavior on a link with a left or right mouse click. It is easy enough to [[http://orgmode.org/manual/Adding-hyperlink-types.html][define a new link type]]. You define a function that is run when you click on the link.

To figure out what to do here, I looked into the events handling in emacs. According to this [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Click-Events.html][page]], there are click events. So, after we click on a link, there should be a click event which was the last input event. We can get that, figure out which button was pressed, and run code accordingly. We will make the code add some lines to the buffer after the link about what happened.

Here is my link definition.

#+BEGIN_SRC emacs-lisp
(setq counter 1)
(org-add-link-type
 "test"
 ;; this function is run when you click
 (lambda (link-string)
   (let ((button (car last-input-event)))
     (cond ((eq button 'mouse-1)
            (end-of-line)
            (insert (format "\nclick %s. mouse-1 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-2)
            (end-of-line)
            (insert (format "\nclick %s. mouse-2 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1)))
           ((eq button 'mouse-3)
            (end-of-line)
            (insert (format "\nclick %s. mouse-3 pressed %s\n" counter last-input-event))
            (setq counter (+ counter 1))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "<pre>%s:%s</pre>" keyword desc)))))
#+END_SRC


Here we make a link. When you click on it, it adds lines right after the link telling you what was clicked on. I left-clicked, middle-clicked and right-clicked. The right-clicked result is the first line.

test:which-button
click 3. mouse-3 pressed (mouse-3 (#<window 46 on blog.org> 56959 (57 . 456) -320964819 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 2. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320965724 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))

click 1. mouse-2 pressed (mouse-2 (#<window 46 on blog.org> 56959 (57 . 456) -320966660 nil 56959 (7 . 28) nil (1 . 8) (8 . 16)))


Curiously, this only shows that mouse-2 (for left or middle mouse) or mouse-3 (for right click) was pressed, never mouse-1. I am not sure what causes that. If I try to capture an event it does show mouse-1 is active.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (down-mouse-1 (#<window 34 on blog.org> 56437 (253 . 308) -322917920 nil 56437 (31 . 19) nil (93 . 4) (8 . 16)))

Anyway, it looks conceivable that you could have different link actions occur for different mouse clicks. I could see using this in a citation link, where a left click might open the citation in my bibtex file, and right clicking would open a pdf of the citation if it existed.

I have not figured out how flexible this might be, for example could you use modifier keys with mouse clicks? This code suggests that it is possible in emacs, but so far none of these make it into the last-input-event in the org-link clicks.

#+BEGIN_SRC emacs-lisp
(princ (read-event))
#+END_SRC

#+RESULTS:
: (S-down-mouse-1 (#<window 34 on blog.org> 56725 (1 . 299) -322897656 nil 56725 (0 . 18) nil (1 . 11) (8 . 16)))

It might be difficult remembering all the modifiers and clicks, but it would be cool if it was possible!
* DONE Hatched symbols in matplotlib
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: plotting
  :date:     2013/10/26 14:35:19
  :updated:  2013/10/26 14:35:19
  :END:
I learned something new about matplotlib today: How to make hatched (patterned) symbols in a plot. Well, sort of. The scatter plot in matplotlib has a hatch keyword argument that specifies a pattern on the marker. Below, is an example that runs through a handful of hatch patterns, on randomly selected symbols.

Curiously, hatch is not a kwarg of the scatter function, but of [[http://matplotlib.org/api/collections_api.html#matplotlib.collections.Collection.set_hatch][collections]]. Anyway, let us see how to get the hatched symbols.

#+BEGIN_SRC python
import random
import numpy as np
import matplotlib.pyplot as plt

patterns = ('-', '+', 'x', '\\', '*', 'o', 'O', '.', '/')
markers = 'os<^>p*'
for pattern in patterns:
    plt.scatter(np.random.uniform(size=(3,1)), np.random.uniform(size=(3,1)), s=1000,
                marker=random.choice(markers),
                facecolor='white',
                hatch=3*pattern, label=pattern)

plt.legend(scatterpoints=1, loc='best')
plt.savefig('images/hatched-symbols.png')
#+END_SRC

#+RESULTS:

[[./images/hatched-symbols.png]]

There are some other interesting things you can do with [[http://matplotlib.org/examples/pylab_examples/filledmarker_demo.html][filled markers]], [[http://matplotlib.org/examples/pylab_examples/contourf_hatching.html][hatched contours]] and with [[http://matplotlib.org/examples/pylab_examples/hatch_demo.html][hatched bar graphs]]. Note this hatching is specific to plt.scatter. It does not work with plt.plot.

* DONE Automating Adobe Acrobat Pro with python
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: automation,pdf
  :date:     2013/11/23 10:34:47
  :updated:  2013/11/23 10:34:47
  :END:

I have a need to automate Adobe Pro for a couple of applications:

1. I could use Adobe Pro to automatically add rubric pages to assignments before grading them. The rubric has embedded javascript that stores the grade inside the pdf file.
2. I could use Adobe Pro to extract information, e.g. grades, stored in a set of PDF files for analysis.

I came across this [[http://win32com.goermezer.de/content/view/232/288/][script]] to automate Adobe Pro using python and OLE automation.  Two other useful references are:

1. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_api_reference.pdf
2. http://www.adobe.com/content/dam/Adobe/en/devnet/acrobat/pdfs/iac_developer_guide.pdf

In this post, we look at some simple code to get data out of a pdf.  We start with just opening a PDF file.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)

app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:

Opening and closing a file is not that useful.  Here, we can get some information out of the file. The pdf we looked at above has a custom property =PTEX.Fullbanner= from pdflatex. We can extract it like this.

#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('writing-exams-in-orgmode.pdf')

app = Dispatch("AcroExch.AVDoc")

app.Open(src, src)
pddoc = app.GetPDDoc()
print pddoc.GetInfo('PTEX.Fullbanner')

print pddoc.GetNumPages()
app.Close(-1)  # do not save on close
#+END_SRC

#+RESULTS:
: This is MiKTeX-pdfTeX 2.9.4535 (1.40.13)
: 5


Finally, let us try inserting pages. I have a [[../../CMU/classes/06-625/rubric/rubric.pdf][rubric file ]] that I want to insert at the end of the [[writing-exams-in-orgmode.pdf][pdf]] above. We will open both documents, insert the rubric, and save the result as a new file.


#+BEGIN_SRC python
import os
from win32com.client.dynamic import Dispatch
src = os.path.abspath('../../CMU/classes/06-625/rubric/rubric.pdf')
src2 = os.path.abspath('writing-exams-in-orgmode.pdf')

# It seems I need two of these
avdoc1 = Dispatch("AcroExch.AVDoc")
avdoc2 = Dispatch("AcroExch.AVDoc")

# this is the rubric
avdoc1.Open(src, src)
pddoc1 = avdoc1.GetPDDoc()
N1 = pddoc1.GetNumPages()

# this is the other doc
avdoc2.Open(src2, src2)
pddoc2 = avdoc2.GetPDDoc()
N2 = pddoc2.GetNumPages()

# Insert rubric after last page of the other doc. pages start at 0
pddoc2.InsertPages(N2 - 1, pddoc1, 0, N1, 0)

# save as a new file. 1 means full save at absolute path provided.
pddoc2.Save(1, os.path.abspath('./woohoo.pdf'))

# close files.
avdoc1.Close(-1)
avdoc2.Close(-1)
#+END_SRC

#+RESULTS:

Here is our result: [[./woohoo.pdf]]. I went ahead and gave myself an A ;).

** Summary
It looks like I can replace the dependence of my box-course code on all the python-based pdf libraries (which are not fully functional, and do not work on all pdfs), and on pdftk, with this automation approach of Adobe Pro. It is unfortunate that it is not a free program, but i would expect it to work on all PDF files, and it provides features like combining PDFs with their javascript, that /no/ other PDF package has. I have tried other PDF programs to combine the rubric and assignment page, but they all lose the javascript. With this method, I could keep a set of enriched rubric files for different types of assignments, and add them to assignments as part of the assessment process.
* DONE Selectively exporting headlines in org-mode
  CLOSED: [2013-12-22 Sun 12:02]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/08 16:35:35
  :updated:  2013/12/08 16:35:35
  :END:
I have on several occasions needed to selectively export only portions of an org document. For example, I may write a problem set or exam, and have some headlines that are the problems, and others that are the solutions. Or, I may have done some analysis in a headline, e.g. statistics of problem scores that I do not want in exported content, or I have a manuscript with a supporting information section that does not go in the exported manuscript, and the manuscript cannot go in the supporting information file.

org-mode supports [[http://www.gnu.org/software/emacs/manual/html_node/org/Selective-export.html][selective export]] through use of tags. However, this is inflexible if you want to export multiple different documents with different selective exports, unless you don't mind changing the settings, or commenting and uncommenting lines all the time.

Enter dynamic binding of variables in emacs-lisp. We can temporarily define variables, especially =org-export-select-tags= and =org-export-exclude-tags=, and write emacs-lisp code blocks to export the current document the way we want. First, let us create some headlines.

** problem 1                                                        :problem:
description of a hard problem
*** solution to problem 1                                          :solution:
it is an easy solution
** problem 2                                                        :problem:
what is the square root of 100?
*** solution to problem 2                                          :solution:
why it's 10 of course.

** Code to export                                                      :code:

*** Export just the problems
First, let us output this document with just the problems. The code block does that, just put your cursor in in block and press C-c C-c (in emacs of course).

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("solution" "code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-1.pdf")
#+END_SRC

#+RESULTS:

You get this: [[./blog-1.pdf]] which only has the problems in it.

*** Problems and solutions
Next, we consider the problems and the solutions. We cannot just get solutions in this document because solutions are nested in the problems.

#+BEGIN_SRC emacs-lisp
(let ((org-export-exclude-tags '("code"))
      (org-latex-default-packages-alist
       '(("" "lmodern" nil)
         ("linktocpage,
  pdfstartview=FitH,
  colorlinks,
  linkcolor=blue,
  anchorcolor=blue,
  citecolor=blue,
  filecolor=blue,
  menucolor=blue,
  urlcolor=blue" "hyperref" t)))
      (async nil)
      (subtreep nil)
      (visible-only nil)
      (body-only nil)
      (ext-plist '()))
  (org-latex-export-to-pdf async subtreep visible-only body-only ext-plist))
(rename-file "blog.pdf" "blog-2.pdf" t)
#+END_SRC

#+RESULTS:

This document ([[./blog-2.pdf]]) now has problems and solutions. Note that neither of these documents has the section we labeled =:code:=.

** Summary
Tags are a nice way to label sections. In combination with dynamic binding, you can build code blocks that selectively export pieces of an org-file by temporarily defining the values of variables. In this example, there are four versions of this document: 1) the org-file that contains everything, 2) the html blog post, 3) a pdf with the problems, and 4) a pdf with problems and solutions. Good luck getting that out of a Word file ;)


#+LATEX_CLASS: revtex4-1
#+LATEX_CLASS_OPTIONS: [aps,prb,citeautoscript,preprint,citeautoscript,showkeys]
* DONE Finding the box root directory on a local machine
  CLOSED: [2013-12-22 Sun 11:38]
  :PROPERTIES:
  :categories: box
  :date:     2013/12/22 10:26:24
  :updated:  2013/12/22 10:26:24
  :END:
I am working to automate some aspects of box.com, specifically to create collaborations in folders and tasks on files on my local computer at the command-line. I use Box Sync to mirror folders and files on my local computer, and I would like to open a prompt in one of these folders and type something like:
#+BEGIN_EXAMPLE
box collaborate --role editor someone@gmail.com
#+END_EXAMPLE
to add that person as an editor to my box folder.

The challenge is that I need to know the =id= of that folder on box. Box stores the files on their server by id, not by name, and the root box folder has an id of =0=. On my local computer, the box root folder is where =Box Sync= puts my synchronized files. In my box_course python module I wrote a function that will return the =id= of an item in box given the /box path/ which is relative to the box root directory. For example, here we can get the =id= for a folder called group-course.

#+BEGIN_SRC python
from box_course import box

print box.get_item('/group-course')
#+END_SRC

#+RESULTS:
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

On my local computer, group course is located at C:\Users\jkitchin\Box Sync\group-course, and C:\Users\jkitchin\Box Sync is like the box root directory. So, the challenge is, if I am on the local computer in some directory, how do I determine the box path to that directory?

What I worked out is to start in the current directory, and check directories above this for a file that indicates you are in the box root directory. With Box Sync 3, that file was "Box Sync ReadMe.pdf", but Box Sync 4 does not include that file anymore. I just put a folder of that name in the Box Sync 4 root directory [fn:1].

Here is a way to start in a box directory, and walk up the path to look for the file. We get the path, and then split each directory off the end, checking for the existence of the file, until the path is gone.
#+BEGIN_SRC python
import os
# change into a box directory
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync

That gets us the box root directory. Now, we need to strip this off of the current working directory. We also need to replace all the backslashes that Windows uses with forward slashes so that we can get the id.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
print cwd.replace(wd, '').replace('\\','/')
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course

This seems to work pretty well, but on some Windows machines, the drive letter is lower case, and then this does not work. In that case, we use =os.path.normcase= to make everything consistent.

#+BEGIN_SRC python
import os
os.chdir('C:\Users\jkitchin\Box Sync\group-course')

from box_course import box

cwd = os.getcwd()

wd, last = os.getcwd(), True
while last:
    wd, last = os.path.split(wd)

    cfile = os.path.join(wd, 'Box Sync ReadMe.pdf')
    if os.path.exists(cfile):
        # we found box root
        break

print wd
print cwd
bpath = os.path.normcase(cwd).replace(os.path.normcase(wd), '').replace('\\','/')

print bpath
print box.get_item(bpath)
#+END_SRC

#+RESULTS:
: C:\Users\jkitchin\Box Sync
: C:\Users\jkitchin\Box Sync\group-course
: /group-course
: {u'sequence_id': u'1', u'etag': u'1', u'type': u'folder', u'id': u'1328895168', u'name': u'group-course'}

This seems to work so far. Something similar this is probably done in git repositories, to find the .git file. This is also a useful way to find a config file higher up the path.

* DONE An improved index function for emacs-lisp
  CLOSED: [2013-12-22 Sun 12:01]
  :PROPERTIES:
  :date:     2013/12/22 12:01:48
  :updated:  2013/12/22 12:02:06
  :categories: emacs-lisp
  :END:
I previously worked out an [[http://kitchingroup.cheme.cmu.edu/blog/2013/03/05/An-index-function-for-strings-in-emacs-lisp/][index]] function for a list of strings in emacs-lisp, but at the end I showed it would not work for arbitrary elements of a list. Here is an exercise to improve on that. The goal is a function that looks like this:
#+BEGIN_EXAMPLE
(index 1 '("a" 2 1 "b"))
#+END_EXAMPLE
that would return 2 in this case. Last time I used string=, which is why I could not find a number in the list. This time, we will use =equal= (see http://www.gnu.org/software/emacs/manual/html_node/elisp/Equality-Predicates.html) which compares components of objects for equality. That should let us find arbitrary objects in a list.

Here is our improved function:

#+BEGIN_SRC emacs-lisp
(defun index (object list)
  "return the index of object in list"
  (let ((counter 0)
        (found nil))
    (catch 'finished
      (dolist (listelement list counter)
        (if (equal object listelement)
            (progn
              (setq found t)
              (throw 'finished counter))
          ;; else increment counter
          (incf counter)))
    ;; if we found it return counter otherwise return nil
    (if found counter nil))))
#+END_SRC

#+RESULTS:

Now, let us test some examples:

#+BEGIN_SRC emacs-lisp :results value
(index 1 '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 2

No problem finding a number in a list.

#+BEGIN_SRC emacs-lisp :results value
(index "b" '("a" 2 1 "b"))
#+END_SRC

#+RESULTS:
: 3

How about something more complicated, like a list in a list?
#+BEGIN_SRC emacs-lisp :results value
(index '(1 2) '("a" 2 1 (1 2) "b"))
#+END_SRC

#+RESULTS:
: 3

That looks good.

#+BEGIN_SRC emacs-lisp
(princ (index '(1 2) '("a" 2 1 (2 (1 2)) "b")))
#+END_SRC

#+RESULTS:
: nil

Note, we do not find the nested object. That is ok, the location of that object would require two indices, which this function is not designed for.

Here we consider an object of an a-list
#+BEGIN_SRC emacs-lisp :results value
(index '("nut" . "acorn") '(("nut" . "acorn") ("fruit" . "apple")))
#+END_SRC

#+RESULTS:
: 0

I am not quite sure how you would use that, but it does illustrate the generality of the index function!

* DONE Using data in a table in another org-file
  CLOSED: [2013-12-22 Sun 13:42]
  :PROPERTIES:
  :categories: org-mode
  :date:     2013/12/22 13:42:20
  :updated:  2014/01/16 07:30:30
  :END:
I have found using tables in an org-file as data sources to code blocks very convenient for documenting work. A typical work flow might go like this:
1. Use a code block to generate some data in an org-table.
2. Use another code block to analyze the data.

For example, here is a code block that prints data in a table [fn:2]:
#+BEGIN_SRC python :results raw
import numpy as np

print '#+tblname: cos-data'
print '| x | cos(x)|'
print '|-'

for x in np.linspace(0, 2*np.pi, 10):
    print '|{0}|{1}|'.format(x, np.cos(x))
#+END_SRC

#+RESULTS:
#+tblname: cos-data
| x | cos(x)|
|-
|0.0|1.0|
|0.698131700798|0.766044443119|
|1.3962634016|0.173648177667|
|2.09439510239|-0.5|
|2.79252680319|-0.939692620786|
|3.49065850399|-0.939692620786|
|4.18879020479|-0.5|
|4.88692190558|0.173648177667|
|5.58505360638|0.766044443119|
|6.28318530718|1.0|

Now, we use that table in a code block to plot the data. We do this by using some header arguments to the code block:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=cos-data
#+END_EXAMPLE

Then we can use the =data= variable inside the code block like this:

#+BEGIN_SRC python :var data=cos-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('cos(x)')
plt.savefig('images/cos-plot.png')
#+END_SRC

#+RESULTS:

[[./images/cos-plot.png]]

That is pretty awesome, but what if we have data in a table from another org-file? It turns out we can use it too. I have data for the sin(x) stored in a table called =sin-data= in [[./sin.org]], which I now want to use. We can access that table like this in a header arg:

#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=sin.org:sin-data
#+END_EXAMPLE

And now use the data variable just like before!

#+BEGIN_SRC python :var data=sin.org:sin-data
import numpy as np
import matplotlib.pyplot as plt

data = np.array(data) # data is a list coming in
x = data[:, 0]
y = data[:, 1]
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('sin(x)')
plt.savefig('images/sin-plot.png')
#+END_SRC

#+RESULTS:

[[./images/sin-plot.png]]

This is a powerful capability, as it allows you to pull data from other files into your current analysis. For example, the supporting information files from some of our recent publications have org-files embedded in them with data stored in org-tables. You could use that data in your own analysis without having to type it in yourself. The only thing you need to do is make sure each table in a document is uniquely named.

Special thanks to Eric Schulte for pointing out the syntax for using external tables!

* DONE Python as alternative to Matlab for engineering calculations
  CLOSED: [2013-12-30 Mon 16:05]
  :PROPERTIES:
  :categories: python
  :date:     2013/12/30 15:20:04
  :updated:  2013/12/30 21:15:44
  :END:
For the past year I have been seriously exploring whether Python could be used as a practical alternative to Matlab in engineering calculations, particularly in chemical engineering undergraduate and graduate courses. Matlab is very well suited for these calculations, and I have used it extensively in teaching in the past. For example, there is my Matlab blog (http://matlab.cheme.cmu.edu), and my cmu Matlab package that contains a very nice units package (https://github.com/jkitchin/matlab-cmu). Matlab is widely used and recognized as a standard software package in engineering. My university has a site license for Matlab, so it doesn't cost me or my students anything to use. Matlab is easy to install, and has almost everything we need out of the box. So why try using something else then? Here are the main reasons:

1. Not everyone has access to a "free" Matlab license, and Matlab may not be available to my students when they leave the University. Python offers a free, always available option to them.
2. There are several recent Python distributions that are easy to install, and contain almost everything we need for engineering calculations.
3. I have been increasingly integrating code into my lecture notes, and this is not easy with Matlab, but it is easy with Python.
4. I use Python exclusively in my research, and although Matlab and Python are similar, they are different enough that switching between them is bothersome to me. I do not like teaching students to use tools I do not regularly use, and I believe I can provide them with more value by teaching with tools I have a high level of proficiency in.

** The significance of an open-source alternative
Many people will be able to use Matlab or some other proprietary software that someone has paid for the license to use. Some people, however, will not have that option for a variety of reasons. Maybe the company they work for will not pay for the license, maybe they are unemployed, or entrepeneurs in a small startup that cannot afford it, maybe they are students at a University without a site license,... For these people Python is a viable option that is always available. That makes me happy.

** Easy to install Python distributions
An important development in using Python as an alternative to Matlab is the development of many "one-click" installers. Ten years ago it took me about 2 weeks to download and build a Python environment suitable for scientific and engineering calculations. That has kept me from trying to use Python in teaching in the past. Today, I can download a package and install one in about 10 minutes! More importantly, so can my students.

My favorite distribution is the Enthought Canopy distribution (https://www.enthought.com/products/canopy/). This distribution comes with all the essential python modules, and an integrated editor with IPython. It is available for Windows, Macs and Linux. They offer free academic licenses.

Another good alternative is the Anaconda distribution (https://store.continuum.io/cshop/anaconda/) by Continuum Analytics. It is also available for Windows, Macs and Linux. I have not used this one, but it looks like it would be very good. Anaconda comes with the Spyder editor. They offer free academic licenses.

Python(x,y) is available for Windows (http://code.google.com/p/pythonxy/) and comes with the Spyder editor.

WinPython (http://winpython.sourceforge.net/) is also available for Windows, and comes with the Spyder editor.

The point here is that there are many options available now that make installing a Python distribution as easy as installing packages like Matlab. Enthought Canopy also provides a "desktop environment" similar to Matlab with an editor, documentation browser, package manager and console that is pretty easy to use.

** Python + numpy/scipy/matplotlib does almost everything you need
Python by itself is not suitable for typical engineering calculations. You need the numerical, scientific and plotting libraries that provide that functionality. These are provided in numpy, scipy and matplotlib, which are included in the distributions described above.

Typical chemical engineering calculations involve one or more of the following kinds of math problems:

- [[http://docs.scipy.org/doc/numpy-dev/reference/routines.linalg.html][Linear algebra]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.fsolve.html#scipy.optimize.fsolve][Root finding]] (nonlinear algebra)
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.leastsq.html#scipy.optimize.leastsq][linear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/generated/scipy.optimize.curve_fit.html#scipy.optimize.curve_fit][Nonlinear regression]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/integrate.html][Integration and ordinary differential equations]]
- [[http://docs.scipy.org/doc/scipy-dev/reference/tutorial/stats.html][statistics]]
- [[http://matplotlib.org/][plotting]]

All of these are doable out of the box with the Python distributions discussed above. You can find many examples of using these, and more on my PYCSE blog (http://kitchingroup.cheme.cmu.edu) and http://kitchingroup.cheme.cmu.edu/pycse/. In short, almost every example I put in the Matlab blog has been done in Python. The only ones I did not do yet are some of the interactive graphics with the steam tables. I have not had time to work those out in detail.

I have found it convenient to augment theses with a package I wrote called pycse (https://github.com/jkitchin/pycse).

- an ode integrator with events similar to the one in Matlab
- some numerical differentiation functions
- linear and nonlinear regression with confidence intervals
- some boundary value problem solvers
- a publish function to convert python scripts to PDF via LaTeX

This package is still a work in progress. Notably, there is not a really good units package in Python that works as well as my Matlab units package does. Two that come close are [[http://pythonhosted.org/quantities/][quantities]] and [[https://pint.readthedocs.org/en/latest/][pint]]. Both have some nuances that make them tricky for regular use, and both have some challenges in covering all the functions you might want to use them for.

** Python from the educator perspective
Make that my perspective. I have developed an approach to using code in my lectures where I use the code to reinforce the structure of the problems, and to analyze the solutions that result. Doing that means I need to have code to show students, and the output, and sometimes to run the code to illustrate something. I also like these examples integrated into my lecture notes, so they have the right context around them.

I have found that [[http://www.youtube.com/watch?v=1-dUkyn_fZA][Emacs+org-mode+python]] allows me to easily integrate notes, equations, images, code and output in one place, and then export it to a PDF which I can annotate in class. This ensures that the code and output stay synchronized, that the code is always right where it needs to be, in the right context, and that I can annotate actual code in class, and not pseudocode. This heavily influenced my decision to use Python because it leverages what I already know and want to do. In fact, using it makes me even better at what I already know and helps me learn more about it. That makes me happy!

Not everyone will be a content developer like this, but that is what I like to do. Python makes that process fun, and worth doing for me.

** Final thoughts
In my opinion Python is and is becoming a more viable alternative to other packages like Matlab for scientific and engineering calculations. I have used it exclusively for about a year solving all kinds of engineering problems that I used to solve in Matlab.

Python is different, for sure. The main differences in my opinion are:
 - Python is less consistent in syntax than Matlab. For example, there are two ODE solvers in scipy with incompatible syntax. That is a result of the fact that you install a Python distribution made of packages written by many different people with different needs.
 - There is duplicated functionality between numpy and scipy.
 - Some functionality in scipy is provided by external "scikits" (http://scikits.appspot.com/).
 - Support for boundary value problems and partial differential equations is not as good in Python as it is in Matlab [fn:3]. At the undergraduate level, this is not a big deal. It is not like the Matlab functions are that easy to use!
 - Data regression in Python is not as complete as in Matlab.
 - indexing in Python starts at 0, and uses [], whereas in Matlab it starts at 1 and uses ()
 - You have to import most functions into Python. In contrast, Matlab has them all in one big namespace.


It is certainly doable to use Python for many scientific and engineering calculations. This past Fall I took the plunge, and taught a whole core course in chemical reaction engineering using Python! It was a Master's level course with 59 graduate students in it. I have also taught a graduate elective course in Molecular Simulation using Python. I still have some polishing to do before I would teach this to undergraduates, but I think it is definitely worth trying!

* Making sure you have a notes entry for each bibtex entry
As I mentioned [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf/][here]], I like to have a notes entry for each bibtex entry in an org-mode file. There are a couple of reasons for that:
1. I can tag the org-mode entries to help me find entries later
2. I can organize the org-mode entries by topic, including using links to entries when they belong in multiple places.
3. I can mark the entry as TODO to make it easy to find unfiled entries
4. I can keep typed notes in these entries.

It is usually part of my workflow to create these entries when I enter the bibtex entry, but occasionally I do not get to that. As part of the regular maintenance of my bibtex file, I like to find entries with no notes entry, and make them.

* non-ascii characters
“ "
” "

β  \beta
° $^{\circ}$
ÇŽ \v{a}
’ '
Ã© \'{e}
Ã± \~{n}
Ã­ \'{i}
Ã£ \~{a}
š \v{s}
δ \delta



* DONE Send email to a list of users
  CLOSED: [2014-02-04 Tue 11:36]
  :PROPERTIES:
  :categories: emacs, emacs-lisp
  :date:     2014/01/13 18:41:55
  :updated:  2014/01/13 18:42:59
  :END:

I have a need to send a lot of emails to users in my class. I have to send each student an email containing there userid and a password assigned to them. I have a list of these, so the strategy is to create a function that will email that information to one user, and then use mapcar to apply the function to each pair in a list.  First, we work out a function that will send one email to one user.

#+BEGIN_SRC emacs-lisp
(defun send-mail (userid password)
  "send email to userid@andrew.cmu.edu containing their password"
  (interactive)
  (mail)
  (mail-to)
  (insert (format "%s@andrew.cmu.edu" userid))
  (mail-subject)
  (insert "[06-640] account information")
  (mail-text)
  (insert (format "
An account has been created on gilgamesh.cheme.cmu.edu
userid: %s
password: %s" userid password))
  (mail-send-and-exit))

(send-mail "jkitchin" "trustme99")
#+END_SRC

#+RESULTS:

That worked well. I ran the block and got the email.

Now, suppose I have this data:
#+tblname: users
| userid | password  |
|--------+-----------|
| user1  | trustme99 |
| user2  | foolme99  |
| user3  | blameme99 |

We can pass that to a source block as a list of lists that will look like this:
#+BEGIN_EXAMPLE
 ((user1 trustme99) (user2 foolme99) (user3 blameme99))
#+END_EXAMPLE

Then, we can use a mapcar to process each element. Here I use a dummy function with two arguments. If I substitute the function above, each of these users would get an email.

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (car x) (cadr x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99

I am not sure that is the best way to get the first and second elements in the list element. It looks funny to me, but it works fine. the alternative is not much prettier:

#+BEGIN_SRC emacs-lisp :var data=users
(defun fun (a b)
  (princ (format "user: %s\npassword: %s\n" a b)))

(mapcar (lambda (x) (fun (nth 0 x) (nth 1 x))) data)
#+END_SRC

#+RESULTS:
: user: user1
: password: trustme99
: user: user2
: password: foolme99
: user: user3
: password: blameme99



* DONE Making org-mode links to files in Emacs packages
  CLOSED: [2014-01-19 Sun 15:23]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/19 12:42:27
  :updated:  2014/01/19 15:27:48
  :END:
Today I will make a new org-mode link that lets me make links to files inside of Emacs packages. These files may be installed in different places on different systems (e.g. in the system directory, in ELPA directories, or in custom directories), so we need a way to construct paths to them. The application of this is eventually I hope to have some emacs packages of documentation, and I would like to have links between the packages that work no matter how they are installed.

I want a syntax that looks like pkg:rainbow-mode==rainbow-mode-pkg.el. We will have a function that parses that to get the package, and the path to the file in the package. Emacs has a function to find the path to the file that defines a library. I chose == because it seems unlikely that would be a string in a package or path.

#+BEGIN_SRC emacs-lisp :results value
(locate-library "rainbow-mode")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode.elc

We can use that to construct the path to where we want. Say we want the file named "rainbow-mode-pkg.el"

#+BEGIN_SRC emacs-lisp :results value
(expand-file-name
 "rainbow-mode-pkg.el"
 (file-name-directory (locate-library "rainbow-mode")))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/rainbow-mode-0.9/rainbow-mode-pkg.el

In org-mode links, the link path gets passed to a function. We can split the string like this to get the package and relative path we are referring to.

#+BEGIN_SRC emacs-lisp :results value
(split-string "rainbow-mode==rainbow-mode-pkg.el" "==")
#+END_SRC

#+RESULTS:
| rainbow-mode | rainbow-mode-pkg.el |

That is all of the pieces we need to construct the link function. Here it is.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg"
 (lambda (path)
   (let ((pkg) (relpath)
	 (splitpath (split-string path "==")))
     (setq pkg (car splitpath))
     (setq relpath (nth 1 splitpath))
     (find-file (expand-file-name
		 relpath
		 (file-name-directory (locate-library pkg)))))))
#+END_SRC

#+RESULTS:

pkg:rainbow-mode==rainbow-mode-pkg.el

This works too, but you have to use auctex-pkg as the package name.

pkg:auctex-pkg==doc/intro.texi

I think that is because locate-library looks for the /file/ a library is defined in. That is not quite the same as the root directory of a package. It turns out to be a little more complicated to find that. Below is some code I hacked up looking at the package.el code. First let us examine some pieces.

This gives us information about an installed package.

#+BEGIN_SRC emacs-lisp :results value
(assq 'auctex package-alist)
#+END_SRC

#+RESULTS:
: (auctex . [(11 87 2) nil Integrated environment for *TeX*])

We can get the version of the package like this

#+BEGIN_SRC emacs-lisp :results value
(package-version-join (package-desc-vers (cdr (assq 'auctex package-alist))))
#+END_SRC

#+RESULTS:
: 11.87.2

Ok, finally, we get the directory where it is installed like this:

#+BEGIN_SRC emacs-lisp :results value
(package--dir "auctex" "11.87.2")
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Note that in some places we use a package symbol, and in other places a string name.Putting that together, we have this block to get the install-dir of a package. If we have a package symbol we can get the path like this.

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg 'auctex)
       (pkg-name (symbol-name pkg)) ; convert symbol to string
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Usually, we will have a string though. We just have to make it a symbol with the =intern= function.

#+BEGIN_SRC emacs-lisp :results value
(setq pkg-name "auctex")
(setq pkg (intern pkg-name))
(setq desc (cdr (assq pkg package-alist)))
#+END_SRC

#+RESULTS:
: [(11 87 2) nil "Integrated environment for *TeX*"]

Now, we have all the pieces to get the path from a package name in a string:

#+BEGIN_SRC emacs-lisp :results value
(let* ((pkg-name "auctex")
       (pkg (intern pkg-name))
       (desc (cdr (assq pkg package-alist)))
       (version (package-version-join (package-desc-vers desc)))
       (pkg-dir (package--dir pkg-name version)))
  pkg-dir)
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2

Let us use that to rewrite the link, and address a few other limitations. We will  use =org-open-link-from-string= so we can use org-link syntax in the path part of the link, e.g. to open a file at a line, or headline. Here is our new link.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg2"
 (lambda (path)
   (let ((pkg) (relpath) (pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (let* ((pkg-symbol (intern pkg-name)) ;convert string to pkg
			  (desc (cdr (assq pkg-symbol package-alist)))
			  (version (package-version-join (package-desc-vers desc)))
			  (pkg-dir (package--dir pkg-name version)))
		     pkg-dir))
     (setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

Now, we can do all of these:
pkg2:auctex==doc/faq.texi
pkg2:auctex==doc/faq.texi::should
pkg2:auctex==doc/faq.texi::10
[[pkg2:auctex==doc/faq.texi::first place]]

Awesome!

Just for fun, I made a toy package called =package1= in my elpa directory. That package has an org file in it. Now, I can test out the following links:

pkg2:package1==intro.org

pkg2:package1==intro.org::*Miscellaneous

[[pkg2:package1==intro.org::*subheading with words]]

pkg2:package1==intro.org::#install-section

pkg2:package1==intro.org::intro-target

They all work! That works for packages installed via the package manager. However, when I try this with my custom installed org-mode, it does not work. If I run (describe-package 'org) I see that org is a build in package, and that there is an alternate version available. It does not point to my org-installation.

pkg2:org==doc/library-of-babel.org

#+BEGIN_SRC emacs-lisp
(princ (locate-library "org"))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/org.elc

#+BEGIN_SRC emacs-lisp
(princ (package-installed-p "org"))
#+END_SRC

#+RESULTS:
: nil

Obviously, we need to check if the package is installed via package.el, or if we should look somewhere else. Let us take a final stab at this. Let us review the challenge.

#+BEGIN_SRC emacs-lisp
(print (locate-library "auctex"))
(print (locate-library "auctex-autoloads"))
#+END_SRC

#+RESULTS:
:
: nil
:
: "c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/auctex-autoloads.el"

We may have to check for a package-autoloads. Ww can wrap that in an =or= macro, which will return the first non-nil result.

#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "auctex"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/elpa/auctex-11.87.2/

Doing this on the org package shows that this points to a lisp directory.
#+BEGIN_SRC emacs-lisp :results value
(let ((pkg-name "org"))
   (file-name-directory
    (or (locate-library pkg-name)
	(locate-library (format "%s-autoloads" pkg-name)))))
#+END_SRC

#+RESULTS:
: c:/Users/jkitchin/Dropbox/kitchingroup/jmax/org-mode/lisp/

So, let's try a final link function.

#+BEGIN_SRC emacs-lisp
(org-add-link-type
 "pkg3"
 (lambda (path)
   (let ((pkg-name) (relpath)(pkg-dir) (link-string)
	 (splitpath (split-string path "==")))
     (setq pkg-name (car splitpath))
     (setq relpath (nth 1 splitpath))
     (setq pkg-dir (file-name-directory
		    (or (locate-library pkg-name)
			(locate-library (format "%s-autoloads" pkg-name)))))
(setq link-string (format "[[file:%s/%s]]" pkg-dir relpath))
     (message "link: %s" link-string)
     (org-open-link-from-string link-string))))
#+END_SRC

#+RESULTS:

Now, we just have to make sure to use the right relative path. This link opens up an org-file in my installed version of org-mode: pkg3:org==../doc/library-of-babel.org

I don't know if there is a more clever way to create these links. There are two parts to them: 1) the package, and 2) the relative path. The link syntax isn't that rich to do it without parsing the linkpath.

* DONE Alternatives to long complex format statements in emacs-lisp
  CLOSED: [2014-02-03 Mon 10:43]
 :PROPERTIES:
 :categories: emacs-lisp
 :date:     2014/01/20 09:50:26
 :updated:  2014/01/20 09:50:26
 :END:
At one point I had a string I wanted to fill in with a bunch of variables.

#+BEGIN_SRC emacs-lisp
(insert (format"
 :PROPERTIES:
  :Custom_ID: %s
  :AUTHOR: %s
  :JOURNAL: %s
  :YEAR: %s
  :VOLUME: %s
  :PAGES: %s
  :DOI: %s
  :URL: %s
 :END:
[[cite:%s]] [[file:%s/%s.pdf][pdf]]\n\n"
key author journal year volume pages doi url key jorg-bib-pdf-directory key ))
#+END_SRC

I find that very difficult to use, because it is tedious to make sure all the variables are in the right order, and it is difficult to change later. In Python, you would be able to put named expansions in, e.g. {author} and then used named arguments. That does not exist as far as I know in emacs-lisp.

Below is an alternatme approach that uses concat to construct this string.

#+BEGIN_SRC emacs-lisp :results value
(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (jorg-bib-pdf-directory "/home/jkitchin/pdfs"))

(concat "
 :PROPERTIES:
  :Custom_ID: " key "
  :AUTHOR: " author "
  :JOURNAL: " journal "
  :YEAR: " year "
  :VOLUME: " volume "
  :PAGES: " pages "
  :DOI: " doi "
  :URL: " url "
 :END:
[[cite:" key "]] [[file:" jorg-bib-pdf-directory "/" key ".pdf][pdf]]\n\n"))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is kind of interesting. It is a little tedious to use all the quotes. It seems like there should be soemthing like named expansions. Let us write one of our own. We will use a regular expression to find {:keyword} and a plist. There is a regexp to match this, and then we can take the characters from position 1 to the second to last character as the keyword. That is not beautiful to me, but it works here. Then we just get the keyword from the plist. The keywords in a plist are symbols, and we will have strings. We have to use the =intern= function to convert them to symbols.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s plist)
  "expand a template containing {:keyword} with the definitions in plist"
  (replace-regexp-in-string "{\\(:[^}]+\\)}"
			    (lambda (arg)
			      (let ((keyword (intern (substring arg 1 -1))))
				(format "%s" (plist-get plist keyword)))) s))

(let ((template "
 :PROPERTIES:
  :Custom_ID: {:key}
  :AUTHOR: {:author}
  :JOURNAL: {:journal}
  :YEAR: {:year}
  :VOLUME: {:volume}
  :PAGES: {:pages}
  :DOI: {:doi}
  :URL: {:url}
 :END:
[[cite:{:key}]] [[file:{:pdf-dir}/{:key}.pdf][pdf]]\n\n"))

(expand-template template
		 '(:key "kitchin-2014"
			:author "Kitchin, J. R."
			:journal "HACS"
			:year 2014
			:volume 1
			:pages "1--10"
			:doi "10.1.1.109/hacs.1.10"
			:url "http://hacs.org/10.1.1.109/hacs.1.10"
			:pdf-dir "/home/jkitchin/pdfs")))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :JOURNAL: HACS
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty close to what I am used to from python! I am surprised there aren't other solutions for this around. I looked, and couldn't find them.

* DONE Another alternative to string templates
  CLOSED: [2014-02-03 Mon 10:43]
  :PROPERTIES:
  :categories: emacs-lisp
  :date:     2014/01/26 09:56:45
  :updated:  2014/01/26 09:56:45
  :END:

In the [[http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/][last post]] I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.

In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it.

Here we get the user-full-name:
#+BEGIN_SRC emacs-lisp :results value
(eval (read "user-full-name"))
#+END_SRC

#+RESULTS:
: John Kitchin

We can use this on variables too.
#+BEGIN_SRC emacs-lisp :results value
(setq some-variable "test")
(eval (read "some-variable"))
#+END_SRC

#+RESULTS:
: test

So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %() with the eval of its contents"
  (replace-regexp-in-string "%(\\([^)]+\\))"
			    (lambda (arg)
			      (format "%s" (eval (read (substring arg 2 -1))))) s))


(let ((key "kitchin-2014")
      (author "Kitchin, J. R.")
      (journal "HACS")
      (year "2014")
      (volume "1")
      (pages "1--10")
      (doi "10.1.1.109/hacs.1.10")
      (url "http://hacs.org/10.1.1.109/hacs.1.10")
      (pdf-dir "/home/jkitchin/pdfs")
      (template "
 :PROPERTIES:
  :Custom_ID: %(key)
  :AUTHOR: %(author
  :JOURNAL: %(journal)
  :YEAR: %(year)
  :VOLUME: %(volume)
  :PAGES: %(pages)
  :DOI: %(doi)
  :URL: %(url)
 :END:
[[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"))

(expand-template template))
#+END_SRC

#+RESULTS:
#+begin_example

 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]

#+end_example

That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.

I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "2 * 2 = %{(* 2 2)}")
#+END_SRC

#+RESULTS:
: 2 * 2 = 4


I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!

#+BEGIN_SRC emacs-lisp :results value
(defun expand-template (s)
  "expand a template containing %{} with the eval of its contents"
  (replace-regexp-in-string "%{\\([^}]+\\)}"
			    (lambda (arg)
			      (let ((sexp (substring arg 2 -1)))
				(format "%s" (eval (read sexp))))) s))

(expand-template "The result is %{(progn
  (if (> 4 3)
      'true
    'false))}")
#+END_SRC

#+RESULTS:
: The result is true

The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!

* DONE Language specific default headers for code blocks in org-mode
  CLOSED: [2014-01-27 Mon 13:44]
  :PROPERTIES:
  :categories: org-mode, emacs-lisp
  :date:     2014/01/26 12:06:12
  :updated:  2014/01/26 12:06:12
  :END:

I use code blocks in org-mode /a lot/. I usually code in Python, and
in Python I usually write code that prints output which I want to see. So I almost always
want the code blocks to return the output, and not the value of the
last function. I have set my default header args like this:
#+BEGIN_SRC emacs-lisp
org-babel-default-header-args
#+END_SRC

#+RESULTS:
| (:exports . both) | (:results . replace output) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

However, I would prefer that emacs-lisp blocks use value for the
results. I know I can get that by putting  =:results value=  in the
code block header, but that annoys me. I learned today from
http://orgmode.org/worg/org-contrib/babel/header-args.html that you
can make language specific default headers!

This code in my init file sets emacs-lisp specific default headers:
#+BEGIN_SRC emacs-lisp
(setq org-babel-default-header-args:emacs-lisp
      (cons '(:results . "value")
	    (assq-delete-all :results org-babel-default-header-args)))
#+END_SRC

That way I do not have type =:results value= at the top of every elisp
block. Of course, if I want the output I could specify =:results
output= in the block.

#+begin_src emacs-lisp
org-babel-default-header-args:emacs-lisp
#+end_src

#+RESULTS:
| (:results . value) | (:exports . both) | (:session . none) | (:cache . no) | (:noweb . no) | (:hlines . no) | (:tangle . no) |

Problem solved!

On a related note, I find I write so many blocks of python and elisp I
added these templates:
#+BEGIN_SRC emacs-lisp
;; add <p for python expansion
(add-to-list 'org-structure-template-alist
             '("p" "#+BEGIN_SRC python\n?\n#+END_SRC" "<src lang=\"python\">\n?\n</src>"))

;; add <el for emacs-lisp expansion
(add-to-list 'org-structure-template-alist
             '("el" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC" "<src lang=\"emacs-lisp\">\n?\n</src>"))
#+END_SRC

I probably could have also coded the :results header into those
too. They add a tidbit of convenience so I do not have to type python
or emacs-lisp after expanding a source block with <s.

* DONE Clocking your time in org-mode
  CLOSED: [2014-01-27 Mon 13:53]
  :LOGBOOK:
  CLOCK: [2014-01-26 Sun 13:08]--[2014-01-26 Sun 13:16] =>  0:08
  CLOCK: [2014-01-26 Sun 13:04]--[2014-01-26 Sun 13:06] =>  0:02
  CLOCK: [2014-01-26 Sun 12:07]--[2014-01-26 Sun 12:10] =>  0:03
  :END:
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/01/27 13:46:21
  :updated:  2014/01/27 13:53:03
  :END:


I have some need for tracking how much time I spend on certain jobs,
e.g. committees, etc... because 1) I have to report this
information, 2) I need a better idea of how much time some things
take.  Org-mode supports the idea of "clocking in to a task". You run
(org-clock-in) in a heading, and it stores a time stamp. You do your
work in that heading, and when done, you (org-clock-out).

You can summarize your time with (org-clock-report) which puts a dynamic block in your file like this.

#+BEGIN: clocktable :maxlevel 2 :scope subtree :link t
#+CAPTION: Clock summary at [2014-01-26 Sun 13:36]
| Headline                       | Time   |      |
|--------------------------------+--------+------|
| *Total time*                   | *0:24* |      |
|--------------------------------+--------+------|
| [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Clocking%20your%20time%20in%20org-mode][Clocking your time in org-mode]] | 0:24   |      |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::work%20in%20subheadings][work in subheadings]]        |        | 0:06 |
| \__ [[file:c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org::Using%20clocking%20effectively][Using clocking effectively]] |        | 0:05 |
#+END:

You can update it by putting your cursor in the #+BEGIN line, and pressing C-c C-c.

** work in subheadings
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:02]--[2014-01-26 Sun 13:04] =>  0:02
   CLOCK: [2014-01-26 Sun 13:00]--[2014-01-26 Sun 13:02] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:13] =>  0:02
   CLOCK: [2014-01-26 Sun 12:11]--[2014-01-26 Sun 12:11] =>  0:00
   :END:
It seems that the clock-in mechanism works on the heading you are
in. So whenever you clock in, it is specific to that heading. If you
clock-in more than once, multiple CLOCK entries are stored, unless you
modify org-clock-into-drawer. It seems like you probably want these CLOCK entries in a drawer, so you should put this in your init.el file:
#+BEGIN_SRC emacs-lisp
(setq org-clock-into-drawer t)
#+END_SRC

** Clock in to the right task
By default, (org-clock-in) creates clocks-in to the current headline. Org-mode seems to store a list of recently clocked tasks. You can access them by typing C-u C-c C-x C-i. You will be given some choices of which task to clock in to. You can switch to another task by doing this too.

** Using clocking effectively
   :LOGBOOK:
   CLOCK: [2014-01-26 Sun 13:31]--[2014-01-26 Sun 13:36] =>  0:05
   :END:
It will take some discipline and practice to use this effectively. It appears you can clock in any heading, and then use the clock report to aggregate all the times into one summary. That report can have a variety of scopes, from subtree to file. In that case, if you keep all relevant task information to a project in a file, you just clock in wherever you work in that file, and let the report keep track of it for you.

You could use this to track the amount of time you spend reviewing manuscripts, or doing work for a committee. You just need to remember to actually use it!

It might be interesting to setup code that would automatically clock in when you open a file, and then clock out when  you close it. Probably this would be done with hooks.

There is a nice [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][map]] of using org-mode for clocking time [[http://sachachua.com/blog/wp-content/uploads/2014/01/2014-01-06-Tracking-time-with-Org-mode.png][here]].

* DONE Using tags to filter lists in Python
  CLOSED: [2014-01-29 Wed 12:52]
  :PROPERTIES:
  :categories: python
  :date:     2014/01/29 12:52:51
  :updated:  2014/01/29 12:52:53
  :END:

Suppose you have a collection of items in a list, and you want to filter the list based on some properties of the items, and then accumulate some other property on the filtered items. We will look at some strategies for this here.

The particular application is that I have a list of courses that make up a curriculum, and I want to summarize the curriculum in a variety of ways. For example, I might want to know how many Gen Ed courses there are, or how many math, chemistry, biology and physics courses there are. I may want to know how may units overall are required.

A course will be represented by a class, which simply holds the data about the course. Here we consider the course number (which is really a string), the number of units of the course, and what category the course fits into. There will be 7 categories here: chemistry, biology, physics, math, engineering, general education, and free elective.

We will use some binary math to represent the categories. Essentially we define tags as if they are binary numbers, and then we can use binary operators to tell if an item is tagged a particular way. We use & to do a logical AND between a variable and a TAG. If it comes out True, the variable has that tag.

This works basically by defining a TAG like a binary number, e.g. TAG1 = 100,
TAG2 = 010, TAG3 = 001. Then, if you have a number like 110, you know it is tagged with TAG1 and TAG2, but not TAG3. We can figure that out with code too.
#+BEGIN_EXAMPLE
100 & 110 = 100 = 1
010 & 110 = 010 = 2
#+END_EXAMPLE

#+BEGIN_SRC python
print 1 & 3
print 2 & 3
#+END_SRC

#+RESULTS:
: 1
: 2

Let us try out an example. The easiest way to define the tags, is as powers of two.
#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010

# Now define a variable that is "tagged"
a = TAG1
print a & TAG1 # remember that 0 = False, everything else is true
print a & TAG2
#+END_SRC

#+RESULTS:
: 1
: 0

We can use multiple tags by adding them together.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print a & TAG1
print a & TAG2
print a & TAG3
#+END_SRC

#+RESULTS:
: 1
: 2
: 0

You can see that the variable is not tagged by TAG3, but is tagged with TAG1 and TAG2. We might want to tag an item with more than one tag.  We create groups of tags by simply adding them together. We can still check if a variable has a particular tag like we did before.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print a & TAG1
print a & TAG2
print a & TAG3
#+END_SRC

#+RESULTS:
: 1
: 2
: 0

It is trickier to say if a variable is tagged with a particular set of tags. Let us consider why. The binary representation of TAG1 + TAG2 is 110. The binary representation of TAG2 + TAG3 is 011. If we simply consider (TAG1 + TAG2) & (TAG2 & TAG3) we get 010. That actually tells us that we do not have a match, because 010 is not equal to (TAG2 & TAG3 = 011). In other words, the logical AND of the tag with some sum of tags is equal to the sum of tags when there is a match. So, we can check if that is the case with an equality comparison.

#+BEGIN_SRC python
# define some tags
TAG1 = 2**0  # 100
TAG2 = 2**1  # 010
TAG3 = 2**2  # 001

# Now define a variable that is "tagged"
a = TAG1 + TAG2  # 1 + 2 = 3 = 110 in binary
print (a & (TAG1 + TAG2)) == TAG1 + TAG2
print (a & (TAG1 + TAG3)) == TAG1 + TAG3
print (a & (TAG2 + TAG3)) == TAG2 + TAG3
#+END_SRC

#+RESULTS:
: True
: False
: False

Ok, enough binary math, let us see an application. Below we create a set of tags indicating the category a course falls into, a class definition to store course data in attributes of an object, and a list of courses. Then, we show some examples of list comprehension filtering based on the tags to summarize properties of the list. The logical comparisons are simple below, as the courses are not multiply tagged at this point.

#+BEGIN_SRC python
CHEMISTRY = 2**0
BIOLOGY = 2**1
PHYSICS = 2**2
MATH = 2**3
ENGINEERING = 2**4
GENED = 2**5
FREE = 2**6

class Course:
    '''simple container for course information'''
    def __init__(self, number, units, category):
        self.number = number
        self.units = units
        self.category = category
    def __repr__(self):
        return self.number


courses = [Course('09-105', 9, CHEMISTRY),
           Course('09-106', 9, CHEMISTRY),
           Course('33-105', 12, PHYSICS),
           Course('33-106', 12, PHYSICS),
           Course('21-120', 10, MATH),
           Course('21-122', 10, MATH),
           Course('21-259', 10, MATH),
           Course('06-100', 12, ENGINEERING),
           Course('xx-xxx', 9, GENED),
           Course('xx-xxx', 9, FREE),
           Course('03-232', 9, BIOLOGY)]

# print the total units
print ' Total units = {0}'.format(sum([x.units for x in courses]))

# get units of math required
math_units = sum([x.units  for x in courses if x.category & MATH])

# get total units of math, chemistry, physics and biology a | b is a
# logical OR. This gives a prescription for tagged with MATH OR
# CHEMISTRY OR PHYSICS OR BIOLOGY
BASIC_MS = MATH | CHEMISTRY | PHYSICS | BIOLOGY

# total units in those categories
basic_math_science = sum([x.units for x in courses if x.category & BASIC_MS])

print 'We require {0} units of math out of {1} units of basic math and science courses.'.format(math_units, basic_math_science)

# We are required to have at least 96 units of Math and Sciences.
print 'We are compliant on number of Math and science: ',basic_math_science >= 96
#+END_SRC

#+RESULTS:
:  Total units = 111
: We require 30 units of math out of 81 units of basic math and science courses.
: We are compliant on number of Math and science:  False

That is all for this example. With more data for each course, you could see what courses are taken in what semesters, how many units are in each semester, maybe create a prerequisite map, and view the curriculum by categories of courses, etc...


* DONE Printing unicode characters in Python strings
  CLOSED: [2014-02-02 Sun 12:18]
  :PROPERTIES:
  :categories: python,unicode
  :date:     2014/02/02 12:18:16
  :updated:  2014/02/02 12:18:16
  :END:

Are you tired of printing strings like this:
#+BEGIN_SRC python :results output
print 'The volume is {0} Angstrom^3'.format(125)
#+END_SRC

#+RESULTS:
: The volume is 125 Angstrom^3

Wish you could get Å in your string? That is the unicode character
U+212B. We can get that to print in Python, but we have to create it
in a unicode string, and print the string properly encoded. Let us try
it out.

#+BEGIN_SRC python :results output
print u'\u212B'.encode('utf-8')
#+END_SRC

#+RESULTS:
: Å

We use u'' to indicate a unicode string. Note we have to encode the
string to print it, or will get this error:

#+BEGIN_EXAMPLE
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeEncodeError: 'ascii' codec can't encode character u'\u212b' in position 0: ordinal not in range(128)
#+END_EXAMPLE

Do more, do more, we wish we could! Unicode also supports some
superscripted and subscripted numbers
(http://en.wikipedia.org/wiki/Unicode_subscripts_and_superscripts). Let
us see that in action.

#+BEGIN_SRC python :results output
print u'\u212B\u00B3'.encode('utf-8')
#+END_SRC

#+RESULTS:
: Å³

Pretty sweet. The code is not all that readable if you aren't fluent
in unicode, but if it was buried in some library it would just print
something nice looking. We can use this to print chemical formulas
too.

#+BEGIN_SRC python  :results output
print u'''The chemical formula of water is H\u2082O.
Water dissociates into H\u207A and OH\u207B'''.encode('utf-8')
#+END_SRC

#+RESULTS:
=The chemical formula of water is H₂O.
Water dissociates into H⁺ and OH⁻

There are other encodings too. See the symbols here: http://en.wikipedia.org/wiki/Number_Forms
#+BEGIN_SRC python  :results output
print u'1/4 or \u00BC'.encode('latin-1')
#+END_SRC

#+RESULTS:
: 1/4 or ¼

That seems like:

#+BEGIN_SRC python :results output
print u'A good idea\u00AE'.encode('latin-1')
#+END_SRC

#+RESULTS:
: A good idea®

I can not tell how you know exactly what encoding to use. If you use
utf-8 in the example above, you get a stray character in front of the
desired trademark symbol. Still, it is interesting you can get
prettier symbols!

* DONE Using YAML in python for structured data
  CLOSED: [2014-02-03 Mon 09:36]
  :PROPERTIES:
  :categories: python,yaml,template
  :date:     2014/02/03 09:36:29
  :updated:  2014/02/03 09:36:29
  :END:
[[http://www.yaml.org/][YAML]] is a data format that is most text, with some indentation. It is like JSON, but without the braces. What is important here is that you can read a yaml document into a python dictionary. Here is an example of reading a yaml string so you can see the format.

#+BEGIN_SRC python :results output
import yaml
document = """
a: 1
b:
  c: 3
  d: 4
"""
print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'a': 1, 'b': {'c': 3, 'd': 4}}

Everything indented by the same level is grouped in its own dictionary. If we put that string into a file ([[./test.yaml]]), we can read that in to python like this.

#+BEGIN_SRC python
import yaml
document = open('test.yaml').read()
print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'a': 1, 'b': {'c': 3, 'd': 4}}

That example is pretty trivial. What I want to do is have  yaml file that represents a course syllabus. Then, if I had a set of these files, I could write code to analyze the collection of syllabi. For example, to figure out how many units of particular category there are. Alternatively, I could create different representations of the document, e.g. a pdf or html file for students or accreditation boards. Below is a YAML representtion of an ABET syllabus. It is pretty readable for a person.

#+BEGIN_SRC python :results output replace
import yaml
document = """
course:
  course-number: 06-364
  title: Chemical Reaction Engineering
  units: 9
  description: Fundamental concepts in the kinetic modeling of chemical reactions, the treatment and analysis of rate data. Multiple reactions and reaction mechanisms. Analysis and design of ideal and non-ideal reactor systems. Energy effects and mass transfer in reactor systems. Introductory principles in heterogeneous catalysis.

  textbook: H. S. Fogler, Elements of Chemical Reaction Engineering, 4th edition, Prentice Hall, New York, 2006.
  prerequisites: [06-321, 06-323, 09-347]
  required: Yes

  goals:
    goal1:
      description: To analyze kinetic data and obtain rate laws
      outcomes: [a, k]
      criteria: [A, F]
    goal2:
      description: To develop a mechanism that is consistent with an experimental rate law
    goal3:
      description: To understand the behavior of different reactor types when they are used either individually or in combination
    goal4:
      description: To choose a reactor and determine its size for a given application
    goal5:
      description: To work with mass and energy balances in the design of non-isothermal reactors
    goal6:
      description: To understand the importance of selectivity and know the strategies that are commonly used in maximizing yields
    goal7:
      description: To effectively use mathematical software in the design of reactors and analysis of data

  topics:
    - Conversion and reactor sizing
    - Rate laws and stoichiometry
    - Isothermal reactor design
    - Collection and analysis of rate data
    - Multiple reactions and selectivity
    - Non-elementary reaction kinetics
    - Non-isothermal reactor design
    - Unsteady operation of reactors
    - Catalysis and catalytic reactors
"""
with open('06-364.yaml', 'w') as f:
    f.write(document)

print yaml.load(document)
#+END_SRC

#+RESULTS:
: {'course': {'description': 'Fundamental concepts in the kinetic modeling of chemical reactions, the treatment and analysis of rate data. Multiple reactions and reaction mechanisms. Analysis and design of ideal and non-ideal reactor systems. Energy effects and mass transfer in reactor systems. Introductory principles in heterogeneous catalysis.', 'title': 'Chemical Reaction Engineering', 'prerequisites': ['06-321', '06-323', '09-347'], 'topics': ['Conversion and reactor sizing', 'Rate laws and stoichiometry', 'Isothermal reactor design', 'Collection and analysis of rate data', 'Multiple reactions and selectivity', 'Non-elementary reaction kinetics', 'Non-isothermal reactor design', 'Unsteady operation of reactors', 'Catalysis and catalytic reactors'], 'required': True, 'textbook': 'H. S. Fogler, Elements of Chemical Reaction Engineering, 4th edition, Prentice Hall, New York, 2006.', 'goals': {'goal6': {'description': 'To understand the importance of selectivity and know the strategies that are commonly used in maximizing yields'}, 'goal7': {'description': 'To effectively use mathematical software in the design of reactors and analysis of data'}, 'goal4': {'description': 'To choose a reactor and determine its size for a given application'}, 'goal5': {'description': 'To work with mass and energy balances in the design of non-isothermal reactors'}, 'goal2': {'description': 'To develop a mechanism that is consistent with an experimental rate law'}, 'goal3': {'description': 'To understand the behavior of different reactor types when they are used either individually or in combination'}, 'goal1': {'outcomes': ['a', 'k'], 'description': 'To analyze kinetic data and obtain rate laws', 'criteria': ['A', 'F']}}, 'units': 9, 'course-number': '06-364'}}




You can see here the whole document is now stored as a dictionary. You
might ask why? I have the following interests:
1. If I have a set of these files, I could loop through them and
   generate some kind of summary, e.g. total units of some category.
2. I could generate a consistent format using a template.

Let us explore the template. We will generate a LaTeX document using
the Cheetah template engine (http://www.cheetahtemplate.org/). I have also used [[http://www.makotemplates.org/][Mako]], and [[http://jinja.pocoo.org/][jinja]]. A
template is a fancy string that has code in that can be evaluated and
substituted at generation time. We use this to replace elements of the
template with data from our yaml document.  Below I created a template
that generates a LaTeX document.

#+BEGIN_SRC python
import yaml
from Cheetah.Template import Template

with open('06-364.yaml', 'r') as f:
    document = yaml.load(f.read())

data = document['course']

template = r'''\documentclass{article}
\renewcommand{\abstractname}{Course Description}

\begin{document}
\title{$data['course-number'] $data['title']}
\maketitle
\begin{abstract}
$data['description']
\end{abstract}

\textbf{Required:} $data['required']

\textbf{Prerequisites:} #echo ', '.join($data['prerequisites'])

{\textbf{Textbook:} $data['textbook']

\section{Course goals}
\begin{enumerate}
#for $goal in $data['goals']
\item $data['goals'][$goal]['description'] \label{$goal}
#end for
\end{enumerate}

\section{Topics}
\begin{itemize}
#for $topic in $data['topics']
\item $topic
#end for
\end{itemize}
\end{document}'''

t = Template(template, searchList=locals())

#import sys; sys.exit()
with open('06-364.tex', 'w') as f:
    f.write(t.respond())
#+END_SRC

#+RESULTS:
: None

You can see the results of the tex file here: [[./06-364.tex]], and the
corresponding pdf here: [[./06-364.pdf]]. It is not spectacular by any
means, but if I had 16 of these to create, this sure would be
convenient! And if we need some other format, we just make a new template!

Some notes about this:
1. The course goals are not in the order defined in the yaml file. That is not too surprising, since dictionaries do not preserve order.
2. Yes in yaml apparently is read in as a boolean, so in the pdf, it is printed as True.
3. I have not thought about how to prepare a table that maps student outcomes (a-k in ABET) to the course goals
4. It would be nice if there were links in the pdf to other syllabi, e.g. the prerequisites. See http://ctan.mirrorcatalogs.com/macros/latex/required/tools/xr.pdf


* DONE Reproducing the research
  CLOSED: [2014-02-04 Tue 08:34]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/04 07:26:18
  :updated:  2014/02/04 07:26:18
  :END:
We have over the past year published a few papers using org-mode. You can find one of them here: http://pubs.acs.org/doi/abs/10.1021/ie400582a. There is a corresponding [[http://pubs.acs.org/doi/suppl/10.1021/ie400582a/suppl_file/ie400582a_si_001.pdf][supporting information]] file that is freely available, which contains within it an org-mode file that documents our work, and that contains the data in it. In this post, I want to explore how easy it is to access that data, and use it. First, download the file:

#+BEGIN_SRC sh
wget http://pubs.acs.org/doi/suppl/10.1021/ie400582a/suppl_file/ie400582a_si_001.pdf
#+END_SRC

#+RESULTS:

Then, open it in Acrobat Reader, and extract the org-file. I saved it as [[./supporting-information.org]]. In that file, there is a table of data that is the SO_2 adsorption and desorption capacity of a resin as a function of cycles. The table is named =so2-capacity-1=.

Here is how simple it is to grab that data, and use it. We need to use this header in our source block:
#+BEGIN_EXAMPLE
#+BEGIN_SRC python :var data=supporting-information.org:so2-capacity-1
#+END_EXAMPLE

In the block, =data= will be a list of lists. I like to convert it into a numpy array, so that indexing it is simple to extract out the data.

#+BEGIN_SRC python :var data=supporting-information.org:so2-capacity-1
import numpy as np
data = np.array(data)
cycles = data[:, 0]
ads_cap = data[:, 1]
des_cap = data[:, 2]

import matplotlib.pyplot as plt
plt.plot(cycles, ads_cap, cycles, des_cap)
plt.legend(['Ads. capacity', 'Des. capacity'])
plt.xlabel('# Cycles')
plt.ylabel('Capacity (mol/kg)')
plt.savefig('images/si-image.png')
#+END_SRC

#+RESULTS:

[[./images/si-image.png]]

That is pretty easy. There are also Excel sheets embedded in that supporting information file, along with scripts that illustrate how to use the data in the Excel sheets for further analysis. How about that for data sharing!

* DONE Invisible text in emacs
  CLOSED: [2014-02-06 Thu 09:03]
  :PROPERTIES:
  :categories: emacs
  :date:     2014/02/06 09:02:44
  :updated:  2014/02/06 09:03:02
  :END:

Emacs supports [[http://www.gnu.org/software/emacs/manual/html_node/elisp/Invisible-Text.html][invisible text]]. In other words, you can use code to set properties on text in a buffer that make it visible, or invisible. You can use code to change the invisibility properties of text.

I have been exploring ways to conditionally navigate in org documents using links. These links may validate that some property has been set in a heading, for example. An alternative approach is to make regions visible, depending on some criteria. That is what we do today. You will probably want to see this  [[./images/invisible-text.swf][video]], since what happens in this post is dynamic, and you will not see visible and invisible text.

What I have below here are a set of headings with properties that indicate what "level" they are at: beginner, medium and advanced.
First, we mark each org subtree  with an overlay that has an 'invisible property that contains the "level". Then, we add the "level" to the list of symbols that marks invisible sections.  If you run this block, the headings all disappear.

#+BEGIN_SRC emacs-lisp :results value silent
(org-map-entries (lambda ()
		   (let ((level (org-entry-get (point) "level"))
			  (symbol-level))
		     (when level
		       (setq symbol-level (intern level))
		       (org-mark-subtree)
		       (overlay-put (make-overlay (point) (mark))
				    'invisible
				    symbol-level)
                       ;; make regions with symbol-level invisible
		       (add-to-invisibility-spec `(,symbol-level))))))
#+END_SRC

Now, we can selectively make them appear with these links.

[[elisp:(remove-from-invisibility-spec '(beginner))][show me beginner]]

[[elisp:(remove-from-invisibility-spec '(medium))][show me medium]]

[[elisp:(remove-from-invisibility-spec '(advanced))][show me advanced]]

I imagine this could be useful to show selective content based on user choices. I am not sure it is better than links to external files. I imagine you would have to open this org file by some elisp command that would run the block at the top to make everything invisible, and then show it to the user. You could definitely build in more complex code to determine if a user was allowed to open a section.

#+BEGIN_SRC emacs-lisp
(defun level2-p ()
  "return if user is ready for level 2 based on value of property named correct"
  (interactive)
  (save-excursion
    (org-open-link-from-string "[[#beginner]]")
    (let ((val (org-entry-get (point) "correct")))
      (if (and val (string= val "true"))
	  t
	nil))))
#+END_SRC

#+RESULTS:
: level2-p

Now, we can build this link: [[elisp:(when (level2-p) (remove-from-invisibility-spec '(medium)))]]

This will show the medium level, provided we have already opened the beginner level and set the property value correctly.

** subsection 1
   :PROPERTIES:
   :level:    beginner
   :CUSTOM_ID: beginner
   :correct:  true
   :END:
some text in 1

** subsection 2
   :PROPERTIES:
   :level:    medium
   :END:
more text in 2

** subsection 3
   :PROPERTIES:
   :level:    advanced
   :END:
last section 3

* DONE Add time to a deadline
  CLOSED: [2014-02-05 Wed 09:41]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/05 09:41:04
  :updated:  2014/02/05 09:41:04
  :END:
I have an application where an org-file is a template with some due dates in it. I would like to update the deadlines to make them all relative to today. In this post I explore a way to do that. The strategy is to find deadlines, parse the time out of the time stamp, add an appropriate amount of time, and replace the time stamp. For this exercise, we use this org-file, which has one DEADLINE of "2014-01-13 Mon", and I want to add 60 days to the time stamp.

Amazingly, emacs can parse time strings into a format that it can understand. I do not claim to understand what this function returns, but it is some representation of time that emacs understands.
#+BEGIN_SRC emacs-lisp :results value raw
(date-to-time "<2014-01-13 Mon>")
#+END_SRC

#+RESULTS:
(21203 11392)

Now, we can add time to that format. Let us say I want to add 60 days. In emacs, we add seconds to a time, so 60 days is 60 days * 24 hours * 60 minutes * 60 seconds, or in elisp: (* 60 24 60 60).
#+BEGIN_SRC emacs-lisp :results value raw
(let ((sixty-days (seconds-to-time (* 60 24 60 60))))
  (time-add (date-to-time "<2014-01-13 Mon>") sixty-days))
#+END_SRC

#+RESULTS:
(21282 18048 0 0)

That does not make too much sense, so we can use another function to format it like a new time stamp.

#+BEGIN_SRC emacs-lisp :results value raw
(let ((sixty-days (seconds-to-time (* 60 24 60 60))))
  (format-time-string "<%Y-%m-%d %a>"
		      (time-add (date-to-time "<2014-01-13 Mon>") sixty-days)))
#+END_SRC

#+RESULTS:
<2014-03-13 Thu>

Beautiful. We just got a timestamp that is 60 days later than the original timestamp. Now we just search forward to find deadline, get the time stamp, add the time to it, and replace the line. I specifically want to change deadlines, so we will develop a regular expression for that. Here is a block that searches forward for a DEADLINE, parses it, adds 60 days to it, and replaces the deadline. The regular expression is limited to timestamps that look like <yyyy-mm-dd day>, i.e. no warnings or repeaters are found. In this post, there is subheading that looks like this initially:

#+BEGIN_EXAMPLE
** s1
    DEADLINE: <2014-01-02 Thu>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(progn
  (save-excursion
    ;; go to timestamp
    (re-search-forward "DEADLINE:\\s-*<\\(\\([0-9]\\{4\\}\\)-\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)\\s-\\(Mon\\|Tue\\|Wed\\|Thu\\|Fri\\|Sat\\|Sun\\)\\)>")
    (let ((ts (match-string 1)) ;; this is the timestamp
          (sixty-days (seconds-to-time (* 60 24 60 60)))
          (new-ts))
      (setq new-ts (format-time-string "    DEADLINE: <%Y-%m-%d %a>"
                                       (time-add (date-to-time ts) sixty-days)))
      ;; now we kill the old time stamp, and insert the new one
      (beginning-of-line)
      (kill-line)
      (insert new-ts))))
#+END_SRC

#+RESULTS:

After we run the code above, the deadline looks like this:
#+BEGIN_EXAMPLE
** s1
    DEADLINE: <2014-03-02 Sun>
#+END_EXAMPLE

We succeeded in moving it by 60 days. An interesting application of this would be to make all the deadlines in an org-file relative to some baseline date. For example, you have a series of deadlines for assignments throughout a semester, and it would be tedious to update these by hand. Suppose you could just establish a new beginning date, and make all deadlines relative to that date with a command. That seems useful.


** s1
    DEADLINE: <2014-03-02 Sun>



* DONE Separating code blocks from results in org-mode
  CLOSED: [2014-02-08 Sat 09:03]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/02/08 08:54:57
  :updated:  2014/02/08 09:15:39
  :END:
I often put my code blocks right where I need them in my org documents. It usually has a section explaining what I want to do, then the code block that implements the idea, following by the output. Sometimes the code blocks are long, however, and it might be desirable for that code to be in an appendix. [fn:4]

Org-mode enables this with #+CALL. For example, I have a function named =circle-area= in the appendix of this post that calculates the area of a circle given its radius. The function is "named" by a line like this:

#+BEGIN_EXAMPLE
#+name: function-name
#+END_EXAMPLE

I can use the function like this:

#+BEGIN_EXAMPLE
#+CALL: circle-area(1)
#+END_EXAMPLE

#+CALL: circle-area(1)

#+RESULTS:
: 3.14159265359

That is pretty nice. You can separate the code out from the main document. You still have to put the #+CALL: line in though. It may be appropriate to put a call inline with your text. If you add the following sentence, and put your cursor on the call_circle-area and press C-c C-c, the output is put in verbatim markers right after it.

#+BEGIN_EXAMPLE
The area of a circle with unit radius is call_circle-area(1).
#+END_EXAMPLE

The area of a circle with unit radius is call_circle-area(1) =3.14159265359=.

Here is another interesting way to do it. We can specify a named results block. Let us consider another function named =hello-block= that prints output. We specify a named results block like this:

#+BEGIN_EXAMPLE
#+RESULTS: function-name
#+END_EXAMPLE

Now, whenever you execute that block, the results will get put where this line is like this.

#+RESULTS: hello-block
: hello John

These could be useful approaches to making the "top" of your document cleaner, with less code in it. The code of course is still in the document, but at the end, in an appendix for example. This kind of separation might make it a little harder to find the code, and to reevaluate it,[fn:5] but it might improve the readability for others.




** Appendix of code

*** Area of a circle
#+name: circle-area
#+header: :var r=0
#+begin_src python :results value
import numpy as np
return np.pi * r**2
#+end_src


*** Hello function

#+name: hello-block
#+header: :var name="John"
#+BEGIN_SRC python  :results output
print 'hello ' + name
#+END_SRC


* DONE yasnippets for jasp, ase and python
  CLOSED: [2014-02-17 Mon 09:03]
  :PROPERTIES:
  :categories: jasp,ase,emacs
  :date:     2014/02/17 09:03:50
  :updated:  2014/02/17 09:03:50
  :END:

In using [[http://github.com/jkitchin/jasp for calculations, I find there are lots of small python phrases I use over and over. Today I will examine using [[http://capitaomorte.github.io/yasnippet/index.html][yasnippet]] to save time and keystrokes. yasnippet is a template expansion module, where you type a small set of characters, press =Tab=, and the
characters "expand" to the full text. It is pretty sophisticated, and allows you to define "tab-stops" which you interactively fill in, and tab between like filling in a form.

All the snippets are defined in the [[*Appendix][Appendix]].

** Tangle the snippets, and add them to yasnippet

Each snippet definition belongs in a file in a directory. The main directory is called "snippets". Since I anticipate using these snippets in org-mode, each snippet is defined in a directory within snippets called "org-mode". First, we make the directory here. I also want to use the snippets in python mode, so we also create a python-mode directory here. We do not have to duplicate the snippets. We can create a file called [[http://capitaomorte.github.io/yasnippet/snippet-organization.html][.yas-parents]], with one line in it containing "org-mode".

#+BEGIN_SRC sh
mkdir -p snippets/org-mode
mkdir -p snippets/python-mode
echo "org-mode" > snippets/python-mode/.yas-parents
#+END_SRC

#+RESULTS:

Each snippet is defined in a src block with  a =:tangle= header. So, we can extract them all in one command here.

#+BEGIN_SRC emacs-lisp
(org-babel-tangle)
#+END_SRC

#+RESULTS:
| snippets/org-mode/iase | snippets/org-mode/imp | snippets/org-mode/inp | snippets/org-mode/ij | snippets/org-mode/pl | snippets/org-mode/pyl | snippets/org-mode/pxl | snippets/org-mode/pp | snippets/org-mode/npa | snippets/org-mode/awt | snippets/org-mode/avw | snippets/org-mode/agf | snippets/org-mode/ape | snippets/org-mode/atms | snippets/org-mode/atm | snippets/org-mode/cga | snippets/org-mode/cc | snippets/org-mode/wjn | snippets/org-mode/wjl |

We also need to add our new directory to yasnippets. This is done by adding the directory to the =yas-snippet-dirs= variable. You could add this to your init.el file to permanently add these snippets.

#+BEGIN_SRC emacs-lisp
(add-to-list 'yas-snippet-dirs "c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/snippets")
#+END_SRC
#+RESULTS:
| c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/snippets | ~/.emacs.d/snippets | c:/users/jkitchin/Dropbox/kitchingroup/jmax/elpa/yasnippet-20140106.1009/snippets |

Finally, we reload all the snippet definitions, so our new definitions are ready to use.
#+BEGIN_SRC emacs-lisp
(yas-reload-all)
#+END_SRC

#+RESULTS:
: [yas] Reloaded everything (snippets will load just-in-time)... (some errors, check *Messages*).

Alternatively, you might just load this directory.
#+BEGIN_SRC emacs-lisp
(yas-load-directory "./snippets")
#+END_SRC

#+RESULTS:

** Using the snippets
Each of these snippets is for a python phrase, but I usually write my python blocks in org-mode. You would use these by typing the shortcut name, and then pressing tab. Below I show what each shortcut expands to.

wjl \to =with jasp('') as calc:=

wjn \to =with jasp('',) as calc:=
    =calc.calculate(atoms)=

cc  \to =calc.calculate(atoms)=

cga \to =atoms = calc.get_atoms()=

atm \to =Atom('', )=

atms \to =atoms = Atoms([], cell=)=

ape \to =atoms.get_potential_energy()=

agf \to =atoms.get_forces()=

avw \to =from ase.visualize import view=
=view(atoms)=

awt \to =from ase.io import write=
=write('.png', atoms, show_unit_cell=2)=

npa \to =np.array()=

pp \to =plt.plot(, )=

pxl \to =plt.xlabel()=

pyl \to =plt.ylabel()=

pl \to =plt.legend()=

ij \to =from jasp import *=

inp \to =import numpy as np=

imp \to =import matplotlib.pyplot as plt=

iase \to =from ase import Atom, Atoms=

What other snippets would be handy?

** Appendix
*** jasp snippets
#+BEGIN_SRC snippet :tangle snippets/org-mode/wjl
# -*- mode: snippet -*-
# --
with jasp('$1') as calc:
    $0
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/wjn
# -*- mode: snippet -*-
# --
with jasp('$1',$0) as calc:
    calc.calculate(atoms)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/cc
# -*- mode: snippet -*-
# --
calc.calculate(atoms)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/cga
# -*- mode: snippet -*-
# --
atoms = calc.get_atoms()
#+END_SRC

*** ase snippets

Template for an ase.Atom

#+BEGIN_SRC snippet :tangle snippets/org-mode/atm
# -*- mode: snippet -*-
# --
Atom('$1', $2)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/atms
# -*- mode: snippet -*-
# --
atoms = Atoms([$1], cell=$2)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/ape
# -*- mode: snippet -*-
# --
atoms.get_potential_energy()
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/agf
# -*- mode: snippet -*-
# --
atoms.get_forces()
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/avw
# -*- mode: snippet -*-
# --
from ase.visualize import view
view(${1:atoms})
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/awt
# -*- mode: snippet -*-
# --
from ase.io import write
write('$1.png', ${2:atoms}, show_unit_cell=${3:2})
#+END_SRC

*** python snippets
#+BEGIN_SRC snippet :tangle snippets/org-mode/inp
# -*- mode: snippet -*-
# --
import numpy as np
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/imp
# -*- mode: snippet -*-
# --
import matplotlib.pyplot as plt
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/iase
# -*- mode: snippet -*-
# --
from ase import Atom, Atoms
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/npa
# -*- mode: snippet -*-
# --
np.array($0)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pp
# -*- mode: snippet -*-
# --
plt.plot($1, $2)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pxl
# -*- mode: snippet -*-
# --
plt.xlabel($1)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pyl
# -*- mode: snippet -*-
# --
plt.ylabel($1)
#+END_SRC

#+BEGIN_SRC snippet :tangle snippets/org-mode/pl
# -*- mode: snippet -*-
# --
plt.legend($1)
#+END_SRC


#+BEGIN_SRC snippet :tangle snippets/org-mode/ij
# -*- mode: snippet -*-
# --
from jasp import *
#+END_SRC
* DONE A dynamic snippet for a task due 7 days from now
  CLOSED: [2014-02-16 Sun 13:50]
  :PROPERTIES:
  :categories: emacs,org-mode
  :date:     2014/02/16 13:50:27
  :updated:  2014/02/16 15:52:44
  :END:

I have been playing with yasnippets. A pretty cool feature is that you can run elisp code in the template to generate text. Below, I define a snippet that will create a todo item due 7 days from the time you define it. This is an unconventional way to define a snippet, but I did not want to save it to a file just to try it out. So, I put it in a temporary buffer, and load it from there. When you run this block, it will note it is a new snippet, and ask if you want to save it. You can say no. 

We will use the code we developed [[http://kitchingroup.cheme.cmu.edu/blog/2014/02/05/Add-time-to-a-deadline/][here]] to create a timestamp from the
current time plus seven days.

#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : todo-followup
# --

*************** TODO $1
${2:		 DEADLINE: `(let ((seven-days (seconds-to-time (* 7 24 60 60))))
  (format-time-string \"<%Y-%m-%d %a>\" (time-add (current-time) seven-days)))`}$0
*************** END 
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:


Now, you will have a new entry in the YASnippet menu that is called todo-followup. If you put the cursor on a blank line, and select that entry you get this below (after you fill in the text for the headline, of course!):

#+BEGIN_EXAMPLE
*************** TODO see how many times this was viewed
		DEADLINE: <2014-02-23 Sun>
*************** END 
#+END_EXAMPLE



That is pretty nice, as it saves a lot of keystrokes for that
particular kind of task. Let us up the ante, and see if we can make it
interactive so you can enter the number of days from now the task is
due.

#+BEGIN_SRC emacs-lisp
(yas-global-mode)
(with-temp-buffer
  (insert "# name : todo-followup
# --

*************** TODO $1
${2:		 DEADLINE: `(let ((ndays (seconds-to-time (* (string-to-int (read-from-minibuffer \"Days until due: \")) 24 60 60))))
  (format-time-string \"<%Y-%m-%d %a>\" (time-add (current-time) ndays)))`}$0
*************** END 
")
  (yas-load-snippet-buffer-and-close 'org-mode))
#+END_SRC

#+RESULTS:

#+BEGIN_EXAMPLE
*************** TODO sweet!
		DEADLINE: <2014-02-26 Wed>
*************** END 
#+END_EXAMPLE
Well, that made it just a bit sweeter! I was prompted for the "Days
until due:", entered 10 days, and a date 10 days from now was
automatically entered!


* TODO A gradebook app for emacs
  :PROPERTIES:
  :categories: emacs-lisp
  :END:
The goal is to create an emacs library to compute grades from a table in org-mode.

All grades are stored in a table with this structure.

#+tblname: gradebook
| first name | last name | email       | Hwk 1 | Hwk2 | exam1 | project 1 |
|            |           |             | 10    | 10   | 60    | 20        |
|------------+-----------+-------------+-------+------+-------+-----------|
| Jane       | Doe       | jd@cmu.edu  | A     | A    | B     | B         |
| John       | Dillinger | jdi@cmu.edu | B     | B/C  | A     | C         |
| jill       | wutz      | jw@cmu.edu  | D     | D    | R     | R         |

The grading system works like this:

1. Each assignment is worth a certain number of points (in row2).
2. Each assignment for a student is given a letter grade that indicates the quality and correctness of the work.
3. Each letter grade corresponds to a point multiplier:

| A++ |  1.0 |
| A+  | 0.95 |
| A   |  0.9 |
| A-  | 0.85 |
| A/B |  0.8 |
| B+  | 0.75 |
| B   |  0.7 |
| B-  | 0.65 |
| C/B |  0.6 |
| C+  | 0.55 |
| C   |  0.5 |
| C-  | 0.45 |
| C/D |  0.4 |
| D+  | 0.35 |
| D   |  0.3 |
| D-  | 0.25 |
| D/R |  0.2 |
| R+  | 0.15 |
| R   |  0.1 |
| R-  | 0.05 |
| R-- |  0.0 |

4. The number of points earned for an assignment is the point multiplier for the letter grade times the number of points for that assignment.
5. The overall grade is computed as sum(multiplier*points)/sum(points).
6. The overall letter grade is determined by the fraction of overall points received, mapped back on to the letter grade scale.

For example, in the table above, Jane Doe's grade is:

#+BEGIN_SRC emacs-lisp :results value
(let* ((multipliers '(0.9 0.9 0.7 0.7))
       (points '(10 10 60 20))
       (earned-points (mapcar* (lambda (a b) (* a b)) multipliers points))
       (total-earned-points (apply '+ earned-points))
       (total-points (apply '+ points)))
  (/ total-earned-points total-points))
#+END_SRC
#+RESULTS:
: 0.74

Which corresponds to an overall grade of B.

The goal here is to write emacs-lisp code to compute the overall grade of each student and convert it to an overall letter grade and write a little report.

We start by defining a variable to hold the multipliers. We will use an association list. We will prefix every variable and function with =gb/= to indicate it is part of our gradebook code.

#+BEGIN_SRC emacs-lisp
(defvar gb/MULTIPLIERS
  '(("A++" . 1.0)
    ("A+"   . 0.95)
    ("A"    . 0.9)
    ("A-"   . 0.85)
    ("A/B"  . 0.8)
    ("B+"   . 0.75)
    ("B"    . 0.7)
    ("B-"   . 0.65)
    ("B/C"  . 0.6)
    ("C+"   . 0.55)
    ("C"    . 0.5)
    ("C-"   . 0.45)
    ("C/D"  . 0.4)
    ("D+"   . 0.35)
    ("D"    . 0.3)
    ("D-"   . 0.25)
    ("D/R"  . 0.2)
    ("R+"   . 0.15)
    ("R"    . 0.1)
    ("R-"   . 0.05)
    ("R--"  . 0.0))
  "Numeric multipliers for letter grades")
#+END_SRC

#+RESULTS:

Here are two examples of using the gb/MULTIPLIER variable. It is an association list, so the multipler we want is the =cdr= of what the letter is associated with. We take the =cdr= of the return value, which is the numeric multiplier

#+BEGIN_SRC emacs-lisp :results value
(cdr (assoc "A" gb/MULTIPLIERS))
#+END_SRC

#+RESULTS:
: 0.9

We are going to write a series of functions that will compute the overall grade for each student.

A function we will need is to move the cursor into the table. Here is a function that will do that. This function moves the cursor to the beginning of the buffer, searches forward to find a line starting with a #+tblname: "name", and then moves the cursor to the next line which is in the table.

#+BEGIN_SRC emacs-lisp
(defun gb/goto-table (tblname)
  "move cursor into the table labeled tblname"
  (interactive)
  (goto-char (point-min))
  (search-forward-regexp (format "^#\\+tblname:\s+%s" tblname))
  (next-line))
#+END_SRC

#+RESULTS:

We use the function to move the cursor into the table, and then extract all the contents out.  We wrap the function call inside =save-excursion= so that the cursor gets put back where we want it. In this snippet, we use the (org-table-to-lisp) function to convert the table to a lisp structure which we can do further analysis on.

#+BEGIN_SRC emacs-lisp :results value verbatim
;; http://orgmode.org/worg/org-api/org-table-api.html
(require 'org-table) ; needed for access to org-table api

(defun gb/get-gradebook-lisp ()
  (interactive)
  (save-excursion
    (gb/goto-table "gradebook")
    (org-table-to-lisp)))

(gb/get-gradebook-lisp)
#+END_SRC
#+RESULTS:
: (("first name" "last name" "email" "Hwk 1" "Hwk2" "exam1" "project 1") ("" "" "" "10" "10" "60" "20") hline ("Jane" "Doe" "jd@cmu.edu" "A" "A" "B" "B") ("John" "Dillinger" "jdi@cmu.edu" "B" "B/C" "A" "C") ("jill" "wutz" "jw@cmu.edu" "D" "D" "R" "R"))

This is handy. Now we can think about processing the lisp data. Let us get the assignment names, and point values and save them in variables. The assignment names are in the first row, and start in column 3.

#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row1 (car (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENTS (mapcar 'identity (nthcdr 3 row1))))

gb/ASSIGNMENTS
#+END_SRC

#+RESULTS:
: ("Hwk 1" "Hwk2" "exam1" "project 1")

And now the point values, and total points.
#+BEGIN_SRC emacs-lisp :results value verbatim
(let ((row2 (cadr (gb/get-gradebook-lisp))))
 (setq gb/ASSIGNMENT-POINTS (mapcar 'string-to-number (nthcdr 3 row2)))
 (setq gb/TOTAL-POINTS (apply '+ gb/ASSIGNMENT-POINTS)))

(format "ASSIGNMENT-POINTS=%s TOTAL-POINTS=%s" gb/ASSIGNMENT-POINTS gb/TOTAL-POINTS)
#+END_SRC

#+RESULTS:
: "ASSIGNMENT-POINTS=(10 10 60 20) TOTAL-POINTS=100"

So far, so good. Now, we need to get the letter grades for each student, and turn them into point multipliers.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-multiplier (LG)
  "return numeric multiplier for a letter grade"
  (interactive)
  (cdr (assoc (upcase LG) gb/MULTIPLIERS)))

(defun gb/get-multipliers(LGS)
  "apply get-multiplier to a list of letter grades"
  (interactive)
  (mapcar 'gb/get-multiplier LGS))

(defun gb/get-all-student-multipliers ()
  (mapcar 'gb/get-multipliers
          (mapcar (lambda (x)
                    (nthcdr 3 x))
                  (cdddr (gb/get-gradebook-lisp)))))

(gb/get-all-student-multipliers)
#+END_SRC

#+RESULTS:
: ((0.9 0.9 0.7 0.7) (0.7 0.6 0.9 0.5) (0.3 0.3 0.1 0.1))


Finally, we need the product of each multiplier with the gb/ASSIGNMENT-POINTS. This needs some care; some grades may be nil, which we cannot multiply. For now we neglect this detail.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-earned-points (multipliers)
  (mapcar* (lambda (a  b) (* a b)) multipliers gb/ASSIGNMENT-POINTS))

(defun gb/get-all-earned-points ()
  "returns total points earned by each student"
  (mapcar 'gb/get-earned-points  (gb/get-all-student-multipliers)))

(gb/get-all-earned-points)
#+END_SRC

#+RESULTS:
: ((9.0 9.0 42.0 14.0) (7.0 6.0 54.0 10.0) (3.0 3.0 6.0 2.0))

Next, we need to sum all the points and divide by the total points to get the overall numeric grade.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-all-numeric-grades ()
(mapcar (lambda (x)
          (/ (apply '+ x) gb/TOTAL-POINTS))
          (gb/get-all-earned-points)))

(gb/get-all-numeric-grades)
#+END_SRC

#+RESULTS:
: (0.74 0.77 0.14)

And finally, convert the numeric grades to letter grades. This involves finding the highest letter grade multiplier that the overall grade is larger than.

#+BEGIN_SRC emacs-lisp :results value verbatim
(defun gb/get-final-letter-grade (grade)
 (dolist (pair gb/MULTIPLIERS letter-grade)
   (if (< (cdr pair) grade)
       (progn
         (setq letter-grade (car pair))
         (return letter-grade)))))

(mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))
#+END_SRC

#+RESULTS:
: ("B" "B+" "R")

That looks good. Now, let's make a final report of the results.

#+BEGIN_SRC emacs-lisp :results value
(let ((emails (mapcar '(lambda (x) (nth 2 x)) (cdddr (gb/get-gradebook-lisp))))
      (first-names (mapcar '(lambda (x) (nth 0 x)) (cdddr (gb/get-gradebook-lisp))))
      (last-names (mapcar '(lambda (x) (nth 1 x)) (cdddr (gb/get-gradebook-lisp))))
      (final-grades (mapcar 'gb/get-final-letter-grade (gb/get-all-numeric-grades))))
(mapcar* (lambda (fn ln em fg)
           `(,fn ,ln ,em ,fg))
         first-names
         last-names
         emails
         final-grades))
#+END_SRC

#+RESULTS:
| Jane | Doe       | jd@cmu.edu  | B  |
| John | Dillinger | jdi@cmu.edu | B+ |
| jill | wutz      | jw@cmu.edu  | R  |

** Summary
This is a pretty functional bit of code for computing final grades of a fixed format gradebook. It is missing some features. For example, it would not work well if any grades are missing, or if the gradebook is incomplete.

* TODO Testing units
#+BEGIN_SRC python
from pycse.units import units

u = units()

a = 5 * u.kJ
print repr(a)

b = u.kJ**2# * (1.0 / u.kJ)
print repr(b)
c = (1.0 / u.kJ)
print repr(c)

print repr(b*c)
print a.AS((1.0 / u.kJ) * u.kJ**2)
#print a.as_units(u.m)

#print '{0:1.3e}'.format(a)
#print '{0:f kJ}'.format(a)
#+END_SRC

#+RESULTS:
: Unit(5000.0, exponents=[ 2 -2  1  0  0  0  0], label=kJ)
: Unit(1000000.0, exponents=[ 4 -4  2  0  0  0  0], label=kJ^2)
: Unit(0.001, exponents=[-2  2 -1  0  0  0  0], label=kJ^-1)
: Unit(1000.0, exponents=[ 2 -2  1  0  0  0  0], label=(kJ^2)*(kJ^-1))
: 5.0 * (kJ^-1)*(kJ^2)



#+BEGIN_SRC python
from pycse.units import *
from pycse.umath import quad


u = units()
k = 0.23 * 1 / u.min
Cao = 2 * u.mol / u.L
V = 1 * u.L

Nao = Cao * V

def integrand(Na):
    return 1 / (k * Na)

t, terr = quad(integrand, 0.5 * Nao, Nao)
print t
#+END_SRC

#+RESULTS:
: 180.821003624 * s

* TODO Overloading subclass methods

#+BEGIN_SRC python
import numpy as np

class A(np.ndarray):

    def __new__(cls, input_array, label=None):
        # Input array is an already formed ndarray instance
        # We first cast to be our class type
        obj = np.asarray(input_array).view(cls)
        # add the new attribute to the created instance
        obj.label = label
        # Finally, we must return the newly created object:
        return obj

    def __array_finalize__(self, obj):
        if obj is None: return
        self.label = getattr(obj, 'label', None)

    def __array_wrap__(self, out_arr, context=None):
        return np.ndarray.__array_wrap__(self, out_arr, context)

    def __str__(self):
        return 'A({0}, label={1!s})'.format(np.array(self), self.label)


a = A(2)
print a

print a * 2
print np.float(2) * a
print np.float32(2) * a
print np.float64(2) * a
print np.__version__

#+END_SRC

#+RESULTS:
: A(2, label=None)
: A(4, label=None)
: A(4.0, label=None)
: A(4.0, label=None)
: 4.0
: 1.6.1
: 1.6.1
* TODO Testing out a new python units package
  :PROPERTIES:
  :categories: units
  :END:

#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()

distance = 1.0 * u.meter

dd = distance / (1*u.cm)
print 'dd = ',dd
print dd.magnitude, dd.dimensionality
print dd.to('dimensionless')
print
print 5 * dd * u.cm
print 'float = ',float(dd)
import numpy as np
print np.log(dd)


E = 10 * u.kJ/u.mol
R = 2 * u.cal/u.mol/u.K
T = 300 * u.K

print E/R/T
#+END_SRC

#+RESULTS:
: dd =  1.0 meter / centimeter
: 1.0 dimensionless

: 100.0 dimensionless
:
: 5.0 meter
: float =  100.0
: 4.60517018599
: 0.0166666666667 kilojoule / cal



#+BEGIN_SRC python
from pint import UnitRegistry
u = UnitRegistry()


from scipy.optimize import fsolve
Fa0 = 3.0                 # mol/min
Fa = Fa0 * (1.0 - 0.8)    # mol/min
G = Fa / Fa0

def objective(D):
    return 1 - G - D * G

Dsol, = fsolve(objective, 1.0)


nu = 1 * u.L / u.min
k = 0.34 * 1 / u.hr

# V = D * nu / k
print Dsol * nu / k   # this prints oddly because the units are not simplified
print (Dsol * nu / k).to(u.L)

#+END_SRC

#+RESULTS:
: 11.7647058824 hour * liter / minute
: 705.882352941 liter

* TODO erf and erfc for switching functions
In a [[http://jkitchin.github.io/blog/2013/01/31/Smooth-transitions-between-discontinuous-functions/][previous post]] I examined a way to switch between discontinuous functions smoothly using a sigmoid function. The [[http://en.wikipedia.org/wiki/Error_function][error function]] has similar properties to the sigmoid function we used previously, and the complementary error function (erfc) is defined as 1 - erf. So, these are two functions we could use to smoothly transition from one function to another.


#+BEGIN_SRC python
import numpy as np
from scipy.special import erf, erfc

xspan = np.linspace(-5, 5)

import matplotlib.pyplot as plt

plt.plot(xspan, 0.5 * (1 + erf(xspan)), xspan, 0.5 * erfc(xspan))
plt.legend(['erf', 'erfc'])
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import numpy as np
from scipy.optimize import fsolve
import matplotlib.pyplot as plt
from scipy.special import erf, erfc

def fF_laminar(Re):
    return 16.0 / Re

def fF_turbulent_unvectorized(Re):
    # Nikuradse correlation for turbulent flow
    # 1/np.sqrt(f) = (4.0*np.log10(Re*np.sqrt(f))-0.4)
    # we have to solve this equation to get f
    def func(f):
        return 1/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    fguess = 0.01
    f, = fsolve(func, fguess)
    return f

# this enables us to pass vectors to the function and get vectors as
# solutions
fF_turbulent = np.vectorize(fF_turbulent_unvectorized)

# Now we plot the correlations.

Re1 = np.linspace(500, 3000)
f1 = fF_laminar(Re1)

Re2 = np.linspace(3000, 10000)
f2 = fF_turbulent(Re2)

plt.figure(1); plt.clf()
plt.plot(Re1, f1, label='laminar')
plt.plot(Re2, f2, label='turbulent')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()


def fanning_friction_factor(Re):
    alpha = 20
    f =  0.5 * erfc(alpha*(Re-3000))* fF_laminar(Re) + 0.5 * (1 + erf(alpha*(Re-3000))) * fF_turbulent(Re)
    return f

Re = np.linspace(500,10000);
f = fanning_friction_factor(Re);

# add data to figure 1
plt.figure(1)
plt.plot(Re,f, label='smooth transition')
plt.xlabel('Re')
plt.ylabel('$f_F$')
plt.legend()
plt.show()
#+END_SRC

#+RESULTS:
* TODO Penalizing digital assignments that are turned in late

This semester I have experimented with using box.com to have students turn in assignments. The assignments often have deadlines. For homeworks, we were soft on this, and there was often time between the deadline and when assignments were "collected" for grading. As long as the assignments were available by the time we collected them, we gave students credit for the assignments. Still, some students turned in assignments after that, and we did not have a good strategy for dealing with that.

A new wrinkle came about when I started using box.com to give quizzes and exams. I learned how to make students collaborators on a folder for the duration of the quiz/exam, and then to turn off their ability to upload at the end of the quiz. The first time I ran this, students were unprepared for the amount of time it could take to upload, and a good fraction failed to turn in their quiz. They were /very/ unhappy. I tried modifying the approach to give them a visual timer, with a warning, and a buffer time to enable uploads. That helped, but some were still unable to upload in time. This puts you in an uncomfortable position of telling students they get no credit, or dealing with emails from them of their assignments after they are due, and then figuring out an appropriate penalty. The students are stressed out because they are worried about their grades, and they don't think it is fair. Even if they are deservedly so, worried, stressed out students aren't learning.

Now, I recognize these students should have turned it in when told to, and if this were a paper exam, there is a hard deadline of me walking out the door with the exams. Digitally turned in assignments do not have this kind of behavior. A way to reduce the overall stress around this is that rather than shutting off access to the upload, we should simply use an appropriate late penalty. That way, students get to turn in their work, which is psychologically less stressful, and they are appropriately penalized for being late.

Now, why is this difficult? It turns out it is not that easy to tell when a file is uploaded or modified on box.com. You can do it through the box.com api, but the timestamp comes in an unfamiliar form. Second, late is a difference in time.  The local time on a computer is not the same as the time on the box.com servers, so we cannot (or should not) use that difference to determine lateness.

#+BEGIN_SRC python
from box_course.box import *
import json

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

print json.dumps(jf, sort_keys=True, indent=4)
#+END_SRC

#+RESULTS:
#+begin_example
{
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
    "created_at": "2013-12-08T06:31:46-08:00",
    "created_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "description": "",
    "etag": "0",
    "id": "12178719122",
    "item_status": "active",
    "modified_at": "2013-12-08T06:31:47-08:00",
    "modified_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "name": "reference.txt",
    "owned_by": {
        "id": "190213074",
        "login": "jkitchin@ANDREW.CMU.EDU",
        "name": "John Kitchin",
        "type": "user"
    },
    "parent": {
        "etag": "0",
        "id": "1364917348",
        "name": "test",
        "sequence_id": "0",
        "type": "folder"
    },
    "path_collection": {
        "entries": [
            {
                "etag": null,
                "id": "0",
                "name": "All Files",
                "sequence_id": null,
                "type": "folder"
            },
            {
                "etag": "1",
                "id": "1328895168",
                "name": "group-course",
                "sequence_id": "1",
                "type": "folder"
            },
            {
                "etag": "0",
                "id": "1364917348",
                "name": "test",
                "sequence_id": "0",
                "type": "folder"
            }
        ],
        "total_count": 3
    },
    "purged_at": null,
    "sequence_id": "0",
    "sha1": "da39a3ee5e6b4b0d3255bfef95601890afd80709",
    "shared_link": null,
    "size": 0,
    "trashed_at": null,
    "type": "file"
}
#+end_example


I think the relevant information is:
#+BEGIN_EXAMPLE
    "content_created_at": "2013-12-08T06:31:46-08:00",
    "content_modified_at": "2013-12-08T06:31:47-08:00",
#+END_EXAMPLE

These timestamps are described [[https://www.ietf.org/rfc/rfc3339.txt][here]]. These timestamps are related to utc time, and can be converted to local time like this:

#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

def utc_to_local(timestamp):
    utc = parser.parse(timestamp)
    to_zone = tz.gettz('America/New_York')
    return utc.astimezone(to_zone)

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
file_id = j['id']
jf = get_file_information(file_id)

from dateutil import parser
dc = jf['content_created_at']
print utc_to_local(dc)
#+END_SRC

#+RESULTS:
: 2013-12-08 09:31:46-05:00

In fact, I did create that file around 9:31am on 12/8. The =-05:00= is related t the offset of our local time with utc.

Now, the key idea in calculating lateness is that I have a reference time on box.com now, by virtue of having created reference.txt at the beginning of the assignment. I created two assignment files, assignment1.txt and assignment2.txt that I uploaded about 30 seconds, and one minute after the reference.txt was created. Below, I calculate the amount of time elapsed between the reference file and assignment files.


#+BEGIN_SRC python
from box_course.box import *

from dateutil import parser
from datetime import datetime
from dateutil import tz

j = get_item('group-course/test/reference.txt') # created about 930am 12/8
jf = get_file_information(j['id'])
t0 = jf['content_modified_at']

j1 = get_item('group-course/test/assignment1.txt')
jf1 = get_file_information(j1['id'])
t1 = jf1['content_modified_at']

j2 = get_item('group-course/test/assignment2.txt')
jf2 = get_file_information(j2['id'])
t2 = jf2['content_modified_at']

p2 = parser.parse(t2)
p1 = parser.parse(t1)
p0 = parser.parse(t0)

d1 = p1 - p0
d2 = p2 - p0

print d1.total_seconds()
print d2.total_seconds()
#+END_SRC

#+RESULTS:
: 25.0
: 63.0

So, now we have a quantitative way to measure lateness. It is not a speedy method, since you have to make several box.com api calls, but, we can say how late it is, and since we use a reference file created on box.com at the beginning of the assignment, we take out the local time issue. The reference file could be created at the end of the assignment to mark when it is done.

Now about the penalty function. This is arbitrary, but should be a function that decays from 100% credit to some lower level of credit that is appropriate. For a homework, you might choose 50% as a floor, with some hours of decay time, whereas for a quiz/exam, it should be minutes of decay time down to 0%. Linear decay is the simplest. Let us say we want the credit to go from 100% to 50% over a 5 minute span. It would look like this:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

@np.vectorize
def penalty(t):
    if t < (5 * 60):
        p = 1.0 - (1.0 - 0.5) / (5 * 60) * t
    else:
        p = 0.5
    return p

t = np.linspace(0, 600, 100)
p = penalty(t)

plt.plot(t, p)
plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-penalty.png')
#+END_SRC

#+RESULTS:

[[./images/example-penalty.png]]

There are many options for a smooth decrease. Let us examine this gaussian function. We define a function that decays in the normal distribution sense, and allows you to set upper and lower bounds. To go from 1.0 to 0.5 we use this code:

#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

def penalty(t, mu=0.0, sigma=5, ub=1.0, lb = 0.0):
    return (ub - lb) * np.exp(-(t-mu)**2 / (2 * sigma**2)) + lb

t = np.linspace(0, 30)
plt.plot(t, penalty(t, lb=0.5))

plt.ylim([0, 1])
plt.ylabel('Late penalty')
plt.xlabel('Time (s)')
plt.savefig('images/example-gaussian-penalty.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./images/example-gaussian-penalty.png]]

You can see that after about 15 minutes (3 * sigma), the penalty will be


I think this would help reduce stress in the classroom, and make it more systematic to apply lateness penalties to assignments. I still have not worked out precisely how to integrate this into a grading workflow, since you need to run a script to get the penalties for each assignment, and then multiply the grade by it to get the penalized grade. You could grade normally, and have the script create a late file in the directory which is only used in calculating the overall grade.

* TODO Exporting LaTeX manuscripts from org-mode
  :PROPERTIES:
  :categories: org-mode
  :END:
We have been using org-mode to write manuscripts for submission to journals for publication. Our typical workflow is writing in org-mode, and then using a custom export function to turn the document into LaTeX, and then compiling to pdf via pdflatex. This /mostly/ works great, except for the following two issues:

1. We use BibTex for references, and most journals want us to replace the \bibliography{} lines with the contents of the .bbl file so it is self-contained.
2. We use png files in the org file so they show up in emacs. However, most journals want eps files, and we have to manually remove the .png extension from the LaTeX file so it will build on the journal site (which does not use pdflatex).

I am exploring some code that would automate those things.

** Replacing the bibliography line
Starting with item one, we need to get the contents of the bbl file, and then replace the bibliography line with that. The .bbl file is typically named after the tex file, which is named after the org file. So, if the org-file is blog.org, the tex file would be blog.tex, and the corresponding bbl file would be blog.bbl.

#+BEGIN_SRC emacs-lisp
; derive bbl filename from org file
(concat (file-name-sans-extension (file-name-nondirectory (buffer-file-name))) ".bbl")
#+END_SRC

An alternative approach is to replace text using a regexp.
#+BEGIN_SRC emacs-lisp
(replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name)))
#+END_SRC

Now, we need a way to get the contents of the bbl file. This works:
#+BEGIN_SRC emacs-lisp
(let* ((bbl-file (replace-regexp-in-string "org$" "bbl" (file-name-nondirectory (buffer-file-name))))
       (contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string))))
  (princ contents))
#+END_SRC

#+RESULTS:
: You got the contents of blog.bbl!

Finally, we should replace the bibliography string in the tex file with the contents of the bbl file. This block seems to do that. I think as long as the bibliography line does not span more than one line, and that there is not more than one of them this should work fine.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (bbl-file (replace-regexp-in-string "org$" "bbl" org-file))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (bbl-contents (with-temp-buffer (insert-file-contents bbl-file) (buffer-string)))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string "\\\\bibliography{.*}" bbl-contents tex-contents))))
#+END_SRC

#+RESULTS:

A work flow here would be to run a code block that exports the org-file to LaTeX, then run the code block above to insert the bbl file.

** Removing the image extensions
We put the .png extension in the figure links in org-mode so that org-mode will show the images in the buffer. That is convenient for writing. It is also fine if one uses pdflatex to compile the resulting LaTeX source. Some journals, however, use latex to build the document, and latex does not support png files; encapsulated postscript is preferrable for latex.

Luckily, you do not have to specify a file extension to latex, it will automatically look for the right extension (.eps for latex, .pdf or .png for pdflatex). So, we just need to strip the extension off of the image paths. Here is a regular expression and code block that seems to do this correctly.

#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"
 "\includegraphics{./images/test.png}


\\includegraphics{image/with/no/extension}
other latex

\\includegraphics[width=2in]{images/figure2.png}

\\includegraphics[width=3in]{./images/bulkmodulus-volume.png}
")
#+END_SRC

#+RESULTS:
: includegraphics{./images/test}
:
:
: \includegraphics{image/with/no/extension}
: other latex
:
: \includegraphics[width=2in]{images/figure2}
:
: \includegraphics[width=3in]{./images/bulkmodulus-volume}


We can combine this with the previous work on replacing the bibliography to replace all the extensions like this.

#+BEGIN_SRC emacs-lisp
(let* ((org-file (file-name-nondirectory (buffer-file-name)))
       (tex-file (replace-regexp-in-string "org$" "tex" org-file))
       (tex-contents (with-temp-buffer (insert-file-contents tex-file) (buffer-string))))
  (with-temp-file tex-file (insert (replace-regexp-in-string
 (concat "\\(\\includegraphics"
         "\\(\[?[^\].*\]?\\)?\\)"       ;; match optional [stuff]
         "{\\([^}\.].*\\)\.\\(png\\)}") ;; {path/to/image.png}
 "\\1{\\3}"  tex-contents))))
#+END_SRC

#+RESULTS:

** Putting this together
What we want to create is a function we could use to create the manuscript. There would be a function like this for different journals and/or publishers. For instance, APS journals use revtex, while ACS journals use achemso. There could be one publisher function that takes some options for the specific journal.

#+BEGIN_SRC emacs-lisp

#+END_SRC
* TODO VASP in emacs
#+BEGIN_EXAMPLE
PREC = Normal              #  precision normal
ENCUT = 300                #  cutoff used throughout all calculations
LREAL = .FALSE.            #  real space projection yes / no
ISMEAR = 0                 #  method to determine partial occupancies
#+END_EXAMPLE

[[./images/vanilla-incar.png]]

Now with vasp-mode:

[[./images/vasp-mode-incar.png]]

* TODO textify html

#+BEGIN_EXAMPLE
 	<title>Philip Herron: Cython Book</title> 	<guid>http://redbrain.co.uk/?p=147</guid> 	<link>http://redbrain.co.uk/cython-book/</link> 	<description><p>Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. <a href="http://bit.ly/195ahQs">http://bit.ly/195ahQs</a></p> <p><a href="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"><img class="aligncenter size-full wp-image-148" alt="photo" src="http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg" width="640" height="480" /></a>The code can be found: <a href="https://github.com/redbrain/cython-book">https://github.com/redbrain/cython-book</a></p></description> 	<pubDate>Tue, 10 Dec 2013 14:45:08 +0000</pubDate>
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(defun ph (start end) (interactive "r")
 (setq output (libxml-parse-html-region start end)))
#+END_SRC

(cdr '(a nil b))


#+BEGIN_SRC emacs-lisp :results output
(setq phtml
'(html nil
      (head nil
            (title nil "Philip Herron: Cython Book")
            (guid nil "http://redbrain.co.uk/?p=147")
            (link nil))
      (body nil
            (p nil "http://redbrain.co.uk/cython-book/ 	"
               (description nil
                            (p nil "Hey all i thought i should really share that i actually wrote a book on Cython. The book has detailed examples and even shows you how you can extend native C/C++ applications in python by doing it for Tmux. "
                               (a
                                ((href . "http://bit.ly/195ahQs"))
                                "http://bit.ly/195ahQs"))
                            " "
                            (p nil
                               (a
                                ((href . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg"))
                                (img
                                 ((class . "aligncenter size-full wp-image-148")
                                  (alt . "photo")
                                  (src . "http://redbrain.co.uk/wp-content/uploads/2013/12/photo.jpg")
                                  (width . "640")
                                  (height . "480"))))
                               "The code can be found: "
                               (a
                                ((href . "https://github.com/redbrain/cython-book"))
                                "https://github.com/redbrain/cython-book")))
               (pubdate nil "Tue, 10 Dec 2013 14:45:08 +0000")))))


;; (defun print-elements-recursively (list)
;;        "Print each element of LIST on a line of its own.
;;      Uses recursion."
;;        (when list                            ; do-again-test
;;              (print (car list))              ; body
;;              (if (listp (cdr list)) (print-elements-recursively (cdr list)))
;;              (print-elements-recursively     ; recursive call
;;               (cdr list))))                  ; next-step-expression

;(print-elements-recursively phtml)

(defun print-list (lst)
 (when lst
   (if (atom (car lst))
     (print (car lst)) (print-list (cdr lst)))))


(print-list phtml)
#+END_SRC

#+RESULTS:
:
: html






** another approach

<p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA"><img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img></a>
</div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
[[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>

(defun ph (r1 r2) (interactive "r") (setq html (buffer-substring r1 r2)))
#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1]]"  html)
#+END_SRC

#+RESULTS:
: <p><img src="http://pubs.acs.org/appl/literatum/publisher/achs/journals/content/jacsat/0/jacsat.ahead-of-print/ja4102634/aop/images/medium/ja-2013-102634_0006.gif" alt="TOC Graphic"/></p><div><cite>Journal of the American Chemical Society</cite></div></p><p><div>DOI: 10.1021/ja4102634</div><div class="feedflare">
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA]]
: </div><img src="http://feeds.feedburner.com/~r/acs/jacsat/~4/q6D8k6U8G2A" height="1" width="1"/>
: [[http://feedproxy.google.com/~r/acs/jacsat/~3/q6D8k6U8G2A/ja4102634]]</p>


http://www.mkyong.com/regular-expressions/how-to-extract-html-links-with-regular-expression/

these worked in re-builder (C-c C-w) then c-y to get them

"<p>\\(.+?\\)</p>" \\1 is the stuff between them


#+BEGIN_SRC emacs-lisp :results value
(replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]"  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>")
#+END_SRC

#+RESULTS:
: [[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]



(url-file-local-copy "http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA")

[[./tst.png]]


** downloading images

#+BEGIN_SRC emacs-lisp :results raw
(defun download-src (arg)
  (format "[[%s][image]]" (save-match-data
                            (url-file-local-copy
                             (replace-regexp-in-string
                              "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"
                              "\\1"
                              arg)))))

(princ (replace-regexp-in-string "<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>" #'download-src  "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
<a href="http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA">[[c:/Users/jkitchin/AppData/Local/Temp/url8408MBa][image]]</a>


** replacing <a>
#+BEGIN_SRC emacs-lisp :results raw
(princ (replace-regexp-in-string "<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>" "[[\\1][\\2]]" "<a href=\"http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA\"><img src=\"http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA\" border=\"0\"></img></a>"))
#+END_SRC

#+RESULTS:
[[http://feeds.feedburner.com/~ff/acs/jacsat?a=q6D8k6U8G2A:VC53erokX5E:yIl2AUoC8zA][<img src="http://feeds.feedburner.com/~ff/acs/jacsat?d=yIl2AUoC8zA" border="0"></img>]]

** some regexs
"<a href=\"\\([^>]+\\)\">\\(.+?\\)</a>"  \\1 is the href \\2 is the target

"<img\\([^>]+\\)></img>"

"<img\\s-*src=\\\"\\([^\\\">]+\\).*</img>"  \\1 is the src
* TODO Copy a bibtex entry with some formatting

#+BEGIN_SRC emacs-lisp
(defun formatted ()
  "copy entry to formatted string"
  (interactive)
  (bibtex-beginning-of-entry)
  (let* ((bibtex-expand-strings t)
         (entry (bibtex-parse-entry t))
         (title (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "title" entry)))
         (year  (reftex-get-bib-field "year" entry))
         (author (replace-regexp-in-string "\n\\|\t\\|\s+" " " (reftex-get-bib-field "author" entry)))
         (key (reftex-get-bib-field "=key=" entry))
         (journal (reftex-get-bib-field "journal" entry))
         (volume (reftex-get-bib-field "volume" entry))
         (issue (reftex-get-bib-field "issue" entry))
         (pages (reftex-get-bib-field "pages" entry))
         (doi (reftex-get-bib-field "doi" entry))
         (output))
    (setq output (concat (when author author) ", "
                         (when title title) ", "
                         (when journal journal) ", "
                         (when volume volume)
                         (if issue (format "(%s), " issue) ", ")
                         (when pages pages) ", "
                         (when year (format "(%s)." year))
                         (when doi (format " http://dx.doi.org/%s" doi))))
    (kill-new output)))

#+END_SRC

Abild-Pedersen, F. and Greeley, J. and Studt, F. and  Rossmeisl, J. and Munter, T. R. and Moses, P. G. and  Sk\'ulason, E. and Bligaard, T. and N\o{}rskov,  J. K., Scaling Properties of Adsorption Energies for  Hydrogen-Containing Molecules on Transition-Metal  Surfaces, Phys. Rev. Lett., 99(1),016105, (2007). http://dx.doi.org/10.1103/PhysRevLett.99.016105
* TODO Email buffer after time out

(timer-duration "0.5 min")


#+BEGIN_SRC emacs-lisp
(run-at-time 5 nil
             (lambda (args)
(princ "uuuu")
               (let ((body (buffer-string)))
                 (mail)
                 (mail-to)
                 (insert "jkitchin@andrew.cmu.edu")
                 (mail-subject)
                 (insert "exam")
                 (mail-text)
                 (insert body)
                 (mail-send-and-exit))))
#+END_SRC

#+RESULTS:


(run-at-time 5 nil
             (lambda (args) (insert "done")))

"09:40pm" 10

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defun totd ()
  (interactive)
  (random t) ;; seed with time-of-day
  (with-output-to-temp-buffer "*Tip of the day*"
    (let* ((commands (loop for s being the symbols
                           when (commandp s) collect s))
           (command (nth (random (length commands)) commands)))
      (princ
       (concat "Your tip for the day is:\\n"
               "========================\\n\\n"
               (describe-function command)
               "\\n\\nInvoke with:\\n\\n"
               (with-temp-buffer
                 (where-is command t)
                 (buffer-string)))))))

(defvar jao-totd-timer (run-at-time "12:00am" (* 30 1) 'totd))
(cancel-timer jao-totd-timer)


(defun jao-cancel-totd
  (interactive)
  (cancel-timer jao-totd-timer))

(defun td ()
  (interactive)
  (with-output-to-temp-buffer "*my-timer*"
  (insert "done")))

(defvar jao-totd-timer (run-at-time "12:00am" 1 'td))
(cancel-timer jao-totd-timer)



* DONE Putting link references to lines of code in a source block
  CLOSED: [2014-04-22 Tue 20:59]
  :PROPERTIES:
  :categories: org-mode
  :date:     2014/04/22 20:59:30
  :updated:  2014/04/22 20:59:30
  :END:
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
http://orgmode.org/manual/Literal-examples.html#Literal-examples

The following code block has some references in it that we can refer to later:
#+BEGIN_EXAMPLE
#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC
#+END_EXAMPLE


#+BEGIN_SRC emacs-lisp -n -r
(save-excursion                   (ref:sc)
  (goto-char (point-min)))        (ref:jump)
#+END_SRC


In line [[(sc)]] we remember the current position. [[(jump)][Line (jump)]] jumps to point-min.

To make this work with python we have to make a slight change to the reference format in the header.

#+BEGIN_EXAMPLE
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC
#+END_EXAMPLE

#+BEGIN_SRC python -n -r -l "#(ref:%s)"
for i in range(5):                #(ref:for)
    print i                       #(ref:body)
#+END_SRC

#+RESULTS:
: 0
: 1
: 2
: 3
: 4


In line [[(for)]] we initialize the loop, and in line [[(body)]] we run it.


* Storing INCAR parameters in a yaml file

#+BEGIN_SRC python
import yaml
document = r'''
encut:
  type: float
  units: eV
  description:  "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$   The number of plane waves differs for each k-point, leading to a superior beahviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations." '''

print yaml.load(document)
#+END_SRC

#+RESULTS:


There doesn't appear to be an emacs yaml reader. This is a dead end for now. Also, it is not clear that yaml is flexible enough to contain the markup.

* Storing INCAR parameters in a json file

I am exploring a way to list all the INCAR parameters for VASP in a file format that would allow me to generate the list of keywords in Python /and/ provide documentation in Emacs. Right now these keywords exist in a set of lists in ase.calculators.vasp, with some comments that indicate what they are. However, the only way to access the comments is via the source code. There is no way to show them to the user via a help command. Furthermore, most of the keywords are built in VASP keywords, but some are ase specific. For the VASP keywords, one can search the internet for them, which often brings up the VASP documentation, but sometimes that is slow. For the ase keywords, which implement convenience, one has to read the source. It would be nice to avoid all these issues, and provide documentation that is accessible in an editor too, e.g. in Emacs. 

Here we explore doing all of this in a json file. There are json parsers for python and emacs, so it seems possible.

Here is an example of what the json file might look like. The encut documentation is adapted from the VASP documentation

#+BEGIN_SRC text :tangle incar.json
{
    "ispin": {
        "description": "turn spin polarization on (2) or off (1)", 
        "default": 1, 
        "allowed_values": [
            1, 
            2
        ], 
        "units": null, 
        "type": "int", 
        "long_description": "The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. "
    }, 
    "encut": {
        "units": "eV", 
        "type": "float", 
        "description": "Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. "
    }
}
#+END_SRC

Now, we parse it with Python.
#+BEGIN_SRC python
import json

with open('incar.json') as f:
    data = json.loads(f.read())

print data

print data.keys()
#+END_SRC

#+RESULTS:
: {u'ispin': {u'description': u'turn spin polarization on (2) or off (1)', u'default': 1, u'allowed_values': [1, 2], u'units': None, u'type': u'int', u'long_description': u'The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. '}, u'encut': {u'units': u'eV', u'type': u'float', u'description': u'Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\\rm cut}$ are included in the basis set: i.e. $\\displaystyle \\vert {\\bf G}+ {\\bf k}\\vert < G_{\\rm cut}$ with $\\displaystyle \\qquad E_{\\rm cut}=\\frac{\\hbar^2}{2m}G_{\\rm cut}^2$   \n\nThe number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \\vert {\\bf G}\\vert < G_{\\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. '}}
: [u'ispin', u'encut']

That is easy enough. We only have to remember that the strings are read in a unicode. It is similarly easy in Emacs.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(let ((my-json (json-read-from-string (with-temp-buffer 
					(insert-file-contents "incar.json")
					(buffer-string)))))
  (princ my-json)
  (princ "\n")
  (princ (mapcar (lambda (x) (car x)) my-json)))
#+END_SRC

#+RESULTS:
: ((encut (description . Cut-off energy for plane wave basis set in eV. All plane-waves with a kinetic energy smaller than $E_ {\rm cut}$ are included in the basis set: i.e. $\displaystyle \vert {\bf G}+ {\bf k}\vert < G_{\rm cut}$ with $\displaystyle \qquad E_{\rm cut}=\frac{\hbar^2}{2m}G_{\rm cut}^2$   
: 
: The number of plane waves differs for each k-point, leading to a superior behaviour for e.g. energy-volume calculations. If the volume is increased the total number of plane waves changes    fairly smoothly. The criterion $ \vert {\bf G}\vert < G_{\rm cut}$ (i.e. same basis set for each k-point) would lead to a very rough energy-volume curve and, generally, slower energy convergence.   Starting from version VASP 3.2 the POTCAR files contains a default ENMAX (and ENMIN) line, therefore it is in principle not necessary to specify ENCUT in the INCAR file. For calculations with more than one species, the maximum cutoff (ENMAX or ENMIN) value is used for the calculation (see below, Sec. 6.11). For consistency reasons we still recommend to specify the cutoff manually in the INCAR file and keep in constant throughout a set of calculations. ) (type . float) (units . eV)) (ispin (long_description . The default for ISPIN is the value in the param.inc file 6.12. Setting ISPIN=1 allows to do non spin polarized (paramagnetic) calculations, even if VASP was compiled for the spin polarized case. It is not possible to set ISPIN=2, if ISPIND is not 2. ) (type . int) (units) (allowed_values . [1 2]) (default . 1) (description . turn spin polarization on (2) or off (1))))
: (encut ispin)

This looks pretty promising. I could have a json file that describes the keywords, provides documentation of the keywords, etc... In python I would use that file to generate the lists that vasp.py uses for each type of keyword, and to provide help functions in python. I could also do that in Emacs too. 

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((my-json (json-read-from-string (with-temp-buffer 
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc 'description (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help 'ispin))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

It might be confusing for a while that you use symbols instead of strings here. That is changeable with the json-object-type and json-key-type variable which can make them into strings. Here is an example.

#+BEGIN_SRC emacs-lisp :results output
(require 'json)

(defun incar-help (keyword)
  "return documentation string for keyword"
(interactive)
  (let* ((json-key-type 'string)
	 (my-json (json-read-from-string (with-temp-buffer 
					  (insert-file-contents "incar.json")
					  (buffer-string))))
	 (keywords (mapcar (lambda (x) (car x)) my-json)))

    (cdr (assoc "description" (cdr (elt my-json (index keyword keywords)))))))

(princ (incar-help "ispin"))
#+END_SRC

#+RESULTS:
: turn spin polarization on (2) or off (1)

This seems like a promising approach to provide flexible documentation to the keywords.

* Set a headline to DONE
  CLOSED: [2014-01-27 Mon 13:50]

#+BEGIN_SRC emacs-lisp
(org-narrow-to-subtree)
(goto-char (point-min)) ; beginning of buffer
(org-todo 'done)
(widen)
#+END_SRC

#+RESULTS:

* Using org-mode files as databases

Below are subheadings that contain data, properties and tags. Here, we use this entry as a database to summarize data.

#+BEGIN_SRC emacs-lisp
(let* ((total-units 0)
      (units)
      (course)
      (courses (org-map-entries (lambda ()
				  (setq units (string-to-number (org-entry-get (point) "UNITS"))
					total-units (+ total-units units)
					course (nth 4 (org-heading-components)))
				  `(,course  ,units ,(org-entry-get (point) "SEMESTER")))
				"chemistry|biology|physics|math" 'tree nil)))
  (add-to-list 'courses `(nil "Total units"  ,total-units) t))
#+END_SRC

#+RESULTS:
| 09-105 |           9 |  1 |
| 09-106 |           9 |  2 |
| 33-105 |          12 |  1 |
| 33-106 |          12 |  3 |
| 21-120 |           9 |  1 |
| 21-122 |           9 |  2 |
| 21-259 |           9 |  3 |
| 03-232 |           9 |  5 |
|    nil | Total units | 78 |





How about classes with less than 12 units?

#+BEGIN_SRC emacs-lisp
(org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil)
#+END_SRC

#+RESULTS:
| Using org-mode files as databases | nil |
|                            09-105 |   9 |
|                            09-106 |   9 |
|                            21-120 |   9 |
|                            21-122 |   9 |
|                            21-259 |   9 |
|                            03-232 |   9 |

I am surprised by the nil entry above. I would have thought an entry with out a property should not be counted. That suggests some list pruning is in order. There is a remove-if-not macro in the cl (common-lisp) library.

#+BEGIN_SRC emacs-lisp
(require 'cl)

(remove-if-not
  (lambda (arg) (nth 1 arg))
    (org-map-entries (lambda ()
		   (let ((heading (nth 4 (org-heading-components)))
			 (units (org-entry-get (point) "UNITS")))
		     `(,heading  ,units)))
		 "UNITS<12" 'tree nil))
#+END_SRC

#+RESULTS:
| 09-105 | 9 |
| 09-106 | 9 |
| 21-120 | 9 |
| 21-122 | 9 |
| 21-259 | 9 |
| 03-232 | 9 |

** 09-105							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 09-106							  :chemistry:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 33-105							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
** 33-106							    :physics:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 3
   :END:
** 21-120 							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 1
   :END:
** 21-122							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 2
   :END:
** 21-259							       :math:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 3
   :END:
** 03-232							    :biology:
   :PROPERTIES:
   :UNITS:    9
   :SEMESTER: 5
   :END:
** 06-100							:engineering:
   :PROPERTIES:
   :UNITS:    12
   :SEMESTER: 1
   :END:
* A widget based quiz in Emacs
  :PROPERTIES:
  :categories: emacs
  :END:

I have been interested in making quizzes in Emacs. Quizzes that
students would take, and somehow submit. One issue with an org-mode
quiz is the totally free-form; everything can be edited. Enter the
[[https://www.gnu.org/software/emacs/manual/html_mono/widget.html][widget]] library in Emacs. Below is an illustrative example of making a
quiz, adapted from [[https://www.gnu.org/software/emacs/manual/html_mono/widget.html#Programming-Example][here]]. I also adapted some code from [[http://stackoverflow.com/questions/13590811/how-i-can-get-values-of-all-widgets-in-current-widget-minor-mode-buffer-in-emacs][here]] to get a
list of widgets in a buffer, how they are tagged, and their values.

#+BEGIN_SRC emacs-lisp
(require 'widget)

(eval-when-compile
  (require 'wid-edit))

(require 'cl)
(defun get-widgets ()
  "return a list of widget tags and values from the buffer"
  (mapcar (lambda (x)
	      `(,(widget-get x :tag) ,(widget-value x)))
	  (save-excursion
	    (goto-char (point-min))
	    (loop while (not (eobp))
		  for new = (widget-at)
		  and old = nil then new
		  when (and new (not (eq new old))) collect new
		  do (goto-char (next-overlay-change (point)))))))

(defun submit-quiz (&rest ignore)
  "email results from quiz"
  (interactive)
  (let ((widgets (get-widgets)))
    (mail)
    (mail-to)
    (insert "jkitchin@andrew.cmu.edu")
    (mail-subject)
    (insert "quiz1")
    (mail-text)
    (insert (format "%s" widgets))
;    (insert quiz)
    (mail-send-and-exit)))

(defun quiz1 ()
  "create a simple quiz"
  (interactive)
  (switch-to-buffer "*Quiz 1*")
  (kill-all-local-variables)
  (let ((inhibit-read-only t))
    (erase-buffer))
  (remove-overlays)
  (widget-insert "You will take a quiz.\n\n")
  (widget-create 'editable-field
		 :size 13
                 :tag "quiz1-name"
		 :format "Name: %v ")

  (widget-insert "\n\nCheck all true statements:\n")
  (widget-create 'checkbox :tag "p1-a" nil)
  (widget-insert " 2+2 = 4\n")
  (widget-create 'checkbox :tag "p1-b" nil)
  (widget-insert " 3*3=8\n")
  (widget-create 'checkbox :tag "p1-c" nil)
  (widget-insert " widgets are cool.\n")

  (widget-insert " \n\nSelect the best answer. \\sqrt{64} = \n\n")
  (widget-create 'radio-button-choice
		 :tag "p2" :value nil
		 '(item "2")
                 '(item "4")
		 '(item "8"))

  (widget-insert "\n\nWrite a long essay.\n")
  (widget-create 'editable-field
                  :format "Text: %v "
                  :tag "p3-essay"
                  :size 20)

  (widget-insert "\n")
  (widget-create 'push-button
		 :notify #'submit-quiz
		 "Submit")
  (widget-insert " ")
  (widget-create 'push-button
		 :notify (lambda (&rest ignore) (kill-buffer))
		 "Quit")

  (use-local-map widget-keymap)
  (widget-setup))
#+END_SRC

#+RESULTS:
: quiz1

Now, we just run [[elisp:(quiz1)]] and we get a "form" to fill out.

On my computer, I get this after I fill it out:

[[./images/quiz1.png]]


After I press submit, this gets emailed to me:

[[./images/quiz1-answers.png]]

It is obviously not perfect, since it did not capture the radio
buttons in a useful way, and it collected the Submit and Quit buttons,
since they are widgets. Those can probably all be fixed with better
code, or maybe more specific code.

It is not too simple to write a quiz like this, but with some
practice, and best practice development, it might be pretty
straightforward after a while. The benefits are a more tightly
controlled quiz environment. Submission may still be tricky, since at
least in this case I rely on Emacs being setup for email. Other
methods might work too, e.g. an http POST, or saving a file to a shared
location.

See these links too:
- http://www.emacswiki.org/emacs/widget-demo.el

* Using macro expansions in org-mode

#+EMAIL: jkitchin@andrew.cmu.edu

#+RANDOM-KEYWORD: interesting

#+MACRO: my-animal-macro  a $1 has $2

Send me mail at {{{email}}}. My response will be {{{random-keyword}}}. Finally, you may be interested to know that {{{my-animal-macro(zebra,stripes)}}}.
* Converting Endnote libraries to bibtex files
  :PROPERTIES:
  :categories: bibtex
  :END:
I have had a need lately to convert Endnote libraries into bibtex files. Endnote has a BibTeX-Export style that will export your library. One issue with that style is it expects you to have a label in each entry. If you are a normal Endnote user, you do not have labels on any entry. There is no need for them. I also found that for entries with no label, there is no comma in the entry header, which causes Emacs to think the entry is syntactically incorrect. I fixed up the style to prevent that from happening. You can get a copy of the style [[C:\Users\jkitchin\Documents\EndNote\Styles\BibTeX-Export-kitchin.ens][here]].

Now, if you load that style, you can export a library to a
file. Endnote insists on making it a text file. We need to rename the
file, then we need to create keys for each entry. Normally, I would do
that with =bibtex-clean-entry=, which mostly works by hand. However, the bibtex entries are not correct yet, because they have no keys. We will add simple numeric keys, and then map over each entry to add proper keys.

#
#+BEGIN_SRC python
from bibtexparser.bparser import BibTexParser
from bibtexparser.customization import convert_to_unicode
import textwrap

def format_bibtex_entry(entry):
    # field, format, wrap or not
    field_order = [(u'author', '{{{0}}},\n', True),
                   (u'title', '{{{0}}},\n', True),
                   (u'journal','"{0}",\n', True),
                   (u'volume','{{{0}}},\n', True),
                   (u'number', '{{{0}}},\n', True),
                   (u'pages', '{{{0}}},\n', True),
                   (u'year', '{0},\n', True),
                   (u'doi','{{{0}}},\n', False),
                   (u'url','{{\url{{{0}}}}},\n', False),
                   (u'link','{{\url{{{0}}}}},\n', False)]

    keys = set(entry.keys())

    extra_fields = keys.difference([f[0] for f in field_order])
    # we do not want these in our entry
    extra_fields.remove('type')
    extra_fields.remove('id')

    # Now build up our entry string
    s = '@{type}{{{id},\n'.format(type=entry['type'].upper(),
                                  id=entry['id'])

    for field, fmt, wrap in field_order:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = fmt.format(entry[field])
            s3 = '{0:17s}{1}'.format(s1, s2)
            if wrap:
                # fill seems to remove trailing '\n'
                s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    for field in extra_fields:
        if field in entry:
            s1 = '  {0} ='.format(field.upper())
            s2 = entry[field]
            s3 = '{0:17s}{{{1}}}'.format(s1, s2)
            s3 = textwrap.fill(s3, subsequent_indent=' '*18, width=70) + '\n'
            s += s3

    s += '}\n\n'
    return s


import os
if os.path.exists('ternary-alloys-exported.bib'):
    os.unlink('ternary-alloys-exported.bib')

# get the entries
with open('ternary-alloys.bib', 'r') as bibfile:
    bp = BibTexParser(bibfile)
    entries = bp.get_entry_list()


for i, entry in enumerate(entries):
    # set key to a simple number
    entry['id'] = i
    with open('ternary-alloys-exported.bib', 'a') as f:
        f.write(format_bibtex_entry(entry))
#+END_SRC

#+RESULTS:


Ok, finally, our goal is consistency with Emacs. Now the entries are syntactically correct, and we can clean each entry. This block runs through each entry and replaces the numeric key with a key formatted our way. Unfortunately you still have to press enter for each entry.

#+BEGIN_SRC emacs-lisp
(find-file "ternary-alloys-exported.bib")
(bibtex-map-entries (lambda (entry start end)
(condition-case ex
    (bibtex-clean-entry t nil)
  ('error (message (format "Caught exception: [%s]" ex))))))
#+END_SRC

#+RESULTS:


[[./ternary-alloys-exported.bib]]




* Introspecting the variables in a python script

I want to build an emacs command that views an atoms, or prints a summary of a calculator in a code block. The idea is to get the python code in the block, run it in an interpreter, then view the atoms or print the calculator.

The reason I want to try this is that I often want a quick view of the atoms, but I do not want to import the module, write in the view line, and then comment them out. 

#+BEGIN_SRC emacs-lisp
(defun get-source ()
  "mark region of source block"
  (interactive)
  (let ((case-fold-search nil)
	(start)
	(end))
    (re-search-backward "^#\\+BEGIN_SRC")
    (forward-line)
    (setq start (point))
    
    (re-search-forward "^#\\+END_SRC")
    (previous-line)
    (end-of-line)
    (setq end (point))
    ;(message-box "%s %s %s" start end (buffer-substring start end))
    (buffer-substring start end)))

(defun print-calculator ()
  "print any calculators found in *jasp-calculator*"
  (interactive)
  (python-shell-internal-send-string (concat (get-source) "\n"))
 
  (switch-to-buffer "*jasp-calculator*")
  (erase-buffer)
  (insert (python-shell-internal-send-string " 
for k,v in globals().items():
    if isinstance(v, ase.calculators.vasp.Vasp):
        print v
")))

(defun view-atoms ()
  (interactive)
  "view any Atoms objects found"
  (python-shell-internal-send-string (concat (get-source) "\n"))
  (insert (python-shell-internal-send-string " 
from ase.visualize import view

for k,v in globals().items():
    if isinstance(v, ase.atoms.Atoms):
        view(v)
")))

#+END_SRC

#+RESULTS:
: get-source

#+BEGIN_SRC python
from ase import Atoms, Atom
from jasp import *

atoms = Atoms([Atom('O',[5, 5, 5], magmom=1)],
             cell=(6, 6, 6))

with jasp('O_sv',
          encut=300,
          xc='PBE',
          ispin=2,
          ismear=0,
          sigma=0.001,
          setups={'O':'_sv'}, # specifies O_sv potential
          atoms=atoms) as calc:
    print type(calc)
    print calc.__class__

#end
#+END_SRC

#+RESULTS:
: <type 'instance'>
: ase.calculators.vasp.Vasp
* Footnotes

[fn:1] Box Sync 4 renames your sync directory from "~/Documents/My Box Files" to "~/Box Sync".

[fn:2] You will have to read the raw org-source to see how the code-block arguments look.

[fn:3] It is true there are packages like FiPy (http://www.ctcms.nist.gov/fipy/) for PDEs, and scikits for BVPS, (http://scikits.appspot.com/bvp1lg, http://scikits.appspot.com/bvp_solver). But these are not easily installed on all platforms, and typically require some developer experience in compiling.

[fn:4] I know I can pretty conveniently collapse a code block by pressing tab on the header. Sometimes that is not enough.

[fn:5] It is not much harder, C-s will let you search for the named block. I do not know if there are nice convenient navigation commands for this.





