* Using linkd.el

#+BEGIN_SRC emacs-lisp
(require 'linkd)
(linkd-mode)
#+END_SRC

#+RESULTS:
: t

** Using stars

A link to (@> "block1") 

A link to (@> "block2")


*** A section for block1
# (@* "block1")


# (@* "block2")
Some buried paragraph



** Using tags

(@> "tag1") if you click on it, it will jump to the next tag, eventually cycling around.

 (@> "tag1") test

(@> "tag1")

** Data blocks

(linkd-insert-datablock-template '(1 2 3))

(defun ^cell (action object &optional start end) (message-box "%s" (list action object start end)) object)

(linkd-activate-datablock :begin)

(linkd-activate-datablock :end)

(^begin ^cell)
(1 2 3)
(^end)

** misc links

(@man :page "ls") a Man page

(@L (loop for i to 5 collect i)) A sexp

(@url :file-name "blog.org")    A file/url

info (@info :file-name "org" :node "Dates and times" :display "info: org (Dates and times)")




(@> "tag1"  )


* linkd inspired approach to embedded things

This is how we find the beginning of a possible match for (symbol-name
#+BEGIN_SRC emacs-lisp
(progn (re-search-forward "\(\\(\\_<.*?\\_>\\)")
(match-string-no-properties 1))
#+END_SRC





#+BEGIN_SRC emacs-lisp
(defun s-link-match (limit)
  "Try to read a s-link between point and LIMIT."
  (let ((sexp nil))
    (when (and (re-search-forward "\(\\(\\_<.*?\\_>\\)" limit t)
	       (string-match "@.*" (match-string 1))
	       (fboundp (match-string 1)))
      (goto-char (match-beginning 0))
      (backward-char 1)
      (let ((begin-point (point)))
	(condition-case nil (setq sexp (read (current-buffer))) ((error nil)))
	(when (and (symbolp (car-safe sexp)))
	  (let ((begin-marker (make-marker))
		(end-marker (make-marker)))
	    (set-marker begin-marker begin-point)
	    (set-marker end-marker (point))
	    (set-match-data (list begin-marker end-marker)))
	  t)))))
#+END_SRC

(defun cite-test () nil)

(s-link-match (point-max))

(@cite-test 
"test")  

(@cite-test 
"test")  

(cite-test "test")  

(@cite-test 
"test")  

You might want to provide (@warning "you are about to destroy something") in the text. It is mildly annoying you have to put that in quotes, but otherwise, they might appear as symbols. This macro might avoid some of that. Note the need for escaping some things though.

#+BEGIN_SRC emacs-lisp
(defmacro text (&rest args)
  (mapconcat 'identity
	     (loop for sym in args collect
		   (if (symbolp sym)
		       (symbol-name sym)
		     (format "%s"
			     (condition-case nil
				 (eval sym)
			       (error sym)))))
	     " "))

(text "A string" I (+ 1 1) (and why not?) a single \(  want to collect.) 
#+END_SRC

#+RESULTS:
: A string I 2 (and why not?) a single ( want to collect.



* Semantic org

I am looking for some way to embed semantic meaning in org-mode. For example (person "John" :email "jkitchin@andrew.cmu.edu" :id 12-23-34) might be recognized as a functional object that could be rendered to different outputs. I might use (cite kitchin-2015-examp) as a citation, for example. One could then extract the data from the document. 
