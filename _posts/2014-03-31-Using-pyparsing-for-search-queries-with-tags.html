---
title: Using pyparsing for search  queries with tags
date: 2014/03/31 13:21:16
updated: 2014/03/31 13:21:16
categories: python
tags: 
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Parsing simple string and generating lisp</a></li>
<li><a href="#sec-2">2. Parsing a search string to generate python set notations</a></li>
</ul>
</div>
</div>

<p>
A few times I  have wanted  to use  a more natural search string like "A and pw and 350 and not  kpt". The trouble  is figuring out how to parse that string and turn it  into search code. There  may  be nested logic,  e.g. "(A xor B)  and  (pw and (200 or 300))". This means we have  to recursively parse  the sstring. Rather  than invent this from  scratch, we  use pyparsing which is designed for that. There is   some code in "Getting started with pyparsing" that provides an example on parsing search strings. I want to see how I can turn the parsed output into search code. Here, we parse the search string and generate something that looks like lisp code. 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Parsing simple string and generating lisp</h2>
<div class="outline-text-2" id="text-1">
<p>
We define  a  hiearchy of classes that codifythe operators, and which print representations of the logic. The grammar we implement is basically words or  strings separatedd by logic operators.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes one operand,e.g. not'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes two or more operands, e.g. and, or'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(AND {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(OR {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(NOT {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'represents a termthat is being searched. here just a word'</span>                         
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">self</span>.term

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])


<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue and heavy or red'</span>)[0]
</pre>
</div>

<pre class="example">
(NOT kpt)
(NOT (AND kpt eos))
(OR (AND wood blue) red)
(OR (AND wood blue heavy) red)
</pre>

<p>
That works pretty well, and does not seem overly complicated to me. There is a lot of class definition, but that would presumably get buried in a module as a one time investment, and some function interface would look like this: <code>search('wood and blue or red')</code>.
</p>

<p>
Now, let us try python notation. 
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Parsing a search string to generate python set notations</h2>
<div class="outline-text-2" id="text-2">
<p>
I will use a similar idea as I used before with TAGS. We will use set operations with the binary logical operators to do the actual searching. Finally, we wrap the code in a little function to search a dictionary we previously made.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' &amp; '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' | '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) +<span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchXor</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' ^ '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'all\'] - {}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #228b22;">'instead of just the  term, we represent it as TAGS[term]'</span>
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'{0}\']'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.term)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">xor_</span> = CaselessLiteral(<span style="color: #228b22;">"xor"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (xor_, 2, opAssoc.LEFT, SearchXor),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])

<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'kpt or not eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue xor red'</span>)[0]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">check it out on tags.</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">search_tags</span>(srch):
    <span style="color: #228b22;">'function to  search the TAGS  file'</span>
    <span style="color: #8b0000;">import</span> pickle

    <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
        <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())
    
    <span style="color: #8b008b;">s</span> = searchExpr.parseString(srch)[0]
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">eval</span>(<span style="color: #cd0000;">str</span>(s))
<span style="color: #8b0000;">print</span> search_tags(<span style="color: #228b22;">'pw and A and not 300'</span>)
</pre>
</div>

<pre class="example">
TAGS['all'] - TAGS['kpt']
TAGS['all'] - (TAGS['kpt'] &amp; TAGS['eos'])
(TAGS['kpt'] | TAGS['all'] - TAGS['eos'])
((TAGS['wood'] &amp; TAGS['blue']) | TAGS['red'])
((TAGS['wood'] &amp; TAGS['blue']) ^ TAGS['red'])
set(['tags\\A\\pw\\350', 'tags\\A\\pw', 'tags\\A\\pw\\200', 'tags\\A\\pw\\400', 'tags\\A\\pw\\250'])
</pre>

<p>
That is pretty nice. It looks like a nice syntax for queries. One day I will try incorporating this into a database application.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/31/Using-pyparsing-for-search-queries-with-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>