---
title: Memoizing expensive functions in python and saving results
date: 2013/06/20 13:29:22
updated: 2013/06/20 13:29:22
categories: programming
tags: 
---


<p>
Sometimes a function is expensive (time-consuming) to run, and you would like to save all the results of the function having been run to avoid having to rerun them. This is called <a href="http://en.wikipedia.org/wiki/Memoization">memoization</a>. A wrinkle on this problem is to save the results in a file so that later you can come back to a function and not have to run simulations over again.
</p>

<p>
In python, a good way to do this is to "decorate" your function. This way, you write the function to do what you want, and then "decorate" it. The decoration wraps your function and in this case checks if the arguments you passed to the function are already stored in the cache. If so, it returns the result, if not it runs the function. The memoize decorator below was adapted from <a href="http://stackoverflow.com/questions/4669391/python-anyone-have-a-memoizing-decorator-that-can-handle-unhashable-arguments">here</a>.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> functools <span style="color: #8b0000;">import</span> wraps
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">memoize</span>(func):
    cache = {}
    <span style="color: #8b0000;">@wraps</span>(func)
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrap</span>(*args):
        <span style="color: #8b0000;">if</span> args <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">in</span> cache:
            <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Running func'</span>
            cache[args] = func(*args)
        <span style="color: #8b0000;">else:</span>
            <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'result in cache'</span>
        <span style="color: #8b0000;">return</span> cache[args]
    <span style="color: #8b0000;">return</span> wrap

<span style="color: #8b0000;">@memoize</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">myfunc</span>(a):
    <span style="color: #8b0000;">return</span> a**2

<span style="color: #8b0000;">print</span> myfunc(2)
<span style="color: #8b0000;">print</span> myfunc(2)

<span style="color: #8b0000;">print</span> myfunc(3)
<span style="color: #8b0000;">print</span> myfunc(2)
</pre>
</div>

<pre class="example">
Running func
4
result in cache
4
Running func
9
result in cache
4
</pre>

<p>
The example above shows the principle, but each time you run that script you start from scratch. If those were expensive calculations that would not be desirable. Let us now write out the cache to a file. We use a simple pickle file to store the results. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os, pickle
<span style="color: #8b0000;">from</span> functools <span style="color: #8b0000;">import</span> wraps
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">memoize</span>(func):
    <span style="color: #8b0000;">if</span> os.path.exists(<span style="color: #228b22;">'memoize.pkl'</span>):
        <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'reading cache file'</span>
        <span style="color: #8b0000;">with</span> <span style="color: #8b0000;">open</span>(<span style="color: #228b22;">'memoize.pkl'</span>) <span style="color: #8b0000;">as</span> f:
            cache = pickle.load(f)
    <span style="color: #8b0000;">else:</span>
        cache = {}
    <span style="color: #8b0000;">@wraps</span>(func)
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrap</span>(*args):
        <span style="color: #8b0000;">if</span> args <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">in</span> cache:
            <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Running func'</span>
            cache[args] = func(*args)
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">update the cache file</span>
            <span style="color: #8b0000;">with</span> <span style="color: #8b0000;">open</span>(<span style="color: #228b22;">'memoize.pkl'</span>, <span style="color: #228b22;">'wb'</span>) <span style="color: #8b0000;">as</span> f:
                pickle.dump(cache, f)
        <span style="color: #8b0000;">else:</span>
            <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'result in cache'</span>
        <span style="color: #8b0000;">return</span> cache[args]
    <span style="color: #8b0000;">return</span> wrap

<span style="color: #8b0000;">@memoize</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">myfunc</span>(a):
    <span style="color: #8b0000;">return</span> a**2


<span style="color: #8b0000;">print</span> myfunc(2)
<span style="color: #8b0000;">print</span> myfunc(2)

<span style="color: #8b0000;">print</span> myfunc(3)
<span style="color: #8b0000;">print</span> myfunc(2)
</pre>
</div>

<pre class="example">
reading cache file
result in cache
4
result in cache
4
result in cache
9
result in cache
4
</pre>

<p>
Now you can see if we run this script a few times, the results are read from the cache file.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/06/20/Memoizing-expensive-functions-in-python-and-saving-results.org">org-mode source</a><p>