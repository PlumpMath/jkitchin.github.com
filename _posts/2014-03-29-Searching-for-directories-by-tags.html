---
title: Searching for directories by tags
date: 2014/03/29 17:41:08
updated: 2014/03/30 12:02:43
categories: python
tags: 
---



<p>
Today I explore searching for directories by using tags. We will create a TAGS table by first walking through the directories and tagging each directory with all of the relative path components. Then, we will use set algebra to identify specific directories.
</p>

<p>
First, let us make a directory setup to use. We will nest some calculations that might be typical. These will be nested directories that might contain planewave (pw) and k-points (kpts) convergence and equation of state (eos) directories, with the sets of calculations inside those. The idea then is that the directory components will form at least some of the tags.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os

os.mkdir(<span style="color: #228b22;">'tags'</span>)

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> c <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'pw'</span>, <span style="color: #228b22;">'kpts'</span>, <span style="color: #228b22;">'eos'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, c))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [1, 2, 3, 4, 5]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'eos'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [200, 250, 300, 350, 400]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'pw'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'2x2x2'</span>, <span style="color: #228b22;">'4x4x4'</span>, <span style="color: #228b22;">'8x8x8'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'kpts'</span>, <span style="color: #cd0000;">str</span>(run)))
</pre>
</div>

<p>
Let us just double check what this directory tree looks like for one compound A.
</p>
<div class="org-src-container">

<pre class="src src-sh">ls tags/A/*
</pre>
</div>

<pre class="example">
tags/A/eos:
1
2
3
4
5

tags/A/kpts:
2x2x2
4x4x4
8x8x8

tags/A/pw:
200
250
300
350
400
</pre>

<p>
Now, we will walk through the directories, and split the path components to create a TAGS structure. I will store these as sets within a dictionary. We will save the structure in a pickle file to reuse it later.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">import</span> pickle

<span style="color: #8b008b;">TAGS</span> = {}
<span style="color: #8b008b;">TAGS</span>[<span style="color: #228b22;">'all'</span>] = <span style="color: #cd0000;">set</span>()

<span style="color: #8b0000;">for</span> root, dirs, files <span style="color: #8b0000;">in</span> os.walk(<span style="color: #228b22;">'tags'</span>):
    <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(root)
    TAGS[<span style="color: #228b22;">'all'</span>].add(root)
    <span style="color: #8b0000;">while</span> base:
        <span style="color: #8b0000;">if</span> tail <span style="color: #8b0000;">in</span> TAGS:
            TAGS[tail].add(root)
        <span style="color: #8b0000;">else</span>:
            <span style="color: #8b008b;">TAGS</span>[tail] = <span style="color: #cd0000;">set</span>([root])
        <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(base)

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'w'</span>) <span style="color: #8b0000;">as</span> f:
    f.write(pickle.dumps(TAGS))

<span style="color: #8b0000;">print</span> TAGS.keys()
</pre>
</div>

<pre class="example">
['A', '1', 'all', 'B', '250', 'pw', '2x2x2', '300', 'C', '400', 'kpts', '8x8x8', 'eos', '3', '2', '5', '4', '350', '200', '4x4x4', 'D']
</pre>

<p>
Now we have a lot of keys that tag each directory. Each tag is a set of directories, and we can do set algebra to get specific results. For example, we can find a result by appropriate differences, intersections and unions of the sets. An advantage of this approach is that order of the tags is not relevant (unlike the path, where each component must be in the right order).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'300'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'A'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
set(['tags\\A\\pw\\300'])
</pre>

<p>
The syntax here is a tad heavy because of the chained dot notation operations. You can also use the logical operators like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>] &amp; TAGS[<span style="color: #228b22;">'pw'</span>] &amp; TAGS[<span style="color: #228b22;">'A'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
</pre>


<p>
We can get a set of calculations, for example an equation of state like this:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\eos', 'tags\\A\\eos\\5', 'tags\\A\\eos\\4', 'tags\\A\\eos\\1', 'tags\\A\\eos\\3', 'tags\\A\\eos\\2'])
</pre>

<p>
Now, let us construct some more complex queries. With sets we use intersections for <code>and</code> and we construct unions of queries that are like an or. We examine different notations to see which one is better.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 3 in eos for B and C</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'3'</span>]
       .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
       .intersection(TAGS[<span style="color: #228b22;">'B'</span>])
       .union
       (TAGS[<span style="color: #228b22;">'3'</span>]
        .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
        .intersection(TAGS[<span style="color: #228b22;">'C'</span>])))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this notation makes more sense to me. ^ = or</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'3'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>] &amp; (TAGS[<span style="color: #228b22;">'B'</span>] ^ TAGS[<span style="color: #228b22;">'C'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
</pre>

<p>
You can see the two approaches give the same results. The logical operator syntax is more concise and (I think) more readable. Let us consider a query with "not". We can use a difference operator for that. We subtract all the paths with tag "B" from the set containing "4x4x4", which will give us paths tagged with "4x4x4" but not "B".
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 4x4x4 but not B</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'4x4x4'</span>].difference(TAGS[<span style="color: #228b22;">'B'</span>]))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this makes more sense 4x4x4 but not B, </span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">i.e. subtract paths tagged B from those tagged 4x4x4</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'4x4x4'</span>] -  TAGS[<span style="color: #228b22;">'B'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
</pre>


<p>
Note it is not so obvious how to get results not tagged with "A". We need to subtract the tagged calculations from some set. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'all'</span>] - TAGS[<span style="color: #228b22;">'A'</span>]  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">not A</span>
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts', 'tags\\D\\pw\\200', 'tags\\D\\pw\\350', 'tags\\D\\pw\\250', 'tags\\D\\kpts\\8x8x8', 'tags\\C\\eos', 'tags\\D\\eos\\2', 'tags\\D\\eos\\3', 'tags\\D\\eos\\4', 'tags\\D\\eos\\5', 'tags\\B\\kpts\\2x2x2', 'tags\\C\\kpts\\4x4x4', 'tags\\C\\eos\\3', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1', 'tags\\C\\kpts\\8x8x8', 'tags\\C\\eos\\5', 'tags\\C\\eos\\4', 'tags\\B\\kpts', 'tags\\C\\pw\\200', 'tags\\B\\eos\\2', 'tags\\B\\pw\\350', 'tags\\B\\eos\\1', 'tags\\B\\kpts\\8x8x8', 'tags\\C\\pw\\300', 'tags\\B\\eos\\4', 'tags\\B\\eos\\5', 'tags\\C\\kpts', 'tags\\D\\pw\\300', 'tags\\B\\kpts\\4x4x4', 'tags\\C\\kpts\\2x2x2', 'tags\\D\\kpts\\4x4x4', 'tags\\B\\pw\\250', 'tags', 'tags\\D\\pw\\400', 'tags\\D\\eos', 'tags\\C\\pw\\400', 'tags\\D\\kpts\\2x2x2', 'tags\\D\\pw', 'tags\\C\\pw\\250', 'tags\\C\\pw\\350', 'tags\\C\\pw', 'tags\\D\\eos\\1', 'tags\\B\\pw\\400', 'tags\\B\\pw', 'tags\\B\\eos', 'tags\\B\\pw\\300', 'tags\\B\\eos\\3', 'tags\\C', 'tags\\B', 'tags\\D', 'tags\\B\\pw\\200'])
</pre>

<p>
We can also look at "or". This is done with the <code>union</code> function, which is the set of elements in either set. The logical operator is <code>|</code>.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>].union(TAGS[<span style="color: #228b22;">'2'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>] | TAGS[<span style="color: #228b22;">'2'</span>]        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1 or 2</span>
</pre>
</div>

<pre class="example">
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
</pre>

<p>
There is an <code>xor</code> operator too. xor is not the same as or, it means <code>A xor B</code> means "A or B but not both". The <code>symmetric_difference</code> function gives this behavior. The logical operator is <code>^</code>. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">I think this is like the xor, A or 2 but not both</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].symmetric_difference(TAGS[<span style="color: #228b22;">'2'</span>]), <span style="color: #228b22;">'\n'</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] ^ TAGS[<span style="color: #228b22;">'2'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200']) 

set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])
</pre>



<p>
To summarize, this is one approach to using tags with the technical infrastructure of the set. The advantage is flexibility, that you do not need to know the full path to a result, provided you know the set of tags that refers to it. You can use the tags in any order.
</p>

<p>
There are many alternative approaches to implementing this idea. One could create a sqlite table and do SQL queries. You could also store lists in the dictionary, and use python code to find the matches. The syntax here is varied. Using the functional approach, the syntax gets heavy with all the dot notation. With the logical operators, the syntax is a little lighter. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/29/Searching-for-directories-by-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>