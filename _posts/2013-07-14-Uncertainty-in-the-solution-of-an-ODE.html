---
title: Uncertainty in the solution of an ODE
date: 2013/07/14 13:36:36
updated: 2013/10/18 15:55:01
categories: ODE, uncertainty
tags: 
---



<p>
Our objective in this post is to examine the effects of uncertainty in parameters that define an ODE on the integrated solution of the ODE. My favorite method for numerical uncertainty analysis is Monte Carlo simulation because it is easy to code and usually easy to understand. We take that approach first.
</p>

<p>
The problem to solve is to estimate the conversion in a constant volume batch reactor with a second order reaction \(A \rightarrow B\), and the rate law: \(-r_A = k C_A^2\), after one hour of reaction. There is 5% uncertainty in the rate constant \(k=0.001\) and in the initial concentration \(C_{A0}=1\). 
</p>

<p>
The relevant differential equation is:
</p>

<p>
\(\frac{dX}{dt} = -r_A /C_{A0}\).
</p>

<p>
We have to assume that 5% uncertainty refers to a normal distribution of error that has a standard deviation of 5% of the mean value. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">N</span> = 1000

<span style="color: #8b008b;">K</span> = np.random.normal(0.001, 0.05*0.001, N)
<span style="color: #8b008b;">CA0</span> = np.random.normal(1, 0.05*1, N)

<span style="color: #8b008b;">X</span> = [] <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">to store answer in</span>
<span style="color: #8b0000;">for</span> k, Ca0 <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">zip</span>(K, CA0):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">define ODE</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(X, t):
        <span style="color: #8b008b;">ra</span> = -k * (Ca0 * (1 - X))**2
        <span style="color: #8b0000;">return</span> -ra / Ca0
    
    <span style="color: #8b008b;">X0</span> = 0
    <span style="color: #8b008b;">tspan</span> = np.linspace(0,3600)

    <span style="color: #8b008b;">sol</span> = odeint(ode, X0, tspan)

    <span style="color: #8b008b;">X</span> += [sol[-1][0]]

<span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'Final conversion at one hour is {0:1.3f} +- {1:1.3f} (1 sigma)'</span>
<span style="color: #8b0000;">print</span> s.<span style="color: #cd0000;">format</span>(np.average(X),
               np.std(X))
</pre>
</div>

<pre class="example">
Final conversion at one hour is 0.782 +- 0.013 (1 sigma)
</pre>

<p>
See, it is not too difficulty to write. It is however, a little on the expensive side to run, since we typically need 1e3-1e6 samples to get the statistics reasonable. Let us try the uncertainties package too. For this we have to wrap a function that takes uncertainties and returns a single float number. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> uncertainties <span style="color: #8b0000;">as</span> u

<span style="color: #8b008b;">k</span> = u.ufloat(0.001, 0.05*0.001)
<span style="color: #8b008b;">Ca0</span> = u.ufloat(1.0, 0.05)

<span style="color: #4682b4;">@u.wrap</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(k, Ca0):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">define the ODE</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(X, t):
        <span style="color: #8b008b;">ra</span> = -k * (Ca0 * (1 - X))**2
        <span style="color: #8b0000;">return</span> -ra / Ca0
    
    <span style="color: #8b008b;">X0</span> = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial condition</span>
    <span style="color: #8b008b;">tspan</span> = np.linspace(0, 3600)
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">integrate it</span>
    <span style="color: #8b008b;">sol</span> = odeint(ode, X0, tspan)
    <span style="color: #8b0000;">return</span> sol[-1][0]

<span style="color: #8b008b;">result</span> = func(k, Ca0)
<span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'Final conversion at one hour is {0}(1 sigma)'</span>
<span style="color: #8b0000;">print</span> s.<span style="color: #cd0000;">format</span>(result)
</pre>
</div>

<pre class="example">
Final conversion at one hour is 0.783+/-0.012(1 sigma)
</pre>

<p>
This is about the same amount of code as the Monte Carlo approach, but it runs much faster, and gets approximately the same results. You have to remember the wrapping technique, since the uncertainties package does not run natively with the odeint function. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/07/14/Uncertainty-in-the-solution-of-an-ODE.org">org-mode source</a><p>