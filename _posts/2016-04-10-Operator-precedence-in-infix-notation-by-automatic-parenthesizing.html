---
title: Operator precedence in infix notation by automatic parenthesizing
date: 2016/04/10 13:32:00
updated: 2016/04/10 13:32:00
categories: hylang
tags: 
---


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Another test of a real problem</a></li>
</ul>
</div>
</div>
<p>
I am continuing some investigation in getting operator precedence right with infix notation. You can fully parenthesize your expressions for this, but it is tedious and hard to read. Apparently in Fortran I (yep, one) the compiler would expand each operator in an expression with a sequence of parentheses to get the precedence right (<a href="https://en.wikipedia.org/wiki/Operator-precedence_parser">https://en.wikipedia.org/wiki/Operator-precedence_parser</a> )!
</p>

<p>
Roughly, these were the rules.
</p>

<ul class="org-ul">
<li>replace + and â€“ with ))+(( and ))-((, respectively;
</li>
<li>replace * and / with )*( and )/(, respectively;
</li>
<li>add (( at the beginning of each expression and after each left parenthesis in the original expression; and
</li>
<li>add )) at the end of the expression and before each right parenthesis in the original expression.
</li>
</ul>

<p>
So this
</p>
<pre class="example">
a * b + c ^ d / e
</pre>

<p>
becomes
</p>

<pre class="example">
((((a))*((b)))+(((c)^(d))/((e))))
</pre>

<p>
Not too pretty, but correct! The wikipedia page provides an example C program to implement this, and we adapt it here for hy. The idea is to take an expression as a string, parenthesize it, and then we could eval it.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">parenthesize</span> [input]
  <span style="color: #008000;">"Fully parenthize the input string."</span>
  (<span style="color: #0000FF;">let</span> [s <span style="color: #008000;">""</span>]
    (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"(((("</span>)
    (<span style="color: #0000FF;">for</span> [(<span style="color: #006FE0;">,</span> i char) (enumerate input)]
      (<span style="color: #0000FF;">cond</span>
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"("</span>)
        (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"(((("</span>)]
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">")"</span>)
        (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"))))"</span>)]
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">rewrite ^ to **</span>
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"^"</span>)
        (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">")**("</span>)]
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"*"</span>)
        (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"))*(("</span>)]
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"/"</span>)
        (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"))/(("</span>)]
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"+"</span>)
        (<span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">or</span> (<span style="color: #006FE0;">=</span> 0 i) (<span style="color: #006FE0;">in</span> (<span style="color: #006FE0;">get</span> input (<span style="color: #006FE0;">-</span> i 1)) [<span style="color: #008000;">"("</span> <span style="color: #008000;">"^"</span> <span style="color: #008000;">"*"</span> <span style="color: #008000;">"/"</span> <span style="color: #008000;">"+"</span> <span style="color: #008000;">"-"</span>]))
          (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"+ "</span>)
          (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">")))+((("</span>))]
       [(<span style="color: #006FE0;">=</span> char <span style="color: #008000;">"-"</span>)
        (<span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">or</span> (<span style="color: #006FE0;">=</span> 0 i) (<span style="color: #006FE0;">in</span> (<span style="color: #006FE0;">get</span> input (<span style="color: #006FE0;">-</span> i 1)) [<span style="color: #008000;">"("</span> <span style="color: #008000;">"^"</span> <span style="color: #008000;">"*"</span> <span style="color: #008000;">"/"</span> <span style="color: #008000;">"+"</span> <span style="color: #008000;">"-"</span>]))
          (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"- "</span>)
          (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">")))-((("</span>))]
       [<span style="color: #D0372D;">true</span>
        (<span style="color: #006FE0;">+=</span> s char)]))
    (<span style="color: #006FE0;">+=</span> s <span style="color: #008000;">"))))"</span>)
    s))
</pre>
</div>

<p>
Let's try it out.
</p>
<div class="org-src-container">

<pre class="src src-hy">(import [infix [*]])

(<span style="color: #006FE0;">print</span> (parenthesize <span style="color: #008000;">"a * b + c ^ d / e"</span>))
</pre>
</div>
<pre class="example">
((((a ))*(( b )))+((( c )**( d ))/(( e))))
</pre>

<p>
For comparison:
</p>

<p>
((((a))*((b)))+(((c)^(d))/((e))))
</p>

<p>
Spaces aside, it looks like we got that right. The spaces should not be a problem for lisp. This is another strategy to get infix notation with operator precedence! Let's see some examples.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [infix [*]])
(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #006FE0;">print</span> (<span style="color: #006FE0;">eval</span> (nfx (<span style="color: #006FE0;">read-str</span> (parenthesize <span style="color: #008000;">"1 + 2 * 5"</span>)))))
(<span style="color: #006FE0;">print</span> (<span style="color: #006FE0;">eval</span> (nfx (<span style="color: #006FE0;">read-str</span> (parenthesize <span style="color: #008000;">"1 * 2 + 5"</span>)))))
(<span style="color: #006FE0;">print</span> (<span style="color: #006FE0;">eval</span> (nfx (<span style="color: #006FE0;">read-str</span> (parenthesize <span style="color: #008000;">"1 * 2 + 2^2"</span>)))))
</pre>
</div>

<pre class="example">
11
7
6
</pre>

<p>
We can get that string representation easy enough.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [infix [*]])
(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #006FE0;">print</span> (<span style="color: #006FE0;">eval</span> (nfx (<span style="color: #006FE0;">read-str</span> (parenthesize (stringify `(1 + 2)))))))
</pre>
</div>

<pre class="example">
3
</pre>

<p>
This too is worthy of simplifying the notation with a function.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">NFX</span> [code <span style="color: #6434A3;">&amp;optional</span> [globals (globals)]]
  <span style="color: #008000;">"Evaluate the infix CODE.</span>
<span style="color: #008000;">CODE is stringified, parenthesized, read back and infixed."</span>
  (<span style="color: #0000FF;">import</span> <span style="color: #006699;">infix</span>)
  (<span style="color: #0000FF;">import</span> <span style="color: #006699;">serialize</span>)
  (<span style="color: #006FE0;">eval</span> (infix.nfx
         (<span style="color: #006FE0;">read-str</span>
          (infix.parenthesize
           (serialize.stringify code)))) globals))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">NFX</span> [code]
  <span style="color: #036A07;">"Evaluate the infix CODE.</span>
<span style="color: #036A07;">CODE is stringified, parenthesized, read back and infixed."</span>
  `(<span style="color: #0000FF;">do</span>
    (<span style="color: #0000FF;">import</span> <span style="color: #006699;">infix</span>)
    (<span style="color: #0000FF;">import</span> <span style="color: #006699;">serialize</span>)
    (<span style="color: #006FE0;">eval</span> (infix.nfx
           (<span style="color: #006FE0;">read-str</span>
            (infix.parenthesize
             (serialize.stringify ~code)))))))
</pre>
</div>

<p>
Here is a simple example.
</p>
<div class="org-src-container">

<pre class="src src-hy"><span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(import [infix [*]])</span>
(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #006FE0;">print</span> (NFX `(1 + 2 * 5)))
(<span style="color: #006FE0;">print</span> (NFX `((1 + 2) * 5)))

(import [numpy <span style="color: #D0372D;">:as</span> np])
(<span style="color: #006FE0;">print</span> (NFX `(1 + (np.exp 2))))

<span style="color: #8D8D84;">; </span><span style="color: #8D8D84; font-style: italic;">not working because of infix</span>
<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">(print (NFX `(1 + (np.linspace 0 1 5))))</span>

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">But this is ok since no infix mangling happens.</span>
(<span style="color: #0000FF;">let</span> [a (np.linspace 0 1 5)]
  (<span style="color: #006FE0;">print</span> (NFX `(1 + a))))
</pre>
</div>

<pre class="example">
11
15
8.38905609893
[ 1.    1.25  1.5   1.75  2.  ]
</pre>

<p>
That is slightly heavy still, and we can fix it with a new reader macro.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">defreader</span> <span style="color: #006699;">m</span> [code]
 `(<span style="color: #0000FF;">do</span>
    (<span style="color: #0000FF;">import</span> <span style="color: #006699;">infix</span>)
    (<span style="color: #0000FF;">import</span> <span style="color: #006699;">serialize</span>)
    (<span style="color: #006FE0;">eval</span> (infix.nfx
           (<span style="color: #006FE0;">read-str</span>
            (infix.parenthesize
             (serialize.stringify ~code)))))))
</pre>
</div>

<p>
Since we return code in that reader macro, we have to quote the code. This is debatably more concise than the NFX macro.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #006FE0;">print</span> #m`(1 + 2 + 5))
(<span style="color: #006FE0;">print</span> #m`(1 + 2 * 5))
(<span style="color: #006FE0;">print</span> #m`((1 + 2) * 5))

(import [numpy <span style="color: #D0372D;">:as</span> np])
(<span style="color: #006FE0;">print</span> #m`((1 + (np.exp 2))))

<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">these are all the same</span>
(<span style="color: #006FE0;">print</span> (<span style="color: #006FE0;">+</span> 1 (np.exp 2) (<span style="color: #006FE0;">*</span> 2 5)))
(<span style="color: #006FE0;">print</span> #m(`(1 + (np.exp 2) + 2 * 5)))
(<span style="color: #006FE0;">print</span> (NFX `(1 + (np.exp 2) + 2 * 5)))
</pre>
</div>

<pre class="example">
8
11
15
8.38905609893
18.3890560989
18.3890560989
18.3890560989
</pre>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Another test of a real problem</h2>
<div class="outline-text-2" id="text-1">
<p>
Here is another test of using an infix notation, this time with operator precedence. Note the use of ^ for exponentiation. The parenthesize function assumes single character operators, and would take some work to use **. Note we still need the space between - and x to avoid a mangling issue with _x in hy.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [numpy <span style="color: #D0372D;">:as</span> np])
(import [scipy.integrate [odeint]])
(import [scipy.special [jn]])
(import [matplotlib.pyplot <span style="color: #D0372D;">:as</span> plt])

(import [infix [*]])
(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">fbessel</span> [Y x]
  <span style="color: #008000;">"System of 1st order ODEs for the Bessel equation."</span>
  (<span style="color: #006FE0;">setv</span> nu 0.0
        y (<span style="color: #006FE0;">get</span> Y 0)
        z (<span style="color: #006FE0;">get</span> Y 1))

  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">define the derivatives</span>
  (<span style="color: #006FE0;">setv</span> dydx z
        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">the Python way is: "1.0 / x**2 * (-x * z - (x**2 - nu**2) * y)"</span>
        dzdx #m`((1.0 / x^2) * ((<span style="color: #006FE0;">-</span> x) * z - (x^2 - nu^2) * y)))
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Here is what it was with prefix notation</span>
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">dzdx (* (/ 1.0 (** x 2)) (- (* (* -1 x) z) (* (- (** x 2) (** nu 2)) y))))</span>
  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return derivatives</span>
  [dydx dzdx])

(<span style="color: #006FE0;">setv</span> x0 1e-15
      y0 1.0
      z0 0.0
      Y0 [y0 z0])

(<span style="color: #006FE0;">setv</span> xspan (np.linspace 1e-15 10)
      sol (odeint fbessel Y0 xspan))

(plt.plot xspan (. sol [[Ellipsis 0]]) <span style="color: #D0372D;">:label</span> <span style="color: #008000;">"Numerical solution"</span>)
(plt.plot xspan (jn 0 xspan) <span style="color: #008000;">"r--"</span> <span style="color: #D0372D;">:label</span> <span style="color: #008000;">"Analytical solution"</span>)
(plt.legend <span style="color: #D0372D;">:loc</span> <span style="color: #008000;">"best"</span>)

(plt.savefig <span style="color: #008000;">"bessel-infix-m.png"</span>)
</pre>
</div>


<div class="figure">
<p><img src="/media/2016-04-10-Operator-precedence-in-infix-notation-by-automatic-parenthesizing/bessel-infix-m.png"> 
</p>
</div>

<p>
I wonder if there is actually some ambiguity in the expression or how it is parenthesized. We get the right answer with:
</p>

<pre class="example">
(1.0 / x^2) * ((- x) * z - (x^2 - nu^2) * y)
</pre>

<p>
but not with:
</p>

<pre class="example">
1.0 / x^2 * ((- x) * z - (x^2 - nu^2) * y))
</pre>

<p>
Let's see if we can see why. Consider 1 / x * a. This should probably be evaluated as (1 / x) * a. This shows the algorithm does not do that.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [infix [*]])

(<span style="color: #006FE0;">print</span>
 (nfx
 (<span style="color: #006FE0;">read-str</span>
 (parenthesize
  (stringify `(1 / x * a))))))
<span style="color: #8D8D84;">;   </span><span style="color: #8D8D84; font-style: italic;">`(1.0 / x^2 * ((- x) * z - (x^2 - nu^2) * y)))))))</span>
</pre>
</div>

<pre class="example">
(u'/' 1L (u'*' u'x' u'a'))
</pre>

<p>
That reads: 1 / (x * a)
</p>

<p>
If we had a layer of parentheses we get the right answer.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [infix [*]])

(<span style="color: #006FE0;">print</span>
 (nfx
 (<span style="color: #006FE0;">read-str</span>
 (parenthesize
  (stringify `((1 / x) * a))))))
<span style="color: #8D8D84;">;   </span><span style="color: #8D8D84; font-style: italic;">`((1.0 / x^2) * ((- x) * z - (x^2 - nu^2) * y)))))))</span>
</pre>
</div>

<pre class="example">
(u'*' (u'/' 1L u'x') u'a')
</pre>

<p>
This reads (1 / x) * a. Our algorithm doesn't do exactly what we expect here. I guess this could be a general issue of neighboring operators with equal precedence.
</p>

<p>
Related to this, the Wikipedia page points out this example:
</p>

<pre class="example">
- a ^ 2
</pre>

<p>
What does this mean? It is either (-a)^2 or -(a^2). The second is correct based on normal precedence, but the algorithm gives the unary operator - a higher precedence.
</p>

<div class="org-src-container">

<pre class="src src-hy">(import [infix [parenthesize]])

(<span style="color: #006FE0;">print</span> (parenthesize <span style="color: #008000;">"- a ^ 2"</span>))
(<span style="color: #006FE0;">print</span> (parenthesize <span style="color: #008000;">"- (a ^ 2)"</span>))
</pre>
</div>
<pre class="example">
((((-  a )**( 2))))
((((-  ((((a )**( 2))))))))
</pre>

<p>
To get the right thing, you need to use parentheses. Sometimes I do that in real code anyway to make sure what I want to happen does. Maybe some of this can be fixed in our parser function. Probably for another day.
</p>
</div>
</div>
<p>Copyright (C) 2016 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2016/04/10/Operator-precedence-in-infix-notation-by-automatic-parenthesizing.org">org-mode source</a></p>
<p>Org-mode version = 8.2.10</p>