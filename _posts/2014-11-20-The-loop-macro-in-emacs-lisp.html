---
title: The loop macro in emacs lisp
date: 2014/11/20 09:50:00
updated: 2014/11/20 09:50:00
categories: emacs_lisp
tags: 
---


<p>
I was reading <a href="http://landoflisp.com">The Land Of Lisp</a> chapter on the loop macro in Common Lisp. I am not too familiar with it, or the implementation in emacs-lisp, so in this post we explore what it can do. Here I will explore some uses of the loop macro to do things I used to do in Python all the time.
</p>

<p>
Here is a simple example to generate a list of numbers with the loop macro..
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i
      below 5
      collect i)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">0</td>
<td class="right">1</td>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">4</td>
</tr>
</tbody>
</table>

<p>
Evidently, i starts at 0, and increments by one. We can specify a different value like this. Here we use the <code>to</code> token, which also includes the last value.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i from 2 to 10
  collect i)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">2</td>
<td class="right">3</td>
<td class="right">4</td>
<td class="right">5</td>
<td class="right">6</td>
<td class="right">7</td>
<td class="right">8</td>
<td class="right">9</td>
<td class="right">10</td>
</tr>
</tbody>
</table>

<p>
IF you want to go backwards:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i downfrom 10 to 2 collect i)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">10</td>
<td class="right">9</td>
<td class="right">8</td>
<td class="right">7</td>
<td class="right">6</td>
<td class="right">5</td>
<td class="right">4</td>
<td class="right">3</td>
<td class="right">2</td>
</tr>
</tbody>
</table>

<p>
And if you want an (de)increment different than one, use the <code>by</code> token.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i downfrom 10 to 2 by 3 collect i)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">10</td>
<td class="right">7</td>
<td class="right">4</td>
</tr>
</tbody>
</table>

<p>
We can use this to iterate over a list too. Let us collect the square of each element in a simple list. This is similar to the mapcar function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(1 2 3 4)
  collect (* i i))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">4</td>
<td class="right">9</td>
<td class="right">16</td>
</tr>
</tbody>
</table>

<p>
You can combine the ideas to get something similar to the enumerate function in python. 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i
      from 0
      for month
      in '(january february march april may june july august september
                   october november december)
      collect (cons i month))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">((0 . january)
 (1 . february)
 (2 . march)
 (3 . april)
 (4 . may)
 (5 . june)
 (6 . july)
 (7 . august)
 (8 . september)
 (9 . october)
 (10 . november)
 (11 . december))
</pre>
</div>

<p>
The loop stops because we run out of months to iterate over.  Here is a variation like the zip function in python.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for element1 in '(a b c d)
      for element2 in '(1 2 3 4)
      collect (list element1 element2))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="left">a</td>
<td class="right">1</td>
</tr>

<tr>
<td class="left">b</td>
<td class="right">2</td>
</tr>

<tr>
<td class="left">c</td>
<td class="right">3</td>
</tr>

<tr>
<td class="left">d</td>
<td class="right">4</td>
</tr>
</tbody>
</table>

<p>
We can sum in the loop:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(100 200 300) sum i)
</pre>
</div>

<pre class="example">
600
</pre>

<p>
We can conditionally sum things in the loop, e.g. sum only the odd numbers.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(1 2 3 4 5)
  when (oddp i)
  sum i)
</pre>
</div>

<pre class="example">
9
</pre>

<p>
We can find the minima and maxima in a list
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(-1 0 1)
  minimize i)
</pre>
</div>

<pre class="example">
-1
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(-1 0 1)
  maximize i)
</pre>
</div>

<pre class="example">
1
</pre>

<p>
You may want to do some action in the loop. Say we want to print even numbers from a list.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i in '(1 2 3 4)
      when (evenp i)
      do (print i))
</pre>
</div>

<pre class="example">
2

4
</pre>

<p>
There are some ways to break out of a loop using <code>return</code> like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i upto 10
      when (= i 3)
      return 'done
      do (print i))
</pre>
</div>

<pre class="example">
0

1

2
</pre>

<p>
Alternatively, you can use while/until.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i downfrom 10
      do (print i)
      until (= i 6))
</pre>
</div>

<pre class="example">
10

9

8

7

6
</pre>

<p>
Or the while variation:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(loop for i downfrom 10
      do (print i)
      while (&gt; i 6))
</pre>
</div>

<pre class="example">
10

9

8

7

6
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
This is not everything the loop macro can do! Here is what the help for that function says.
</p>

<pre class="example">
loop is an alias for `cl-loop' in `cl.el'.

(loop CLAUSE...)

The Common Lisp `loop' macro.
Valid clauses include:
  For clauses:
    for VAR from/upfrom/downfrom EXPR1 to/upto/downto/above/below EXPR2 by EXPR3
    for VAR = EXPR1 then EXPR2
    for VAR in/on/in-ref LIST by FUNC
    for VAR across/across-ref ARRAY
    for VAR being:
      the elements of/of-ref SEQUENCE [using (index VAR2)]
      the symbols [of OBARRAY]
      the hash-keys/hash-values of HASH-TABLE [using (hash-values/hash-keys V2)]
      the key-codes/key-bindings/key-seqs of KEYMAP [using (key-bindings VAR2)]
      the overlays/intervals [of BUFFER] [from POS1] [to POS2]
      the frames/buffers
      the windows [of FRAME]
  Iteration clauses:
    repeat INTEGER
    while/until/always/never/thereis CONDITION
  Accumulation clauses:
    collect/append/nconc/concat/vconcat/count/sum/maximize/minimize FORM
      [into VAR]
  Miscellaneous clauses:
    with VAR = INIT
    if/when/unless COND CLAUSE [and CLAUSE]... else CLAUSE [and CLAUSE...]
    named NAME
    initially/finally [do] EXPRS...
    do EXPRS...
    [finally] return EXPR

For more details, see Info node `(cl)Loop Facility'.
</pre>

<p>
It is obviously quite powerful, although the syntax seems quite different than the usual lisp code I have been writing. It is not clear when this is superior to something like mapcar/mapconcat, or the dolist/dotimes functions. 
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/11/20/The-loop-macro-in-emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>