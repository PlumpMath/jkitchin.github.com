---
title: Handling units with dimensionless equations
date: 2013/03/26 16:47:39
updated: 2013/03/26 16:47:39
categories: units
tags: 
---


<p>
As we have seen, handling units with third party functions is fragile, and often requires additional code to wrap the function to handle the units. An alternative approach that avoids the wrapping is to rescale the equations so they are dimensionless. Then, we should be able to use all the standard external functions without modification. We obtain the final solutions by rescaling back to the answers we want.
</p>

<p>
Before doing the examples, let us consider how the quantities package handles dimensionless numbers.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

a = 5 * u.m
L = 10 * u.m <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">characteristic length</span>

<span style="color: #8b0000;">print</span> a/L
<span style="color: #8b0000;">print</span> type(a/L)
</pre>
</div>

<pre class="example">
0.5 dimensionless
&lt;class 'quantities.quantity.Quantity'&gt;
</pre>

<p>
As you can see, the dimensionless number is scaled properly, and is listed as dimensionless. The result is still an instance of a quantities object though. That is not likely to be a problem.
</p>

<p>
Now, we consider using fsolve with dimensionless equations. Our goal is to solve \(C_A = C_{A0} \exp(-k t)\) for the time required to reach a desired \(C_A\). We let \(X = Ca / Ca0\) and \(\tau = t * k\), which leads to \(X = \exp{-\tau}\) in dimensionless terms.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">desired exit concentration</span>
k = 1.0 / u.s

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we need new dimensionless variables</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let X = Ca / Ca0</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">so, Ca = Ca0 * X</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let tau = t * k</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">so t = tau / k</span>

X = CA / CA0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">desired exit dimensionless concentration</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(tau):
    <span style="color: #8b0000;">return</span> X - np.exp(-tau)

tauguess = 2

<span style="color: #8b0000;">print</span> func(tauguess) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">confirm we have a dimensionless function</span>

tau_sol, = fsolve(func, tauguess)
t = tau_sol / k
<span style="color: #8b0000;">print</span> t
</pre>
</div>

<pre class="example">
-0.125335283237 dimensionless
4.60517018599 s
</pre>

<p>
Now consider the ODE \(\frac{dCa}{dt} = -k Ca\). We let \(X = Ca/Ca0\), so \(Ca0 dX = dCa\). Let \(\tau = t * k\) which in this case is dimensionless. That means \(d\tau = k dt\). Substitution of these new variables leads to:
</p>

<p>
\(Ca0*k \frac{dX}{d\tau} = -k Ca0 X \)
</p>

<p>
or equivalently:
\(\frac{dX}{d\tau} = -X \)
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

k = 0.23 / u.s
Ca0 = 1 * u.mol / u.L

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Let X = Ca/Ca0  -&gt; Ca = Ca0 * X  dCa = dX/Ca0</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">let tau = t * k -&gt; dt = 1/k dtau</span>


<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dXdtau</span>(X, tau):
    <span style="color: #8b0000;">return</span> -X

<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

tspan = np.linspace(0, 5) * u.s
tauspan = tspan * k

X0 = 1
X_sol = odeint(dXdtau, X0, tauspan)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Ca at t = {0} = {1}'</span>.format(tspan[-1], X_sol.flatten()[-1] * Ca0)
</pre>
</div>

<pre class="example">
Ca at t = 5.0 s = 0.316636777351 mol/L
</pre>

<p>
That is pretty much it. Using dimensionless quantities simplifies the need to write wrapper code, although it does increase the effort to rederive your equations (with corresponding increased opportunities to make mistakes). Using units to confirm your dimensionless derivation reduces those opportunities.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/26/Handling-units-with-dimensionless-equations.org">org-mode source</a><p>