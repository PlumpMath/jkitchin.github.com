---
title: Another alternative to string templates
date: 2014/01/26 09:56:45
updated: 2014/01/26 09:56:45
categories: emacs-lisp
tags: 
---


<p>
In the <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/01/20/Alternatives-to-long-complex-format-statements-in-emacs-lisp/">last post</a> I explored a way to expand a string template that was
more readable than the usual format. Today I look at another approach
where I use sexp expansions to accomplish the same thing. The idea is
to embed lisp expressions and replace them by what they evaluate to.
</p>

<p>
In emacs-lisp, if we have a command in a string, we can "read" it, and
then eval it. 
</p>

<p>
Here we get the user-full-name:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval (read <span style="color: #228b22;">"user-full-name"</span>))
</pre>
</div>

<pre class="example">
John Kitchin
</pre>

<p>
We can use this on variables too.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq some-variable <span style="color: #228b22;">"test"</span>)
(eval (read <span style="color: #228b22;">"some-variable"</span>))
</pre>
</div>

<pre class="example">
test
</pre>

<p>
So, if we use a syntax to identify what to replace, we can substitute
in the values. Let us try %() as the syntax.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %() with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%(</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">)]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">)"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (format <span style="color: #228b22;">"%s"</span> (eval (read (substring arg 2 -1))))) s))


(<span style="color: #8b0000;">let</span> ((key <span style="color: #228b22;">"kitchin-2014"</span>)
      (author <span style="color: #228b22;">"Kitchin, J. R."</span>)
      (journal <span style="color: #228b22;">"HACS"</span>)
      (year <span style="color: #228b22;">"2014"</span>)
      (volume <span style="color: #228b22;">"1"</span>)
      (pages <span style="color: #228b22;">"1--10"</span>)
      (doi <span style="color: #228b22;">"10.1.1.109/hacs.1.10"</span>)
      (url <span style="color: #228b22;">"http://hacs.org/10.1.1.109/hacs.1.10"</span>)
      (pdf-dir <span style="color: #228b22;">"/home/jkitchin/pdfs"</span>)
      (template <span style="color: #228b22;">"</span>
<span style="color: #228b22;"> :PROPERTIES:</span>
<span style="color: #228b22;">  :Custom_ID: %(key)</span>
<span style="color: #228b22;">  :AUTHOR: %(author</span>
<span style="color: #228b22;">  :JOURNAL: %(journal)</span>
<span style="color: #228b22;">  :YEAR: %(year)</span>
<span style="color: #228b22;">  :VOLUME: %(volume)</span>
<span style="color: #228b22;">  :PAGES: %(pages)</span>
<span style="color: #228b22;">  :DOI: %(doi)</span>
<span style="color: #228b22;">  :URL: %(url)</span>
<span style="color: #228b22;"> :END:</span>
<span style="color: #ff0000; font-weight: bold;">[</span><span style="color: #228b22;">[cite:%(key)]] [[file:%(pdf-dir)/%(key).pdf][pdf]]\n\n"</span>))

(expand-template template))
</pre>
</div>

<pre class="example">
 :PROPERTIES:
  :Custom_ID: kitchin-2014
  :AUTHOR: Kitchin, J. R.
  :YEAR: 2014
  :VOLUME: 1
  :PAGES: 1--10
  :DOI: 10.1.1.109/hacs.1.10
  :URL: http://hacs.org/10.1.1.109/hacs.1.10
 :END:
[[cite:kitchin-2014]] [[file:/home/jkitchin/pdfs/kitchin-2014.pdf][pdf]]
</pre>

<p>
That is pretty nice. I like it better than the plist expansion I used
before. Presumably these variables would already be defined somewhere
in your code.
</p>

<p>
I thought of trying this on a more complex expansion, and discovered a
weakness in the regexp that finds the expansion values. It turns out
to be simpler to use %{} as the delimiter than %(), because you may
want nested parentheses. The regexp above does not correctly match
sets of parentheses.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %{} with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%{</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">}]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">}"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (<span style="color: #8b0000;">let</span> ((sexp (substring arg 2 -1)))
                                (format <span style="color: #228b22;">"%s"</span> (eval (read sexp))))) s))

(expand-template <span style="color: #228b22;">"2 * 2 = %{(* 2 2)}"</span>)
</pre>
</div>

<pre class="example">
2 * 2 = 4
</pre>


<p>
I am not sure this is a desirable way to make a template, with
multiline code to be expanded, but at least this works!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">expand-template</span> (s)
  <span style="color: #228b22;">"expand a template containing %{} with the eval of its contents"</span>
  (replace-regexp-in-string <span style="color: #228b22;">"%{</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">}]+</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">}"</span>
                            (<span style="color: #8b0000;">lambda</span> (arg)
                              (<span style="color: #8b0000;">let</span> ((sexp (substring arg 2 -1)))
                                (format <span style="color: #228b22;">"%s"</span> (eval (read sexp))))) s))

(expand-template <span style="color: #228b22;">"The result is %{(progn</span>
<span style="color: #228b22;">  (if (&gt; 4 3)</span>
<span style="color: #228b22;">      'true</span>
<span style="color: #228b22;">    'false))}"</span>)
</pre>
</div>

<pre class="example">
The result is true
</pre>

<p>
The regexp used in the expansion is not very robust. In particular if
there is a } in the code, it will probably fail because the regexp
does not match closing } correctly. Fixing that is beyond me right
now!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/26/Another-alternative-to-string-templates.org">org-mode source</a><p><p>Org-mode version = 8.2.5g</p>