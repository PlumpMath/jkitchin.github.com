---
title: What region is a point in
date: 2013/06/06 10:35:57
updated: 2013/06/26 18:55:07
categories: programming
tags: 
---



<p>
Suppose we have a space that is divided by a boundary into two regions, and we want to know if an arbitrary point is on one region or the other. One way to figure this out is to pick a point that is known to be in a region, and then draw a line to the arbitrary point counting the number of times it crosses the boundary. If the line crosses an even number of times, then the point is in the same region and if it crosses an odd number of times, then the point is in the other region. 
</p>

<p>
Here is the boundary and region we consider in this example:
</p>

<div class="org-src-container">

<pre class="src src-python">boundary = [[0.1, 0],
            [0.25, 0.1],
            [0.3, 0.2],
            [0.35, 0.34],
            [0.4, 0.43],
            [0.51, 0.47],
            [0.48, 0.55],
            [0.44, 0.62],
            [0.5, 0.66],
            [0.55,0.57],
            [0.556, 0.48],
            [0.63, 0.43],
            [0.70, 0.44],
            [0.8, 0.51],
            [0.91, 0.57],
            [1.0, 0.6]]

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot([p[0] <span style="color: #8b0000;">for</span> p <span style="color: #8b0000;">in</span> boundary],
         [p[1] <span style="color: #8b0000;">for</span> p <span style="color: #8b0000;">in</span> boundary])
plt.ylim([0, 1])
plt.savefig(<span style="color: #228b22;">'images/boundary-1.png'</span>)
</pre>
</div>

<pre class="example">
... ... ... ... ... ... ... ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... [&lt;matplotlib.lines.Line2D object at 0x00000000062FEBA8&gt;]
(0, 1)
</pre>

<p><img src="/img/./images/boundary-1.png"><p>

<p>
In this example, the boundary is complicated, and not described by a simple function. We will check for intersections of the line from the arbitrary point to the reference point with each segment defining the boundary. If there is an intersection in the boundary, we count that as a crossing. We choose the origin (0, 0) in this case for the reference point. For an arbitrary point (x1, y1), the equation of the line is therefore (provided x1 !=0):
</p>

<p>
\(y = \frac{y1}{x1} x\).
</p>

<p>
Let the points defining a boundary segment be (bx1, by1) and (bx2, by2). The equation for the line connecting these points (provided bx1 != bx2) is:
</p>

<p>
\(y = by1 + \frac{by2 - by1}{bx2 - bx1}(x - bx1)\)
</p>

<p>
Setting these two equations equal to each other, we can solve for the value of \(x\), and if \(bx1 <= x <= bx2\) then we would say there is an intersection with that segment. The solution for x is:
</p>

<p>
\(x = \frac{m bx1 - by1}{m - y1/x1}\)
</p>

<p>
This can only fail if \(m = y1/x1\) which means the segments are parallel and either do not intersect or go through each other. One issue we have to resolve is what to do when the intersection is at the boundary. In that case, we would see an intersection with two segments since bx1 of one segment is also bx2 of another segment. We resolve the issue by only counting intersections with bx1. Finally, there may be intersections at values of \(x\) greater than the point, and we are not interested in those because the intersections are not between the point and reference point.
</p>

<p>
Here are all of the special cases that we  have to handle:
</p>

<p><img src="/img/./images/region-determination.png"><p>

<p>
We will have to do float comparisons, so we will define <i>tolerance functions</i> for all of these. I tried this previously with regular comparison operators, and there were many cases that did not work because of float comparisons. In the code that follows, we define the tolerance functions, the function that handles almost all the special cases, and show that it almost always correctly identifies the region a point is in.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

TOLERANCE = 2 * np.spacing(1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">feq</span>(x, y, epsilon=TOLERANCE):
    <span style="color: #228b22;">'x == y'</span>
    <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">not</span>((x &lt; (y - epsilon)) <span style="color: #8b0000;">or</span> (y &lt; (x - epsilon)))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">flt</span>(x, y, epsilon=TOLERANCE):
    <span style="color: #228b22;">'x &lt; y'</span>
    <span style="color: #8b0000;">return</span> x &lt; (y - epsilon)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fgt</span>(x, y, epsilon=TOLERANCE):
    <span style="color: #228b22;">'x &gt; y'</span>
    <span style="color: #8b0000;">return</span> y &lt; (x - epsilon)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fle</span>(x, y, epsilon=TOLERANCE):
    <span style="color: #228b22;">'x &lt;= y'</span>
    <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">not</span>(y &lt; (x - epsilon))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fge</span>(x, y, epsilon=TOLERANCE):
    <span style="color: #228b22;">'x &gt;= y'</span>
    <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">not</span>(x &lt; (y - epsilon))

boundary = [[0.1, 0],
            [0.25, 0.1],
            [0.3, 0.2],
            [0.35, 0.34],
            [0.4, 0.43],
            [0.51, 0.47],
            [0.48, 0.55],
            [0.44, 0.62],
            [0.5, 0.66],
            [0.55,0.57],
            [0.556, 0.48],
            [0.63, 0.43],
            [0.70, 0.44],
            [0.8, 0.51],
            [0.91, 0.57],
            [1.0, 0.6]]

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">intersects</span>(p, isegment):
    <span style="color: #228b22;">'p is a point (x1, y1), isegment is an integer indicating which segment starting with 0'</span>
    x1, y1 = p
    bx1, by1 = boundary[isegment]
    bx2, by2 = boundary[isegment + 1]

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">outline cases to handle</span>
    <span style="color: #8b0000;">if</span> feq(bx1, bx2) <span style="color: #8b0000;">and</span> feq(x1, 0.0): <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">both segments are vertical</span>
        <span style="color: #8b0000;">if</span> feq(bx1, x1):
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">True</span>
        <span style="color: #8b0000;">else:</span>
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">False</span>
    <span style="color: #8b0000;">elif</span> feq(bx1, bx2):  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">segment is vertical</span>
        m1 = y1 / x1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">slope of reference line</span>
        y = m1 * bx1 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">value of reference line at bx1</span>
        <span style="color: #8b0000;">if</span> ((fge(y, by1) <span style="color: #8b0000;">and</span> flt(y, by2))
            <span style="color: #8b0000;">or</span> (fle(y, by1) <span style="color: #8b0000;">and</span> fgt(y,by2))):
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">reference line intersects the segment</span>
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">True</span>
        <span style="color: #8b0000;">else:</span>
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">False</span>
    <span style="color: #8b0000;">else:</span> <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">neither reference line nor segment is vertical</span>
        m = (by2 - by1) / (bx2 - bx1) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">segment slope</span>
        m1 = y1 / x1
        <span style="color: #8b0000;">if</span> feq(m, m1): <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">line and segment are parallel</span>
            <span style="color: #8b0000;">if</span> feq(y1, m * bx1):
                <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">True</span>
            <span style="color: #8b0000;">else:</span>
                <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">False</span>
        <span style="color: #8b0000;">else:</span> <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">lines are not parallel</span>
            x = (m * bx1 - by1) / (m - m1) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">x at intersection</span>

            <span style="color: #8b0000;">if</span> ((fge(x, bx1) <span style="color: #8b0000;">and</span> flt(x, bx2))
                <span style="color: #8b0000;">or</span> (fle(x, bx1) <span style="color: #8b0000;">and</span> fgt(x, bx2))) <span style="color: #8b0000;">and</span> fle(x, x1):
                <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">True</span>
            <span style="color: #8b0000;">else:</span>
                <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">False</span>

    <span style="color: #8b0000;">raise</span> <span style="color: #cd0000;">Exception</span>(<span style="color: #228b22;">'you should not get here'</span>)

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot([p[0] <span style="color: #8b0000;">for</span> p <span style="color: #8b0000;">in</span> boundary],
         [p[1] <span style="color: #8b0000;">for</span> p <span style="color: #8b0000;">in</span> boundary], <span style="color: #228b22;">'go-'</span>)
plt.ylim([0, 1])

N = 100

X = np.linspace(0, 1, N)

<span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> X:
    <span style="color: #8b0000;">for</span> y <span style="color: #8b0000;">in</span> X:
        p = (x, y)
        
        nintersections = <span style="color: #8b0000;">sum</span>([intersects(p, i) <span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(len(boundary) - 1)])

        <span style="color: #8b0000;">if</span> nintersections % 2 == 0:
            plt.plot(x, y, <span style="color: #228b22;">'r.'</span>)
        <span style="color: #8b0000;">else:</span>
            plt.plot(x, y, <span style="color: #228b22;">'b.'</span>)

plt.savefig(<span style="color: #228b22;">'images/boundary-2.png'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/boundary-2.png"><p>

<p>
If you look carefully, there are two blue points in the red region, which means there is some edge case we do not capture in our function. Kudos to the person who figures it out. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/06/06/What-region-is-a-point-in.org">org-mode source</a><p>