---
title: Handling units with the quantities module
date: 2013/03/22 22:00:30
updated: 2013/03/23 09:22:54
categories: units
tags: 
---


<p>
The quantities module (<a href="https://pypi.python.org/pypi/quantities" >https://pypi.python.org/pypi/quantities</a>) is another option for handling units in python. We are going to try the previous example. It does not work, because scipy.optimize.fsolve is not designed to work with units. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)

tguess = 4 * u.s

<span style="color: #8b0000;">print</span> func(tguess)

<span style="color: #8b0000;">print</span> fsolve(func, tguess)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; -0.00831563888873 mol/L
&gt;&gt;&gt; Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "c:\Python27\lib\site-packages\scipy\optimize\minpack.py", line 115, in fsolve
    _check_func('fsolve', 'func', func, x0, args, n, (n,))
  File "c:\Python27\lib\site-packages\scipy\optimize\minpack.py", line 13, in _check_func
    res = atleast_1d(thefunc(*((x0[:numinputs],) + args)))
  File "&lt;stdin&gt;", line 2, in func
  File "c:\Python27\lib\site-packages\quantities-0.10.1-py2.7.egg\quantities\quantity.py", line 231, in __array_prepare__
    res._dimensionality = p_dict[uf](*objs)
  File "c:\Python27\lib\site-packages\quantities-0.10.1-py2.7.egg\quantities\dimensionality.py", line 347, in _d_dimensionless
    raise ValueError("quantity must be dimensionless")
ValueError: quantity must be dimensionless
</pre>

<p>
Our function works fine with units, but fsolve does not pass numbers with units back to the function, so this function fails because the exponential function gets an argument with dimensions in it.  We can create a new function that solves this problem. We need to &ldquo;wrap&rdquo; the function we want to solve to make sure that it uses units, but returns a float number. Then, we put the units back onto the final solved value. Here is how we do that.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0):
    <span style="color: #228b22;">'wrapped fsolve command to work with units'</span>
    tU = t0 / <span style="color: #8b0000;">float</span>(t0)  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>
        <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(t * tU))

    sol, = _fsolve(wrapped_func, t0)
    <span style="color: #8b0000;">return</span> sol * tU
    
tguess = 4 * u.s

<span style="color: #8b0000;">print</span> fsolve(func, tguess)
</pre>
</div>

<pre class="example">
4.60517018599 s
</pre>

<p>
It is a little tedious to do this, but we might only have to do it once if we store the new fsolve command in a module. You might notice the wrapped function we wrote above only works for one dimensional problems. If there are multiple dimensions, we have to be a little more careful. In the next example, we expand the wrapped function definition to do both one and multidimensional problems. It appears we cannot use numpy.array element-wise multiplication because you cannot mix units in an array. We will use lists instead. When the problem is one-dimensional, the function will take a scalar, but when it is multidimensional it will take a list or array. We will use try/except blocks to handle these two cases. We will assume multidimensional cases, and if that raises an exception because the argument is not a list, we assume it is scalar. Here is the more robust code example. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0):
    <span style="color: #228b22;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #228b22;">    the function argument, then wrap the function so we can add units</span>
<span style="color: #228b22;">    to the argument and return floats. Finally we call the original</span>
<span style="color: #228b22;">    fsolve from scipy. Note: this does not support all of the options</span>
<span style="color: #228b22;">    to fsolve.'''</span> 

    <span style="color: #8b0000;">try:</span>
        tU = [t / <span style="color: #8b0000;">float</span>(t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> t0]  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        tU = t0 / <span style="color: #8b0000;">float</span>(t0)
    
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>    
        <span style="color: #8b0000;">try:</span>
            T = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(t, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            T = t * tU

        <span style="color: #8b0000;">try:</span>
            <span style="color: #8b0000;">return</span> [<span style="color: #8b0000;">float</span>(x) <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> func(T)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(T))

    sol = _fsolve(wrapped_func, t0)
    <span style="color: #8b0000;">try:</span>
        <span style="color: #8b0000;">return</span> [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(sol, tU)]
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        <span style="color: #8b0000;">return</span> sol * tU

<span style="color: #ff0000; font-weight: bold;">### Problem 1</span>
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)


tguess = 4 * u.s
sol1, = fsolve(func, tguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'sol1 = '</span>,sol1

<span style="color: #ff0000; font-weight: bold;">### Problem 2</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func2</span>(X):
    a,b = X
    <span style="color: #8b0000;">return</span> [a**2 - 4*u.kg**2,
            b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
s2a, s2b = fsolve(func2, Xguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'s2a = {0}\ns2b = {1}'</span>.format(s2a, s2b)
</pre>
</div>

<pre class="example">
sol1 =  4.60517018599 s
s2a = 2.0 kg
s2b = 5.0 J
</pre>

<p>
That is pretty good. There is still room for improvement in the wrapped function, as it does not support all of the options that scipy.optimize.fsolve supports. Here is a draft of a function that does that. We have to return different numbers of arguments depending on the value of full_output. This function works, but I have not fully tested all the options. Here are three examples that work, including one with an argument.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve <span style="color: #8b0000;">as</span> _fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fsolve</span>(func, t0, args=(), 
           fprime=<span style="color: #8b0000;">None</span>, full_output=0, col_deriv=0, 
           xtol=1.49012e-08, maxfev=0, band=<span style="color: #8b0000;">None</span>, 
           epsfcn=0.0, factor=100, diag=<span style="color: #8b0000;">None</span>):
    <span style="color: #228b22;">'''wrapped fsolve command to work with units. We get the units on</span>
<span style="color: #228b22;">    the function argument, then wrap the function so we can add units</span>
<span style="color: #228b22;">    to the argument and return floats. Finally we call the original</span>
<span style="color: #228b22;">    fsolve from scipy. '''</span> 

    <span style="color: #8b0000;">try:</span>
        tU = [t / <span style="color: #8b0000;">float</span>(t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> t0]  <span style="color: #ff0000; font-weight: bold;"># units on initial guess, normalized</span>
    <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
        tU = t0 / <span style="color: #8b0000;">float</span>(t0)
    
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">wrapped_func</span>(t, *args):
        <span style="color: #228b22;">'t will be unitless, so we add unit to it. t * tU has units.'</span>    
        <span style="color: #8b0000;">try:</span>
            T = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(t, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            T = t * tU

        <span style="color: #8b0000;">try:</span>
            <span style="color: #8b0000;">return</span> [<span style="color: #8b0000;">float</span>(x) <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> func(T, *args)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">float</span>(func(T))

    sol = _fsolve(wrapped_func, t0, args, 
           fprime, full_output, col_deriv, 
           xtol, maxfev, band, 
           epsfcn, factor, diag)

    <span style="color: #8b0000;">if</span> full_output:
        x, infodict, ier, mesg = sol
        <span style="color: #8b0000;">try:</span>
            x = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(x, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            x = x * tU
        <span style="color: #8b0000;">return</span> x, infodict, ier, mesg
    <span style="color: #8b0000;">else:</span>
        <span style="color: #8b0000;">try:</span>
            x = [x1 * x2 <span style="color: #8b0000;">for</span> x1,x2 <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(sol, tU)]
        <span style="color: #8b0000;">except</span> <span style="color: #cd0000;">TypeError</span>:
            x = sol * tU
        <span style="color: #8b0000;">return</span> x

<span style="color: #ff0000; font-weight: bold;">### Problem 1</span>
CA0 = 1 * u.mol / u.L
CA = 0.01 * u.mol / u.L
k = 1.0 / u.s

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(t):
    <span style="color: #8b0000;">return</span> CA - CA0 * np.exp(-k * t)


tguess = 4 * u.s
sol1, = fsolve(func, tguess)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'sol1 = '</span>,sol1

<span style="color: #ff0000; font-weight: bold;">### Problem 2</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func2</span>(X):
    a,b = X
    <span style="color: #8b0000;">return</span> [a**2 - 4*u.kg**2,
            b**2 - 25*u.J**2]

Xguess = [2.2*u.kg, 5.2*u.J]
sol, infodict, ier, mesg = fsolve(func2, Xguess, full_output=1)
s2a, s2b = sol
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'s2a = {0}\ns2b = {1}'</span>.format(s2a, s2b)

<span style="color: #ff0000; font-weight: bold;">### Problem 3 - with an arg</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func3</span>(a, arg):
    <span style="color: #8b0000;">return</span> a**2 - 4*u.kg**2 + arg**2

Xguess = 1.5 * u.kg
arg = 0.0* u.kg

sol3, = fsolve(func3, Xguess, args=(arg,))
print<span style="color: #228b22;">'sol3 = '</span>, sol3
</pre>
</div>

<pre class="example">
sol1 =  4.60517018599 s
s2a = 2.0 kg
s2b = 5.0 J
sol3 =  2.0 kg
</pre>

<p>
The only downside I can see in the quantities module is that it only handle temperature differences, and not absolute temperatures. If you only use absolute temperatures, this would not be a problem I think. But, if you have mixed temperature scales, the quantities module does not convert them on an absolute scale.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> quantities <span style="color: #8b0000;">as</span> u

T = 20 * u.degC

<span style="color: #8b0000;">print</span> T.rescale(u.K)
<span style="color: #8b0000;">print</span> T.rescale(u.degF)
</pre>
</div>

<pre class="example">
20.0 K
36.0 degF
</pre>

<p>
Nevertheless, this module seems pretty promising, and there are a lot more features than shown here. Some documentation can be found at <a href="http://pythonhosted.org/quantities/" >http://pythonhosted.org/quantities/</a>.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/22/Handling-units-with-the-quantities-module.org">org-mode source</a><p>