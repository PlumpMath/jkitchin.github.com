---
title: Don't get hysterical - they are just unicode function names
date: 2016/04/23 12:57:58
updated: 2016/04/23 12:57:58
categories: hylang
tags: 
---



<p>
<a href="http://hylang.org">Hy</a> allows us to define functions with unicode names. Here we play around with this to define logical operators with the symbols you normally see in formal papers (i.e. the LaTeX symbols). I think in Python3 you can also define unicode names for functions. It definitely does not work for Python2.7 which we use here (although remarkably via Hy it does work).
</p>

<p>
First, we define the logical operators or, and, xor and not, and a few other interesting ones. In case it is not clear why a unicode representation of and is helpful, note there are three instances of the word and in the previous sentence, and only one is a logical operator!  This is just some syntactical beauty, but it will shortly make for a different representation of code. We tangle this code block to logical_operators.hy.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8744;</span> [a b] (<span style="color: #006FE0;">or</span> a b))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8743;</span> [a b] (<span style="color: #006FE0;">and</span> a b))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8853;</span> [a b] (xor a b))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#172;</span> [a] (<span style="color: #006FE0;">not</span> a))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8704;</span> [x func]
  <span style="color: #008000;">"(func x) is True for every x."</span>
  (<span style="color: #006FE0;">every?</span> func x))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8707;</span> [x func]
  <span style="color: #008000;">"func(x) is true for at least one x."</span>
  (<span style="color: #006FE0;">some</span> func x))

(<span style="color: #0000FF;">defn</span> <span style="color: #006699;">&#8707;!</span> [x func]
  <span style="color: #008000;">"func(x) is true for exactly one x."</span>
  (<span style="color: #006FE0;">=</span> 1 (len (list (<span style="color: #006FE0;">filter</span> func x)))))
</pre>
</div>

<p>
Here is an example of using those operators. At the moment, we use the prefix notation of Lisp.
</p>
<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">import</span> <span style="color: #006699;">[logical_operators [*]]</span>)
(<span style="color: #0000FF;">import</span> <span style="color: #006699;">[serialize [stringify]]</span>)

(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">show</span> [body]
  `(<span style="color: #0000FF;">do</span>
    (<span style="color: #006FE0;">print</span> (.encode (.format <span style="color: #008000;">"{0} = {1}"</span> (stringify '~body) ~body) <span style="color: #008000;">"utf-8"</span>))))

(show (&#172; <span style="color: #D0372D;">True</span>))
(show (&#8743; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">False</span>))
(show (&#8743; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">True</span>))
(show (&#8744; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">False</span>))
(show (&#8744; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">True</span>))
(show (&#8853; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">False</span>))
(show (&#8853; <span style="color: #D0372D;">True</span> <span style="color: #D0372D;">True</span>))
(show (&#8853; <span style="color: #D0372D;">False</span> <span style="color: #D0372D;">False</span>))
(show (&#8704; [2 4 6] even?))
(show (&#8707; [2 3 4] odd?))
(show (&#8707;! [2 3 4] odd?))
(show (&#8707;! [2 3 5] odd?))
</pre>
</div>
<pre class="example">
(¬ True) = False
(∧ True False) = False
(∧ True True) = True
(∨ True False) = True
(∨ True True) = True
(⊕ True False) = True
(⊕ True True) = False
(⊕ False False) = False
(∀ [2 4 6] is_even) = True
(∃ [2 3 4] is_odd) = True
(∃_bang [2 3 4] is_odd) = True
(∃_bang [2 3 5] is_odd) = False
</pre>

<p>
Note the exclamation mark got expanded to _bang. It is evidently an ordinary ascii character.
</p>

<p>
We can get an infix notation if we use our infix module and the #$ reader macro defined in it. Here are some examples. Note it doesn't make sense to use this all time, e.g. it would even be a mistake to do this with the not operator.
</p>

<div class="org-src-container">

<pre class="src src-hy">(<span style="color: #0000FF;">import</span> <span style="color: #006699;">[logical_operators [*]]</span>)
(<span style="color: #0000FF;">import</span> <span style="color: #006699;">[serialize [stringify]]</span>)
(<span style="color: #0000FF;">import</span> <span style="color: #006699;">[infix [*]]</span>)
(<span style="color: #0000FF;">require</span> <span style="color: #006699;">infix</span>)

(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">show</span> [body]
  `(<span style="color: #0000FF;">do</span>
    (<span style="color: #006FE0;">print</span> (.encode (.format <span style="color: #008000;">"{0} = {1}"</span> (stringify '~body) ~body) <span style="color: #008000;">"utf-8"</span>))))

(show (&#172; <span style="color: #D0372D;">True</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8743; <span style="color: #D0372D;">False</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8743; <span style="color: #D0372D;">True</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8744; <span style="color: #D0372D;">False</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8744; <span style="color: #D0372D;">True</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8853; <span style="color: #D0372D;">False</span>))
(show #$(<span style="color: #D0372D;">True</span> &#8853; <span style="color: #D0372D;">True</span>))
(show #$(<span style="color: #D0372D;">False</span> &#8853; <span style="color: #D0372D;">False</span>))
</pre>
</div>
<pre class="example">
(¬ True) = False
(dispatch_reader_macro "$" (True ∧ False)) = False
(dispatch_reader_macro "$" (True ∧ True)) = True
(dispatch_reader_macro "$" (True ∨ False)) = True
(dispatch_reader_macro "$" (True ∨ True)) = True
(dispatch_reader_macro "$" (True ⊕ False)) = True
(dispatch_reader_macro "$" (True ⊕ True)) = False
(dispatch_reader_macro "$" (False ⊕ False)) = False
</pre>

<p>
The show macro shows us how the reader macro gets expanded into, you guessed it, regular old function calls. They are just syntactical sugar to help us be more concise. The unicode symbols are not quite as simple to type as ascii names, but there are solutions to this: abbreviations in Emacs (<a href="http://ergoemacs.org/emacs/emacs_n_unicode.html">http://ergoemacs.org/emacs/emacs_n_unicode.html</a> ), custom commands, learn the keystrokes (<a href="http://www.johndcook.com/blog/emacs_unicode/">http://www.johndcook.com/blog/emacs_unicode/</a> ) and C-x 8 RET and the unicode name, etc&#x2026; Is it worth it? That might depend on how ingrained those logical symbols are in your mental model of your work. If it is deeply ingrained, your code will be better aligned with your thoughts, and easier to understand.
</p>
<p>Copyright (C) 2016 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2016/04/23/Don't-get-hysterical---they-are-just-unicode-function-names.org">org-mode source</a></p>
<p>Org-mode version = 8.2.10</p>