---
title: A novel way to numerically estimate the derivative of a function - complex-step derivative approximation
date: 2013/02/27 14:51:38
updated: 2013/03/06 18:26:30
categories: math
tags: 
---


<p>

</p>

<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/24/a-novel-way-to-numerically-estimate-the-derivative-of-a-function-complex-step-derivative-approximation/" >Matlab post</a>
</p>

<p>
Adapted from <a href="http://biomedicalcomputationreview.org/2/3/8.pdf" >http://biomedicalcomputationreview.org/2/3/8.pdf</a> and
<a href="http://dl.acm.org/citation.cfm?id=838250.838251" >http://dl.acm.org/citation.cfm?id=838250.838251</a>
</p>

<p>
This posts introduces a novel way to numerically estimate the derivative
of a function that does not involve finite difference schemes. Finite
difference schemes are approximations to derivatives that become more and
more accurate as the step size goes to zero, except that as the step size
approaches the limits of machine accuracy, new errors can appear in the
approximated results. In the references above, a new way to compute the
derivative is presented that does not rely on differences!
</p>

<p>
The new way is: \(f'(x) = \rm{imag}(f(x + i\Delta x)/\Delta x)\) where the
function \(f\) is evaluated in imaginary space with a small \(\Delta x\) in
the complex plane. The derivative is miraculously equal to the imaginary
part of the result in the limit of $&Delta; x &rarr; 0$!
</p>

<p>
This example comes from the first link. The derivative must be evaluated
using the chain rule.  We compare a forward difference, central
difference and complex-step derivative approximations.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):   <span style="color: #8b0000;">return</span> np.sin(3*x)*np.log(x)

x = 0.7
h = 1e-7

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">analytical derivative</span>
dfdx_a = 3 * np.cos( 3*x)*np.log(x) + np.sin(3*x) / x

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">finite difference</span>
dfdx_fd = (f(x + h) - f(x))/h

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">central difference</span>
dfdx_cd = (f(x+h)-f(x-h))/(2*h)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">complex method</span>
dfdx_I = np.imag(f(x + np.complex(0, h))/h)

<span style="color: #8b0000;">print</span> dfdx_a
<span style="color: #8b0000;">print</span> dfdx_fd
<span style="color: #8b0000;">print</span> dfdx_cd
<span style="color: #8b0000;">print</span> dfdx_cd
</pre>
</div>

<pre class="example">
1.77335410624
1.7733539398
1.77335410523
1.77335410523
</pre>

<p>
These are all the same to 4 decimal places. The simple finite difference is the least accurate, and the central differences is practically the same as the complex number approach.
</p>

<p>
Let us use this method to verify the fundamental Theorem of Calculus, i.e.
to evaluate the derivative of an integral function. Let \(f(x) =
\int\limits_1^{x^2} tan(t^3)dt\), and we now want to compute df/dx.
Of course, this can be done
<a href="http://mathmistakes.info/facts/CalculusFacts/learn/doi/doif.html" >analytically</a>, but it is not trivial!
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> quad

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f_</span>(z):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">integrand</span>(t):
        <span style="color: #8b0000;">return</span> np.tan(t**3)
    <span style="color: #8b0000;">return</span> quad(integrand, 0, z**2)

f = np.vectorize(f_)

x = np.linspace(0, 1)

h = 1e-7

dfdx = np.imag(f(x + <span style="color: #8b0000;">complex</span>(0, h)))/h
dfdx_analytical = 2 * x * np.tan(x**6)

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot(x, dfdx, x, dfdx_analytical, <span style="color: #228b22;">'r--'</span>)
plt.show()
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; c:\Python27\lib\site-packages\scipy\integrate\quadpack.py:312: ComplexWarning: Casting complex values to real discards the imaginary part
  return _quadpack._qagse(func,a,b,args,full_output,epsabs,epsrel,limit)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "c:\Python27\lib\site-packages\numpy\lib\function_base.py", line 1885, in __call__
    for x, c in zip(self.ufunc(*newargs), self.otypes)])
  File "&lt;stdin&gt;", line 4, in f_
  File "c:\Python27\lib\site-packages\scipy\integrate\quadpack.py", line 247, in quad
    retval = _quad(func,a,b,args,full_output,epsabs,epsrel,limit,points)
  File "c:\Python27\lib\site-packages\scipy\integrate\quadpack.py", line 312, in _quad
    return _quadpack._qagse(func,a,b,args,full_output,epsabs,epsrel,limit)
TypeError: can't convert complex to float
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'dfdx' is not defined
</pre>

<p>
Interesting this fails.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/A-novel-way-to-numerically-estimate-the-derivative-of-a-function---complex-step-derivative-approximation.org">org-mode source</a><p>