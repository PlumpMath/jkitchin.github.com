---
title: The trapezoidal method of integration
date: 2013/02/23 09:00:00
updated: 2013/02/27 14:54:17
categories: math, integration
tags: ''
---


<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/14/the-trapezoidal-method-of-integration/" >Matlab post</a>

See <a href="http://en.wikipedia.org/wiki/Trapezoidal_rule" >http://en.wikipedia.org/wiki/Trapezoidal_rule</a>
</p>

<p>
$$\int_a^b f(x) dx \approx \frac{1}{2}\displaystyle\sum\limits_{k=1}^N(x_{k+1}-x_k)(f(x_{k+1}) + f(x_k))$$
</p>

<p>
Let us compute the integral of sin(x) from x=0 to \(\pi\). To approximate the integral, we need to divide the interval from \(a\) to \(b\) into \(N\) intervals. The analytical answer is 2.0.
</p>

<p>
We will use this example to illustrate the difference in performance between loops and vectorized operations in python.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> time

a = 0.0; b = np.pi;
N = 1000; <span style="color: #ff0000; font-weight: bold;"># this is the number of intervals</span>

h = (b - a)/N; <span style="color: #ff0000; font-weight: bold;"># this is the width of each interval</span>
x = np.linspace(a, b, N) 
y = np.sin(x); <span style="color: #ff0000; font-weight: bold;"># the sin function is already vectorized</span>

t0 = time.time()
f = 0.0
<span style="color: #8b0000;">for</span> k <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(len(x) - 1):
    f += 0.5 * ((x[k+1] - x[k]) * (y[k+1] + y[k]))

tf = time.time() - t0
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'time elapsed = {0} sec'</span>.format(tf)

<span style="color: #8b0000;">print</span> f
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; time elapsed = 0.0780000686646 sec
&gt;&gt;&gt; 1.99999835177
</pre>

<div class="org-src-container">

<pre class="src src-python">t0 = time.time()
Xk = x[1:-1] - x[0:-2] <span style="color: #ff0000; font-weight: bold;"># vectorized version of (x[k+1] - x[k])</span>
Yk = y[1:-1] + y[0:-2] <span style="color: #ff0000; font-weight: bold;"># vectorized version of (y[k+1] + y[k])</span>

f = 0.5 * np.sum(Xk * Yk) <span style="color: #ff0000; font-weight: bold;"># vectorized version of the loop above</span>
tf = time.time() - t0
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'time elapsed = {0} sec'</span>.format(tf)

<span style="color: #8b0000;">print</span> f
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; time elapsed = 0.077999830246 sec
&gt;&gt;&gt; 1.99999340709
</pre>

<p>
In the last example, there may be loop buried in the sum command. Let us do one final method, using linear algebra, in a single line. The key to understanding this is to recognize the sum is just the result of a dot product of the x differences and y sums. 
</p>

<div class="org-src-container">

<pre class="src src-python">t0 = time.time()
f = 0.5 * np.dot(Xk, Yk)
tf = time.time() - t0
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'time elapsed = {0} sec'</span>.format(tf)

<span style="color: #8b0000;">print</span> f
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; time elapsed = 0.0310001373291 sec
&gt;&gt;&gt; 1.99999340709
</pre>

<p>
The loop method is straightforward to code, and looks alot like the formula that defines the trapezoid method. the vectorized methods are not as easy to read, and take fewer lines of code to write. However, the vectorized methods are much faster than the loop, so the loss of readability could be worth it for very large problems.
</p>

<p>
The times here are considerably slower than in Matlab. I am not sure if that is a totally fair comparison. Here I am running python through emacs, which may result in slower performance. I also used a very crude way of timing the performance which lumps some system performance in too.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/23/The-trapezoidal-method-of-integration.org">org-mode source</a><p>