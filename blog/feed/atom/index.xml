<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2015-06-25T14:37:35Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Integrating swish-e and Emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs" />
    <id>http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs</id>
    <updated>2015-06-25T10:37:05Z</updated>
    <published>2015-06-25T10:37:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Integrating swish-e and Emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs"><![CDATA[



<p>
<a href="http://swish-e.org">swish-e</a> is a software package that indexes files on your computer, and then allows you to search the index. Spotlight on my Mac is not working too well (sometimes not at all), and I want some more flexibility so today we try getting swish-e up and running and integrated with Emacs. I don't know that swish-e is the best tool for this available, but it has been on my radar a <i>long</i> time (probably since 2003 from this <a href="http://joshr.com/src/docs/HowToIndexAnything.pdf">article</a> ), and it was easy to setup and use.
</p>

<p>
I use homebrew, so installation was this simple:
</p>

<div class="org-src-container">

<pre class="src src-sh">brew install swish-e
</pre>
</div>

<p>
To test things out, I will only index org-files. I have these all over the place, and they are not all in my org-mode agenda. So, finding them quickly would be awesome.
</p>

<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# Tell Swish-e what to index (same as -i switch above)
IndexDir /Users/jkitchin/Dropbox/org-mode

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

# Otherwise, use the HTML parser
DefaultContents HTML*

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
</pre>
</div>

<p>
Now, we create our index.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c ~/.swish-e/swish.conf
</pre>
</div>
<pre class="example">
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox/org-mode"
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 29,589 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
29,589 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
87 files indexed.  2,900,196 total bytes.  372,888 total words.
Elapsed time: 00:00:00 CPU time: 00:00:00
Indexing done!
</pre>

<p>
Now an example search. I have been looking into the Energy frontier research centers, and I want to find my notes on it. Here is a little query. I use a special output format to keep things simple for the parsing later, just the rank and path, separated by a space.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -x <span style="color: #008000;">'%r %p\n'</span> -w EFRC
</pre>
</div>
<pre class="example">
# SWISH format: 2.4.7
# Search words: EFRC
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.009 seconds
1000 /Users/jkitchin/Dropbox/org-mode/journal.org
471 /Users/jkitchin/Dropbox/org-mode/proposals.org
.
</pre>

<p>
Now, for the integration with Emacs. We just get that output in a string, split it, and get the parts we want.  I think I will use helm to provide a selection buffer to these results. We need a list of cons cells (string . candidate). Then we write an interactive helm function. We provide two sources. One for the initial query, and another to start a new search, in case you don't find what you want.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e-candidates</span> (query)
  <span style="color: #036A07;">"Generate a list of cons cells (swish-e result . path)."</span>
  (<span style="color: #0000FF;">let*</span> ((result (shell-command-to-string
                  (format <span style="color: #008000;">"swish-e -x \"%%r %%p\n\" -w %s"</span>
                          (shell-quote-argument query))))
         (lines (s-split <span style="color: #008000;">"\n"</span> result t))
         (candidates '()))
    (<span style="color: #0000FF;">loop</span> for line in lines
          unless (<span style="color: #0000FF;">or</span>  (s-starts-with? <span style="color: #008000;">"#"</span> line)
                      (s-starts-with? <span style="color: #008000;">"."</span> line))
          collect (cons line (cdr (s-split <span style="color: #008000;">" "</span> line))))))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e</span> (query)
  <span style="color: #036A07;">"Run a swish-e query and provide helm selection buffer of the results."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sQuery: "</span>)
  (helm <span style="color: #006FE0;">:sources</span> `(((name . ,(format <span style="color: #008000;">"swish-e: %s"</span> query))
                    (candidates . ,(helm-swish-e-candidates query))
                    (action . ((<span style="color: #008000;">"open"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                           (find-file (car f)))))))
                   ((name . <span style="color: #008000;">"New search"</span>)
                    (dummy)
                    (action . ((<span style="color: #008000;">"search"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                             (helm-swish-e helm-pattern)))))))))
</pre>
</div>

<pre class="example">
helm-swish-e
</pre>

<p>
Now I can run M-x helm-swish-e and enter "efrc AND computing infrastructure" to find org files containing those words, then press enter to find the file. Nice and easy. I have not tested the query syntax very fully, but so far it is working fine!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/25/Integrating-swish-e-and-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Conditional hydra menus]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/24/Conditional-hydra-menus" />
    <id>http://jkitchin.github.io/blog/2015/06/24/Conditional-hydra-menus</id>
    <updated>2015-06-24T07:31:41Z</updated>
    <published>2015-06-24T07:31:41Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="hydra" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Conditional hydra menus]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/24/Conditional-hydra-menus"><![CDATA[



<p>
Usually the <a href="https://github.com/abo-abo/hydra">hydra</a> menu is hard coded in the defhydra macro. Sometimes, you would like conditional options, that is, depending on some condition we get different options <i>when we run the hydra</i> and not when it was defined. This is an open <a href="https://github.com/abo-abo/hydra/issues/86">issue</a> in hydra. Here we explore a way to achieve that. The idea is to construct the code for the hydra, then eval it, and run the hydra. In this example we make the conditional menu depend on whether we are on an even or odd numbered line. I use the `' syntax for defining the list of code. ` is a variation of ' (quote) that enables you to use the , operator to evaluate that element while in data mode. So, here is our first idea:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">my-hydra-1</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (eval
   `(<span style="color: #0000FF;">defhydra</span> my-hydra-1 (<span style="color: #006FE0;">:color</span> blue) <span style="color: #008000;">"My hydra"</span>
      ,(<span style="color: #0000FF;">if</span> (evenp (line-number-at-pos))
           '(<span style="color: #008000;">"e"</span> (message-box <span style="color: #008000;">"Even line"</span>) <span style="color: #008000;">"Even"</span>)
         '(<span style="color: #008000;">"o"</span> (message-box <span style="color: #008000;">"Odd line"</span>) <span style="color: #008000;">"Odd"</span>))
      ,(<span style="color: #0000FF;">when</span> t '(<span style="color: #008000;">"a"</span> (message-box <span style="color: #008000;">"always true"</span>) <span style="color: #008000;">"always"</span>))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">This does not work. you must return a legitimate hydra menu item</span>
      <span style="color: #8D8D84;">;;      </span><span style="color: #8D8D84; font-style: italic;">,(when nil '("n" (message-box "never") "never"))</span>
      ))
  (my-hydra-1/body))

(my-hydra-1)
(my-hydra-1)
</pre>
</div>

<pre class="example">
my-hydra
</pre>

<p>
As long as it is not expensive to compute the conditionals, this seems like an easy enough way to get conditional options in a hydra. One limitation of the previous approach is our menu conditionals must return a hydra menu, and not nil. Here is an alternative approach to writing the function that solves the issue of the nil return in the last function. Here we build up the code list using append. It might seem like a macro should be used here, but I have not figured out how to get the macro to run the conditionals at the run-time. Note, we cannot use funcall on the defhydra because that is a macro.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">my-hydra-2</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((conditionals '((<span style="color: #0000FF;">if</span> (evenp (line-number-at-pos))
                            '(<span style="color: #008000;">"e"</span> (message-box <span style="color: #008000;">"Even second"</span>) <span style="color: #008000;">"Even"</span>)
                          '(<span style="color: #008000;">"o"</span> (message-box <span style="color: #008000;">"Odd second"</span>) <span style="color: #008000;">"Odd"</span>))
                        (<span style="color: #0000FF;">when</span> t '(<span style="color: #008000;">"a"</span> (message-box <span style="color: #008000;">"always true"</span>) <span style="color: #008000;">"always"</span>))
                        (<span style="color: #0000FF;">when</span> nil '(<span style="color: #008000;">"n"</span> (message-box <span style="color: #008000;">"never"</span>) <span style="color: #008000;">"never"</span>)))))
    (eval
     (append
      '(defhydra my-hydra-2 (<span style="color: #006FE0;">:color</span> blue) <span style="color: #008000;">"My hydra"</span>)
      (<span style="color: #0000FF;">loop</span> for cond in conditionals
            with result = (eval cond)
            if (eval cond)
            collect (eval cond))))
    (my-hydra-2/body)))

(my-hydra-2)
(my-hydra-2)
</pre>
</div>

<p>
That works too. Let us try another type of syntax where the conditional statements have a cons cell with a conditional statement, and a hydra menu option for when the statement is true. This is functionally similar to our first method, but has some advantages in brevity and less quoting. We add a conditional hint here too (at some expense of additional quoting).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">my-hydra-3</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((conditionals
         `(((evenp (line-number-at-pos)) . (<span style="color: #008000;">"e"</span> (message-box <span style="color: #008000;">"Even second"</span>) ,(format <span style="color: #008000;">"Even: %s"</span> (line-number-at-pos))))
           ((oddp (line-number-at-pos)) . (<span style="color: #008000;">"o"</span> (message-box <span style="color: #008000;">"Odd second"</span>) ,(format <span style="color: #008000;">"Odd: %s"</span> (line-number-at-pos))))
           (t . (<span style="color: #008000;">"a"</span> (message-box <span style="color: #008000;">"always true"</span>) <span style="color: #008000;">"always"</span>))
           (nil . (<span style="color: #008000;">"n"</span> (message-box <span style="color: #008000;">"never"</span>) <span style="color: #008000;">"never"</span>)))))
    (eval
     (append
      '(defhydra my-hydra-3 (<span style="color: #006FE0;">:color</span> blue) <span style="color: #008000;">"My hydra"</span>)
      (<span style="color: #0000FF;">loop</span> for cond in conditionals
            if (eval (car  cond))
            collect (cdr cond))))
    (my-hydra-3/body)))

(my-hydra-3)
(my-hydra-3)
</pre>
</div>

<p>
I cannot figure out how to abstract this much further. There is a little redundancy in names, e.g. in the defhydra and at the end, but it is not too bad, which would usually be handled by a macro. I tried some defmacros to try this, but I could not figure out how to get the conditionals to expand at the right times, which is at run time, and not at macro expansion time. I need a macro that generates a function that has the call to defhydra in it! Maybe next year ;)
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/24/Conditional-hydra-menus.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Clickable org-contacts in text files]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files" />
    <id>http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files</id>
    <updated>2015-06-22T13:07:03Z</updated>
    <published>2015-06-22T13:07:03Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="contacts" />
    <summary type="html"><![CDATA[Clickable org-contacts in text files]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files"><![CDATA[



<p>
Continuing my adventures with clickable text (See <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/21/Clickable-email-addresses-in-emacs/">clickable email addresses</a> and <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/03/18/Clickable-links-for-Twitter-handles-in-Emacs/">clickable twitter handles</a> ), here we consider how to get clickable names that are also in my org-contacts database. The goal is to have these names highlighted and clickable so that when I click on them I get a hydra menu of actions, e.g. to open the contact, email them, etc&#x2026; We will again use button-lock to do the action. We will construct a fairly large regexp to match all the names in the org-contacts database. This turns out to be very easy using the regexp-opt function.
</p>

<p>
First, I formalize the code I used last time to get text around the point that has a text-property. We will use that to get the text that has been highlighted by button-lock.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-surrounding-text-with-property</span> (property)
  <span style="color: #036A07;">"Return text surrounding point with the text-property PROPERTY."</span>
  (<span style="color: #0000FF;">let</span> ((start) (end))
    (<span style="color: #0000FF;">when</span> (get-text-property (point) property)
      (<span style="color: #0000FF;">save-excursion</span>
        (<span style="color: #0000FF;">while</span> (get-text-property (point) property)
          (backward-char))
        (forward-char)
        (<span style="color: #0000FF;">setq</span> start (point))
        (<span style="color: #0000FF;">while</span> (get-text-property (point) property)
          (forward-char))
        (<span style="color: #0000FF;">setq</span> end (point)))
      (buffer-substring start end))))
</pre>
</div>

<pre class="example">
get-surrounding-text-with-property
</pre>

<p>
I want to use nicknames that are defined in my org-contacts database. We first try to return an assoc lookup, then the slower approach of looping through the entries to find a matching nickname.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-contact-from-name-or-nickname</span> (name-or-nickname)
  <span style="color: #036A07;">"Return a contact from the org-contacts database for NAME-OR-NICKNAME."</span>
  (<span style="color: #0000FF;">or</span>
   (assoc name-or-nickname (org-contacts-db))
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">no assoc, so now we have to find a nickname</span>
   (<span style="color: #0000FF;">catch</span> '<span style="color: #D0372D;">contact</span>
     (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
       (<span style="color: #0000FF;">when</span> (-contains? (s-split <span style="color: #008000;">","</span> (<span style="color: #0000FF;">or</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))) <span style="color: #008000;">" "</span>)) name-or-nickname)
         (<span style="color: #0000FF;">throw</span> '<span style="color: #D0372D;">contact</span> contact))))))
</pre>
</div>

<pre class="example">
get-contact-from-name-or-nickname
</pre>

<p>
Now, let us write a hydra function that will be our menu of actions. For some reason, when you click on a highlighted text the mouse moves to the end of the text, so in our hydra function we move back a char, and then get the info. Basically, we get the name, then get the contact, and extract what we need from there. Here we provide functionality to open a contact, email a contact or open the url of the contact (if it exists). I also want a conditional hydra, which doesn't seem to be an option yet, so we we roll our own here. Basically, we construct the code for a hydra, and only add a menu option to open the url if we find one in the contact. We will have to eval the code returned from this function to get the hydra body, and then call the body function in the action function for the highlighted text.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">conditional-hydra-actions</span> ()
  <span style="color: #036A07;">"Construct code to create a hydra with conditional options."</span>
  (<span style="color: #0000FF;">let</span> ((code  '(defhydra org-contacts (<span style="color: #006FE0;">:color</span> blue)
                  <span style="color: #008000;">"Org contacts"</span>)))
    (<span style="color: #0000FF;">setq</span> code
          (append
           code
           '((<span style="color: #008000;">"o"</span> (<span style="color: #0000FF;">progn</span>
                    (backward-char)
                    (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                           (contact (get-contact-from-name-or-nickname name))
                           (contact-marker (nth 1 contact)))
                      (switch-to-buffer (marker-buffer contact-marker))
                      (goto-char (marker-position contact-marker))
                      (show-subtree)))
              <span style="color: #008000;">"Open contact"</span>))))

    (<span style="color: #0000FF;">setq</span> code
          (append
           code '((<span style="color: #008000;">"e"</span> (<span style="color: #0000FF;">progn</span>
                         (backward-char)
                         (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                                (contact (get-contact-from-name-or-nickname name))
                                (email (cdr (assoc <span style="color: #008000;">"EMAIL"</span> (caddr contact))))))
                         (mu4e~compose-mail email))
                   <span style="color: #008000;">"Email contact"</span>))))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">conditional menu for opening a URL</span>
    (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
           (contact (assoc name (org-contacts-db)))
           (url (cdr (assoc <span style="color: #008000;">"URL"</span> (caddr contact)))))
      (<span style="color: #0000FF;">when</span> url
        (<span style="color: #0000FF;">setq</span> code
              (append
               code '((<span style="color: #008000;">"w"</span> (<span style="color: #0000FF;">progn</span>
                             (backward-char)
                             (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                                    (contact (get-contact-from-name-or-nickname name))
                                    (url (cdr (assoc <span style="color: #008000;">"URL"</span> (caddr contact)))))
                               (<span style="color: #0000FF;">if</span> url
                                   (browse-url url)
                                 (message <span style="color: #008000;">"No url found."</span>))))
                       <span style="color: #008000;">"Open in browser"</span>))))))
    code))
</pre>
</div>

<pre class="example">
conditional-hydra-actions
</pre>

<p>
I also want to have nicknames in this list, because sometimes I don't use the full names in my contact database. These are stored in a comma-separated property called NICKNAMES in entries that have them. A subtle point here is that it complicates looking up the contact in the database. Normally, I can get this by a simple assoc lookup. For the nicknames, that will fail, so we need a back up method. Now, the highlighting code. You can make the regexp by passing a list of strings to match to regexp-opt. We get our list of strings from:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(append
 (mapcar 'car (org-contacts-db))
 (<span style="color: #0000FF;">let</span> ((nicknames '()))
   (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
     (<span style="color: #0000FF;">when</span> (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))
       (<span style="color: #0000FF;">setq</span> nicknames
             (append nicknames (s-split <span style="color: #008000;">","</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))))))))
   nicknames))
</pre>
</div>

<p>
I am not going to show them here to protect my contacts ;). Now, we create the function that highlights the contacts. and add it as a hook function to text-mode-hook.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-org-contacts</span> ()
  (button-lock-set-button
   (regexp-opt
    (append
     (mapcar 'car (org-contacts-db))
     (<span style="color: #0000FF;">let</span> ((nicknames '()))
       (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
         (<span style="color: #0000FF;">when</span> (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))
           (<span style="color: #0000FF;">setq</span> nicknames
                 (append
                  nicknames
                  (s-split <span style="color: #008000;">","</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))))))))
       nicknames)))
   (<span style="color: #0000FF;">lambda</span> ()
     (<span style="color: #0000FF;">interactive</span>)
     (eval (conditional-hydra-actions))
     (org-contacts/body))
   <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"MistyRose1"</span>)
           (<span style="color: #006FE0;">:underline</span> t))
   <span style="color: #006FE0;">:help-echo</span> (format <span style="color: #008000;">"An org contact"</span>)
   <span style="color: #006FE0;">:keyboard-binding</span> (kbd <span style="color: #008000;">"RET"</span>)
   <span style="color: #006FE0;">:additional-property</span> 'org-contact))

(add-hook 'text-mode-hook 'highlight-org-contacts)
</pre>
</div>

<p>
That does it. Now, whenever I open a text-based file, the names that are in my contacts are highlighted and actionable. This should be useful for meeting notes, etc&#x2026;
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/22/Clickable-org-contacts-in-text-files.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Clickable email addresses in emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/21/Clickable-email-addresses-in-emacs" />
    <id>http://jkitchin.github.io/blog/2015/06/21/Clickable-email-addresses-in-emacs</id>
    <updated>2015-06-21T16:42:40Z</updated>
    <published>2015-06-21T16:42:40Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="email" />
    <summary type="html"><![CDATA[Clickable email addresses in emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/21/Clickable-email-addresses-in-emacs"><![CDATA[



<p>
There are clickable <a href="mailto:jkitchin@andrew.cmu.edu">mailto:jkitchin@andrew.cmu.edu</a> links in org-mode, but standalone email addresses like jkitchin@cmu.edu are just ordinary text. Here, I want to explore using clickable text instead. I will use the button-lock package for this. I borrowed an email regexp from <a href="http://www.emacswiki.org/emacs/RegularExpression">EmacsWiki: Regular Expression</a> for this. The idea is to define a regular expression for an email address, and use it to make the emails clickable.
</p>

<p>
I am still not sure what the canonical way to get the value of the text that was highlighted. Here we use the :additional-property feature to set a property to t, and then use that property to get the characters that have a non-nil "email-address" property. It seems clunky, but it works. The main action is to compose an email in mu4e (my preferred email program in emacs). You could also put a call to helm here, or to a hydra for other options.
</p>

<p>
I make the email addresses stand out a little by giving them a gray background, and a tooltip so you can see why they are highlighted. I also bind RET so I don't have to use the mouse. Don't forget you can type C-h . to see the local help instead of mousing over it! Finally, we add a text-mode hook so this will get loaded when we open a text file (or one with a mode derived from text-mode like org-mode).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-email-addresses</span> ()
  <span style="color: #036A07;">"Add button to email address. Clicking or RET will open a compose email window."</span>
  (button-lock-set-button
   <span style="color: #008000;">"\\w+</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">\\.\\w+</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">?@</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">\\w</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">\\.</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">+"</span>
   (<span style="color: #0000FF;">lambda</span> ()
     (<span style="color: #0000FF;">interactive</span>)
     (<span style="color: #0000FF;">let</span> ((start) (end) (email-address))
       (<span style="color: #0000FF;">while</span> (get-text-property (point) 'email-address)
         (backward-char))
       (forward-char)
       (<span style="color: #0000FF;">setq</span> start (point))
       (<span style="color: #0000FF;">while</span> (get-text-property (point) 'email-address)
         (forward-char))
       (<span style="color: #0000FF;">setq</span> end (point))
       (<span style="color: #0000FF;">setq</span> email-address (buffer-substring start end))
       (mu4e~compose-mail email-address)))
     <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"gray80"</span>) (<span style="color: #006FE0;">:underline</span> t))
     <span style="color: #006FE0;">:help-echo</span> <span style="color: #008000;">"click to send mu4e email"</span>
     <span style="color: #006FE0;">:keyboard-binding</span> (kbd <span style="color: #008000;">"RET"</span>)
     <span style="color: #006FE0;">:additional-property</span> 'email-address))

(add-hook 'text-mode-hook 'highlight-email-addresses)
</pre>
</div>

<p>
That doesn't look too bad. Now, anytime I open an org-mode file with an email address in it, the address is highlighted in light gray, and underlined. I can click on it or put the cursor on it and press return and I get a compose email window open, with the email address pre-filled in! I am sure this will have some other applications.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/21/Clickable-email-addresses-in-emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[ox-pandoc - org-mode + org-ref to docx with bibliographies]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies" />
    <id>http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies</id>
    <updated>2015-06-12T11:19:37Z</updated>
    <published>2015-06-11T12:58:07Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="docx" />
    <category scheme="http://jkitchin.github.io/blog" term="pandoc" />
    <summary type="html"><![CDATA[ox-pandoc - org-mode + org-ref to docx with bibliographies]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. The setup</a></li>
<li><a href="#sec-2">2. The document</a></li>
<li><a href="#sec-3">3. Summary</a></li>
</ul>
</div>
</div>
<p>
There is a new org-mode exporter: <a href="https://github.com/kawabata/ox-pandoc">ox-pandoc</a> . It seems like it makes it easy to convert org-mode to other formats, including docx, and including references in a bibliography. Let us try it out.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The setup</h2>
<div class="outline-text-2" id="text-1">
<p>
<del>We  have to modify org-ref</del> org-ref modifies helm-bibtex to insert citation links. We have to undo that here to insert LaTeX style citations. We do that here so that the key binding for inserting references from org-ref inserts the LaTeX citations. This is necessary for pandoc to convert the reference citations to the bibliography in the docx format. If you do not use org-ref, this is probably not necessary.
</p>


<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> helm-bibtex-format-citation-functions
      '((org-mode . (<span style="color: #0000FF;">lambda</span> (x) (insert (concat
                                         <span style="color: #008000;">"\\cite{"</span>
                                         (mapconcat 'identity x <span style="color: #008000;">","</span>)
                                         <span style="color: #008000;">"}"</span>)) <span style="color: #008000;">""</span>))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">org-mode</td>
<td class="left">lambda</td>
<td class="left">(x)</td>
<td class="left">(insert (concat \cite{ (mapconcat (quote identity) x ,) }))</td>
</tr>
</tbody>
</table>

<p>
We have to add ox-pandoc and require it.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"ox-pandoc"</span> starter-kit-dir))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">ox-pandoc</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> The document</h2>
<div class="outline-text-2" id="text-2">
<p>
Now, for some text. Grindy wrote this nice paper on approaching chemical accuracy with density functional  calculations \cite{grindy-2013-approac}. Two other interesting papers include these ones \cite{guldner-1961,guerrini-2008-effec-feo}.
</p>

<p>
An equation: \(e^x = 4\).
</p>

<p>
And a figure with a caption:
</p>


<div class="figure">
<p><img src="/media/2015-06-11-ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies/bib.png"> 
</p>
<p><span class="figure-number">Figure 1:</span> Make sure this is in your org-file.</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
This is better than what I have seen in the past. ox-pandoc has some options that might tailor the bibliography to specific formats. You lose some functionality of org-ref cite links by using raw LaTeX, but if that is not a deal breaker this might be a good way to go for some purposes.
</p>

<p>
Here is the word document that results from this file: <a href="/media/2015-06-11-ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies/test-doc.docx">test-doc.docx</a> 
</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/11/ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A python version of the s-exp bibtex entry]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry" />
    <id>http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry</id>
    <updated>2015-06-11T10:02:33Z</updated>
    <published>2015-06-11T10:02:33Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[A python version of the s-exp bibtex entry]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry"><![CDATA[



<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/">post</a> we explored representing a bibtex entry in lisp s-exp notation, and showed interesting things that enables. Here, I explore something similar in Python. The s-exp notation in Python is really more like tuples. It looks almost identical, except we need a lot of commas for the Python syntax. One significant difference in Python is we need to define the functions in advance because otherwise the function symbols are undefined. Similar to lisp, we can define the field functions at run-time in a loop. We have to use an eval statement, which some Pythonistas find distasteful, but it is not that different to me than what we did in lisp.
</p>

<p>
The syntax for "executing" the data structure is quite different than in lisp, because this data is <i>not</i> code in Python. Instead, we have to deconstruct the data, knowing that the function is the first object, and it takes the remaining arguments in the tuple.
</p>

<p>
Here is the proof of concept:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">print</span> entry[0](entry[1], entry[2:])
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \&amp; Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
</pre>

<p>
We can still get specific fields out. Since we used a tuple here, it is not quite as nice as using a dictionary, but it is neither too bad, and it can be wrapped in a reasonably convenient function.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">for</span> field <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> field[0] == author:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span> field

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_field</span>(entry, field):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> element <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> element[0] == field:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> element[1]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">None</span>

<span style="color: #0000FF;">print</span> get_field(entry, title)
<span style="color: #0000FF;">print</span> get_field(entry, <span style="color: #008000;">"bad"</span>)
</pre>
</div>

<pre class="example">
(&lt;function &lt;lambda&gt; at 0x1005975f0&gt;, 'Hallenbeck, Alexander P. and Kitchin, John R.')
Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent
None
</pre>

<p>
So, it seems Python can do some things like lisp in treating functions like first-class objects that can be used as functions, or keys. I still like the lisp s-exp better, but this is an interesting idea for Python too.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A sexp version of a bibtex entry]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry" />
    <id>http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry</id>
    <updated>2015-06-10T08:54:00Z</updated>
    <published>2015-06-10T08:54:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="lisp" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A sexp version of a bibtex entry]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry"><![CDATA[



<p>
Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">hallenbeck-2013-effec-o2</span>,
  <span style="color: #BA36A5;">author</span> =       "Hallenbeck, Alexander P. and Kitchin, John R.",
  <span style="color: #BA36A5;">title</span> =        {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  <span style="color: #BA36A5;">keywords</span> =     {RUA, orgmode},
  <span style="color: #BA36A5;">journal</span> =      "Industrial \&amp; Engineering Chemistry Research",
  <span style="color: #BA36A5;">pages</span> =        "10788-10794",
  <span style="color: #BA36A5;">year</span> =         2013,
  <span style="color: #BA36A5;">volume</span> =       {52},
  <span style="color: #BA36A5;">number</span> =       {31},
  <span style="color: #BA36A5;">doi</span> =          "<span style="color: #006DAF; text-decoration: underline;">10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">url</span> =          "<span style="color: #006DAF; text-decoration: underline;">http://pubs.acs.org/doi/abs/10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">eprint</span> =       "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
</pre>
</div>

<p>
Here is what that same data structure might look like as a sexp-based lisp data structure.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (year 2013)
         (number 31)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<p>
We can retrieve data from the sexp form pretty easily. Here we get the authors.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                      (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                      (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                      (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                      (pages <span style="color: #008000;">"10788-10794"</span>)
                      (year 2013)
                      (number 31)
                      (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                      (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                      (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>)))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R.
</pre>

<p>
That is simple enough you might just write a little function to streamline it like this, and return a formatted string.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-article-field</span> (article field)
  <span style="color: #036A07;">"Return value of FIELD in ARTICLE."</span>
  (cadr (assoc field (cddr article))))

(<span style="color: #0000FF;">let</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                     (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                     (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                     (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                     (pages <span style="color: #008000;">"10788-10794"</span>)
                     (year 2013)
                     (number 31)
                     (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                     (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                     (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
  (format <span style="color: #008000;">"%s, doi:%s (%s)"</span>
          (get-article-field art 'author)
          (get-article-field art 'doi)
          (get-article-field art 'year)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)
</pre>

<p>
You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">make-field</span> (field-name)
  <span style="color: #036A07;">"define a field that returns a string"</span>
  `(<span style="color: #0000FF;">defun</span> ,(intern field-name) (content)
     (format <span style="color: #008000;">"  %s = {%s}"</span> ,field-name content)))

(<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span> <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
  do (eval `(make-field ,field)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">article</span> (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
  (concat
   (format <span style="color: #008000;">"@article{%s,\n"</span> bibtex-key)
   (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
   <span style="color: #008000;">"\n}\n"</span>))

(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (number 31)
         (year 2013)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial &amp; Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
</pre>

<p>
Wow. We <i>executed</i> our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"  &lt;%s&gt;%s&lt;/%s&gt;"</span> ,field content ,field)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"&lt;article bibtex-key=\"%s\"&gt;\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">"\n"</span>)
                           <span style="color: #008000;">"\n&lt;/article&gt;"</span>)))
               )
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
&lt;article bibtex-key="hallenbeck-2013-effec-o2"&gt;
  &lt;author&gt;Hallenbeck, Alexander P. and Kitchin, John R.&lt;/author&gt;
  &lt;title&gt;Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent&lt;/title&gt;
  &lt;journal&gt;Industrial &amp; Engineering Chemistry Research&lt;/journal&gt;
  &lt;pages&gt;10788-10794&lt;/pages&gt;
  &lt;number&gt;31&lt;/number&gt;
  &lt;year&gt;2013&lt;/year&gt;
  &lt;doi&gt;10.1021/ie400582a&lt;/doi&gt;
  &lt;url&gt;http://pubs.acs.org/doi/abs/10.1021/ie400582a&lt;/url&gt;
  &lt;eprint&gt;http://pubs.acs.org/doi/pdf/10.1021/ie400582a&lt;/eprint&gt;
&lt;/article&gt;
</pre>

<p>
Prefer json? No problem, just reformat the functions!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"   \"%s\": \"%s\""</span> ,field content)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"{\"article\":\n  {\"bibtex-key\": \"%s\",\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
                           <span style="color: #008000;">"}\n}"</span>))))
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial &amp; Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
</pre>

<p>
Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc&#x2026; Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.
</p>

<p>
I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we <i>never</i> had to write a parser for the sexp notation. That <i>already exists as the lisp interpreter</i>. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/10/A-sexp-version-of-a-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed" />
    <id>http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed</id>
    <updated>2015-06-09T07:29:08Z</updated>
    <published>2015-06-09T07:29:08Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed"><![CDATA[



<p>
Sometimes it is useful to convert a DOI to another type of identifier. For example, in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/">post</a> we converted a DOI to a Scopus EID, and in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/">one</a> we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/">http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/</a> 
</p>

<p>
We will use the DOI tool. According to the documentation, we need to form a URL like this:
</p>

<p>
DOI: <a href="http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195">http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195</a> 
</p>

<p>
We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max)))))
xml)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">((pmcids
  ((status . <span style="color: #008000;">"ok"</span>))
  <span style="color: #008000;">"\n"</span>
  (request
   ((idtype . <span style="color: #008000;">"doi"</span>)
    (dois . <span style="color: #008000;">""</span>)
    (versions . <span style="color: #008000;">"yes"</span>)
    (showaiid . <span style="color: #008000;">"no"</span>))
   <span style="color: #008000;">"\n"</span>
   (echo nil <span style="color: #008000;">"tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195"</span>)
   <span style="color: #008000;">"\n"</span>)
  <span style="color: #008000;">"\n"</span>
  (record
   ((requested-id . <span style="color: #008000;">"10.1093/NAR/GKS1195"</span>)
    (pmcid . <span style="color: #008000;">"PMC3531190"</span>)
    (pmid . <span style="color: #008000;">"23193287"</span>)
    (doi . <span style="color: #008000;">"10.1093/nar/gks1195"</span>))
   (versions nil
             (version
              ((pmcid . <span style="color: #008000;">"PMC3531190.1"</span>)
               (current . <span style="color: #008000;">"true"</span>)))))
  <span style="color: #008000;">"\n"</span>))
</pre>
</div>

<p>
The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list <span style="color: #006FE0;">:doi</span> doi <span style="color: #006FE0;">:pmid</span> pmid <span style="color: #006FE0;">:pmcid</span> pmcid <span style="color: #006FE0;">:eid</span> (scopus-doi-to-eid doi) <span style="color: #006FE0;">:wos</span> (wos-doi-to-accession-number doi)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #006FE0;">:doi</span> <span style="color: #008000;">"10.1093/nar/gks1195"</span> <span style="color: #006FE0;">:pmid</span> <span style="color: #008000;">"23193287"</span> <span style="color: #006FE0;">:pmcid</span> <span style="color: #008000;">"PMC3531190"</span> <span style="color: #006FE0;">:eid</span> <span style="color: #008000;">"2-s2.0-80053651587"</span> <span style="color: #006FE0;">:wos</span> <span style="color: #008000;">"000312893300006"</span>)
</pre>
</div>

<p>
Well, there you have it, four new scientific document ids from one DOI. <i>Of course</i> we have defined org-mode links for each one of these:
</p>

<p>
<a href="http://dx.doi.org/10.1093/nar/gks1195">doi:10.1093/nar/gks1195</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/mid/23193287">pmid:23193287</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3531190">pmcid:PMC3531190</a>
</p>

<p>
<a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-80053651587&origin=resultslist">eid:2-s2.0-80053651587</a>
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000312893300006">wos:000312893300006</a>
</p>

<p>
I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI</id>
    <updated>2015-06-09T07:25:39Z</updated>
    <published>2015-06-08T11:23:33Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI"><![CDATA[


<p>
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.
</p>

<p>
In a previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/">post</a> we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j</a> is redirected to
<a href="http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44">http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44</a> . You can see the <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">wos:000225079300029</a> in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr (assoc <span style="color: #008000;">"KeyUT"</span> (url-parse-query-string (url-filename (url-generic-parse-url  <span style="color: #008000;">"http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&amp;SrcApp=PARTNER_APP&amp;SrcAuth=LinksAMR&amp;KeyUT=WOS:000225079300029&amp;DestLinkType=FullRecord&amp;DestApp=ALL_WOS&amp;UsrCustomerID=8703b88d69db6b417a9c0dc510538f44"</span>)))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><a href="000225079300029">000225079300029</a></td>
</tr>
</tbody>
</table>

<p>
It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-redirect*</span> nil)
(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-waiting*</span> nil)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-get-wos-redirect</span> (url)
  <span style="color: #036A07;">"Return final redirect url for open-url"</span>
  (<span style="color: #0000FF;">setq</span> *wos-waiting* t)
  (url-retrieve
   url
   (<span style="color: #0000FF;">lambda</span> (status)
     (<span style="color: #0000FF;">setq</span> *wos-redirect* (car (last status)))
     (<span style="color: #0000FF;">setq</span> *wos-waiting* nil)))
  (<span style="color: #0000FF;">while</span> *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-doi-to-accession-number</span> (doi)
  <span style="color: #036A07;">"Return a WOS Accession number for a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((open-url (concat <span style="color: #008000;">"http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&amp;rft_id=info:doi/"</span> doi))
         (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
                 (assoc
                  <span style="color: #008000;">"KeyUT"</span>
                  (url-parse-query-string
                   (url-filename
                    (url-generic-parse-url redirect)))))
    4)))

(concat <span style="color: #008000;">"wos:"</span> (wos-doi-to-accession-number <span style="color: #008000;">"10.1021/jp047349j"</span>))
</pre>
</div>

<pre class="example">
wos:000225079300029
</pre>

<p>
I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:
</p>

<p>
<a href="http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029">http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029</a> 
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029</a> 
</p>

<p>
That might turn out to be handy at some point.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a Scopus EID from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI</id>
    <updated>2015-06-07T16:54:38Z</updated>
    <published>2015-06-07T16:29:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a Scopus EID from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI"><![CDATA[


<p>
<a href="http://www.scopus.com">Scopus</a> is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: <a href="http://dev.elsevier.com/myapikey.html">http://dev.elsevier.com/myapikey.html</a> and set <b>scopus-api-key</b> in Emacs to use this code.
</p>

<p>
Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:
</p>

<p>
Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial &amp; Engineering Chemistry Research, 52:10788-10794 (2013)
</p>

<p>
With the EID, we can construct a URL to the Scopus document page:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/record/display.url?eid=%s&amp;origin=resultslist"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&amp;origin=resultslist
</pre>

<p>
We can construct a URL to citing documents:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=%s&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=2-s2.0-84881394200&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage
</pre>

<p>
And there are three types of related document urls we can create: by author, keyword or references.
</p>

<p>
By authors:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=aut&amp;zone=relatedDocuments"</span>)
            eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments</a> 
</p>

<p>
By keywords:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=key&amp;zone=relatedDocuments"</span>)
          eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments</a> 
</p>

<p>
And by references:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat  <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url?"</span>
                   <span style="color: #008000;">"eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                   <span style="color: #008000;">"&amp;method=ref&amp;zone=relatedDocuments"</span>)
           eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments</a> 
</p>

<p>
We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, <i>not</i> the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.
</p>

<p>
The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.
</p>

<p>
I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (json-object-type 'plist)
       (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                    (json-read-from-string
                     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid-json</span> (doi)
  <span style="color: #036A07;">"Return a parsed xml from the Scopus article retrieval api for DOI.</span>
<span style="color: #036A07;">This does not always seem to work for the most recent DOIs."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (json-object-type 'plist)
         (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                      (json-read-from-string
                       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>)))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<p>
XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
              (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
Now we wrap this in a function for reusability.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid</span> (doi)
  <span style="color: #036A07;">"Get a Scopus eid from a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max))))
         (results (car xml))
         (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
This code is wrapped up in <a href="https://github.com/jkitchin/org-ref/blob/master/scopus.el">org-ref/scopus.el</a> . It provides a new org-mode eid link, e.g. <a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist">eid:2-s2.0-84881394200</a> which is functional and provides access to the citing and related article Scopus pages for that eid.
</p>

<p>
There are also new links and functions for a <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=b&sdt=b&sl=35&s=TITLE-ABS-KEY%28alloy%20Au%20segregation%29&origin=searchbasic">alloy Au segregation</a> and <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=a&sdt=a&sl=48&s=auth%28kitchin%29%20and%20title%28segregation%29&origin=searchadvanced">auth(kitchin) and title(segregation)</a>.
</p>

<p>
Let's not forget the <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a> link to Scopus Author pages.
</p>

<p>
Now you can use org-mode for reproducible scientific literature searching in Scopus!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/07/Getting-a-Scopus-EID-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
</feed>
