<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2014-05-12T22:06:49Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Autogenerating functions in emacs-lisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/05/12/Autogenerating-functions-in-emacs-lisp" />
    <id>http://jkitchin.github.io/blog/2014/05/12/Autogenerating-functions-in-emacs-lisp</id>
    <updated>2014-05-12T18:05:54Z</updated>
    <published>2014-05-12T18:05:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs-lisp" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Autogenerating functions in emacs-lisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/05/12/Autogenerating-functions-in-emacs-lisp"><![CDATA[



<p>
I have a need to generate a lot of similar functions, and I do not want to cut and paste the code. I want to generate the functions with code. This seems to be what macros are for in emacs lisp. 
</p>

<p>
As a prototype example, we will make functions that raise a number to a power. We want functions like power-3 and power-4 that raise numbers to the third and fourth powers. We will define functions like this for the numbers 0-9.
</p>

<p>
Here we define the macro. i do not want to get into the nitty gritty details of macro definitions here.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(make-power-n 4)

(power-4 4)
</pre>
</div>

<pre class="example">
256
</pre>

<p>
Now we use the macro and mapcar on it onto a list of numbers. We have to eval the macro in the mapcar lambda function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(mapcar (lambda (x) (eval `(make-power-n ,x))) '(0 1 2 3 4 5 6 7 8 9))
 
;; example of a few functions
(list (power-0 3) (power-1 3) (power-2 3))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">3</td>
<td class="right">9</td>
</tr>
</tbody>
</table>

<p>
It works! We created 10 functions in a little bit of code. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/12/Autogenerating-functions-in-emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding missing citation entries in an org-file]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/29/Finding-missing-citation-entries-in-an-org-file" />
    <id>http://jkitchin.github.io/blog/2014/04/29/Finding-missing-citation-entries-in-an-org-file</id>
    <updated>2014-04-29T10:37:51Z</updated>
    <published>2014-04-29T10:37:51Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtes" />
    <summary type="html"><![CDATA[Finding missing citation entries in an org-file]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/29/Finding-missing-citation-entries-in-an-org-file"><![CDATA[



<p>
Today we consider how to find citations in a document that have no corresponding entries in a bibtex file. There are a couple of pieces to this which we work out in stages below. First, we specify the bibtex file using a bibliography link defined in jorg-bib.el. 
</p>


<p>

</p>

<p>
jorg-bib provides a function that gives us the relevant bibliography files found in this file.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cite-find-bibliography)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">bib1.bib</td>
<td class="left">bib2.bib</td>
</tr>
</tbody>
</table>

<p>
We can get a list of keys in these files 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((bibtex-files (cite-find-bibliography)))
(bibtex-global-key-alist))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">(adams-1993-orien-imagin . t)</td>
<td class="left">(aarik-1997-effec-tio2 . t)</td>
<td class="left">(aruga-1985-struc-iron . t)</td>
</tr>
</tbody>
</table>


<p>
Now, here are some citations that we want to include in this document.
</p>

<p>
<pre>cite:aruga-1985-struc-iron,aarik-1997-effec-tio2</pre> 
</p>

<p>
Here is a citation that is not in the bibtex file <pre>cite:kitchin-2016-nobel-lecture</pre> 
</p>


<p>
To find out if any of these are missing, we need a list of the citation keys in this document. We first get all the content from the cite links.  We parse the buffer, and for each cite link, we get the path of the link, which contains our keys.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((parsetree (org-element-parse-buffer)))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (plist-get plist ':path))))))
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">aruga-1985-struc-iron,aarik-1997-effec-tio2</td>
<td class="left">kitchin-2016-nobel-lecture</td>
</tr>
</tbody>
</table>

<p>
That is almost what we need, but we need to separate the keys that are joined by commas. That function already exists in jorg-bib as cite-split-keys. We need to make a slight variation to get a list of all the entries, since the cite-split-keys returns a list of entries for each link. Here is on approach to that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((parsetree (org-element-parse-buffer))
      (results '()))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))
	(when (equal (plist-get plist ':type) "cite")
	  (setq results (append results (cite-split-keys (plist-get plist ':path))))))))
results)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">aruga-1985-struc-iron</td>
<td class="left">aarik-1997-effec-tio2</td>
<td class="left">kitchin-2016-nobel-lecture</td>
</tr>
</tbody>
</table>

<p>
Ok, now we just need to check each entry of that list against the list of entries in the bibtex files, and highlight any that are not good. We use an index function below to tell us if an element is in a list. This index function works for strings. We use the strange remove-if-not function, which requires something like triple negative logic to get the list of keys that are not in the bibtex files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (parsetree (org-element-parse-buffer))
       (cited-keys))
  (org-element-map parsetree 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (setq cited-keys (append cited-keys (cite-split-keys (plist-get plist ':path))))))))

(princ (remove-if-not (lambda (arg) (not (index arg bibtex-keys))) cited-keys))
)
</pre>
</div>

<pre class="example">
(kitchin-2016-nobel-lecture)
</pre>


<p>
The only improvement from here would be if this generated a temporary buffer with clickable links to find that bad entry! Let us take a different approach here, and print this to a temporary buffer of clickable links. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(require 'cl)

(defun index (substring list)
  "return the index of string in a list of strings"
  (let ((i 0)
	(found nil))
    (dolist (arg list i)
      (if (string-match substring arg)
	  (progn 
	    (setq found t)
	    (return i)))
      (setq i (+ i 1)))
    ;; return counter if found, otherwise return nil
    (if found i nil)))

;; generate the list of bibtex-keys and cited keys
(let* ((bibtex-files (cite-find-bibliography))
       (bibtex-keys (mapcar (lambda (x) (car x)) (bibtex-global-key-alist)))
       (bad-citations '()))

  (org-element-map (org-element-parse-buffer) 'link
    (lambda (link)       
      (let ((plist (nth 1 link)))			     
	(when (equal (plist-get plist ':type) "cite")
	  (dolist (key (cite-split-keys (plist-get plist ':path)) )
	    (when (not (index key bibtex-keys))
	      (setq bad-citations (append bad-citations
			    `(,(format "%s [[elisp:(progn (find-file \"%s\")(goto-char %s))][not found here]]\n"
		      key (buffer-file-name)(plist-get plist ':begin)))))
			    ))))))

(mapconcat 'identity bad-citations ""))
</pre>
</div>

<p>
kitchin-2016-nobel-lecture <pre>elisp:(progn (find-file "/home-research/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/blog.org")(goto-char 1052))</pre> 
</p>

<p>
That is likely to come in handy. I have put a variation of this code in jorb-bib, in the function called jorg-bib-find-bad-citations.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/29/Finding-missing-citation-entries-in-an-org-file.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A popup menu for citation links in org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode</id>
    <updated>2014-04-28T10:13:17Z</updated>
    <published>2014-04-28T10:13:17Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A popup menu for citation links in org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode"><![CDATA[



<p>
I have been exploring ways to get more information out of links in org-mode. I have considered <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/">popups</a> , and <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/">right-clicking</a> . Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.
</p>

<p>
Here is the function. We use <a href="https://github.com/auto-complete/popup-el">https://github.com/auto-complete/popup-el</a> , and some code from <a href="https://github.com/jkitchin/jmax/blob/master/jorg-bib.el">https://github.com/jkitchin/jmax/blob/master/jorg-bib.el</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string) 
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu* 
	    (list (popup-make-item (if 
				       (progn
					 (let ((cb (current-buffer)) result)					
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)					  
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item 
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")       
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")   
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))
       
      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")   
       (find-file bibfile)
       (bibtex-search-entry key)       
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))	
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)  
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(&lt;cite&gt;%s&lt;/cite&gt;)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
</pre>
</div>


<p>
<pre>cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2</pre> 
</p>


<p>

</p>



<p>
Here you can see an example of a menu where I have the PDF:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-1.png"> 
</p>
</div>

<p>
Here is an example menu of a key with no entry:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-2.png"> 
</p>

<p>
And, and entry with no PDF:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-3.png"> 
</p>

<p>
Here is the simple citation:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-4.png"> 
</p>
</div>

<p>
And a reference from the other bibliography:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-5.png"> 
</p>
</div>

<p>
Not bad! I will probably replace the cite link in jorg-bib with something like this.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/28/A-popup-menu-for-citation-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A better insert citation function for org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode</id>
    <updated>2014-04-27T14:40:45Z</updated>
    <published>2014-04-27T14:40:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A better insert citation function for org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode"><![CDATA[



<p>
I have setup a reftex citation format that inserts a cite link using reftex like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
</pre>
</div>

<p>
I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
</pre>
</div>

<p>
That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    (if (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
</pre>
</div>

<p>
That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/27/A-better-insert-citation-function-for-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Putting link references to lines of code in a source block]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block" />
    <id>http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block</id>
    <updated>2014-04-22T20:59:30Z</updated>
    <published>2014-04-22T20:59:30Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Putting link references to lines of code in a source block]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block"><![CDATA[


<p>
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
<a href="http://orgmode.org/manual/Literal-examples.html#Literal-examples">http://orgmode.org/manual/Literal-examples.html#Literal-examples</a> 
</p>

<p>
The following code block has some references in it that we can refer to later:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp -n -r
<span id="coderef-sc" class="coderef-off">(save-excursion (sc)</span>
<span id="coderef-jump" class="coderef-off">  (goto-char (point-min))) (jump)</span>
#+END_SRC
</pre>


<div class="org-src-container">

<pre class="src src-emacs-lisp"><span id="coderef-sc" class="coderef-off"><span class="linenr">1: </span>(<span style="color: #8b0000;">save-excursion</span></span>
<span id="coderef-jump" class="coderef-off"><span class="linenr">2: </span>  (goto-char (point-min)))</span>
</pre>
</div>


<p>
In line <pre>(sc)</pre> we remember the current position. <pre>(jump)</pre> jumps to point-min.
</p>

<p>
To make this work with python we have to make a slight change to the reference format in the header.
</p>

<pre class="example">
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
<span id="coderef-for" class="coderef-off">for i in range(5):                # (for)</span>
<span id="coderef-body" class="coderef-off">    print i                       # (body)</span>
#+END_SRC
</pre>

<div class="org-src-container">

<pre class="src src-python"><span id="coderef-for" class="coderef-off"><span class="linenr">1: </span><span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">range</span>(5):</span>
<span id="coderef-body" class="coderef-off"><span class="linenr">2: </span>    <span style="color: #8b0000;">print</span> i</span>
</pre>
</div>

<pre class="example">
0
1
2
3
4
</pre>


<p>
In line <pre>(for)</pre> we initialize the loop, and in line <pre>(body)</pre> we run it.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[The sqlite variation of ase.db]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/17/The-sqlite-variation-of-ase-db" />
    <id>http://jkitchin.github.io/blog/2014/04/17/The-sqlite-variation-of-ase-db</id>
    <updated>2014-04-17T15:51:20Z</updated>
    <published>2014-04-17T15:51:20Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="vasp" />
    <category scheme="http://jkitchin.github.io/blog" term="ase" />
    <summary type="html"><![CDATA[The sqlite variation of ase.db]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/17/The-sqlite-variation-of-ase-db"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Exploring the database with sqlite</a></li>
<li><a href="#sec-2">2. The python interface to the ase-db</a></li>
<li><a href="#sec-3">3. Summary</a></li>
</ul>
</div>
</div>

<p>
In a recent <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/26/writing-VASP-calculations-to-ase-db-formats/">post</a> we explored writing VASP calculations to an ase database in json format. Today we explore a similar idea, but writing to sqlite. I have incorporated the code from the previous post into a utils module in jasp.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> jasp.utils <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">print</span> get_jasp_dirs(<span style="color: #228b22;">'/home-research/jkitchin/research/rutile-atat'</span>)
</pre>
</div>

<pre class="example">
['/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/0', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/1', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/10', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/11', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/12', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/13', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/14', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/15', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/16', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/17', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/2', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/3', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/4', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/5', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/59', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/6', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/66', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/7', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/73', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/74', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/78', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/8', '/home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/9']
</pre>

<p>
That new function <code>get_jasp_dirs</code> just returns a list of directories that are known finished VASP calculations. We will use a functional style of programming to map a function onto each directory in that list.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *
<span style="color: #8b0000;">from</span> jasp.utils <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">from</span> ase.db <span style="color: #8b0000;">import</span> connect

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">I want a sqlite extension, so we have to specify db as the type, which means sqlite</span>
<span style="color: #8b008b;">c</span> = connect(<span style="color: #228b22;">'vaspdb.sqlite'</span>, <span style="color: #cd0000;">type</span>=<span style="color: #228b22;">'db'</span>)

<span style="color: #8b008b;">dirs</span> = get_jasp_dirs(<span style="color: #228b22;">'/home-research/jkitchin/research/rutile-atat'</span>)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">write</span>(directory):
    <span style="color: #8b0000;">with</span> jasp(directory) <span style="color: #8b0000;">as</span> calc:
        <span style="color: #8b008b;">atoms</span> = calc.get_atoms()
        <span style="color: #8b008b;">calc.results</span>[<span style="color: #228b22;">'energy'</span>] = atoms.get_potential_energy()
        <span style="color: #8b008b;">calc.results</span>[<span style="color: #228b22;">'forces'</span>] = atoms.get_forces()
    <span style="color: #8b0000;">print</span> c.write(atoms), directory

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">functional approach to writing</span>
<span style="color: #cd0000;">map</span>(write, dirs)
</pre>
</div>

<pre class="example">
1 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/0
2 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/1
3 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/10
4 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/11
5 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/12
6 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/13
7 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/14
8 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/15
9 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/16
10 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/17
11 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/2
12 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/3
13 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/4
14 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/5
15 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/59
16 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/6
17 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/66
18 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/7
19 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/73
20 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/74
21 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/78
22 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/8
23 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/9
</pre>

<p>
Now, we have a sqlite database. Let us explore that a bit before using the python interface again. 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Exploring the database with sqlite</h2>
<div class="outline-text-2" id="text-1">
<p>
First we see the tables.
</p>

<div class="org-src-container">

<pre class="src src-sqlite">.tables
</pre>
</div>

<pre class="example">
keywords           species            text_key_values  
number_key_values  systems          
</pre>

<p>
We can see details of the tables like this.
</p>
<div class="org-src-container">

<pre class="src src-sqlite">select * from sqlite_master;
</pre>
</div>

<pre class="example">
table|systems|systems|2|CREATE TABLE systems (
    id integer primary key autoincrement,
    unique_id text unique,
    ctime real,
    mtime real,
    user text,
    numbers blob,
    positions blob,
    cell blob,
    pbc integer,
    initial_magmoms blob,
    initial_charges blob,
    masses blob,
    tags blob,
    momenta blob,
    constraints text,
    calculator text,
    calculator_parameters text,
    energy real,
    free_energy real,
    forces blob,
    stress blob,
    dipole blob,
    magmoms blob,
    magmom blob,
    charges blob,
    data text)
index|sqlite_autoindex_systems_1|systems|3|
table|sqlite_sequence|sqlite_sequence|4|CREATE TABLE sqlite_sequence(name,seq)
table|species|species|5|CREATE TABLE species (
    Z integer,
    n integer,
    id text,
    foreign key (id) references systems(id))
table|keywords|keywords|6|CREATE TABLE keywords (
    keyword text,
    id text,
    foreign key (id) references systems(id))
table|text_key_values|text_key_values|8|CREATE TABLE text_key_values (
    key text,
    value text,
    id text,
    foreign key (id) references systems(id))
table|number_key_values|number_key_values|10|CREATE TABLE number_key_values (
    key text,
    value real,
    id text,
    foreign key (id) references systems (id))
index|unique_id_index|systems|11|CREATE INDEX unique_id_index on systems(unique_id)
index|ctime_index|systems|12|CREATE INDEX ctime_index on systems(ctime)
index|user_index|systems|13|CREATE INDEX user_index on systems(user)
index|calculator_index|systems|14|CREATE INDEX calculator_index on systems(calculator)
index|species_index|species|15|CREATE INDEX species_index on species(Z)
index|keyword_index|keywords|16|CREATE INDEX keyword_index on keywords(keyword)
index|text_index|text_key_values|17|CREATE INDEX text_index on text_key_values(key)
index|number_index|number_key_values|18|CREATE INDEX number_index on number_key_values(key)
</pre>

<p>
Let us see one entry from the systems table.
</p>

<div class="org-src-container">

<pre class="src src-sqlite">select * from systems where id=1;
</pre>
</div>

<pre class="example">
id|unique_id|ctime|mtime|user|numbers|positions|cell|pbc|initial_magmoms|initial_charges|masses|tags|momenta|constraints|calculator|calculator_parameters|energy|free_energy|forces|stress|dipole|magmoms|magmom|charges|data
1|3ed58bb16897177be0ed56400c90b6f4|14.2361260035084|14.2361260035084|jkitchin|@|7|||||||vasp|{"incar": {"doc": "INCAR parameters", "nbands": 43, "sigma": 0.1, "prec": "high", "encut": 350.0}, "doc": "JSON representation of a VASP calculation.\n\nenergy is in eV\nforces are in eV/\\AA\nstress is in GPa (sxx, syy, szz,  syz, sxz, sxy)\nmagnetic moments are in Bohr-magneton\nThe density of states is reported with E_f at 0 eV.\nVolume is reported in \\AA^3\nCoordinates and cell parameters are reported in \\AA\n\nIf atom-projected dos are included they are in the form:\n{ados:{energy:data, {atom index: {orbital : dos}}}\n", "potcar": [["Ru", "potpaw_PBE/Ru/POTCAR", "dee616f2a1e7a5430bb588f1710bfea3001d54ea"], ["O", "potpaw_PBE/O/POTCAR", "9a0489b46120b0cad515d935f44b5fbe3a3b1dfa"]], "input": {"kpts": [6, 6, 10], "kpts_nintersections": null, "reciprocal": false, "setups": {}, "xc": "PBE", "txt": "-", "gamma": true}, "atoms": {"cell": [[4.526933343669885, 0.0, 0.0], [0.0, 4.526933343669885, 0.0], [0.0, 0.0, 3.095292162609941]], "symbols": ["O", "O", "O", "O", "Ru", "Ru"], "tags": [0, 0, 0, 0, 0, 0], "pbc": [true, true, true], "positions": [[1.3820537023391204, 1.3820537023391204, 0.0], [3.1448796413307645, 3.1448796413307645, 0.0], [3.645520374174063, 0.8814129694958222, 1.5476460813049704], [0.8814129694958222, 3.645520374174063, 1.5476460813049704], [0.0, 0.0, 0.0], [2.2634666718349425, 2.2634666718349425, 1.5476460813049704]]}, "data": {"stress": [0.0884313161515024, 0.0884313161515024, 0.06042693164307849, -0.0, -0.0, -0.0], "doc": "Data from the output of the calculation", "volume": 63.432210741434858, "total_energy": -44.251496, "forces": [[-0.023609, -0.023609, 0.0], [0.023609, 0.023609, 0.0], [-0.023609, 0.023609, 0.0], [0.023609, -0.023609, 0.0], [0.0, 0.0, 0.0], [0.0, 0.0, 0.0]], "fermi_level": 5.0374}, "metadata": {"date.created": 1395241327.477995, "uuid": "7081ee4a-af77-11e3-a6e6-003048f5e49e", "date.created.ascii": "Wed Mar 19 11:02:07 2014", "user.username": "jkitchin", "atoms.resort": [2, 3, 4, 5, 0, 1], "user.email": "jkitchin@andrew.cmu.edu", "user.fullname": "John Kitchin", "O.potential.git_hash": "9a0489b46120b0cad515d935f44b5fbe3a3b1dfa", "atoms.tags": [0, 0, 0, 0, 0, 0], "O.potential.path": "potpaw_PBE/O/POTCAR", "Ru.potential.path": "potpaw_PBE/Ru/POTCAR", "Ru.potential.git_hash": "dee616f2a1e7a5430bb588f1710bfea3001d54ea"}}|-44.251496||+|||||{"keywords": [], "data": {}, "key_value_pairs": {}}
</pre>

<p>
How about the species table:
</p>
<div class="org-src-container">

<pre class="src src-sqlite">select * from species where id=1;
</pre>
</div>

<pre class="example">
Z|n|id
8|4|1
44|2|1
</pre>

<p>
Now we can find a calculation with two Ru and 4 oxygen atoms, but it takes some sqlite knowledge.
</p>

<div class="org-src-container">

<pre class="src src-sqlite">select sp1.id,sys.id 
from species as sp1 
inner join
species as sp2
on sp1.id = sp2.id
inner join systems as sys
on sp1.id=sys.id
where (sp1.Z=44 and sp1.n=2) and (sp2.Z=8 and sp2.n=4);
</pre>
</div>

<pre class="example">
id|id
1|1
</pre>

<p>
That is an expected result. Let us get back to the python interface.
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> The python interface to the ase-db</h2>
<div class="outline-text-2" id="text-2">
<p>
Let us search for entries containing 2 Ru atoms and 4 O atoms again. We know this should be the first entry from before. Note how much simpler this syntax is.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> ase.db <span style="color: #8b0000;">import</span> connect

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">I want a sqlite extension, so we have to specify db as the type, which means sqlite</span>
<span style="color: #8b008b;">c</span> = connect(<span style="color: #228b22;">'vaspdb.sqlite'</span>, <span style="color: #cd0000;">type</span>=<span style="color: #228b22;">'db'</span>)

<span style="color: #8b0000;">for</span> row <span style="color: #8b0000;">in</span> c.select(<span style="color: #228b22;">'Ru=2,O=4'</span>): <span style="color: #8b0000;">print</span> row
</pre>
</div>

<pre class="example">
{'ctime': 14.236126003508412, 'energy': -44.251496, 'tags': array([0, 0, 0, 0, 0, 0], dtype=int32), 'positions': array([[ 1.3820537 ,  1.3820537 ,  0.        ],
       [ 3.14487964,  3.14487964,  0.        ],
       [ 3.64552037,  0.88141297,  1.54764608],
       [ 0.88141297,  3.64552037,  1.54764608],
       [ 0.        ,  0.        ,  0.        ],
       [ 2.26346667,  2.26346667,  1.54764608]]), 'calculator': u'vasp', 'calculator_parameters': {u'incar': {u'doc': u'INCAR parameters', u'prec': u'high', u'nbands': 43, u'sigma': 0.1, u'encut': 350.0}, u'doc': u'JSON representation of a VASP calculation.\n\nenergy is in eV\nforces are in eV/\\AA\nstress is in GPa (sxx, syy, szz,  syz, sxz, sxy)\nmagnetic moments are in Bohr-magneton\nThe density of states is reported with E_f at 0 eV.\nVolume is reported in \\AA^3\nCoordinates and cell parameters are reported in \\AA\n\nIf atom-projected dos are included they are in the form:\n{ados:{energy:data, {atom index: {orbital : dos}}}\n', u'potcar': [[u'Ru', u'potpaw_PBE/Ru/POTCAR', u'dee616f2a1e7a5430bb588f1710bfea3001d54ea'], [u'O', u'potpaw_PBE/O/POTCAR', u'9a0489b46120b0cad515d935f44b5fbe3a3b1dfa']], u'input': {u'kpts': array([ 6,  6, 10]), u'reciprocal': False, u'xc': u'PBE', u'kpts_nintersections': None, u'setups': {}, u'txt': u'-', u'gamma': True}, u'atoms': {u'cell': array([[ 4.52693334,  0.        ,  0.        ],
       [ 0.        ,  4.52693334,  0.        ],
       [ 0.        ,  0.        ,  3.09529216]]), u'symbols': [u'O', u'O', u'O', u'O', u'Ru', u'Ru'], u'tags': array([0, 0, 0, 0, 0, 0]), u'pbc': array([ True,  True,  True], dtype=bool), u'positions': array([[ 1.3820537 ,  1.3820537 ,  0.        ],
       [ 3.14487964,  3.14487964,  0.        ],
       [ 3.64552037,  0.88141297,  1.54764608],
       [ 0.88141297,  3.64552037,  1.54764608],
       [ 0.        ,  0.        ,  0.        ],
       [ 2.26346667,  2.26346667,  1.54764608]])}, u'data': {u'stress': array([ 0.08843132,  0.08843132,  0.06042693, -0.        , -0.        , -0.        ]), u'doc': u'Data from the output of the calculation', u'volume': 63.43221074143486, u'total_energy': -44.251496, u'forces': array([[-0.023609, -0.023609,  0.      ],
       [ 0.023609,  0.023609,  0.      ],
       [-0.023609,  0.023609,  0.      ],
       [ 0.023609, -0.023609,  0.      ],
       [ 0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      ]]), u'fermi_level': 5.0374}, u'metadata': {u'date.created': 1395241327.477995, u'uuid': u'7081ee4a-af77-11e3-a6e6-003048f5e49e', u'date.created.ascii': u'Wed Mar 19 11:02:07 2014', u'user.username': u'jkitchin', u'atoms.resort': array([2, 3, 4, 5, 0, 1]), u'user.email': u'jkitchin@andrew.cmu.edu', u'user.fullname': u'John Kitchin', u'O.potential.git_hash': u'9a0489b46120b0cad515d935f44b5fbe3a3b1dfa', u'atoms.tags': array([0, 0, 0, 0, 0, 0]), u'O.potential.path': u'potpaw_PBE/O/POTCAR', u'Ru.potential.path': u'potpaw_PBE/Ru/POTCAR', u'Ru.potential.git_hash': u'dee616f2a1e7a5430bb588f1710bfea3001d54ea'}}, 'cell': array([[ 4.52693334,  0.        ,  0.        ],
       [ 0.        ,  4.52693334,  0.        ],
       [ 0.        ,  0.        ,  3.09529216]]), 'numbers': array([ 8,  8,  8,  8, 44, 44], dtype=int32), 'forces': array([[-0.023609, -0.023609,  0.      ],
       [ 0.023609,  0.023609,  0.      ],
       [-0.023609,  0.023609,  0.      ],
       [ 0.023609, -0.023609,  0.      ],
       [ 0.      ,  0.      ,  0.      ],
       [ 0.      ,  0.      ,  0.      ]]), 'mtime': 14.236126003508412, 'pbc': array([ True,  True,  True], dtype=bool), 'id': 1, 'unique_id': u'3ed58bb16897177be0ed56400c90b6f4', 'user': u'jkitchin'}
</pre>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
It is not yet obvious what the advantage of the sqlite format over the json format is. One is that you can use SQL to create queries, which is probably more powerful than the ase-db format. It is a little mysterious how the ase-db searches the json format to me.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/17/The-sqlite-variation-of-ase.db.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>
]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding the maximum power of a photovoltaic device.]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device" />
    <id>http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device</id>
    <updated>2014-04-15T20:38:10Z</updated>
    <published>2014-04-15T20:38:10Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="optimization" />
    <summary type="html"><![CDATA[Finding the maximum power of a photovoltaic device.]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device"><![CDATA[



<p>
A photovoltaic device is characterized by a current-voltage relationship. Let us say, for argument's sake, that the relationship is known and defined by
</p>

<p>
\(i = 0.5 - 0.5 * V^2\)
</p>

<p>
The voltage is highest when the current is equal to zero, but of course then you get no power. The current is highest when the voltage is zero, i.e. short-circuited, but there is again no power. We seek the highest power condition, which is to find the maximum of \(i V\). This is a constrained optimization. We solve it by creating an objective function that returns the negative of (\i V\), and then find the minimum.
</p>

<p>
First, let us examine the i-V relationship.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">V</span> = np.linspace(0, 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">i</span>(V):
    <span style="color: #8b0000;">return</span> 0.5 - 0.5 * V**2
plt.plot(V, i(V))
plt.savefig(<span style="color: #228b22;">'images/iV.png'</span>)
</pre>
</div>


<div class="figure">
<p><img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./iV.png"> 
</p>
</div>


<p>
Now, let us be sure there is a maximum in power.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">V</span> = np.linspace(0, 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">i</span>(V):
    <span style="color: #8b0000;">return</span> 0.5 - 0.5 * V**2
plt.plot(V, i(V) * V)
plt.savefig(<span style="color: #228b22;">'images/P1.png'</span>)
</pre>
</div>


<div class="figure">
<p><img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./P1.png"> 
</p>
</div>

<p>
You can see in fact there is a maximum, near V=0.6. We could solve this problem analytically by taking the appropriate derivative and solving it for zero. That still might require solving a nonlinear problem though. We will directly setup and solve the constrained optimization. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fmin_slsqp
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(X):
    <span style="color: #8b008b;">i</span>, <span style="color: #8b008b;">V</span> = X
    <span style="color: #8b0000;">return</span> - i * V

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">eqc</span>(X):
    <span style="color: #228b22;">'equality constraint'</span>
    <span style="color: #8b008b;">i</span>, <span style="color: #8b008b;">V</span> = X
    <span style="color: #8b0000;">return</span> (0.5 - 0.5 * V**2) - i

<span style="color: #8b008b;">X0</span> = [0.2, 0.6]
<span style="color: #8b008b;">X</span> = fmin_slsqp(objective, X0, eqcons=[eqc])

<span style="color: #8b008b;">imax</span>, <span style="color: #8b008b;">Vmax</span> = X


<span style="color: #8b008b;">V</span> = np.linspace(0, 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">i</span>(V):
    <span style="color: #8b0000;">return</span> 0.5 - 0.5 * V**2
plt.plot(V, i(V), Vmax, imax, <span style="color: #228b22;">'ro'</span>)
plt.savefig(<span style="color: #228b22;">'images/P2.png'</span>)
</pre>
</div>

<pre class="example">
Optimization terminated successfully.    (Exit mode 0)
            Current function value: -0.192450127337
            Iterations: 5
            Function evaluations: 20
            Gradient evaluations: 5
</pre>


<div class="figure">
<p><img src="/media/2014-04-15-Finding-the-maximum-power-of-a-photovoltaic-device./P2.png"> 
</p>
</div>

<p>
You can see the maximum power is approximately 0.2 (unspecified units), at the conditions indicated by the red dot in the figure above.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/15/Finding-the-maximum-power-of-a-photovoltaic-device..org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Popup tips on bibtex links in org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode</id>
    <updated>2014-04-12T14:15:45Z</updated>
    <published>2014-04-12T14:15:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="uncategorized" />
    <summary type="html"><![CDATA[Popup tips on bibtex links in org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode"><![CDATA[



<p>
I want to explore using popup tips to display richer information about org-mode links. The idea is to have something like a tooltip that displays the bibtex entry when you hover over it, or click on it. 
</p>

<p>
<a href="https://github.com/auto-complete/popup-el/blob/master/popup.el">https://github.com/auto-complete/popup-el/blob/master/popup.el</a> 
</p>

<p>
Here is a canonical example of a popup.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(popup-tip <span style="color: #228b22;">"Hello, World!"</span>)
</pre>
</div>

<pre class="example">
t
</pre>


<div class="figure">
<p><img src="/media/2014-04-12-Popup-tips-on-bibtex-links-in-org-mode/hello-world-popup.png"> 
</p>
</div>

<p>
All I need to do is figure out a simple way to get the bibtex entry as a string, and pop it up when a link is clicked on.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 <span style="color: #228b22;">"test"</span>
 <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">this function is run when you click</span>
 (<span style="color: #8b0000;">lambda</span> (link-string) 
   (popup-tip link-string))
 <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">formatting</span>
(<span style="color: #8b0000;">lambda</span> (keyword desc format)
   (<span style="color: #8b0000;">cond</span>
    ((eq format 'html) (format <span style="color: #228b22;">"&lt;pre&gt;%s:%s&lt;/pre&gt;"</span> keyword desc)))))
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">(link-string)</td>
<td class="left">(popup-tip link-string)</td>
</tr>

<tr>
<td class="left">lambda</td>
<td class="left">(keyword desc format)</td>
<td class="left">(cond ((eq format (quote html)) (format &lt;pre&gt;%s:%s&lt;/pre&gt; keyword desc)))</td>
</tr>
</tbody>
</table>

<p>
Now we give it a try.   <pre>test:show-me-the-popup</pre> 
</p>


<div class="figure">
<p><img src="/media/2014-04-12-Popup-tips-on-bibtex-links-in-org-mode/test-link-popup.png"> 
</p>
</div>

<p>
That looks good.
</p>

<p>
Ok, the penultimate step will be to lookup a bibtex entry, and show the entry in a popup. We will hardcode the path to the bibtex file. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 <span style="color: #228b22;">"test"</span>
 <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">this function is run when you click</span>
 (<span style="color: #8b0000;">lambda</span> (bibtex-key)
   (<span style="color: #8b0000;">let</span> ((entry (<span style="color: #8b0000;">with-temp-buffer</span>
                  (insert-file-contents <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
                  (goto-char (point-min))
                  (re-search-forward bibtex-key)
                  (bibtex-narrow-to-entry)
                  (buffer-string))))
     (popup-tip entry))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">(bibtex-key)</td>
<td class="left">(let ((cb (current-buffer)) (entry (with-temp-buffer (insert-file-contents ~/Dropbox/bibliography/references.bib) (goto-char (point-min)) (re-search-forward bibtex-key) (bibtex-narrow-to-entry) (buffer-string)))) (popup-tip entry))</td>
</tr>
</tbody>
</table>


<p>
<pre>test:mehta-2014-ident-poten</pre> 
</p>

<p>
And here is what appears for me:
<img src="/media/2014-04-12-Popup-tips-on-bibtex-links-in-org-mode/bibtex-popup-entry.png"> 
</p>

<p>
The final step is to connect this to an <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Idle-Timers.html">idle timer</a> . We want a popup to occur when our mouse is idle. I am setting this up to run one time, after 5 seconds of idleness.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(run-with-idle-timer 5 nil (<span style="color: #8b0000;">lambda</span> () (popup-tip <span style="color: #228b22;">"You are being idle"</span>)))
</pre>
</div>
<pre class="example">
[nil 0 5 0 nil (lambda nil (popup-tip "You are being idle")) nil idle 0]
</pre>


<div class="figure">
<p><img src="/media/2014-04-12-Popup-tips-on-bibtex-links-in-org-mode/idle-timer-popup.png"> 
</p>
</div>

<p>
So, we need to setup an idle timer that runs on some interval. When the cursor is on the right kind of link, we want to get a popup. I adapted the following code from <a href="http://www.emacswiki.org/emacs/IdleTimers">http://www.emacswiki.org/emacs/IdleTimers</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">variable for the timer object</span>
(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">idle-timer-bibtex-timer</span> nil)

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">callback function </span>
(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">idle-timer-bibtex-callback</span> ()
  <span style="color: #228b22;">"displays a popup of the bibtex entry in a test link"</span>
  (interactive)
  (<span style="color: #8b0000;">let</span> ((object (org-element-context)))    
    (<span style="color: #8b0000;">when</span> (and (equal (org-element-type object) 'link) 
               (equal (org-element-property <span style="color: #cd0000;">:type</span> object) <span style="color: #228b22;">"test"</span>))
      (<span style="color: #8b0000;">let*</span> ((bibtex-key (org-element-property <span style="color: #cd0000;">:path</span> object))
             (entry (<span style="color: #8b0000;">with-temp-buffer</span>
                      (insert-file-contents <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
                      (goto-char (point-min))
                      (re-search-forward bibtex-key)
                      (bibtex-narrow-to-entry)
                      (buffer-string))))
        (popup-tip entry)))))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">start functions</span>
(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">idle-timer-bibtex-start</span> ()
  (interactive)
  (<span style="color: #8b0000;">when</span> (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer
          (run-with-timer 1 1 #'idle-timer-bibtex-callback)))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">stop function</span>
(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">idle-timer-bibtex-stop</span> ()
  (interactive)
  (<span style="color: #8b0000;">when</span> (timerp idle-timer-bibtex-timer)
    (cancel-timer idle-timer-bibtex-timer))
  (setq idle-timer-bibtex-timer nil))

(idle-timer-bibtex-start)
</pre>
</div>
<pre class="example">
idle-timer-bibtex-stop
</pre>


<p>
<pre>test:kitchin-2008-alloy</pre> 
</p>

<p>
Now, whenever the cursor is on the link, and there is an idle of about a sec, I get a popup window of the bibtex entry. It looks like this:
</p>


<div class="figure">
<p><img src="/media/2014-04-12-Popup-tips-on-bibtex-links-in-org-mode/bibtex-popup2.png"> 
</p>
</div>

<p>
There are still some limitations to this code. It does not handle multiple citations in a link (like the cite links I normally use do). That will take a little work to fixup. I cannot figure out how to get mouse-over tooltips; this only works when the cursor is on the link.  I do not know what the optimal timer setting is. This one runs every second. I do not see any issues in performance with that. Another issue might be making the timer a file local variable. It would be nice if the timer quit running when the file was closed. I do not know how easy that would be to implement, or if there should be one timer running for org-mode. Finally, this code is hard-coded to use my reference file. For a real module, we would probably provide some customization to choose other bibtex files. Overall though, this might be a handy way to quickly peruse the citations in an org-file.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Multiple search criteria to find bibtex entries]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries" />
    <id>http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries</id>
    <updated>2014-04-08T20:45:35Z</updated>
    <published>2014-04-08T20:45:35Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Multiple search criteria to find bibtex entries]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries"><![CDATA[



<p>
I have been thinking about ways to search my bibtex file with multiple criteria. Eventually, I want a decent natural language search like "au=kitchin and alloy" to find papers authored by me about alloys. For now, I am going to settle with a way to find these. This strategy will create a search function that prints the entries that are found. Here is the prototype idea:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-search</span> (key start end)
  (<span style="color: #8b0000;">when</span> (and (re-search-forward <span style="color: #228b22;">"kitchin"</span> end t)
           (re-search-forward <span style="color: #228b22;">"alloy"</span> end t))
      (princ (format <span style="color: #228b22;">"%s\n"</span> (buffer-substring start end)))))

(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert-file-contents <span style="color: #228b22;">"../../bibliography/references.bib"</span>)
  (bibtex-map-entries  'my-search))
</pre>
</div>

<pre class="example">
@ARTICLE{inoglu-2011-ident-sulfur,
  pdf =		 {[[file:bibtex-pdfs/inoglu-2011-ident-sulfur.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::inoglu-2011-ident-sulfur]]},
  author =	 {Inoglu, Nilay and Kitchin, John R.},
  title =	 {Identification of Sulfur-Tolerant Bimetallic
                  Surfaces Using {DFT} Parametrized Models and
                  Atomistic Thermodynamics},
  journal =	 {ACS Catalysis},
  year =	 2011,
  pages =	 {399--407},
  abstract =	 {The identification of sulfur-tolerant alloys for
                  catalytic applications is difficult due to the
                  combinatorially large number of alloy compositions
                  and surface structures that may be
                  considered. Density functional theory calculations
                  (DFT) are not fast enough to enumerate all the
                  possible structures and their sulfur tolerance. In
                  this work, a DFT parametrized algebraic model that
                  accounts for structure and composition was used to
                  estimate the d-band properties and sulfur adsorption
                  energies of 370 transition metal-based bimetallic
                  alloy surfaces.  The estimated properties were
                  validated by DFT calculations for 110 of the surface
                  structures. We then utilized an atomistic
                  thermodynamic framework that includes surface
                  segregation, the presence of adsorbates, and effects
                  of environmental conditions to identify alloy
                  compositions and structures with enhanced sulfur
                  tolerance that are likely to be stable under the
                  environmental conditions. As a case study, we show
                  how this database can be used to identify
                  sulfur-tolerant Cu-based catalysts and compare the
                  results with what is known about these catalysts
                  experimentally.},
  doi =		 {10.1021/cs200039t},
  issn =	 {null},
  type =	 {Journal Article}
}
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
@ARTICLE{tierney-2009-hydrog-dissoc,
  pdf =		 {[[file:bibtex-pdfs/tierney-2009-hydrog-dissoc.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::tierney-2009-hydrog-dissoc]]},
  author =	 {Tierney, H. L. and Baber, A. E. and Kitchin,
                  J. R. and Sykes, E.  C. H.},
  title =	 {Hydrogen Dissociation and Spillover on Individual
                  Isolated Palladium Atoms},
  journal =	 {Physical Review Letters},
  year =	 2009,
  volume =	 103,
  number =	 24,
  abstract =	 {Using a combination of low-temperature scanning
                  tunneling microscopy and density functional theory
                  it is demonstrated how the nature of an inert host
                  metal of an alloy can affect the thermodynamics and
                  kinetics of a reaction pathway in a much more
                  profound way than simply a dilution, electronic, or
                  geometric effect. This study reveals that
                  individual, isolated Pd atoms can promote H-2
                  dissociation and spillover onto a Cu(111) surface,
                  but that the same mechanism is not observed for an
                  identical array of Pd atoms in Au(111).},
  pages =	 246102,
  doi =		 {10.1103/PhysRevLett.103.246102},
  issn =	 {0031-9007},
  url =		 {http://prl.aps.org/abstract/PRL/v103/i24/e246102},
  type =	 {Journal Article}
}
</pre>

<p>
That is not too bad. If I had a parser like <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags/">this one</a> , I could do some reasonable searches. I could try integrating it with reftex or something similar for selecting citations. I would like that a lot.
</p>

<p>
What if I wanted to find articles with Kitchin as an author, and alloy in the title? This is my best effort at doing that, where I explicitly match the fields in the bibtex entries.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end) 
                      (<span style="color: #8b0000;">let*</span> ((entry (bibtex-parse-entry))
                             (title (cdr (assoc <span style="color: #228b22;">"title"</span> entry)))
                             (authors (cdr (assoc <span style="color: #228b22;">"author"</span> entry))))
                        (<span style="color: #8b0000;">when</span> (and title (string-match <span style="color: #228b22;">"alloy"</span> title) 
                                   authors (string-match <span style="color: #228b22;">"kitchin"</span> authors))
                          (princ (buffer-substring start end)))))))
</pre>
</div>

<pre class="example">
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
</pre>

<p>
This is a more precise search, which yields only one entry. That is not exactly nimble searching, but it does provide precision. I need to think about this some more.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in JACS]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS" />
    <id>http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS</id>
    <updated>2014-04-07T21:08:42Z</updated>
    <published>2014-04-07T21:08:42Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in JACS]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS"><![CDATA[


<p>
<b>Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator</b>
</p>

<p>
Ethan L. Demeter, Shayna L. Hilburg, Newell R. Washburn, Terrence J. Collins, and John R. Kitchin
</p>

<p>
Iron complexes of tetra-amido macrocyclic ligands are important members of the suite of oxidation catalysts known as TAML activators. TAML activators are known to be fast homogeneous water oxidation (WO) catalysts, producing oxygen in the presence of chemical oxidants, e.g., ceric ammonium nitrate. These homogeneous systems exhibited low turnover numbers (TONs). Here we demonstrate immobilization on glassy carbon and carbon paper in an ink composed of the prototype TAML activator, carbon black, and Nafion and the subsequent use of this composition in heterogeneous electrocatalytic WO. The immobilized TAML system is shown to readily produce O2 with much higher TONs than the homogeneous predecessors.
</p>

<p>
<a href="http://pubs.acs.org/doi/full/10.1021/ja5015986">http://pubs.acs.org/doi/full/10.1021/ja5015986</a> 
</p>

<p>
Congratulations Ethan!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/07/New-publication-in-JACS.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
</feed>
