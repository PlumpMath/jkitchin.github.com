<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2015-06-11T14:03:07Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A python version of the s-exp bibtex entry]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry" />
    <id>http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry</id>
    <updated>2015-06-11T10:02:33Z</updated>
    <published>2015-06-11T10:02:33Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[A python version of the s-exp bibtex entry]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry"><![CDATA[



<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry/">post</a> we explored representing a bibtex entry in lisp s-exp notation, and showed interesting things that enables. Here, I explore something similar in Python. The s-exp notation in Python is really more like tuples. It looks almost identical, except we need a lot of commas for the Python syntax. One significant difference in Python is we need to define the functions in advance because otherwise the function symbols are undefined. Similar to lisp, we can define the field functions at run-time in a loop. We have to use an eval statement, which some Pythonistas find distasteful, but it is not that different to me than what we did in lisp.
</p>

<p>
The syntax for "executing" the data structure is quite different than in lisp, because this data is <i>not</i> code in Python. Instead, we have to deconstruct the data, knowing that the function is the first object, and it takes the remaining arguments in the tuple.
</p>

<p>
Here is the proof of concept:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">print</span> entry[0](entry[1], entry[2:])
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2},
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent},
  journal = {Industrial \&amp; Engineering Chemistry Research},
  pages = {10788-10794},
  year = {2013},
  number = {31},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a},
}
</pre>

<p>
We can still get specific fields out. Since we used a tuple here, it is not quite as nice as using a dictionary, but it is neither too bad, and it can be wrapped in a reasonably convenient function.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">article</span>(bibtex_key, *args):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Return the bibtex formatted entry"</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">',\n'</span>.join([<span style="color: #008000;">'@article{{{0}}}'</span>.<span style="color: #006FE0;">format</span>(bibtex_key)] +[arg[0](arg[1]) <span style="color: #0000FF;">for</span> arg <span style="color: #0000FF;">in</span> args[0]] + [<span style="color: #008000;">'}'</span>])

<span style="color: #BA36A5;">fields</span> = (<span style="color: #008000;">"author"</span>, <span style="color: #008000;">"title"</span>, <span style="color: #008000;">"journal"</span>, <span style="color: #008000;">"pages"</span>, <span style="color: #008000;">"number"</span>, <span style="color: #008000;">"doi"</span>, <span style="color: #008000;">"url"</span>, <span style="color: #008000;">"eprint"</span>, <span style="color: #008000;">"year"</span>)

<span style="color: #0000FF;">for</span> f <span style="color: #0000FF;">in</span> fields:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #006FE0;">locals</span>()[f] = <span style="color: #006FE0;">eval</span> (<span style="color: #008000;">'lambda x: "  {0} = {{{1}}}".format("'</span> + f + <span style="color: #008000;">'", x)'</span>)

<span style="color: #BA36A5;">entry</span> = (article, <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>,
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (author, <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>),
         (title, <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>),
         (journal, <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>),
         (pages, <span style="color: #008000;">"10788-10794"</span>),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>    (year, 2013),
         (number, 31),
         (doi, <span style="color: #008000;">"10.1021/ie400582a"</span>),
         (url, <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>),
         (eprint, <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))


<span style="color: #0000FF;">for</span> field <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> field[0] == author:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span> field

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_field</span>(entry, field):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> element <span style="color: #0000FF;">in</span> entry[2:]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> element[0] == field:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> element[1]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #D0372D;">None</span>

<span style="color: #0000FF;">print</span> get_field(entry, title)
<span style="color: #0000FF;">print</span> get_field(entry, <span style="color: #008000;">"bad"</span>)
</pre>
</div>

<pre class="example">
(&lt;function &lt;lambda&gt; at 0x1005975f0&gt;, 'Hallenbeck, Alexander P. and Kitchin, John R.')
Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent
None
</pre>

<p>
So, it seems Python can do some things like lisp in treating functions like first-class objects that can be used as functions, or keys. I still like the lisp s-exp better, but this is an interesting idea for Python too.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/11/A-python-version-of-the-s-exp-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A sexp version of a bibtex entry]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry" />
    <id>http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry</id>
    <updated>2015-06-10T08:54:00Z</updated>
    <published>2015-06-10T08:54:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="lisp" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A sexp version of a bibtex entry]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/10/A-sexp-version-of-a-bibtex-entry"><![CDATA[



<p>
Below you see a typical bibtex entry. Today we explore an alternate approach to represent the information (data) in that entry as s-expressions, i.e. as a lisp data structure. Why? because it seems like an interesting exploration!
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">hallenbeck-2013-effec-o2</span>,
  <span style="color: #BA36A5;">author</span> =       "Hallenbeck, Alexander P. and Kitchin, John R.",
  <span style="color: #BA36A5;">title</span> =        {Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a
                  primary-amine based polymeric \ce{CO_2} sorbent},
  <span style="color: #BA36A5;">keywords</span> =     {RUA, orgmode},
  <span style="color: #BA36A5;">journal</span> =      "Industrial \&amp; Engineering Chemistry Research",
  <span style="color: #BA36A5;">pages</span> =        "10788-10794",
  <span style="color: #BA36A5;">year</span> =         2013,
  <span style="color: #BA36A5;">volume</span> =       {52},
  <span style="color: #BA36A5;">number</span> =       {31},
  <span style="color: #BA36A5;">doi</span> =          "<span style="color: #006DAF; text-decoration: underline;">10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">url</span> =          "<span style="color: #006DAF; text-decoration: underline;">http://pubs.acs.org/doi/abs/10.1021/ie400582a</span>",
  <span style="color: #BA36A5;">eprint</span> =       "http://pubs.acs.org/doi/pdf/10.1021/ie400582a",
}
</pre>
</div>

<p>
Here is what that same data structure might look like as a sexp-based lisp data structure.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (year 2013)
         (number 31)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<p>
We can retrieve data from the sexp form pretty easily. Here we get the authors.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                      (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                      (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                      (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                      (pages <span style="color: #008000;">"10788-10794"</span>)
                      (year 2013)
                      (number 31)
                      (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                      (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                      (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>)))
       (fields (cddr art)))
  (cadr (assoc 'author fields)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R.
</pre>

<p>
That is simple enough you might just write a little function to streamline it like this, and return a formatted string.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-article-field</span> (article field)
  <span style="color: #036A07;">"Return value of FIELD in ARTICLE."</span>
  (cadr (assoc field (cddr article))))

(<span style="color: #0000FF;">let</span> ((art '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                     (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                     (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                     (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                     (pages <span style="color: #008000;">"10788-10794"</span>)
                     (year 2013)
                     (number 31)
                     (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                     (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                     (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
  (format <span style="color: #008000;">"%s, doi:%s (%s)"</span>
          (get-article-field art 'author)
          (get-article-field art 'doi)
          (get-article-field art 'year)))
</pre>
</div>

<pre class="example">
Hallenbeck, Alexander P. and Kitchin, John R., doi:10.1021/ie400582a (2013)
</pre>

<p>
You might be wondering, why is that even a little bit interesting? One reason is that it looks a little like what lisp returns after parsing an xml file. Another is, the data structure looks kind of like data, but it is also some code, if article was defined as a function!  Let us consider what this might look like. I use a macro to define the field functions since in this case they all do the same thing, and these simply return a string with the field-name and value in curly brackets. We eval the macro to make sure it defines the function. I define an article function that wraps the fields in @bibtex-key{fields}, which defines a bibtex entry.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defmacro</span> <span style="color: #006699;">make-field</span> (field-name)
  <span style="color: #036A07;">"define a field that returns a string"</span>
  `(<span style="color: #0000FF;">defun</span> ,(intern field-name) (content)
     (format <span style="color: #008000;">"  %s = {%s}"</span> ,field-name content)))

(<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span> <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
  do (eval `(make-field ,field)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">article</span> (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
  (concat
   (format <span style="color: #008000;">"@article{%s,\n"</span> bibtex-key)
   (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
   <span style="color: #008000;">"\n}\n"</span>))

(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
         (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
         (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
         (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
         (pages <span style="color: #008000;">"10788-10794"</span>)
         (number 31)
         (year 2013)
         (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
         (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
         (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))
</pre>
</div>

<pre class="example">
@article{hallenbeck-2013-effec-o2,
  author = {Hallenbeck, Alexander P. and Kitchin, John R.},
  title = {Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent},
  journal = {Industrial &amp; Engineering Chemistry Research},
  pages = {10788-10794},
  number = {31},
  year = {2013},
  doi = {10.1021/ie400582a},
  url = {http://pubs.acs.org/doi/abs/10.1021/ie400582a},
  eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie400582a}
}
</pre>

<p>
Wow. We <i>executed</i> our data structure, and got a bibtex entry! That seems moderately interesting to me. Next is an example of taking the same data structure and rendering it as xml. This is some lispy wizardry, rather than use a macro to define functions, I temporarily define functions within a cl-flet macro, which I have to collect as a list of code. Then, I eval the list. This feels pretty odd, but seems like a lispy kind of thing to do.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"  &lt;%s&gt;%s&lt;/%s&gt;"</span> ,field content ,field)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"&lt;article bibtex-key=\"%s\"&gt;\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">"\n"</span>)
                           <span style="color: #008000;">"\n&lt;/article&gt;"</span>)))
               )
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
&lt;article bibtex-key="hallenbeck-2013-effec-o2"&gt;
  &lt;author&gt;Hallenbeck, Alexander P. and Kitchin, John R.&lt;/author&gt;
  &lt;title&gt;Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent&lt;/title&gt;
  &lt;journal&gt;Industrial &amp; Engineering Chemistry Research&lt;/journal&gt;
  &lt;pages&gt;10788-10794&lt;/pages&gt;
  &lt;number&gt;31&lt;/number&gt;
  &lt;year&gt;2013&lt;/year&gt;
  &lt;doi&gt;10.1021/ie400582a&lt;/doi&gt;
  &lt;url&gt;http://pubs.acs.org/doi/abs/10.1021/ie400582a&lt;/url&gt;
  &lt;eprint&gt;http://pubs.acs.org/doi/pdf/10.1021/ie400582a&lt;/eprint&gt;
&lt;/article&gt;
</pre>

<p>
Prefer json? No problem, just reformat the functions!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval
 (list 'cl-flet
       (append (<span style="color: #0000FF;">loop</span> for field in '(<span style="color: #008000;">"author"</span> <span style="color: #008000;">"title"</span> <span style="color: #008000;">"journal"</span> <span style="color: #008000;">"pages"</span>
                                      <span style="color: #008000;">"number"</span> <span style="color: #008000;">"doi"</span> <span style="color: #008000;">"url"</span> <span style="color: #008000;">"eprint"</span> <span style="color: #008000;">"year"</span>)
                       collect (list (intern field)
                                     '(content)
                                     `(format <span style="color: #008000;">"   \"%s\": \"%s\""</span> ,field content)))
               '((article (bibtex-key <span style="color: #6434A3;">&amp;rest</span> fields)
                          (concat
                           (format
                            <span style="color: #008000;">"{\"article\":\n  {\"bibtex-key\": \"%s\",\n"</span> bibtex-key)
                           (mapconcat (<span style="color: #0000FF;">lambda</span> (field) (eval field)) fields <span style="color: #008000;">",\n"</span>)
                           <span style="color: #008000;">"}\n}"</span>))))
       <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">body of cl-flet</span>
       '(article <span style="color: #008000;">"hallenbeck-2013-effec-o2"</span>
                (author <span style="color: #008000;">"Hallenbeck, Alexander P. and Kitchin, John R."</span>)
                (title <span style="color: #008000;">"Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a primary-amine based polymeric \ce{CO_2} sorbent"</span>)
                (journal <span style="color: #008000;">"Industrial \&amp; Engineering Chemistry Research"</span>)
                (pages <span style="color: #008000;">"10788-10794"</span>)
                (number 31)
                (year 2013)
                (doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
                (url <span style="color: #008000;">"http://pubs.acs.org/doi/abs/10.1021/ie400582a"</span>)
                (eprint <span style="color: #008000;">"http://pubs.acs.org/doi/pdf/10.1021/ie400582a"</span>))))
</pre>
</div>

<pre class="example">
{"article":
  {"bibtex-key": "hallenbeck-2013-effec-o2",
   "author": "Hallenbeck, Alexander P. and Kitchin, John R.",
   "title": "Effects of ce{O_2} and ce{SO_2} on the capture capacity of a primary-amine based polymeric ce{CO_2} sorbent",
   "journal": "Industrial &amp; Engineering Chemistry Research",
   "pages": "10788-10794",
   "number": "31",
   "year": "2013",
   "doi": "10.1021/ie400582a",
   "url": "http://pubs.acs.org/doi/abs/10.1021/ie400582a",
   "eprint": "http://pubs.acs.org/doi/pdf/10.1021/ie400582a"}
}
</pre>

<p>
Is this useful? Great question. I don't plan to convert by bibtex files to sexp format anytime soon ;) The format I used above is just a simple one. It might be desirable to include individual authors instead of an author string, and maybe support attributes to establish an author order. An author structure might be more complex to include scientific ids like an orcid, alternative names, etc&#x2026; Finally, the s-exp data structure is super easy to use in lisp, but other languages would have parse it into some native structure the way they parse json or xml. There is limited support for s-expressions in most other non-lispy languages.
</p>

<p>
I like the idea of data representation as code, and its conversion to some other kind of format. It is subtle here, but notice we <i>never</i> had to write a parser for the sexp notation. That <i>already exists as the lisp interpreter</i>. We did write code to use the data, and convert the data. The sexp notation is pretty easy to write, in contrast to the xml or json representations. Some interesting issues might be what to do with fields that are not defined, perhaps a macro would be used on the fly, or in the cl-flet definition. It is hard to imagine doing these things in another language than lisp!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/10/A-sexp-version-of-a-bibtex-entry.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed" />
    <id>http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed</id>
    <updated>2015-06-09T07:29:08Z</updated>
    <published>2015-06-09T07:29:08Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed"><![CDATA[



<p>
Sometimes it is useful to convert a DOI to another type of identifier. For example, in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/">post</a> we converted a DOI to a Scopus EID, and in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/">one</a> we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/">http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/</a> 
</p>

<p>
We will use the DOI tool. According to the documentation, we need to form a URL like this:
</p>

<p>
DOI: <a href="http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195">http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195</a> 
</p>

<p>
We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max)))))
xml)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">((pmcids
  ((status . <span style="color: #008000;">"ok"</span>))
  <span style="color: #008000;">"\n"</span>
  (request
   ((idtype . <span style="color: #008000;">"doi"</span>)
    (dois . <span style="color: #008000;">""</span>)
    (versions . <span style="color: #008000;">"yes"</span>)
    (showaiid . <span style="color: #008000;">"no"</span>))
   <span style="color: #008000;">"\n"</span>
   (echo nil <span style="color: #008000;">"tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195"</span>)
   <span style="color: #008000;">"\n"</span>)
  <span style="color: #008000;">"\n"</span>
  (record
   ((requested-id . <span style="color: #008000;">"10.1093/NAR/GKS1195"</span>)
    (pmcid . <span style="color: #008000;">"PMC3531190"</span>)
    (pmid . <span style="color: #008000;">"23193287"</span>)
    (doi . <span style="color: #008000;">"10.1093/nar/gks1195"</span>))
   (versions nil
             (version
              ((pmcid . <span style="color: #008000;">"PMC3531190.1"</span>)
               (current . <span style="color: #008000;">"true"</span>)))))
  <span style="color: #008000;">"\n"</span>))
</pre>
</div>

<p>
The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list <span style="color: #006FE0;">:doi</span> doi <span style="color: #006FE0;">:pmid</span> pmid <span style="color: #006FE0;">:pmcid</span> pmcid <span style="color: #006FE0;">:eid</span> (scopus-doi-to-eid doi) <span style="color: #006FE0;">:wos</span> (wos-doi-to-accession-number doi)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #006FE0;">:doi</span> <span style="color: #008000;">"10.1093/nar/gks1195"</span> <span style="color: #006FE0;">:pmid</span> <span style="color: #008000;">"23193287"</span> <span style="color: #006FE0;">:pmcid</span> <span style="color: #008000;">"PMC3531190"</span> <span style="color: #006FE0;">:eid</span> <span style="color: #008000;">"2-s2.0-80053651587"</span> <span style="color: #006FE0;">:wos</span> <span style="color: #008000;">"000312893300006"</span>)
</pre>
</div>

<p>
Well, there you have it, four new scientific document ids from one DOI. <i>Of course</i> we have defined org-mode links for each one of these:
</p>

<p>
<a href="http://dx.doi.org/10.1093/nar/gks1195">doi:10.1093/nar/gks1195</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/mid/23193287">pmid:23193287</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3531190">pmcid:PMC3531190</a>
</p>

<p>
<a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-80053651587&origin=resultslist">eid:2-s2.0-80053651587</a>
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000312893300006">wos:000312893300006</a>
</p>

<p>
I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI</id>
    <updated>2015-06-09T07:25:39Z</updated>
    <published>2015-06-08T11:23:33Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI"><![CDATA[


<p>
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.
</p>

<p>
In a previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/">post</a> we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j</a> is redirected to
<a href="http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44">http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44</a> . You can see the <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">wos:000225079300029</a> in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr (assoc <span style="color: #008000;">"KeyUT"</span> (url-parse-query-string (url-filename (url-generic-parse-url  <span style="color: #008000;">"http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&amp;SrcApp=PARTNER_APP&amp;SrcAuth=LinksAMR&amp;KeyUT=WOS:000225079300029&amp;DestLinkType=FullRecord&amp;DestApp=ALL_WOS&amp;UsrCustomerID=8703b88d69db6b417a9c0dc510538f44"</span>)))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><a href="000225079300029">000225079300029</a></td>
</tr>
</tbody>
</table>

<p>
It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-redirect*</span> nil)
(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-waiting*</span> nil)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-get-wos-redirect</span> (url)
  <span style="color: #036A07;">"Return final redirect url for open-url"</span>
  (<span style="color: #0000FF;">setq</span> *wos-waiting* t)
  (url-retrieve
   url
   (<span style="color: #0000FF;">lambda</span> (status)
     (<span style="color: #0000FF;">setq</span> *wos-redirect* (car (last status)))
     (<span style="color: #0000FF;">setq</span> *wos-waiting* nil)))
  (<span style="color: #0000FF;">while</span> *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-doi-to-accession-number</span> (doi)
  <span style="color: #036A07;">"Return a WOS Accession number for a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((open-url (concat <span style="color: #008000;">"http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&amp;rft_id=info:doi/"</span> doi))
         (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
                 (assoc
                  <span style="color: #008000;">"KeyUT"</span>
                  (url-parse-query-string
                   (url-filename
                    (url-generic-parse-url redirect)))))
    4)))

(concat <span style="color: #008000;">"wos:"</span> (wos-doi-to-accession-number <span style="color: #008000;">"10.1021/jp047349j"</span>))
</pre>
</div>

<pre class="example">
wos:000225079300029
</pre>

<p>
I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:
</p>

<p>
<a href="http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029">http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029</a> 
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029</a> 
</p>

<p>
That might turn out to be handy at some point.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a Scopus EID from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI</id>
    <updated>2015-06-07T16:54:38Z</updated>
    <published>2015-06-07T16:29:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a Scopus EID from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI"><![CDATA[


<p>
<a href="http://www.scopus.com">Scopus</a> is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: <a href="http://dev.elsevier.com/myapikey.html">http://dev.elsevier.com/myapikey.html</a> and set <b>scopus-api-key</b> in Emacs to use this code.
</p>

<p>
Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:
</p>

<p>
Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial &amp; Engineering Chemistry Research, 52:10788-10794 (2013)
</p>

<p>
With the EID, we can construct a URL to the Scopus document page:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/record/display.url?eid=%s&amp;origin=resultslist"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&amp;origin=resultslist
</pre>

<p>
We can construct a URL to citing documents:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=%s&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=2-s2.0-84881394200&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage
</pre>

<p>
And there are three types of related document urls we can create: by author, keyword or references.
</p>

<p>
By authors:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=aut&amp;zone=relatedDocuments"</span>)
            eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments</a> 
</p>

<p>
By keywords:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=key&amp;zone=relatedDocuments"</span>)
          eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments</a> 
</p>

<p>
And by references:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat  <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url?"</span>
                   <span style="color: #008000;">"eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                   <span style="color: #008000;">"&amp;method=ref&amp;zone=relatedDocuments"</span>)
           eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments</a> 
</p>

<p>
We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, <i>not</i> the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.
</p>

<p>
The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.
</p>

<p>
I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (json-object-type 'plist)
       (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                    (json-read-from-string
                     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid-json</span> (doi)
  <span style="color: #036A07;">"Return a parsed xml from the Scopus article retrieval api for DOI.</span>
<span style="color: #036A07;">This does not always seem to work for the most recent DOIs."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (json-object-type 'plist)
         (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                      (json-read-from-string
                       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>)))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<p>
XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
              (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
Now we wrap this in a function for reusability.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid</span> (doi)
  <span style="color: #036A07;">"Get a Scopus eid from a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max))))
         (results (car xml))
         (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
This code is wrapped up in <a href="https://github.com/jkitchin/org-ref/blob/master/scopus.el">org-ref/scopus.el</a> . It provides a new org-mode eid link, e.g. <a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist">eid:2-s2.0-84881394200</a> which is functional and provides access to the citing and related article Scopus pages for that eid.
</p>

<p>
There are also new links and functions for a <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=b&sdt=b&sl=35&s=TITLE-ABS-KEY%28alloy%20Au%20segregation%29&origin=searchbasic">alloy Au segregation</a> and <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=a&sdt=a&sl=48&s=auth%28kitchin%29%20and%20title%28segregation%29&origin=searchadvanced">auth(kitchin) and title(segregation)</a>.
</p>

<p>
Let's not forget the <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a> link to Scopus Author pages.
</p>

<p>
Now you can use org-mode for reproducible scientific literature searching in Scopus!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/07/Getting-a-Scopus-EID-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in ACS Catalysis on data sharing practices]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices" />
    <id>http://jkitchin.github.io/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices</id>
    <updated>2015-05-17T14:22:54Z</updated>
    <published>2015-05-17T14:22:54Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in ACS Catalysis on data sharing practices]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices"><![CDATA[


<p>
In this perspective we show an example of data sharing practices we have developed. We use the supporting information file from <a href="#boes-2015-estim-bulk">boes-2015-estim-bulk</a> to show how one can extract the data from our paper and reuse it for new purposes. We illustrate this for both computational and experimental data. We use org-mode for doing this, but we also show that data in the supporting information can be extracted using Python, and independently of Emacs, so that org-mode is not critical for people who do not use it.
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">kitchin-2015-examp</span>,
  <span style="color: #BA36A5;">author</span> =       {Kitchin, John R.},
  <span style="color: #BA36A5;">title</span> =        {Examples of Effective Data Sharing in Scientific Publishing},
  <span style="color: #BA36A5;">journal</span> =      {ACS Catalysis},
  <span style="color: #BA36A5;">volume</span> =       0,
  <span style="color: #BA36A5;">number</span> =       {ja},
  <span style="color: #BA36A5;">pages</span> =        {null},
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1021/acscatal.5b00538</span>},
  <span style="color: #BA36A5;">url</span> =          {<span style="color: #006DAF; text-decoration: underline;"> http://dx.doi.org/10.1021/acscatal.5b00538 </span>},
  <span style="color: #BA36A5;">eprint</span> =       { http://dx.doi.org/10.1021/acscatal.5b00538 },
}
</pre>
</div>

<p>
The published version of this manuscript doesn't look exactly like the version I generated, for example, the output from the source blocks is missing. Hopefully that will make it into a supporting information file. Until then, you may be interested in the org file and version I submitted below.
</p>

<p>
Org source: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-manuscript.org">acs-cat-manuscript.org</a> 
</p>

<p>
References: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-references.bib">acs-cat-references.bib</a> 
</p>

<p>
Manuscript: <a href="/media/2015-05-17-New-publication-in-ACS-Catalysis-on-data-sharing-practices/acs-cat-manuscript-2015-05-07.zip">acs-cat-manuscript-2015-05-07.zip</a> 
</p>


<p>
<h1>Bibliography</h1>
<ul><li><a id="boes-2015-estim-bulk">[boes-2015-estim-bulk] Jacob Boes, Gamze Gumuslu, James Miller, Andrew, Gellman & John Kitchin, Estimating Bulk-Composition-Dependent \ceH2 Adsorption  Energies on \ceCu_xPd_1-x Alloy (111) Surfaces, <i>ACS Catalysis</i>, <b>5</b>, 1020-1026 (2015). <a href="http://dx.doi.org/10.1021/cs501585k">link</a>. <a href="http://dx.doi.org/10.1021/cs501585k">doi</a>.</a></li>
</ul></p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/17/New-publication-in-ACS-Catalysis-on-data-sharing-practices.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New publication in Surface Science on data sharing]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing" />
    <id>http://jkitchin.github.io/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing</id>
    <updated>2015-05-17T13:48:15Z</updated>
    <published>2015-05-17T09:10:01Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New publication in Surface Science on data sharing]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/17/New-publication-in-Surface-Science-on-data-sharing"><![CDATA[



<p>
In this perspective we illustrate how we use org-mode to prepare manuscripts and supporting information files that are rich in data, and that make it easy to share the code we use for our analysis. We use the supporting information file from <a href="#boes-2015-core-cu">boes-2015-core-cu</a> to show examples of how to extract the data, and reuse it in new analyses. This approach works for both computational and experimental data. You can see the manuscript I submitted here: <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript-2015-05-07.zip">ss-manuscript-2015-05-07.zip</a> , and the org file that generated it here: <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript.org">ss-manuscript.org</a> . The references from the manuscript are contained here <a href="/media/2015-05-17-New-publication-in-Surface-Science-on-data-sharing/ss-manuscript.bib">ss-manuscript.bib</a> 
</p>

<p>
<a href="http://www.sciencedirect.com/science/article/pii/S0039602815001326">http://www.sciencedirect.com/science/article/pii/S0039602815001326</a> 
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">kitchin-2015-data-surfac-scien</span>,
  <span style="color: #BA36A5;">author</span> =       "John R. Kitchin",
  <span style="color: #BA36A5;">title</span> =        {Data Sharing in Surface Science},
  <span style="color: #BA36A5;">journal</span> =      "Surface Science ",
  <span style="color: #BA36A5;">number</span> =       0,
  <span style="color: #BA36A5;">pages</span> =        " - ",
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1016/j.susc.2015.05.007</span>},
  <span style="color: #BA36A5;">url</span> =
                  "http://www.sciencedirect.com/science/article/pii/S0039602815001326",
  <span style="color: #BA36A5;">issn</span> =         "0039-6028",
  <span style="color: #BA36A5;">keywords</span> =     "Data sharing ",
}
</pre>
</div>

<p>
<h1>Bibliography</h1>
<ul><li><a id="boes-2015-core-cu">[boes-2015-core-cu] "Jacob Boes, Peter Kondratyuk, Chunrong Yin, James, Miller, Andrew Gellman & John Kitchin", Core Level Shifts in Cu-Pd Alloys As a Function of Bulk  Composition and Structure, <i>"Surface Science "</i>, <b>(0)</b>,  -  (2015). <a href="http://www.sciencedirect.com/science/article/pii/S0039602815000461">link</a>. <a href="http://dx.doi.org/10.1016/j.susc.2015.02.011">doi</a>.</a></li>
</ul></p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/17/New-publication-in-Surface-Science-on-data-sharing.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Python data structures to lisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/16/Python-data-structures-to-lisp" />
    <id>http://jkitchin.github.io/blog/2015/05/16/Python-data-structures-to-lisp</id>
    <updated>2015-05-16T10:47:59Z</updated>
    <published>2015-05-16T10:47:59Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="lisp" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Python data structures to lisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/16/Python-data-structures-to-lisp"><![CDATA[


<p>
I have an idea in mind that would use the output of python scripts in lisp functions. Xah Lee posted an <a href="http://ergoemacs.org/emacs/elisp_perl_wrapper.html">idea for writing emacs commands in scripting languages</a> . In this post I want to explore an extension of the idea, where a Python script will return output that can be read in Lisp, e.g. we can convert a Python list to a lisp list, or a dictionary to an a-list or p-list. I can already see that simple data structures will be "simple", and arbitrary data structures will offer a lot of challenges, e.g. nested lists or dictionaries&#x2026;
</p>

<p>
If I could add some custom functions to the basic builtin types in Python, then I could use another approach to format python objects as lisp data types. This isn't recommended by Pythonistas, but I guess they don't want to use lisp as much as I do ;) I found this approach to modifying builtins:
</p>

<p>
<a href="http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a">http://stackoverflow.com/questions/2444680/how-do-i-add-my-own-custom-attributes-to-existing-built-in-python-types-like-a</a> 
</p>

<p>
We use that almost verbatim here to get what I want. This is a super low level way to add functions to the builtins. I add some simple formatting to floats, ints and strings. I add a more complex recursive formatting function to lists, tuples and dictionaries. A dictionary can be represented as an alist or plist. Both examples are shown, but I leave the alist version commented out. Finally, we add a lispify function to numpy arrays.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> ctypes <span style="color: #0000FF;">as</span> c

<span style="color: #0000FF;">class</span> <span style="color: #6434A3;">PyObject_HEAD</span>(c.Structure):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">_fields_</span> = [(<span style="color: #008000;">'HEAD'</span>, c.c_ubyte * (<span style="color: #006FE0;">object</span>.__basicsize__ -
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     c.sizeof(c.c_void_p))),
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   (<span style="color: #008000;">'ob_type'</span>, c.c_void_p)]

<span style="color: #BA36A5;">_get_dict</span> = c.pythonapi._PyObject_GetDictPtr
<span style="color: #BA36A5;">_get_dict.restype</span> = c.POINTER(c.py_object)
<span style="color: #BA36A5;">_get_dict.argtypes</span> = [c.py_object]

<span style="color: #0000FF;">def</span> <span style="color: #006699;">get_dict</span>(<span style="color: #006FE0;">object</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> _get_dict(<span style="color: #006FE0;">object</span>).contents.value

get_dict(<span style="color: #006FE0;">str</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> s:<span style="color: #008000;">'"{}"'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(s))
get_dict(<span style="color: #006FE0;">float</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> f:<span style="color: #008000;">'{}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(f))
get_dict(<span style="color: #006FE0;">int</span>)[<span style="color: #008000;">'lisp'</span>] = <span style="color: #0000FF;">lambda</span> f:<span style="color: #008000;">'{}'</span>.<span style="color: #006FE0;">format</span>(<span style="color: #006FE0;">str</span>(f))

<span style="color: #0000FF;">import</span> collections
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">lispify</span>(L):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #008000;">"Convert a Python object L to a lisp representation."</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">str</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">float</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">int</span>)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> L.lisp()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">elif</span> (<span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">list</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">tuple</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>     <span style="color: #0000FF;">or</span> <span style="color: #006FE0;">isinstance</span>(L, np.ndarray)):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = []
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> element <span style="color: #0000FF;">in</span> L:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> += [element.lisp()]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'('</span> + <span style="color: #008000;">' '</span>.join(s) + <span style="color: #008000;">')'</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">elif</span> <span style="color: #006FE0;">isinstance</span>(L, <span style="color: #006FE0;">dict</span>):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = []
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">for</span> key <span style="color: #0000FF;">in</span> L:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">alist format</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">s += ["({0} . {1})".format(key, L[key].lisp())]</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">plist</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> += [<span style="color: #008000;">":{0} {1}"</span>.<span style="color: #006FE0;">format</span>(key, L[key].lisp())]
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> <span style="color: #008000;">'('</span> + <span style="color: #008000;">' '</span>.join(s) + <span style="color: #008000;">')'</span>

get_dict(<span style="color: #006FE0;">list</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(<span style="color: #006FE0;">tuple</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(<span style="color: #006FE0;">dict</span>)[<span style="color: #008000;">'lisp'</span>] = lispify
get_dict(np.ndarray)[<span style="color: #008000;">'lisp'</span>] = lispify
</pre>
</div>

<p>
Let us test these out.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">from</span> pylisp <span style="color: #0000FF;">import</span> *
<span style="color: #BA36A5;">a</span> = 4.5
<span style="color: #0000FF;">print</span> <span style="color: #006FE0;">int</span>(a).lisp()
<span style="color: #0000FF;">print</span> a.lisp()
<span style="color: #0000FF;">print</span> <span style="color: #008000;">"test"</span>.lisp()

<span style="color: #0000FF;">print</span> [1, 2, 3].lisp()
<span style="color: #0000FF;">print</span> (1, 2, 3).lisp()

<span style="color: #0000FF;">print</span> [[1, 3], (5, 6)].lisp()

<span style="color: #0000FF;">print</span> {<span style="color: #008000;">"a"</span>: 5}.lisp()
<span style="color: #0000FF;">print</span> [[1, 3], (5, 6), {<span style="color: #008000;">"a"</span>: 5, <span style="color: #008000;">"b"</span>: <span style="color: #008000;">"test"</span>}].lisp()


<span style="color: #BA36A5;">A</span> = np.array([1, 3, 4])
<span style="color: #0000FF;">print</span> A.lisp()
<span style="color: #0000FF;">print</span> ({<span style="color: #008000;">"tree"</span>: [5, 6]}, [<span style="color: #008000;">"a"</span>, 4, <span style="color: #008000;">"list"</span>], 5, 2.0 / 3.0).lisp()
</pre>
</div>

<pre class="example">
4
4.5
"test"
(1 2 3)
(1 2 3)
((1 3) (5 6))
(:a 5)
((1 3) (5 6) (:a 5 :b "test"))
(1 3 4)
((:tree (5 6)) ("a" 4 "list") 5 0.666666666667)
</pre>


<p>
Now, is that better than a single lisp function with a lot of conditionals to handle each type? I am not sure. This seems to work pretty well.
</p>


<p>
Here is how I imagine using this idea. We would have some emacs-lisp variables and use them to dynamically generate a python script. We run the python script, capturing the output, and read it back in as a lisp data structure. Here is a simple kind of example that generates a dictionary.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((elisp-var 6)
       (result)
      (script (format <span style="color: #008000;">"</span>
<span style="color: #008000;">from pylisp import *</span>
<span style="color: #008000;">print {x: [2*y for y in range(x)] for x in range(1, %s)}.lisp()</span>
<span style="color: #008000;">"</span> elisp-var)))

  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">start a python process</span>
  (run-python)
  (<span style="color: #0000FF;">setq</span> result (read (python-shell-send-string-no-output
   script)))
  (plist-get result <span style="color: #006FE0;">:5</span>))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(0 2 4 6 8)
</pre>
</div>

<p>
That seems to work pretty well. One alternative idea to this is <a href="https://github.com/pinard/Pymacs">Pymacs</a> , which I have written about <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/10/19/Using-Pymacs-to-integrate-Python-into-Emacs/">before</a> . This project isn't currently under active development, and I ran into some difficulties with it before.
</p>

<p>
Here we can solve the problem I previously posed and get the result back as an elisp float, and then reuse the result
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((myvar 3)
       (script (format <span style="color: #008000;">"from pylisp import *</span>
<span style="color: #008000;">from scipy.optimize import fsolve</span>
<span style="color: #008000;">def objective(x):</span>
<span style="color: #008000;">    return x - 5</span>

<span style="color: #008000;">ans, = fsolve(objective, %s)</span>
<span style="color: #008000;">print ans.lisp()"</span> myvar)))
  (run-python)
  (<span style="color: #0000FF;">setq</span> result (read (python-shell-send-string-no-output
                       script)))
  (- 5 result))
</pre>
</div>

<pre class="example">
0.0
</pre>

<p>
Bottom line: we can write python code in lisp functions that are dynamically updated, execute them, and get lisp data structures back for simple data types. I think that could be useful in some applications, where it is easier to do parsing/analysis in Python, but you want to do something else that is easier in Lisp.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/16/Python-data-structures-to-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Another approach to embedding org-source in html]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html" />
    <id>http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html</id>
    <updated>2015-05-10T09:34:55Z</updated>
    <published>2015-05-09T19:19:10Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="data" />
    <summary type="html"><![CDATA[Another approach to embedding org-source in html]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html"><![CDATA[


<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts/">post</a> I examined a way to embed the org-source in a comment in the html of the post, and developed a reasonably convenient way to extract the source in emacs. One downside of the approach was the need to escape at least the dashes, and then unescape them on extraction. I came across another idea, which is to put the org-source in base64 encoded form in a <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">data uri</a> .
</p>

<p>
First let us see what the encoding means:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(base64-encode-string <span style="color: #008000;">"&lt;!-- test--&gt;"</span>)
</pre>
</div>
<pre class="example">
PCEtLSB0ZXN0LS0+
</pre>

<p>
And decoding:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(base64-decode-string <span style="color: #008000;">"PCEtLSB0ZXN0LS0+"</span>)
</pre>
</div>

<pre class="example">
&lt;!-- test--&gt;
</pre>

<p>
The encoding looks random, but it is reversible. More importantly, it probably will not have any html like characters in it that need escaped. The idea of a data uri is that the data it serves is embedded in the URL href attribute. This is basically how to make a data uri. We give the url here a class so we can find it later.
</p>
<pre class="example">
&lt;a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+"&gt;source&lt;/a&gt;
</pre>

<p>
Here is the actual html for the browser. If you click on it, your browser automatically decodes it for you!
</p>
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>

<p>
So, during the blog publish step, we just need to add this little step to the html generation, and it will be included as a data uri. Here is the function that generates the data uri for us, and example of using it. The encoded source is not at all attractive to look at it, but you almost never need to look at it, it is invisible in the browser. Interestingly, if you click on the link, you will see the org source right in your browser!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">source-data-uri</span> (source)
  <span style="color: #036A07;">"Encode the string in SOURCE to a data uri."</span>
  (format
   <span style="color: #008000;">"&lt;a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\"&gt;source&lt;/a&gt;"</span>
   (base64-encode-string source)))

(source-data-uri (buffer-string))
</pre>
</div>

<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBBbm90aGVyIGFwcHJvYWNoIHRvIGVtYmVkZGluZyBvcmctc291cmNlIGluIGh0bWwKSW4gdGhp
cyBbW2h0dHA6Ly9raXRjaGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4t
YWx0ZXJuYXRpdmUtYXBwcm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0
cy9dW3Bvc3RdXSBJIGV4YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEg
Y29tbWVudCBpbiB0aGUgaHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFi
bHkgY29udmVuaWVudCB3YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93
bnNpZGUgb2YgdGhlIGFwcHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhl
IGRhc2hlcywgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNy
b3NzIGFub3RoZXIgaWRlYSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2
NCBlbmNvZGVkIGZvcm0gaW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9V
Uklfc2NoZW1lXVtkYXRhIHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGlu
ZyBtZWFuczoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8
IS0tIHRlc3QtLT4iKQojK0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFu
ZCBkZWNvZGluZzoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5n
ICJQQ0V0TFNCMFpYTjBMUzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+
CgpBbmQgdGhpcyBpcyBiYXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0
aGUgdXJsIGhlcmUgYSBjbGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFN
UExFCjxhIGNsYXNzPSJvcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9FWEFNUExF
CgpIZXJlIGlzIHRoZSBhY3R1YWwgaHRtbCBmb3IgdGhlIGJyb3dzZXI6IAojK0JFR0lOX0hUTUwK
PGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFT
Q0lJO2Jhc2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0hUTUwKClNvLCBk
dXJpbmcgdGhlIGJsb2cgcHVibGlzaCBzdGVwLCB3ZSBqdXN0IG5lZWQgdG8gYWRkIHRoaXMgbGl0
dGxlIHN0ZXAgdG8gdGhlIGh0bWwgZ2VuZXJhdGlvbiwgYW5kIGl0IHdpbGwgYmUgaW5jbHVkZWQg
YXMgYSBkYXRhIHVyaS4gSGVyZSBpcyB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIGRh
dGEgdXJpIGZvciB1cywgYW5kIGV4YW1wbGUgb2YgdXNpbmcgaXQ6CgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIiBkb3dubG9hZD1cInNvdXJjZS5vcmdcIj5zb3VyY2U8L2E+IiAK
ICAgKGJhc2U2NC1lbmNvZGUtc3RyaW5nIHNvdXJjZSkpKQoKKHNvdXJjZS1kYXRhLXVyaSAoYnVm
ZmVyLXN0cmluZykpCiMrRU5EX1NSQwoKCgoKCgoK" download="source.org">source</a>

<p>
Now, we integrate it into the blogofile function:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">bf-get-post-html</span> ()
  <span style="color: #036A07;">"Return a string containing the YAML header, the post html, my</span>
<span style="color: #036A07;">copyright line, and a link to the org-source code."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((org-source (buffer-string))
        (url-to-org (bf-get-url-to-org-source))
        (yaml (bf-get-YAML-heading))
        (body (bf-get-HTML)))

    (<span style="color: #0000FF;">with-temp-buffer</span>
      (insert yaml)
      (insert body)
      (insert
       (format <span style="color: #008000;">"&lt;p&gt;Copyright (C) %s by John Kitchin. See the &lt;a href=\"/copying.html\"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;"</span>
               (format-time-string <span style="color: #008000;">"%Y"</span>)))
      (insert (format <span style="color: #008000;">"&lt;p&gt;&lt;a href=\"%s\"&gt;org-mode source&lt;/a&gt;&lt;p&gt;"</span>
                      url-to-org))
      (insert (format <span style="color: #008000;">"&lt;p&gt;Org-mode version = %s&lt;/p&gt;"</span> (org-version)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is the only new code we need to add.</span>
      (insert (source-data-uri org-source))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return value</span>
      (buffer-string))))
</pre>
</div>

<p>
Now we need a new adaptation of the grab-org-source function. We still need a regexp search to get the source, and we still need to decode it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">grab-org-source</span> (url)
  <span style="color: #036A07;">"Extract org-source from URL to a buffer named *grab-org-source*."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sURL: "</span>)
  (switch-to-buffer (get-buffer-create <span style="color: #008000;">"*grab-org-source*"</span>))
  (erase-buffer)
  (org-mode)
  (insert
   (<span style="color: #0000FF;">with-current-buffer</span>
       (url-retrieve-synchronously url)
     (<span style="color: #0000FF;">let</span> (start)
       (re-search-forward
        <span style="color: #008000;">"&lt;a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">[</span><span style="color: #008000;">^</span><span style="color: #008000;">\"]*</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">\\\"&gt;"</span> nil t)
       (base64-decode-string  (match-string 1))))))
</pre>
</div>

<p>
What else could we do with this? One idea would be to generate data uris for each code block that you could open in your browser. For example, here we generate a list of data uris for each code block in the buffer. We don't take care to label them or make it easy to see what they are, but if you click on one, you should see a plain text version of the block. If this is done a lot, it might even make sense to change the mime type to download the code in some native app.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-element-map (org-element-parse-buffer) 'src-block
  (<span style="color: #0000FF;">lambda</span> (src-block)
    (source-data-uri (org-element-property <span style="color: #006FE0;">:value</span> src-block))))
</pre>
</div>

(<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBMUzArIikK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIHNvdXJjZS1kYXRhLXVyaSAoc291cmNlKQogICJFbmNvZGUgdGhlIHN0cmluZyBpbiBT
T1VSQ0UgdG8gYSBkYXRhIHVyaS4iCiAgKGZvcm1hdAogICAiPGEgY2xhc3M9XCJvcmctc291cmNl
XCIgaHJlZj1cImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jhc2U2NCwlc1wiPnNv
dXJjZTwvYT4iCiAgIChiYXNlNjQtZW5jb2RlLXN0cmluZyBzb3VyY2UpKSkKCihzb3VyY2UtZGF0
YS11cmkgKGJ1ZmZlci1zdHJpbmcpKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGJmLWdldC1wb3N0LWh0bWwgKCkKICAiUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcg
dGhlIFlBTUwgaGVhZGVyLCB0aGUgcG9zdCBodG1sLCBteQpjb3B5cmlnaHQgbGluZSwgYW5kIGEg
bGluayB0byB0aGUgb3JnLXNvdXJjZSBjb2RlLiIKICAoaW50ZXJhY3RpdmUpCiAgKGxldCAoKG9y
Zy1zb3VyY2UgKGJ1ZmZlci1zdHJpbmcpKQoJKHVybC10by1vcmcgKGJmLWdldC11cmwtdG8tb3Jn
LXNvdXJjZSkpCgkoeWFtbCAoYmYtZ2V0LVlBTUwtaGVhZGluZykpCgkoYm9keSAoYmYtZ2V0LUhU
TUwpKSkKCiAgICAod2l0aC10ZW1wLWJ1ZmZlcgogICAgICAoaW5zZXJ0IHlhbWwpCiAgICAgIChp
bnNlcnQgYm9keSkKICAgICAgKGluc2VydAogICAgICAgKGZvcm1hdCAiPHA+Q29weXJpZ2h0IChD
KSAlcyBieSBKb2huIEtpdGNoaW4uIFNlZSB0aGUgPGEgaHJlZj1cIi9jb3B5aW5nLmh0bWxcIj5M
aWNlbnNlPC9hPiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY29weWluZy48cD4iCgkgICAgICAgKGZv
cm1hdC10aW1lLXN0cmluZyAiJVkiKSkpCiAgICAgIChpbnNlcnQgKGZvcm1hdCAiPHA+PGEgaHJl
Zj1cIiVzXCI+b3JnLW1vZGUgc291cmNlPC9hPjxwPiIKCQkgICAgICB1cmwtdG8tb3JnKSkKICAg
ICAgKGluc2VydCAoZm9ybWF0ICI8cD5PcmctbW9kZSB2ZXJzaW9uID0gJXM8L3A+IiAob3JnLXZl
cnNpb24pKSkKICAgICAgOzsgdGhpcyBpcyB0aGUgb25seSBuZXcgY29kZSB3ZSBuZWVkIHRvIGFk
ZC4KICAgICAgKGluc2VydCAoc291cmNlLWRhdGEtdXJpIG9yZy1zb3VyY2UpKQogICAgICA7OyBy
ZXR1cm4gdmFsdWUKICAgICAgKGJ1ZmZlci1zdHJpbmcpKSkpCg==">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGdyYWItb3JnLXNvdXJjZSAodXJsKQogICJFeHRyYWN0IG9yZy1zb3VyY2UgZnJvbSBV
UkwgdG8gYSBidWZmZXIgbmFtZWQgKmdyYWItb3JnLXNvdXJjZSouIgogIChpbnRlcmFjdGl2ZSAi
c1VSTDogIikKICAoc3dpdGNoLXRvLWJ1ZmZlciAoZ2V0LWJ1ZmZlci1jcmVhdGUgIipncmFiLW9y
Zy1zb3VyY2UqIikpCiAgKGVyYXNlLWJ1ZmZlcikKICAob3JnLW1vZGUpCiAgKGluc2VydAogICAo
d2l0aC1jdXJyZW50LWJ1ZmZlcgogICAgICAgKHVybC1yZXRyaWV2ZS1zeW5jaHJvbm91c2x5IHVy
bCkKICAgICAobGV0IChzdGFydCkKICAgICAgIChyZS1zZWFyY2gtZm9yd2FyZAoJIjxhIGNsYXNz
PVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSTti
YXNlNjQsXFwoW15cIl0qXFwpXFxcIj4iIG5pbCB0KQogICAgICAgKGJhc2U2NC1kZWNvZGUtc3Ry
aW5nICAobWF0Y2gtc3RyaW5nIDEpKSkpKSkK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KG9yZy1lbGVtZW50LW1hcCAob3JnLWVsZW1lbnQtcGFyc2UtYnVmZmVyKSAnc3JjLWJsb2NrCiAg
KGxhbWJkYSAoc3JjLWJsb2NrKQogICAgKHNvdXJjZS1kYXRhLXVyaSAob3JnLWVsZW1lbnQtcHJv
cGVydHkgOnZhbHVlIHNyYy1ibG9jaykpKSkK">source</a>)


<p>
I am not sure if this is better or worse than the other approach. I have not tested it very thoroughly, but it seems like it should work pretty generally. I imagine you could also embed other kinds of files in the html, if for some reason you did not want to put the files on your server. Overall this seems to lack some elegance in searching for data, e.g. like <a href="http://en.wikipedia.org/wiki/Embedded_RDF">RDF</a> or <a href="http://en.wikipedia.org/wiki/RDFa">RDFa</a> is supposed to enable, but it might be a step in that direction, using org-mode and Emacs as the editor.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/09/Another-approach-to-embedding-org-source-in-html.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p><a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBET05FIEFub3RoZXIgYXBwcm9hY2ggdG8gZW1iZWRkaW5nIG9yZy1zb3VyY2UgaW4gaHRtbAog
IENMT1NFRDogWzIwMTUtMDUtMDkgU2F0IDE5OjE5XQogIDpQUk9QRVJUSUVTOgogIDpkYXRlOiAg
ICAgMjAxNS8wNS8wOSAxOToxOToxMAogIDp1cGRhdGVkOiAgMjAxNS8wNS8xMCAwOTozNDo1NQog
IDpjYXRlZ29yaWVzOiBvcmdtb2RlLCBkYXRhCiAgOkVORDoKSW4gdGhpcyBbW2h0dHA6Ly9raXRj
aGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4tYWx0ZXJuYXRpdmUtYXBw
cm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0cy9dW3Bvc3RdXSBJIGV4
YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEgY29tbWVudCBpbiB0aGUg
aHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFibHkgY29udmVuaWVudCB3
YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93bnNpZGUgb2YgdGhlIGFw
cHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhlIGRhc2hlcywgYW5kIHRo
ZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNyb3NzIGFub3RoZXIgaWRl
YSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2NCBlbmNvZGVkIGZvcm0g
aW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9VUklfc2NoZW1lXVtkYXRh
IHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGluZyBtZWFuczoKCiMrQkVH
SU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQoj
K0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFuZCBkZWNvZGluZzoKCiMr
QkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBM
UzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+CgpUaGUgZW5jb2Rpbmcg
bG9va3MgcmFuZG9tLCBidXQgaXQgaXMgcmV2ZXJzaWJsZS4gTW9yZSBpbXBvcnRhbnRseSwgaXQg
cHJvYmFibHkgd2lsbCBub3QgaGF2ZSBhbnkgaHRtbCBsaWtlIGNoYXJhY3RlcnMgaW4gaXQgdGhh
dCBuZWVkIGVzY2FwZWQuIFRoZSBpZGVhIG9mIGEgZGF0YSB1cmkgaXMgdGhhdCB0aGUgZGF0YSBp
dCBzZXJ2ZXMgaXMgZW1iZWRkZWQgaW4gdGhlIFVSTCBocmVmIGF0dHJpYnV0ZS4gVGhpcyBpcyBi
YXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0aGUgdXJsIGhlcmUgYSBj
bGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFNUExFCjxhIGNsYXNzPSJz
b21lLW9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jh
c2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0VYQU1QTEUKCkhlcmUgaXMg
dGhlIGFjdHVhbCBodG1sIGZvciB0aGUgYnJvd3Nlci4gSWYgeW91IGNsaWNrIG9uIGl0LCB5b3Vy
IGJyb3dzZXIgYXV0b21hdGljYWxseSBkZWNvZGVzIGl0IGZvciB5b3UhCiMrQkVHSU5fSFRNTAo8
YSBjbGFzcz0ic29tZS1vcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9IVE1MCgpT
bywgZHVyaW5nIHRoZSBibG9nIHB1Ymxpc2ggc3RlcCwgd2UganVzdCBuZWVkIHRvIGFkZCB0aGlz
IGxpdHRsZSBzdGVwIHRvIHRoZSBodG1sIGdlbmVyYXRpb24sIGFuZCBpdCB3aWxsIGJlIGluY2x1
ZGVkIGFzIGEgZGF0YSB1cmkuIEhlcmUgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRo
ZSBkYXRhIHVyaSBmb3IgdXMsIGFuZCBleGFtcGxlIG9mIHVzaW5nIGl0LiBUaGUgZW5jb2RlZCBz
b3VyY2UgaXMgbm90IGF0IGFsbCBhdHRyYWN0aXZlIHRvIGxvb2sgYXQgaXQsIGJ1dCB5b3UgYWxt
b3N0IG5ldmVyIG5lZWQgdG8gbG9vayBhdCBpdCwgaXQgaXMgaW52aXNpYmxlIGluIHRoZSBicm93
c2VyLiBJbnRlcmVzdGluZ2x5LCBpZiB5b3UgY2xpY2sgb24gdGhlIGxpbmssIHlvdSB3aWxsIHNl
ZSB0aGUgb3JnIHNvdXJjZSByaWdodCBpbiB5b3VyIGJyb3dzZXIhCgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIj5zb3VyY2U8L2E+IgogICAoYmFzZTY0LWVuY29kZS1zdHJpbmcg
c291cmNlKSkpCgooc291cmNlLWRhdGEtdXJpIChidWZmZXItc3RyaW5nKSkKIytFTkRfU1JDCgoj
K1JFU1VMVFM6CiMrQkVHSU5fSFRNTAo8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0
ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtpQkJibTkwYUdWeUlHRndjSEp2WVdO
b0lIUnZJR1Z0WW1Wa1pHbHVaeUJ2Y21jdGMyOTFjbU5sSUdsdUlHaDBiV3dLU1c0Z2RHaHAKY3lC
YlcyaDBkSEE2THk5cmFYUmphR2x1WjNKdmRYQXVZMmhsYldVdVkyMTFMbVZrZFM5aWJHOW5Mekl3
TVRVdk1EVXZNRGt2UVc0dApZV3gwWlhKdVlYUnBkbVV0WVhCd2NtOWhZMmd0ZEc4dGFXNWpiSFZr
YVc1bkxXOXlaeTF6YjNWeVkyVXRhVzR0WW14dlp5MXdiM04wCmN5OWRXM0J2YzNSZFhTQkpJR1Y0
WVcxcGJtVmtJR0VnZDJGNUlIUnZJR1Z0WW1Wa0lIUm9aU0J2Y21jdGMyOTFjbU5sSUdsdUlHRWcK
WTI5dGJXVnVkQ0JwYmlCMGFHVWdhSFJ0YkNCdlppQjBhR1VnY0c5emRDd2dZVzVrSUdSbGRtVnNi
M0JsWkNCaElISmxZWE52Ym1GaQpiSGtnWTI5dWRtVnVhV1Z1ZENCM1lYa2dkRzhnWlhoMGNtRmpk
Q0IwYUdVZ2MyOTFjbU5sSUdsdUlHVnRZV056TGlCUGJtVWdaRzkzCmJuTnBaR1VnYjJZZ2RHaGxJ
R0Z3Y0hKdllXTm9JSGRoY3lCMGFHVWdibVZsWkNCMGJ5QmxjMk5oY0dVZ1lYUWdiR1ZoYzNRZ2RH
aGwKSUdSaGMyaGxjeXdnWVc1a0lIUm9aVzRnZFc1bGMyTmhjR1VnZEdobGJTQnZiaUJsZUhSeVlX
TjBhVzl1TGlCSklHTmhiV1VnWVdOeQpiM056SUdGdWIzUm9aWElnYVdSbFlTd2dkMmhwWTJnZ2FY
TWdkRzhnY0hWMElIUm9aU0J2Y21jdGMyOTFjbU5sSUdsdUlHSmhjMlUyCk5DQmxibU52WkdWa0lH
WnZjbTBnYVc0Z1lTQmJXMmgwZEhBNkx5OWxiaTUzYVd0cGNHVmthV0V1YjNKbkwzZHBhMmt2UkdG
MFlWOVYKVWtsZmMyTm9aVzFsWFZ0a1lYUmhJSFZ5YVYxZExnb0tSbWx5YzNRZ2JHVjBJSFZ6SUhO
bFpTQjNhR0YwSUhSb1pTQmxibU52WkdsdQpaeUJ0WldGdWN6b0tDaU1yUWtWSFNVNWZVMUpESUdW
dFlXTnpMV3hwYzNBS0tHSmhjMlUyTkMxbGJtTnZaR1V0YzNSeWFXNW5JQ0k4CklTMHRJSFJsYzNR
dExUNGlLUW9qSzBWT1JGOVRVa01LSXl0U1JWTlZURlJUT2dvNklGQkRSWFJNVTBJd1dsaE9NRXhU
TUNzS0NrRnUKWkNCa1pXTnZaR2x1WnpvS0NpTXJRa1ZIU1U1ZlUxSkRJR1Z0WVdOekxXeHBjM0FL
S0dKaGMyVTJOQzFrWldOdlpHVXRjM1J5YVc1bgpJQ0pRUTBWMFRGTkNNRnBZVGpCTVV6QXJJaWtL
SXl0RlRrUmZVMUpEQ2dvaksxSkZVMVZNVkZNNkNqb2dQQ0V0TFNCMFpYTjBMUzArCkNncEJibVFn
ZEdocGN5QnBjeUJpWVhOcFkyRnNiSGtnYUc5M0lIUnZJRzFoYTJVZ1lTQmtZWFJoSUhWeWFTNGdW
MlVnWjJsMlpTQjAKYUdVZ2RYSnNJR2hsY21VZ1lTQmpiR0Z6Y3lCemJ5QjNaU0JqWVc0Z1ptbHVa
Q0JwZENCc1lYUmxjaTRLSXl0Q1JVZEpUbDlGV0VGTgpVRXhGQ2p4aElHTnNZWE56UFNKdmNtY3Rj
MjkxY21ObElpQm9jbVZtUFNKa1lYUmhPblJsZUhRdmNHeGhhVzQ3WTJoaGNuTmxkRDFWClV5MUJV
ME5KU1R0aVlYTmxOalFzVUVORmRFeFRRakJhV0U0d1RGTXdLeUkrYzI5MWNtTmxQQzloUGdvaksw
Vk9SRjlGV0VGTlVFeEYKQ2dwSVpYSmxJR2x6SUhSb1pTQmhZM1IxWVd3Z2FIUnRiQ0JtYjNJZ2RH
aGxJR0p5YjNkelpYSTZJQW9qSzBKRlIwbE9YMGhVVFV3SwpQR0VnWTJ4aGMzTTlJbTl5WnkxemIz
VnlZMlVpSUdoeVpXWTlJbVJoZEdFNmRHVjRkQzl3YkdGcGJqdGphR0Z5YzJWMFBWVlRMVUZUClEw
bEpPMkpoYzJVMk5DeFFRMFYwVEZOQ01GcFlUakJNVXpBcklqNXpiM1Z5WTJVOEwyRStDaU1yUlU1
RVgwaFVUVXdLQ2xOdkxDQmsKZFhKcGJtY2dkR2hsSUdKc2IyY2djSFZpYkdsemFDQnpkR1Z3TENC
M1pTQnFkWE4wSUc1bFpXUWdkRzhnWVdSa0lIUm9hWE1nYkdsMApkR3hsSUhOMFpYQWdkRzhnZEdo
bElHaDBiV3dnWjJWdVpYSmhkR2x2Yml3Z1lXNWtJR2wwSUhkcGJHd2dZbVVnYVc1amJIVmtaV1Fn
CllYTWdZU0JrWVhSaElIVnlhUzRnU0dWeVpTQnBjeUIwYUdVZ1puVnVZM1JwYjI0Z2RHaGhkQ0Ju
Wlc1bGNtRjBaWE1nZEdobElHUmgKZEdFZ2RYSnBJR1p2Y2lCMWN5d2dZVzVrSUdWNFlXMXdiR1Vn
YjJZZ2RYTnBibWNnYVhRNkNnb2pLMEpGUjBsT1gxTlNReUJsYldGagpjeTFzYVhOd0lDQTZjbVZ6
ZFd4MGN5Qm9kRzFzQ2loa1pXWjFiaUJ6YjNWeVkyVXRaR0YwWVMxMWNta2dLSE52ZFhKalpTa0tJ
Q0FpClJXNWpiMlJsSUhSb1pTQnpkSEpwYm1jZ2FXNGdVMDlWVWtORklIUnZJR0VnWkdGMFlTQjFj
bWt1SWdvZ0lDaG1iM0p0WVhRS0lDQWcKSWp4aElHTnNZWE56UFZ3aWIzSm5MWE52ZFhKalpWd2lJ
R2h5WldZOVhDSmtZWFJoT25SbGVIUXZjR3hoYVc0N1kyaGhjbk5sZEQxVgpVeTFCVTBOSlNUdGlZ
WE5sTmpRc0pYTmNJaUJrYjNkdWJHOWhaRDFjSW5OdmRYSmpaUzV2Y21kY0lqNXpiM1Z5WTJVOEwy
RStJaUFLCklDQWdLR0poYzJVMk5DMWxibU52WkdVdGMzUnlhVzVuSUhOdmRYSmpaU2twS1FvS0tI
TnZkWEpqWlMxa1lYUmhMWFZ5YVNBb1luVm0KWm1WeUxYTjBjbWx1WnlrcENpTXJSVTVFWDFOU1F3
b0tDZ29LQ2dvSyIgZG93bmxvYWQ9InNvdXJjZS5vcmciPnNvdXJjZTwvYT4KIytFTkRfSFRNTAoK
Tm93LCB3ZSBpbnRlZ3JhdGUgaXQgaW50byB0aGUgYmxvZ29maWxlIGZ1bmN0aW9uOgoKIytCRUdJ
Tl9TUkMgZW1hY3MtbGlzcAooZGVmdW4gYmYtZ2V0LXBvc3QtaHRtbCAoKQogICJSZXR1cm4gYSBz
dHJpbmcgY29udGFpbmluZyB0aGUgWUFNTCBoZWFkZXIsIHRoZSBwb3N0IGh0bWwsIG15CmNvcHly
aWdodCBsaW5lLCBhbmQgYSBsaW5rIHRvIHRoZSBvcmctc291cmNlIGNvZGUuIgogIChpbnRlcmFj
dGl2ZSkKICAobGV0ICgob3JnLXNvdXJjZSAoYnVmZmVyLXN0cmluZykpCgkodXJsLXRvLW9yZyAo
YmYtZ2V0LXVybC10by1vcmctc291cmNlKSkKCSh5YW1sIChiZi1nZXQtWUFNTC1oZWFkaW5nKSkK
CShib2R5IChiZi1nZXQtSFRNTCkpKQoKICAgICh3aXRoLXRlbXAtYnVmZmVyCiAgICAgIChpbnNl
cnQgeWFtbCkKICAgICAgKGluc2VydCBib2R5KQogICAgICAoaW5zZXJ0CiAgICAgICAoZm9ybWF0
ICI8cD5Db3B5cmlnaHQgKEMpICVzIGJ5IEpvaG4gS2l0Y2hpbi4gU2VlIHRoZSA8YSBocmVmPVwi
L2NvcHlpbmcuaHRtbFwiPkxpY2Vuc2U8L2E+IGZvciBpbmZvcm1hdGlvbiBhYm91dCBjb3B5aW5n
LjxwPiIKCSAgICAgICAoZm9ybWF0LXRpbWUtc3RyaW5nICIlWSIpKSkKICAgICAgKGluc2VydCAo
Zm9ybWF0ICI8cD48YSBocmVmPVwiJXNcIj5vcmctbW9kZSBzb3VyY2U8L2E+PHA+IgoJCSAgICAg
IHVybC10by1vcmcpKQogICAgICAoaW5zZXJ0IChmb3JtYXQgIjxwPk9yZy1tb2RlIHZlcnNpb24g
PSAlczwvcD4iIChvcmctdmVyc2lvbikpKQogICAgICA7OyB0aGlzIGlzIHRoZSBvbmx5IG5ldyBj
b2RlIHdlIG5lZWQgdG8gYWRkLgogICAgICAoaW5zZXJ0IChzb3VyY2UtZGF0YS11cmkgb3JnLXNv
dXJjZSkpCiAgICAgIDs7IHJldHVybiB2YWx1ZQogICAgICAoYnVmZmVyLXN0cmluZykpKSkKIytF
TkRfU1JDCgpOb3cgd2UgbmVlZCBhIG5ldyBhZGFwdGF0aW9uIG9mIHRoZSBncmFiLW9yZy1zb3Vy
Y2UgZnVuY3Rpb24uIFdlIHN0aWxsIG5lZWQgYSByZWdleHAgc2VhcmNoIHRvIGdldCB0aGUgc291
cmNlLCBhbmQgd2Ugc3RpbGwgbmVlZCB0byBkZWNvZGUgaXQuCgojK0JFR0lOX1NSQyBlbWFjcy1s
aXNwCihkZWZ1biBncmFiLW9yZy1zb3VyY2UgKHVybCkKICAiRXh0cmFjdCBvcmctc291cmNlIGZy
b20gVVJMIHRvIGEgYnVmZmVyIG5hbWVkICpncmFiLW9yZy1zb3VyY2UqLiIKICAoaW50ZXJhY3Rp
dmUgInNVUkw6ICIpCiAgKHN3aXRjaC10by1idWZmZXIgKGdldC1idWZmZXItY3JlYXRlICIqZ3Jh
Yi1vcmctc291cmNlKiIpKQogIChlcmFzZS1idWZmZXIpCiAgKG9yZy1tb2RlKQogIChpbnNlcnQK
ICAgKHdpdGgtY3VycmVudC1idWZmZXIKICAgICAgICh1cmwtcmV0cmlldmUtc3luY2hyb25vdXNs
eSB1cmwpCiAgICAgKGxldCAoc3RhcnQpCiAgICAgICAocmUtc2VhcmNoLWZvcndhcmQKCSI8YSBj
bGFzcz1cIm9yZy1zb3VyY2VcIiBocmVmPVwiZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVND
SUk7YmFzZTY0LFxcKFteXCJdKlxcKVxcXCI+IiBuaWwgdCkKICAgICAgIChiYXNlNjQtZGVjb2Rl
LXN0cmluZyAgKG1hdGNoLXN0cmluZyAxKSkpKSkpCiMrRU5EX1NSQwoKV2hhdCBlbHNlIGNvdWxk
IHdlIGRvIHdpdGggdGhpcz8gT25lIGlkZWEgd291bGQgYmUgdG8gZ2VuZXJhdGUgZGF0YSB1cmlz
IGZvciBlYWNoIGNvZGUgYmxvY2sgdGhhdCB5b3UgY291bGQgb3BlbiBpbiB5b3VyIGJyb3dzZXIu
IEZvciBleGFtcGxlLCBoZXJlIHdlIGdlbmVyYXRlIGEgbGlzdCBvZiBkYXRhIHVyaXMgZm9yIGVh
Y2ggY29kZSBibG9jayBpbiB0aGUgYnVmZmVyLiBXZSBkb24ndCB0YWtlIGNhcmUgdG8gbGFiZWwg
dGhlbSBvciBtYWtlIGl0IGVhc3kgdG8gc2VlIHdoYXQgdGhleSBhcmUsIGJ1dCBpZiB5b3UgY2xp
Y2sgb24gb25lLCB5b3Ugc2hvdWxkIHNlZSBhIHBsYWluIHRleHQgdmVyc2lvbiBvZiB0aGUgYmxv
Y2suIElmIHRoaXMgaXMgZG9uZSBhIGxvdCwgaXQgbWlnaHQgZXZlbiBtYWtlIHNlbnNlIHRvIGNo
YW5nZSB0aGUgbWltZSB0eXBlIHRvIGRvd25sb2FkIHRoZSBjb2RlIGluIHNvbWUgbmF0aXZlIGFw
cC4KCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AgOnJlc3VsdHMgaHRtbAoob3JnLWVsZW1lbnQtbWFw
IChvcmctZWxlbWVudC1wYXJzZS1idWZmZXIpICdzcmMtYmxvY2sKICAobGFtYmRhIChzcmMtYmxv
Y2spCiAgICAoc291cmNlLWRhdGEtdXJpIChvcmctZWxlbWVudC1wcm9wZXJ0eSA6dmFsdWUgc3Jj
LWJsb2NrKSkpKQojK0VORF9TUkMKCiMrUkVTVUxUUzoKIytCRUdJTl9IVE1MCig8YSBjbGFzcz0i
b3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0
LEtHSmhjMlUyTkMxbGJtTnZaR1V0YzNSeWFXNW5JQ0k4SVMwdElIUmxjM1F0TFQ0aUtRbz0iPnNv
dXJjZTwvYT4gPGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFy
c2V0PVVTLUFTQ0lJO2Jhc2U2NCxLR0poYzJVMk5DMWtaV052WkdVdGMzUnlhVzVuSUNKUVEwVjBU
Rk5DTUZwWVRqQk1VekFySWlrSyI+c291cmNlPC9hPiA8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJl
Zj0iZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtHUmxablZ1SUhOdmRY
SmpaUzFrWVhSaExYVnlhU0FvYzI5MWNtTmxLUW9nSUNKRmJtTnZaR1VnZEdobElITjBjbWx1WnlC
cGJpQlQKVDFWU1EwVWdkRzhnWVNCa1lYUmhJSFZ5YVM0aUNpQWdLR1p2Y20xaGRBb2dJQ0FpUEdF
Z1kyeGhjM005WENKdmNtY3RjMjkxY21ObApYQ0lnYUhKbFpqMWNJbVJoZEdFNmRHVjRkQzl3YkdG
cGJqdGphR0Z5YzJWMFBWVlRMVUZUUTBsSk8ySmhjMlUyTkN3bGMxd2lQbk52CmRYSmpaVHd2WVQ0
aUNpQWdJQ2hpWVhObE5qUXRaVzVqYjJSbExYTjBjbWx1WnlCemIzVnlZMlVwS1NrS0NpaHpiM1Z5
WTJVdFpHRjAKWVMxMWNta2dLR0oxWm1abGNpMXpkSEpwYm1jcEtRbz0iPnNvdXJjZTwvYT4gPGEg
Y2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJ
O2Jhc2U2NCxLR1JsWm5WdUlHSm1MV2RsZEMxd2IzTjBMV2gwYld3Z0tDa0tJQ0FpVW1WMGRYSnVJ
R0VnYzNSeWFXNW5JR052Ym5SaGFXNXBibWNnCmRHaGxJRmxCVFV3Z2FHVmhaR1Z5TENCMGFHVWdj
Rzl6ZENCb2RHMXNMQ0J0ZVFwamIzQjVjbWxuYUhRZ2JHbHVaU3dnWVc1a0lHRWcKYkdsdWF5QjBi
eUIwYUdVZ2IzSm5MWE52ZFhKalpTQmpiMlJsTGlJS0lDQW9hVzUwWlhKaFkzUnBkbVVwQ2lBZ0tH
eGxkQ0FvS0c5eQpaeTF6YjNWeVkyVWdLR0oxWm1abGNpMXpkSEpwYm1jcEtRb0pLSFZ5YkMxMGJ5
MXZjbWNnS0dKbUxXZGxkQzExY213dGRHOHRiM0puCkxYTnZkWEpqWlNrcENna29lV0Z0YkNBb1lt
WXRaMlYwTFZsQlRVd3RhR1ZoWkdsdVp5a3BDZ2tvWW05a2VTQW9ZbVl0WjJWMExVaFUKVFV3cEtT
a0tDaUFnSUNBb2QybDBhQzEwWlcxd0xXSjFabVpsY2dvZ0lDQWdJQ0FvYVc1elpYSjBJSGxoYld3
cENpQWdJQ0FnSUNocApibk5sY25RZ1ltOWtlU2tLSUNBZ0lDQWdLR2x1YzJWeWRBb2dJQ0FnSUNB
Z0tHWnZjbTFoZENBaVBIQStRMjl3ZVhKcFoyaDBJQ2hECktTQWxjeUJpZVNCS2IyaHVJRXRwZEdO
b2FXNHVJRk5sWlNCMGFHVWdQR0VnYUhKbFpqMWNJaTlqYjNCNWFXNW5MbWgwYld4Y0lqNU0KYVdO
bGJuTmxQQzloUGlCbWIzSWdhVzVtYjNKdFlYUnBiMjRnWVdKdmRYUWdZMjl3ZVdsdVp5NDhjRDRp
Q2drZ0lDQWdJQ0FnS0dadgpjbTFoZEMxMGFXMWxMWE4wY21sdVp5QWlKVmtpS1NrcENpQWdJQ0Fn
SUNocGJuTmxjblFnS0dadmNtMWhkQ0FpUEhBK1BHRWdhSEpsClpqMWNJaVZ6WENJK2IzSm5MVzF2
WkdVZ2MyOTFjbU5sUEM5aFBqeHdQaUlLQ1FrZ0lDQWdJQ0IxY213dGRHOHRiM0puS1NrS0lDQWcK
SUNBZ0tHbHVjMlZ5ZENBb1ptOXliV0YwSUNJOGNENVBjbWN0Ylc5a1pTQjJaWEp6YVc5dUlEMGdK
WE04TDNBK0lpQW9iM0puTFhabApjbk5wYjI0cEtTa0tJQ0FnSUNBZ096c2dkR2hwY3lCcGN5QjBh
R1VnYjI1c2VTQnVaWGNnWTI5a1pTQjNaU0J1WldWa0lIUnZJR0ZrClpDNEtJQ0FnSUNBZ0tHbHVj
MlZ5ZENBb2MyOTFjbU5sTFdSaGRHRXRkWEpwSUc5eVp5MXpiM1Z5WTJVcEtRb2dJQ0FnSUNBN095
QnkKWlhSMWNtNGdkbUZzZFdVS0lDQWdJQ0FnS0dKMVptWmxjaTF6ZEhKcGJtY3BLU2twQ2c9PSI+
c291cmNlPC9hPiA8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0ZXh0L3BsYWluO2No
YXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtHUmxablZ1SUdkeVlXSXRiM0puTFhOdmRYSmpaU0FvZFhK
c0tRb2dJQ0pGZUhSeVlXTjBJRzl5WnkxemIzVnlZMlVnWm5KdmJTQlYKVWt3Z2RHOGdZU0JpZFda
bVpYSWdibUZ0WldRZ0ttZHlZV0l0YjNKbkxYTnZkWEpqWlNvdUlnb2dJQ2hwYm5SbGNtRmpkR2wy
WlNBaQpjMVZTVERvZ0lpa0tJQ0FvYzNkcGRHTm9MWFJ2TFdKMVptWmxjaUFvWjJWMExXSjFabVps
Y2kxamNtVmhkR1VnSWlwbmNtRmlMVzl5Clp5MXpiM1Z5WTJVcUlpa3BDaUFnS0dWeVlYTmxMV0ox
Wm1abGNpa0tJQ0FvYjNKbkxXMXZaR1VwQ2lBZ0tHbHVjMlZ5ZEFvZ0lDQW8KZDJsMGFDMWpkWEp5
Wlc1MExXSjFabVpsY2dvZ0lDQWdJQ0FnS0hWeWJDMXlaWFJ5YVdWMlpTMXplVzVqYUhKdmJtOTFj
Mng1SUhWeQpiQ2tLSUNBZ0lDQW9iR1YwSUNoemRHRnlkQ2tLSUNBZ0lDQWdJQ2h5WlMxelpXRnlZ
Mmd0Wm05eWQyRnlaQW9KSWp4aElHTnNZWE56ClBWd2liM0puTFhOdmRYSmpaVndpSUdoeVpXWTlY
Q0prWVhSaE9uUmxlSFF2Y0d4aGFXNDdZMmhoY25ObGREMVZVeTFCVTBOSlNUdGkKWVhObE5qUXNY
RndvVzE1Y0lsMHFYRndwWEZ4Y0lqNGlJRzVwYkNCMEtRb2dJQ0FnSUNBZ0tHSmhjMlUyTkMxa1pX
TnZaR1V0YzNSeQphVzVuSUNBb2JXRjBZMmd0YzNSeWFXNW5JREVwS1NrcEtTa0siPnNvdXJjZTwv
YT4gPGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVT
LUFTQ0lJO2Jhc2U2NCxLRzl5WnkxbGJHVnRaVzUwTFcxaGNDQW9iM0puTFdWc1pXMWxiblF0Y0dG
eWMyVXRZblZtWm1WeUtTQW5jM0pqTFdKc2IyTnJDaUFnCktHeGhiV0prWVNBb2MzSmpMV0pzYjJO
cktRb2dJQ0FnS0hOdmRYSmpaUzFrWVhSaExYVnlhU0FvYjNKbkxXVnNaVzFsYm5RdGNISnYKY0dW
eWRIa2dPblpoYkhWbElITnlZeTFpYkc5amF5a3BLU2tLIj5zb3VyY2U8L2E+KQojK0VORF9IVE1M
CgoKSSBhbSBub3Qgc3VyZSBpZiB0aGlzIGlzIGJldHRlciBvciB3b3JzZSB0aGFuIHRoZSBvdGhl
ciBhcHByb2FjaC4gSSBoYXZlIG5vdCB0ZXN0ZWQgaXQgdmVyeSB0aG9yb3VnaGx5LCBidXQgaXQg
c2VlbXMgbGlrZSBpdCBzaG91bGQgd29yayBwcmV0dHkgZ2VuZXJhbGx5LiBJIGltYWdpbmUgeW91
IGNvdWxkIGFsc28gZW1iZWQgb3RoZXIga2luZHMgb2YgZmlsZXMgaW4gdGhlIGh0bWwsIGlmIGZv
ciBzb21lIHJlYXNvbiB5b3UgZGlkIG5vdCB3YW50IHRvIHB1dCB0aGUgZmlsZXMgb24geW91ciBz
ZXJ2ZXIuIE92ZXJhbGwgdGhpcyBzZWVtcyB0byBsYWNrIHNvbWUgZWxlZ2FuY2UgaW4gc2VhcmNo
aW5nIGZvciBkYXRhLCBlLmcuIGxpa2UgW1todHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Vt
YmVkZGVkX1JERl1bUkRGXV0gb3IgW1todHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JERmFd
W1JERmFdXSBpcyBzdXBwb3NlZCB0byBlbmFibGUsIGJ1dCBpdCBtaWdodCBiZSBhIHN0ZXAgaW4g
dGhhdCBkaXJlY3Rpb24sIHVzaW5nIG9yZy1tb2RlIGFuZCBFbWFjcyBhcyB0aGUgZWRpdG9yLgoK">source</a>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[An alternative approach to including org-source in blog posts]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts" />
    <id>http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts</id>
    <updated>2015-05-09T14:58:24Z</updated>
    <published>2015-05-09T13:50:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <summary type="html"><![CDATA[An alternative approach to including org-source in blog posts]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts"><![CDATA[


<p>
When you publish a Matlab m-file to HTML, Matlab includes the m-file source as an html comment in the output. They also provide a nice function called grabcode that will take a url, and open the source code in the editor. Today, we try a similar approach for org-mode.
</p>

<p>
This post is not totally self-contained. I have my own emacs-lisp module that converts org-mode to blogofile posts, and so far I have not made it broadly available. This is also a super exploratory idea, so I am just going to show the changes I need to make to my setup to get to the evaluation of the idea.
</p>

<p>
The idea is pretty simple, we just insert the current buffer string into an HTML comment. I just modify the bf-get-post-html function lightly to do that. This is a somewhat pathological example since there are html comments in the post! So, we will encode all the dashes to get around that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">browse-url</span>)
(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">bf-get-post-html</span> ()
  <span style="color: #036A07;">"Return a string containing the YAML header, the post html, my</span>
<span style="color: #036A07;">copyright line, and a link to the org-source code."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((org-source (buffer-string))
        (url-to-org (bf-get-url-to-org-source))
        (yaml (bf-get-YAML-heading))
        (body (bf-get-HTML)))

    (<span style="color: #0000FF;">with-temp-buffer</span>
      (insert yaml)
      (insert body)
      (insert
       (format <span style="color: #008000;">"&lt;p&gt;Copyright (C) %s by John Kitchin. See the &lt;a href=\"/copying.html\"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;"</span>
               (format-time-string <span style="color: #008000;">"%Y"</span>)))
      (insert (format <span style="color: #008000;">"&lt;p&gt;&lt;a href=\"%s\"&gt;org-mode source&lt;/a&gt;&lt;p&gt;"</span>
                      url-to-org))
      (insert (format <span style="color: #008000;">"&lt;p&gt;Org-mode version = %s&lt;/p&gt;"</span> (org-version)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is the only new code we need to add.</span>
      (insert (format <span style="color: #008000;">"</span>
<span style="color: #008000;">&lt;!--</span>
<span style="color: #008000;">  ##### SOURCE BEGIN #####</span>
<span style="color: #008000;">%s</span>
<span style="color: #008000;">##### SOURCE END #####</span>
<span style="color: #008000;">--&gt;"</span> (browse-url-url-encode-chars org-source <span style="color: #008000;">"[-]"</span>)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return value</span>
      (buffer-string))))
</pre>
</div>

<p>
By itself, that has limited value to me. So, let's also create a grab-org-source function to get the embedded source and open it in a buffer. This might be a naive approach, we just use a regexp to find the source boundaries and open it in a new buffer. We have to unescape the dashes, which appear as %2D in the comments. Here is our function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">grab-org-source</span> (url)
  <span style="color: #036A07;">"Extract org-source from URL to a buffer named *grab-org-source*."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sURL: "</span>)
  (switch-to-buffer (get-buffer-create <span style="color: #008000;">"*grab-org-source*"</span>))
  (erase-buffer)
  (org-mode)
  (insert
   (<span style="color: #0000FF;">with-current-buffer</span>
       (url-retrieve-synchronously url)
     (<span style="color: #0000FF;">let</span> (start)
       (re-search-forward
        <span style="color: #008000;">"</span>
<span style="color: #008000;">&lt;!--</span>
<span style="color: #008000;">  ##### SOURCE BEGIN #####</span>
<span style="color: #008000;">"</span> nil t)
       (<span style="color: #0000FF;">setq</span> start (point))
       (re-search-forward <span style="color: #008000;">"##### SOURCE END #####</span>
<span style="color: #008000;">--&gt;"</span> nil t)
       (buffer-substring start (match-beginning 0)))))
  (goto-char (point-min))
  (<span style="color: #0000FF;">while</span> (search-forward <span style="color: #008000;">"%2D"</span> nil t)
    (replace-match <span style="color: #008000;">"-"</span>))
  (goto-char (point-min)))
</pre>
</div>

<p>
This concludes my basic proof of concept. I think there is a general escaping challenge in this approach, because it isn't clear if you can put really arbitrary stuff in an html comment, e.g. you cannot put &#x2013;&gt;! I am going to try incorporating this into my posts and see what other issues come up in the future.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>
<!--
  ##### SOURCE BEGIN #####
* DONE An alternative approach to including org%2Dsource in blog posts
  CLOSED: [2015%2D05%2D09 Sat 13:57]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/05/09 13:50:18
  :updated:  2015/05/09 14:58:24
  :END:
When you publish a Matlab m%2Dfile to HTML, Matlab includes the m%2Dfile source as an html comment in the output. They also provide a nice function called grabcode that will take a url, and open the source code in the editor. Today, we try a similar approach for org%2Dmode.

This post is not totally self%2Dcontained. I have my own emacs%2Dlisp module that converts org%2Dmode to blogofile posts, and so far I have not made it broadly available. This is also a super exploratory idea, so I am just going to show the changes I need to make to my setup to get to the evaluation of the idea.

The idea is pretty simple, we just insert the current buffer string into an HTML comment. I just modify the bf%2Dget%2Dpost%2Dhtml function lightly to do that. This is a somewhat pathological example since there are html comments in the post! So, we will encode all the dashes to get around that.

#+BEGIN_SRC emacs%2Dlisp
(require 'browse%2Durl)
(defun bf%2Dget%2Dpost%2Dhtml ()
  "Return a string containing the YAML header, the post html, my
copyright line, and a link to the org%2Dsource code."
  (interactive)
  (let ((org%2Dsource (buffer%2Dstring))
	(url%2Dto%2Dorg (bf%2Dget%2Durl%2Dto%2Dorg%2Dsource))
	(yaml (bf%2Dget%2DYAML%2Dheading))
	(body (bf%2Dget%2DHTML)))

    (with%2Dtemp%2Dbuffer
      (insert yaml)
      (insert body)
      (insert
       (format "<p>Copyright (C) %s by John Kitchin. See the <a href=\"/copying.html\">License</a> for information about copying.<p>"
	       (format%2Dtime%2Dstring "%Y")))
      (insert (format "<p><a href=\"%s\">org%2Dmode source</a><p>"
		      url%2Dto%2Dorg))
      (insert (format "<p>Org%2Dmode version = %s</p>" (org%2Dversion)))
      ;; this is the only new code we need to add.
      (insert (format "
<!%2D%2D
  ##### SOURCE BEGIN #####
%s
##### SOURCE END #####
%2D%2D>" (browse%2Durl%2Durl%2Dencode%2Dchars org%2Dsource "[%2D]")))
      ;; return value
      (buffer%2Dstring))))
#+END_SRC

By itself, that has limited value to me. So, let's also create a grab%2Dorg%2Dsource function to get the embedded source and open it in a buffer. This might be a naive approach, we just use a regexp to find the source boundaries and open it in a new buffer. We have to unescape the dashes, which appear as %2D in the comments. Here is our function.

#+BEGIN_SRC emacs%2Dlisp
(defun grab%2Dorg%2Dsource (url)
  "Extract org%2Dsource from URL to a buffer named *grab%2Dorg%2Dsource*."
  (interactive "sURL: ")
  (switch%2Dto%2Dbuffer (get%2Dbuffer%2Dcreate "*grab%2Dorg%2Dsource*"))
  (erase%2Dbuffer)
  (org%2Dmode)
  (insert
   (with%2Dcurrent%2Dbuffer
       (url%2Dretrieve%2Dsynchronously url)
     (let (start)
       (re%2Dsearch%2Dforward
	"
<!%2D%2D
  ##### SOURCE BEGIN #####
" nil t)
       (setq start (point))
       (re%2Dsearch%2Dforward "##### SOURCE END #####
%2D%2D>" nil t)
       (buffer%2Dsubstring start (match%2Dbeginning 0)))))
  (goto%2Dchar (point%2Dmin))
  (while (search%2Dforward "%2D" nil t)
    (replace%2Dmatch "%2D"))
  (goto%2Dchar (point%2Dmin)))
#+END_SRC

This concludes my basic proof of concept. I think there is a general escaping challenge in this approach, because it isn't clear if you can put really arbitrary stuff in an html comment, e.g. you cannot put %2D%2D>! I am going to try incorporating this into my posts and see what other issues come up in the future.

##### SOURCE END #####
-->]]></content>
  </entry>
</feed>
