<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2015-11-18T01:27:23Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[New Publication in International Journal of Greenhouse Gas Control]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/11/17/New-Publication-in-International-Journal-of-Greenhouse-Gas-Control" />
    <id>http://jkitchin.github.io/blog/2015/11/17/New-Publication-in-International-Journal-of-Greenhouse-Gas-Control</id>
    <updated>2015-11-17T20:27:11Z</updated>
    <published>2015-11-17T20:24:28Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[New Publication in International Journal of Greenhouse Gas Control]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/11/17/New-Publication-in-International-Journal-of-Greenhouse-Gas-Control"><![CDATA[


<p>
We have published a new paper on CO<sub>2</sub> capture in aqueous amino acid solvents! In this collaborative effort with the <a href="http://annalab.org">Anna Research group</a> and NETL, we show that potassium lysinate solvents show potential for CO<sub>2</sub> capture applications using a microfluidic characterization device and a continuously stirred tank reactor. We also examined the aqueous potassium salts of glycine, taurine and proline. Raman spectroscopy was used to characterize the speciation of CO<sub>2</sub> in the solvent. Congratulations Alex!
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">hallenbeck-2015-compar-co2</span>,
  <span style="color: #BA36A5;">author</span> =       "Alexander P. Hallenbeck and Adefemi Egbebi and Kevin P. Resnik
                  and David Hopkinson and Shelley L. Anna and John R. Kitchin",
  <span style="color: #BA36A5;">title</span> =        {Comparative Microfluidic Screening of Amino Acid Salt
                  Solutions for Post-Combustion \ce{CO2} Capture},
  <span style="color: #BA36A5;">journal</span> =      "International Journal of Greenhouse Gas Control ",
  <span style="color: #BA36A5;">volume</span> =       43,
  <span style="color: #BA36A5;">pages</span> =        "189 - 197",
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          {<span style="color: #006DAF; text-decoration: underline;">10.1016/j.ijggc.2015.10.026</span>},
  <span style="color: #BA36A5;">url</span> =
                  "http://www.sciencedirect.com/science/article/pii/S1750583615301134",
  <span style="color: #BA36A5;">issn</span> =         "1750-5836",
}
</pre>
</div>

<p>
See it here: <a href="http://www.sciencedirect.com/science/article/pii/S1750583615301134">http://www.sciencedirect.com/science/article/pii/S1750583615301134</a> 
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/11/17/New-Publication-in-International-Journal-of-Greenhouse-Gas-Control.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Clickable telephone numbers in mu4e messages]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/11/04/Clickable-telephone-numbers-in-mu4e-messages" />
    <id>http://jkitchin.github.io/blog/2015/11/04/Clickable-telephone-numbers-in-mu4e-messages</id>
    <updated>2015-11-04T12:45:12Z</updated>
    <published>2015-11-04T12:45:12Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Clickable telephone numbers in mu4e messages]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/11/04/Clickable-telephone-numbers-in-mu4e-messages"><![CDATA[


<p>
We recently updated our university phone system to a VoIP system that uses Cisco Jabber. I am excited about that because finally I can make phone calls from Emacs with a little applescript automation! So, spoiler alert, this post mostly only applies to Macs, unless you know how to automate a Jabber client to make calls. How to make the telephone numbers clickable is general though, and could be used to do other things as well.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">cisco-call</span> (phone-number)
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sPhone number: "</span>)
  (do-applescript
   (format <span style="color: #008000;">"tell application \"Cisco Jabber\"</span>
<span style="color: #008000;">        activate</span>
<span style="color: #008000;">        tell application \"System Events\" to keystroke \"n\" using {shift down, command down}</span>
<span style="color: #008000;">        tell application \"System Events\" to keystroke \"%s\"</span>
<span style="color: #008000;">        tell application \"System Events\" to key code 36 #return</span>
<span style="color: #008000;">end tell"</span> phone-number)))
</pre>
</div>

<pre class="example">
cisco-call
</pre>

<p>
I would like to go a step further, and make clickable phone numbers in my Emacs buffers. Let's take a look at some options.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> org-mode phone link</h2>
<div class="outline-text-2" id="text-1">
<p>
This is a no-brainer approach. We can define an org-mode link that runs the cisco-call function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 <span style="color: #008000;">"phone"</span>
 (<span style="color: #0000FF;">lambda</span> (phone-number)
   (cisco-call phone-number)))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">lambda</td>
<td class="left">(phone-number)</td>
<td class="left">(cisco-call phone-number)</td>
</tr>
</tbody>
</table>

<p>
This makes simple link that just calls the number in the path of the link.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Clickable text with button-lock</h2>
<div class="outline-text-2" id="text-2">
<p>
I have used the button-lock package very often to make clickable text. Here we use it to highlight phone numbers matching a regular expression that seems to match most US numbers. This seems to work great in org-mode buffers.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">rx</span>)

(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">highlight-phone-numbers</span> nil
 <span style="color: #036A07;">"Button for `</span><span style="color: #D0372D;">highlight-phone-numbers</span><span style="color: #036A07;">'"</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-phone-numbers</span> ()
  <span style="color: #036A07;">"Make phone numbers of the following types clickable:</span>
<span style="color: #036A07;">  (xxx) xxx-xxxx</span>
<span style="color: #036A07;">  xxx.xxx.xxx</span>
<span style="color: #036A07;">  xxxxxxxxxx</span>
<span style="color: #036A07;">  xxx-xxx-xxxx"</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((inhibit-read-only t))
    (<span style="color: #0000FF;">setq</span> highlight-phone-numbers
          (button-lock-set-button
           (<span style="color: #0000FF;">rx</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">optional () around area code</span>
            (optional <span style="color: #008000;">"("</span>)
            (= 3 digit)
            (optional <span style="color: #008000;">")"</span>)
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">delimiters</span>
            (<span style="color: #0000FF;">or</span> (optional <span style="color: #008000;">"-"</span>)
                (optional <span style="color: #008000;">"."</span>)
                (optional <span style="color: #008000;">" "</span>))
            (= 3 digit)
            (<span style="color: #0000FF;">or</span> (optional <span style="color: #008000;">"-"</span>)
                (optional <span style="color: #008000;">"."</span>)
                (optional <span style="color: #008000;">" "</span>))
            (= 4 digit))
           (<span style="color: #0000FF;">lambda</span> ()
             (<span style="color: #0000FF;">interactive</span>)
             (cisco-call (get-surrounding-text-with-property 'phone-number)))
           <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"Darkolivegreen2"</span>)
                   (<span style="color: #006FE0;">:underline</span> t))
           <span style="color: #006FE0;">:help-echo</span> <span style="color: #008000;">"click to call"</span>
           <span style="color: #006FE0;">:keyboard-binding</span> (kbd <span style="color: #008000;">"RET"</span>)
           <span style="color: #006FE0;">:additional-property</span> 'phone-number))))

(add-hook 'text-mode 'highlight-phone-numbers)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">highlight-phone-numbers</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Phone numbers in mu4e messages</h2>
<div class="outline-text-2" id="text-3">
<p>
For some reason, the button-lock package doesn't seem to work in mu4e message buffers, Maybe it is because . The highlight-regexp package does work though, so for these special buffers we use a new approach. We will just put text properties where we want them, and use those properties to make the text clickable.
</p>

<p>
The messages are in read-only buffers, but we can inhibit that so we can modify the properties. All we need to do is create a little key map as a copy of the existing map, define some keys on it, then search through the buffer adding properties to every phone number we find. I wrote a function that does that, and put that function in a hook to run each time I open a message. Whammo, now I have clickable phone numbers in email! It works pretty well for me.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defface</span> <span style="color: #BA36A5;">mu4e-phone-face</span>
  '((t (<span style="color: #006FE0;">:foreground</span> <span style="color: #008000;">"SteelBlue4"</span> <span style="color: #006FE0;">:background</span> <span style="color: #008000;">"Darkolivegreen2"</span> <span style="color: #006FE0;">:underline</span> t)))
  <span style="color: #036A07;">"Phone number directive face."</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">mu4e-highlight-phone-numbers</span> ()
  <span style="color: #036A07;">"Make phone numbers clickable in mu4e-view buffers."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((phone-regex (<span style="color: #0000FF;">rx</span>
                      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">optional () around area code</span>
                      (optional <span style="color: #008000;">"("</span>)
                      (= 3 digit)
                      (optional <span style="color: #008000;">")"</span>)
                      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">delimiters</span>
                      (<span style="color: #0000FF;">or</span> (optional <span style="color: #008000;">"-"</span>)
                          (optional <span style="color: #008000;">"."</span>)
                          (optional <span style="color: #008000;">" "</span>))
                      (= 3 digit)
                      (<span style="color: #0000FF;">or</span> (optional <span style="color: #008000;">"-"</span>)
                          (optional <span style="color: #008000;">"."</span>)
                          (optional <span style="color: #008000;">" "</span>))
                      (= 4 digit))))
    (<span style="color: #0000FF;">save-excursion</span>
      (<span style="color: #0000FF;">let</span> ((inhibit-read-only t))
        (goto-char (point-min))
        (<span style="color: #0000FF;">while</span> (re-search-forward phone-regex nil t)
          (<span style="color: #0000FF;">let</span> ((map (copy-keymap mu4e-view-mode-map))
                (start (match-beginning 0))
                (end (match-end 0)))

            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">set file to be clickable to open the source</span>
            (define-key map [mouse-1]
              `(<span style="color: #0000FF;">lambda</span> ()
                 (<span style="color: #0000FF;">interactive</span>)
                 (cisco-call ,(match-string 0))))

            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">let letter c also make the call</span>
            (define-key map <span style="color: #008000;">"c"</span>
               `(<span style="color: #0000FF;">lambda</span> ()
                 (<span style="color: #0000FF;">interactive</span>)
                 (cisco-call ,(match-string 0))))

            (set-text-properties
             start end
             `(local-map, map
                          face mu4e-phone-face
                          mouse-face highlight
                          help-echo <span style="color: #008000;">"mouse-1: click to call"</span>))))))))

(add-hook 'mu4e-view-mode-hook 'mu4e-highlight-phone-numbers)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Summary</h2>
<div class="outline-text-2" id="text-4">
<p>
That works pretty well for me overall. The phone number regex is not perfect, e.g. it makes any 10 digit number clickable, and it doesn't recognize international numbers. I am not sure I can call those through the Jabber client anyway. This is purely convenience for me to easily make calls from emails, or other kinds of documents I might read in Emacs.
</p>

<p>
I don't use phone calls very often, but an interesting thing might be to open a phone log in org-mode, or open the contact that has that phone number to log that you called them, and provide some notes for them. Alternatively, open a new capture for a phone log that could be refiled later.
</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/11/04/Clickable-telephone-numbers-in-mu4e-messages.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[YAT - yet another template strategy]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/11/01/YAT-yet-another-template-strategy" />
    <id>http://jkitchin.github.io/blog/2015/11/01/YAT-yet-another-template-strategy</id>
    <updated>2015-11-01T14:12:34Z</updated>
    <published>2015-11-01T14:12:34Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[YAT - yet another template strategy]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/11/01/YAT-yet-another-template-strategy"><![CDATA[



<p>
I have another need for a template that is dynamically evaluated. I previously wrote about this <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/01/26/Another-alternative-to-string-templates/">here</a> , and today I am going to do a variation of the theme. We will still use a syntax of $(expression), but a new approach to evaluating the expression. I saw this interesting function to evaluate and replace an s-expression in a buffer <a href="http://emacsredux.com/blog/2013/06/21/eval-and-replace/">Eval and Replace - Emacs Redux</a> . I am going use that to replace a template expression in a string, with a little variation to avoid replacing non-sexp variations, e.g. $(. Here we go.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">eval-and-replace</span> ()
  <span style="color: #036A07;">"Replace the preceding sexp with its value."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (backward-kill-sexp)
  (<span style="color: #0000FF;">condition-case</span> nil
      (princ (eval (read (current-kill 0)))
             (current-buffer))
    (<span style="color: #ff0000; font-weight: bold;">error</span> (message <span style="color: #008000;">"Invalid expression"</span>)
           (insert (concat <span style="color: #008000;">"$"</span> (current-kill 0))))))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">j-format</span> (s)
  <span style="color: #036A07;">"Replace all instances of $(expression) in S with the evaluated</span>
<span style="color: #036A07;">expression."</span>
  (<span style="color: #0000FF;">with-temp-buffer</span>
    (insert s)
    (goto-char (point-min))
    (<span style="color: #0000FF;">while</span> (re-search-forward <span style="color: #008000;">"$("</span> nil t)
      (backward-char)
      (<span style="color: #0000FF;">when</span> (sexp-at-point)
        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">get rid of the $</span>
        (delete-char -1)
        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">go to the end of the sexp and then eval-and-replace it.</span>
        (end-of-sexp)
        (eval-and-replace)))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return the formatted text.</span>
    (buffer-string)))


(<span style="color: #0000FF;">let</span> ((some-var <span style="color: #008000;">"You got me"</span>))
  (j-format <span style="color: #008000;">"Test of 4 + 5 = $(+ 4 5). $(  $(foobar). $(progn (setq x 5) \"\")</span>
<span style="color: #008000;">and then we have 2x=$(prin1 (* 2 x)).</span>

<span style="color: #008000;">some-var = $(print some-var)"</span>))
</pre>
</div>

<pre class="example">
Test of 4 + 5 = 9. $(  $(foobar).
and then we have 2x=10.

some-var = You got me
</pre>

<p>
That seems pretty ok. I obviously have not tested it extensively, but it looks pretty promising.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/11/01/YAT---yet-another-template-strategy.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Saving the current restriction and restoring it while following links]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/24/Saving-the-current-restriction-and-restoring-it-while-following-links" />
    <id>http://jkitchin.github.io/blog/2015/10/24/Saving-the-current-restriction-and-restoring-it-while-following-links</id>
    <updated>2015-10-25T07:09:15Z</updated>
    <published>2015-10-24T13:41:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Saving the current restriction and restoring it while following links]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/24/Saving-the-current-restriction-and-restoring-it-while-following-links"><![CDATA[



<p>
On the org-mode mailing list there has been some discussion about following id links. The issue is that if your buffer is narrowed, clicking on the link does not change the restriction to actually take you to the entry. This is debatably desirable. If I click on a link, I want it to go where it points. But, I might also like to go back to my narrowed view. So here consider how to save the state of narrowing, and restore it. We modify the function that opens an id link to save the restriction, and widen the buffer if necessary.
</p>

<p>
Saving the restriction seems easy, we just save a marker to point, and the point-min and point-max. We save the marker for a convenient way to get the buffer, and perhaps the actual point. We advise the C-c &amp; function to restore the restriction after we leave it. This should fix the restriction in whatever buffer we undid it in.
</p>

<p>
Here is the code that seems to work for me. Thanks to Rasmus for the idea on saving the restriction data.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*saved-restriction*</span> nil
 <span style="color: #036A07;">"A global var containing the current restriction.</span>
<span style="color: #036A07;">Returns (current-buffer point-min point-max"</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">save-current-restriction</span> ()
  <span style="color: #036A07;">"Save the current restriction at point."</span>
  (<span style="color: #0000FF;">setq</span> *saved-restriction*
        (<span style="color: #0000FF;">if</span> (buffer-narrowed-p)
            (list (current-buffer) (point-min) (point-max))
          nil)))

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">restore-saved-restriction</span> ()
  <span style="color: #036A07;">"Restore the last saved restriction."</span>
  (<span style="color: #0000FF;">when</span> *saved-restriction*
    (set-buffer (car *saved-restriction*))
    (narrow-to-region (nth 1 *saved-restriction*)
                      (nth 2 *saved-restriction*)))
  (<span style="color: #0000FF;">setq</span> *saved-restriction* nil))

<span style="color: #8D8D84;">;</span><span style="color: #8D8D84; font-style: italic;">' actually modify this function to save the restriction, and widen if needed.</span>
(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-id-open</span> (id)
  <span style="color: #036A07;">"Go to the entry with id ID."</span>
  (org-mark-ring-push)
  (<span style="color: #0000FF;">let</span> ((m (org-id-find id 'marker))
        cmd)
    (<span style="color: #0000FF;">unless</span> m
      (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"Cannot find entry with ID \"%s\""</span> id))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Use a buffer-switching command in analogy to finding files</span>
    (<span style="color: #0000FF;">setq</span> cmd
          (<span style="color: #0000FF;">or</span>
           (cdr
            (assq
             (cdr (assq 'file org-link-frame-setup))
             '((find-file . switch-to-buffer)
               (find-file-other-window . switch-to-buffer-other-window)
               (find-file-other-frame . switch-to-buffer-other-frame))))
           'switch-to-buffer-other-window))
    (<span style="color: #0000FF;">if</span> (not (equal (current-buffer) (marker-buffer m)))
        (funcall cmd (marker-buffer m)))
    (save-current-restriction)
    (<span style="color: #0000FF;">when</span> (&gt; m (point-max))
      (widen))
    (goto-char m)
    (move-marker m nil)
    (org-show-context)))


<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">And we advise the function going back to restore the restriction.</span>
(<span style="color: #0000FF;">defadvice</span> <span style="color: #006699;">org-mark-ring-goto</span> (after restore-my-restriction () activate)
  <span style="color: #036A07;">"Restore narrowing."</span>
  (restore-saved-restriction))
</pre>
</div>

<pre class="example">
org-mark-ring-goto
</pre>

<p>
This seems to preserve restrictions in the current buffer and in other buffers, as long as I use C-c &amp; to invoke org-mark-ring goto. I am not sure how easy it would be to make this work for all links. Each link has its own function for following so I am not sure we can easily get them all to do this unless there is some high level function to advise like org-mouse-down-mouse or something similar. It also has the limitation that the restoration only occurs using org-mark-ring-goto, unless you specifically run the  (restore-saved-restriction) function yourself. That could be made an interactive function for that purpose. Otherwise, this seems like a reasonable approach.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/24/Saving-the-current-restriction-and-restoring-it-while-following-links.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Line numbers in org-mode code blocks]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/13/Line-numbers-in-org-mode-code-blocks" />
    <id>http://jkitchin.github.io/blog/2015/10/13/Line-numbers-in-org-mode-code-blocks</id>
    <updated>2015-10-13T08:58:34Z</updated>
    <published>2015-10-13T08:58:34Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Line numbers in org-mode code blocks]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/13/Line-numbers-in-org-mode-code-blocks"><![CDATA[



<p>
Some of my students have wanted to show line numbers in code blocks. This is especially useful for when you run a Python block, and you get an error message with a line number in it. Right now, to figure out which line that is, you have to into the code block, type C-c ' to get into edit mode, and turn line numbers on. We look into how to achieve that here.
</p>

<p>
You may want to see the video here: <a href="https://www.youtube.com/watch?v=kinWijGzXms">https://www.youtube.com/watch?v=kinWijGzXms</a> .
</p>

<p>
First, we need to get the region that is the code block. We can find some info in the org-element, but, the :begin and :end include lines we don't want, like the header lines, and the results. But, we can get the beginning, and maybe from there search forward to the block. Run this code block to see where the point goes.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp" id="boring-example"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">a boring comment</span>

(<span style="color: #0000FF;">progn</span>
  (+ 40 2))

(goto-char (org-element-property <span style="color: #006FE0;">:begin</span> (org-element-context)))
(re-search-forward (regexp-quote (org-element-property <span style="color: #006FE0;">:value</span> (org-element-context))))
(goto-char (match-beginning 0))
<span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">number of lines in block. The last carriage return doesn't count.</span>
(1- (length (s-split <span style="color: #008000;">"\n"</span> (org-element-property <span style="color: #006FE0;">:value</span> (org-element-context)))))
</pre>
</div>

<pre class="example">
9
</pre>

<p>
So, we can get the number of lines, and move the point to the first line. For numbers, we will use overlays. Here is a simple way to put a number at the beginning of a line.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> (ov)
  (beginning-of-line)
  (<span style="color: #0000FF;">setq</span> ov (make-overlay (point) (point)))
  (overlay-put ov 'before-string <span style="color: #008000;">"1"</span>))
</pre>
</div>

<pre class="example">
1
</pre>

<p>
The next thing to do is make a function that puts a number at the beginning of a line. We might as well store these overlays in a variable, so they are easy to remove later. This is just for exploration of how to do it. Later we combine all these pieces together.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">number-line-overlays</span> '()
  <span style="color: #036A07;">"List of overlays for line numbers."</span>)

(make-variable-buffer-local 'number-line-overlays)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">number-line</span> (N)
 <span style="color: #036A07;">"Put an overlay at the beginning of a line."</span>
  (beginning-of-line)
  (<span style="color: #0000FF;">let</span> (ov)
    (<span style="color: #0000FF;">setq</span> ov (make-overlay (point) (point)))
    (overlay-put ov 'before-string (format <span style="color: #008000;">"%3s"</span> (number-to-string N)))
    (add-to-list 'number-line-overlays ov)))

(number-line 4)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">#&lt;overlay from 1782 to 1782 in blog.org&gt;</td>
</tr>
</tbody>
</table>


<p>
That looks promising. Let's make a function to clear those overlays. It is so easy it may not even be worth writing.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">number-line-clear</span> ()
  (mapc 'delete-overlay number-line-overlays)
  (<span style="color: #0000FF;">setq</span> number-line-overlays '()))

(number-line-clear)
</pre>
</div>

<p>
Finally, we are ready to hack up the code block numbering code. The numbers will not automatically update, so we will write a function that numbers the block, but only temporarily. Any key press will get rid of the numbers so we can get back to work.  I am going to go ahead and make this a stand-alone function and block.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">number-line-overlays</span> '()
  <span style="color: #036A07;">"List of overlays for line numbers."</span>)

(make-variable-buffer-local 'number-line-overlays)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">number-line-src-block</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">save-excursion</span>
    (<span style="color: #0000FF;">let*</span> ((src-block (org-element-context))
           (nlines (- (length
                       (s-split
                        <span style="color: #008000;">"\n"</span>
                        (org-element-property <span style="color: #006FE0;">:value</span> src-block)))
                      1)))
      (goto-char (org-element-property <span style="color: #006FE0;">:begin</span> src-block))
      (re-search-forward (regexp-quote (org-element-property <span style="color: #006FE0;">:value</span> src-block)))
      (goto-char (match-beginning 0))

      (<span style="color: #0000FF;">loop</span> for i from 1 to nlines
            do
            (beginning-of-line)
            (<span style="color: #0000FF;">let</span> (ov)
              (<span style="color: #0000FF;">setq</span> ov (make-overlay (point) (point)))
              (overlay-put ov 'before-string (format <span style="color: #008000;">"%3s"</span> (number-to-string i)))
              (add-to-list 'number-line-overlays ov))
            (next-line))))

  <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">now read a char to clear them</span>
  (read-key <span style="color: #008000;">"Press a key to clear numbers."</span>)
  (mapc 'delete-overlay number-line-overlays)
  (<span style="color: #0000FF;">setq</span> number-line-overlays '()))

(number-line-src-block)
</pre>
</div>

<p>
I am not sure how to get the numbers to automatically update smoothly like they do in linum-mode. That code uses a lot of hooks to make updates work, and embeds them in a minor mode to get rid of them. It also puts them in the fringe I think, but it is not clear how that is done.
</p>

<p>
We could modify what happens after the numbers are put on, e.g. pressing numbers might jump to a line, or some other kind of functionality. I don't have a critical need for this right now, so I didn't explore it more. Let me know if you have any good ideas for it!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/13/Line-numbers-in-org-mode-code-blocks.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[The Kitchingroup welcomes Kenate Nemera]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/11/The-Kitchingroup-welcomes-Kenate-Nemera" />
    <id>http://jkitchin.github.io/blog/2015/10/11/The-Kitchingroup-welcomes-Kenate-Nemera</id>
    <updated>2015-10-11T14:17:40Z</updated>
    <published>2015-10-11T14:17:40Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <summary type="html"><![CDATA[The Kitchingroup welcomes Kenate Nemera]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/11/The-Kitchingroup-welcomes-Kenate-Nemera"><![CDATA[


<p>
Kenate Nemera is joining us for 9 months on a Fulbright Fellowship! Kenate is an assistant professor at Addis Ababa University in Ethiopia. Kenate will help us with our recent work in modeling metal oxide polymorphs. Welcome Kenate!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/11/The-Kitchingroup-welcomes-Kenate-Nemera.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Automatic latex image toggling when cursor is on a fragment]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment" />
    <id>http://jkitchin.github.io/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment</id>
    <updated>2015-10-09T11:54:50Z</updated>
    <published>2015-10-09T11:54:50Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <summary type="html"><![CDATA[Automatic latex image toggling when cursor is on a fragment]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment"><![CDATA[



<p>
There was a recent suggestion on the org-mode mailing list to make it possible to toggle individual equations in org-mode when the cursor is on them, and have them toggle back when the mouse is off. Presumably, this would let you edit the equation and see the result very easily.
</p>

<p>
The strategy to enable this is to use add a function to the post-command function hook. The function will store the last fragment/environment you were on, and compare it to where you are now.  If they are different the function will put the overlay back on the previous point, and do something appropriate at the current point, e.g. nothing if you are not on a fragment, or remove the overlay of the fragment you are on. The function will get run after every command, so we make sure we are in org-mode first!
</p>

<p>
Here are some example equations.
</p>

<p>
Here is a sentence with an equation \(f^{2x}=3\) and another form \(e^x = 20\) in it.
</p>

<p>
Here is a standalone equation environment.
</p>

\begin{equation}
a + b \sqrt{5o}
\end{equation}

<p>
And now, \[15 + 7 = 12\],
</p>

<p>
It is easiest to see this in a video here: <a href="https://www.youtube.com/watch?v=E0s3PDBqsEc">https://www.youtube.com/watch?v=E0s3PDBqsEc</a> 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">org-latex-fragment-last</span> nil
  <span style="color: #036A07;">"Holds last fragment/environment you were on."</span>)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-latex-fragment-toggle</span> ()
  <span style="color: #036A07;">"Toggle a latex fragment image "</span>
  (<span style="color: #0000FF;">and</span> (eq 'org-mode major-mode)
       (<span style="color: #0000FF;">let*</span> ((el (org-element-context))
              (el-type (car el)))
         (<span style="color: #0000FF;">cond</span>
          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">were on a fragment and now on a new fragment</span>
          ((<span style="color: #0000FF;">and</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">fragment we were on</span>
            org-latex-fragment-last
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and are on a fragment now</span>
            (<span style="color: #0000FF;">or</span>
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type))
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">but not on the last one this is a little tricky. as you edit the</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">fragment, it is not equal to the last one. We use the begin</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">property which is less likely to change for the comparison.</span>
            (not (= (org-element-property <span style="color: #006FE0;">:begin</span> el)
                    (org-element-property <span style="color: #006FE0;">:begin</span> org-latex-fragment-last))))
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">go back to last one and put image back</span>
           (<span style="color: #0000FF;">save-excursion</span>
             (goto-char (org-element-property <span style="color: #006FE0;">:begin</span> org-latex-fragment-last))
             (org-preview-latex-fragment))
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">now remove current image</span>
           (goto-char (org-element-property <span style="color: #006FE0;">:begin</span> el))
           (<span style="color: #0000FF;">let</span> ((ov (<span style="color: #0000FF;">loop</span> for ov in org-latex-fragment-image-overlays
                           if
                           (<span style="color: #0000FF;">and</span>
                            (&lt;= (overlay-start ov) (point))
                            (&gt;= (overlay-end ov) (point)))
                           return ov)))
             (<span style="color: #0000FF;">when</span> ov
               (delete-overlay ov)))
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and save new fragment</span>
           (<span style="color: #0000FF;">setq</span> org-latex-fragment-last el))

          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">were on a fragment and now are not on a fragment</span>
          ((<span style="color: #0000FF;">and</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">not on a fragment now</span>
            (not (<span style="color: #0000FF;">or</span>
                  (eq 'latex-fragment el-type)
                  (eq 'latex-environment el-type)))
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">but we were on one</span>
            org-latex-fragment-last)
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">put image back on</span>
           (<span style="color: #0000FF;">save-excursion</span>
             (goto-char (org-element-property <span style="color: #006FE0;">:begin</span> org-latex-fragment-last))
             (org-preview-latex-fragment))
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">unset last fragment</span>
           (<span style="color: #0000FF;">setq</span> org-latex-fragment-last nil))

          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">were not on a fragment, and now are</span>
          ((<span style="color: #0000FF;">and</span>
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">we were not one one</span>
            (not org-latex-fragment-last)
            <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">but now we are</span>
            (<span style="color: #0000FF;">or</span>
             (eq 'latex-fragment el-type)
             (eq 'latex-environment el-type)))
           (goto-char (org-element-property <span style="color: #006FE0;">:begin</span> el))
           <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">remove image</span>
           (<span style="color: #0000FF;">let</span> ((ov (<span style="color: #0000FF;">loop</span> for ov in org-latex-fragment-image-overlays
                           if
                           (<span style="color: #0000FF;">and</span>
                            (&lt;= (overlay-start ov) (point))
                            (&gt;= (overlay-end ov) (point)))
                           return ov)))
             (<span style="color: #0000FF;">when</span> ov
               (delete-overlay ov)))
           (<span style="color: #0000FF;">setq</span> org-latex-fragment-last el))))))


(add-hook 'post-command-hook 'org-latex-fragment-toggle)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">org-latex-fragment-toggle</td>
<td class="left">matlab-start-block-highlight-timer</td>
<td class="left">eldoc-schedule-timer</td>
</tr>
</tbody>
</table>


<p>
I think there could be another way to do this with text properties, e.g. point-left and point-entered, but that would require those properties to be set on the fragments. I might try that approach another day.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/09/Automatic-latex-image-toggling-when-cursor-is-on-a-fragment.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A checkbox list in org-mode with one value]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/05/A-checkbox-list-in-org-mode-with-one-value" />
    <id>http://jkitchin.github.io/blog/2015/10/05/A-checkbox-list-in-org-mode-with-one-value</id>
    <updated>2015-10-05T19:15:25Z</updated>
    <published>2015-10-05T19:15:25Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[A checkbox list in org-mode with one value]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/05/A-checkbox-list-in-org-mode-with-one-value"><![CDATA[



<p>
A while ago I had a need for a checklist in org-mode where only one value would be checked at a time. Like a radio button in a browser form. That isn't as far as I know a feature yet, but it was not hard to achieve thanks to the org-element api.  My simple idea is to make a function that will be added to the org-checkbox-statistics-hook. The function will uncheck all the boxes, and recheck the one you just clicked with a hybrid of manipulating the cursor and inserting characters with org-element code. We will use an attribute on the checklist to indicate it is a "radio" list. This seems like a feature that might already exist, but I couldn't find it.
</p>

<p>
Here is the code we run. First, we make sure we are on a plain list that has an attr_org property of ":radio", that way this won't apply to all lists, just the radio lists. Then, we loop through each element in the structure, and if it is checked, we replace [X] with [ ]. Then, we reinsert the X and delete a space, which puts [X] where we originally clicked, or used C-c C-c. Finally, we add it to the hook, so it only gets run when a checkbox is changed via clicking with org-mouse, or C-c C-c. Of course, this doesn't work if you type X in the box.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">dash</span>)
(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">check-hook-fn</span> ()
  (<span style="color: #0000FF;">when</span> (-contains? (org-element-property
                     <span style="color: #006FE0;">:attr_org</span>
                     (org-element-property <span style="color: #006FE0;">:parent</span> (org-element-context)))
                    <span style="color: #008000;">":radio"</span>)
    (<span style="color: #0000FF;">save-excursion</span>
      (<span style="color: #0000FF;">loop</span> for el in (org-element-property <span style="color: #006FE0;">:structure</span> (org-element-context))
            do
            (goto-char (car el))
            (<span style="color: #0000FF;">when</span> (re-search-forward <span style="color: #008000;">"\\[X\\]"</span> (line-end-position) t)
              (replace-match <span style="color: #008000;">"[ ]"</span>))))
    (forward-char)
    (insert <span style="color: #008000;">"X"</span>)
    (delete-char 1)))

(add-hook 'org-checkbox-statistics-hook 'check-hook-fn)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">check-hook-fn</td>
</tr>
</tbody>
</table>

<p>
Here is a regular checklist. You can check as many as you want.
</p>
<ul class="org-ul">
<li><code>[X]</code> one
</li>
<li><code>[X]</code> two
</li>
<li><code>[&#xa0;]</code> three
</li>
</ul>

<p>
Now, here is a radio checklist. Only one item at a time can be checked. Nice!
</p>

<ul class="org-ul">
<li><code>[&#xa0;]</code> a
</li>
<li><code>[&#xa0;]</code> b
</li>
<li><code>[X]</code> c
</li>
</ul>

<p>
It is worth noting here that if we put a name on the list, it becomes an addressable data source. First we need this convenient function to get the data associated with a named list.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-get-plain-list</span> (name)
  <span style="color: #036A07;">"Get the org-element representation of a plain-list with NAME."</span>
  (<span style="color: #0000FF;">catch</span> '<span style="color: #D0372D;">found</span>
    (org-element-map
        (org-element-parse-buffer)
        'plain-list
      (<span style="color: #0000FF;">lambda</span> (plain-list)
        (<span style="color: #0000FF;">when</span>
            (string= name (org-element-property <span style="color: #006FE0;">:name</span> plain-list))
          (<span style="color: #0000FF;">throw</span> '<span style="color: #D0372D;">found</span> plain-list))))))
</pre>
</div>

<pre class="example">
org-get-plain-list
</pre>

<p>
Now, let's use that to get the value of the checked item in the "test" list. We define the item as everything after the [X] and get it from a regular expression match.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-radio-list-value</span> (list-name)
  <span style="color: #036A07;">"Return the value of the checked item in a radio list."</span>
  (<span style="color: #0000FF;">save-excursion</span>
    (<span style="color: #0000FF;">loop</span> for el in (org-element-property
                     <span style="color: #006FE0;">:structure</span>
                     (org-jump-to-plain-list list-name))
          if (string= (nth 4 el) <span style="color: #008000;">"[X]"</span>)
          return (<span style="color: #0000FF;">progn</span>
                   (<span style="color: #0000FF;">let</span> ((item (buffer-substring (car el) (car (last el)))))
                     (string-match <span style="color: #008000;">"\\[X\\]</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">.*</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">$"</span> item)
                     (match-string 1 item))))))

(get-radio-list-value <span style="color: #008000;">"test"</span>)
</pre>
</div>

<pre class="example">
c
</pre>

<p>
Perfect. This has lots of potential applications. Data collection and quizzes come to mind, with associated ability to autograde and aggregate the data!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/05/A-checkbox-list-in-org-mode-with-one-value.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A framework for automated feedback with Python and org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/10/03/A-framework-for-automated-feedback-with-Python-and-org-mode" />
    <id>http://jkitchin.github.io/blog/2015/10/03/A-framework-for-automated-feedback-with-Python-and-org-mode</id>
    <updated>2015-10-03T20:29:00Z</updated>
    <published>2015-10-03T20:23:29Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[A framework for automated feedback with Python and org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/10/03/A-framework-for-automated-feedback-with-Python-and-org-mode"><![CDATA[



<p>
<a href="http://docs.autolab.cs.cmu.edu">Autolab</a> is an autograding service that automatically grades code assignments. It uses a program to evaluate a program on a secure virtual system. Using this requires you to run a server, and run code from students. I have never liked that because it is hard to sandbox code well enough to prevent malicious code from doing bad things. Autolab does it well, but it is a heavy solution. Here we explore a local version, one that is used to test for correctness, and not for grading. Here, if you are malicious, you reap what you sow&#x2026;
</p>

<p>
The basic idea I am working towards is that Emacs will provide content to be learned (through org-mode) with active exercises. The exercises will involve a code block, and the user will run a command on their code (or an advised C-c C-c) that checks the solution for correctness. A user will be able to see the solution, and maybe get hints.
</p>

<p>
Suppose we have a problem to solve \(e^x = 3\). This is a simple problem to solve, and here is a solution.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(x) - 3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">solve</span>():
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> fsolve(objective, 3)

<span style="color: #0000FF;">print</span> solve()
</pre>
</div>

<pre class="example">
[ 1.09861229]
</pre>

<p>
We would like to test this for correctness. We code this in a function-based form because we will later use the function <code>solve</code> to test for correctness. Let's see how we could test it with a test function. We will use exec on a string representing our code to get it into our namespace. I don't see a security issue here. You are writing the code! Eventually, we will be passing code to the test framework this way from an org-mode source block.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> unittest
<span style="color: #BA36A5;">TOLERANCE</span> = 1e-5

<span style="color: #BA36A5;">s</span> = <span style="color: #008000;">'''from scipy.optimize import fsolve</span>
<span style="color: #008000;">import numpy as np</span>

<span style="color: #008000;">def objective(x):</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #008000;">   return np.exp(x) - 3</span>

<span style="color: #008000;">def solve():</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #008000;">   return fsolve(objective, 3)[0]</span>

<span style="color: #008000;">print solve()'''</span>

<span style="color: #0000FF;">def</span> <span style="color: #006699;">test_solve</span>(s):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">exec</span> s <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">globals</span>()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">abs</span>(np.log(3) - solve()) &lt;= TOLERANCE):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Correct'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'incorrect'</span>)

test_solve(s)
</pre>
</div>

<pre class="example">
1.09861228867
Correct
</pre>

<p>
Next, we need to think about how we could generate an import statement from a code block name, import in python, and run a test function. We can assume that the test code will be in a file called "test_%s.py" on your python path. Here are the contents of test_solve.py.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np
<span style="color: #BA36A5;">TOLERANCE</span> = 1e-5

<span style="color: #0000FF;">def</span> <span style="color: #006699;">solve_solution</span>():
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">from</span> scipy. optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(x) - 3

<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> fsolve(objective, 3)[0]


<span style="color: #0000FF;">def</span> <span style="color: #006699;">test_solve</span>(s):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">exec</span> s <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">globals</span>()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> (<span style="color: #006FE0;">abs</span>(solve_solution() - solve()) &lt;= TOLERANCE):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Correct!'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">else</span>:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'Incorrect'</span>)
</pre>
</div>

<p>
Now, we can import that, and use the functions. Here is the Python script we need to run to test it.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> test_solve
test_solve.test_solve(<span style="color: #036A07;">'''</span>
<span style="color: #036A07;">from scipy. optimize import fsolve</span>
<span style="color: #036A07;">import numpy as np</span>

<span style="color: #036A07;">def objective(x):</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   return np.exp(x) - 3</span>

<span style="color: #036A07;">def solve():</span>
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span><span style="color: #036A07;">   return fsolve(objective, 3)[0]</span>

<span style="color: #036A07;">print solve()'''</span>)
</pre>
</div>

<pre class="example">
1.09861228867
Correct!
</pre>

<p>
Now, an elisp block to do that. One way to do this is to just run a shell command passing the string to a python interpreter. This is a short way away from an Emacs command now.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((string <span style="color: #008000;">"import test_solve</span>
<span style="color: #008000;">test_solve.test_solve('''</span>
<span style="color: #008000;">from scipy. optimize import fsolve</span>
<span style="color: #008000;">import numpy as np</span>

<span style="color: #008000;">def objective(x):</span>
<span style="color: #008000;">    return np.exp(x) - 3</span>

<span style="color: #008000;">def solve():</span>
<span style="color: #008000;">    return fsolve(objective, 3)[0]</span>

<span style="color: #008000;">print solve()''')"</span>))
  (shell-command-to-string (format <span style="color: #008000;">"python -c \"%s\""</span> string)))
</pre>
</div>

<pre class="example">
1.09861228867
Correct!
</pre>

<p>
Ok, now to wrap it all up in a function we can run from Emacs in a code block to test it. With the cursor in a code block, we get the name, and build the python code, and run it. The function is more complex than I anticipated because I end up  running the code block essentially twice, once to get a results block and once to get the test results. For short problems this is not an issue. I also add the test results in a way that is compatible with the current results.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">check</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let*</span> ((src-block (org-element-context))
         (name (org-element-property <span style="color: #006FE0;">:name</span> src-block))
         (code (org-element-property <span style="color: #006FE0;">:value</span> src-block))
         (end (org-element-property <span style="color: #006FE0;">:end</span> src-block))
         (results)
         (template (format <span style="color: #008000;">"import test_%s</span>
<span style="color: #008000;">test_%s.test_%s('''%s''')"</span> name name name code))
         (output (format
                  <span style="color: #008000;">"\n%s\n"</span>
                  (s-join
                   <span style="color: #008000;">"\n"</span>
                   (mapcar
                    (<span style="color: #0000FF;">lambda</span> (s)
                      (<span style="color: #0000FF;">if</span> (s-starts-with? <span style="color: #008000;">":"</span> s)
                          s
                        (concat <span style="color: #008000;">": "</span> s)))
                    (s-split
                     <span style="color: #008000;">"\n"</span>
                     (shell-command-to-string
                      (format <span style="color: #008000;">"python -c \"%s\""</span> template))))))))
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">execute block as normal</span>
    (org-babel-execute-src-block)
    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and add some output to the Results block</span>
    (<span style="color: #0000FF;">if</span> (org-babel-where-is-src-block-result)
        (<span style="color: #0000FF;">progn</span>
          (goto-char (org-babel-where-is-src-block-result))
          (<span style="color: #0000FF;">setq</span> results (org-element-context))
          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">delete results line</span>
          (kill-line)
          <span style="color: #8D8D84;">;;  </span><span style="color: #8D8D84; font-style: italic;">delete the results</span>
          (<span style="color: #0000FF;">setf</span> (buffer-substring (org-element-property <span style="color: #006FE0;">:begin</span> results)
                                  (org-element-property <span style="color: #006FE0;">:post-affiliated</span> results))
                <span style="color: #008000;">""</span>)
          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">paste results line back</span>
          (yank)
          <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">and the output from your code</span>
          (insert output))
      (message <span style="color: #008000;">"%s"</span> output))))
</pre>
</div>

<pre class="example">
check
</pre>

<p>
Now, we use a named src-block so we can call M-x check in it, and check the answer.
</p>

<div class="org-src-container">

<pre class="src src-python" id="solve"><span style="color: #0000FF;">from</span> scipy.optimize <span style="color: #0000FF;">import</span> fsolve
<span style="color: #0000FF;">import</span> numpy <span style="color: #0000FF;">as</span> np

<span style="color: #0000FF;">def</span> <span style="color: #006699;">objective</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> np.exp(x) - 3

<span style="color: #0000FF;">def</span> <span style="color: #006699;">solve</span>():
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> fsolve(objective, 3)

<span style="color: #0000FF;">print</span> solve()
</pre>
</div>

<pre class="example">
[ 1.09861229]
Correct!
</pre>

<p>
I would like to be able to provide a solution function that would show a user my solution they were tested against. Python provides the <code>inspect</code> module that can do this. Here is how we get the code in Python.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">import</span> inspect
<span style="color: #0000FF;">import</span> test_solve

<span style="color: #0000FF;">print</span> inspect.getsource(test_solve.solve_solution)
</pre>
</div>

<pre class="example">
def solve_solution():
    from scipy. optimize import fsolve
    import numpy as np

    def objective(x):
        return np.exp(x) - 3

    return fsolve(objective, 3)[0]
</pre>

<p>
This makes it easy to wrap up a function in emacs that will show this from at src block. We just get the block name, and build the python code and execute it here.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">show-solution</span> ()
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let*</span> ((src-block (org-element-context))
         (name (org-element-property <span style="color: #006FE0;">:name</span> src-block))
         (template (format  <span style="color: #008000;">"import inspect</span>
<span style="color: #008000;">import test_%s</span>

<span style="color: #008000;">print inspect.getsource(test_%s.%s_solution)"</span> name name name)))
    (switch-to-buffer-other-window (get-buffer-create <span style="color: #008000;">"solution"</span>))
    (erase-buffer)
    (insert (shell-command-to-string
             (format <span style="color: #008000;">"python -c \"%s\""</span> template)))
    (python-mode)))
</pre>
</div>

<pre class="example">
show-solution
</pre>

<p>
That summarizes the main features. It allows me to write a test module that has some name conventions to define a solution function, and a test function. Emacs can generate some boilerplate code for different problem names, and run the test to give the user some feedback. Most of the code in this post would not be directly visible to a user, it would be buried in a python module somewhere on the path, and in elisp files providing the glue. I am not sure how much obfuscation you can put in the python files, e.g. just providing byte-compiled code, so it is less easy to just read it. That is not as big a deal when it is just a study guide/feedback system.
</p>

<p>
From an authoring point of view, this seems pretty good to me. It is feasible I think to write an org-source document like this with tangling for the test modules, and an export to org that does not have the solutions in it. The only subtle point might be needing to alter Python paths to find the test modules if they aren't installed via something like pip.
</p>


<p>
I think this is pretty flexible, and could handle problems that take arguments, e.g. write a function that sorts a list. Here is a simple example of that. First we write the test_sort.py file with a solution, and some tests.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">sort_solution</span>(LIST):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> LIST.sort()

<span style="color: #0000FF;">def</span> <span style="color: #006699;">test_sort</span>(s):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">exec</span> s <span style="color: #0000FF;">in</span> <span style="color: #006FE0;">globals</span>()
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> sort([3, 4, 2]) == [2, 3, 4]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'passed test 1'</span>)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">if</span> sort([<span style="color: #008000;">'z'</span>, <span style="color: #008000;">'b'</span>]) == [<span style="color: #008000;">'b'</span>, <span style="color: #008000;">'z'</span>]:
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">print</span>(<span style="color: #008000;">'passed test 2'</span>)
</pre>
</div>


<div class="org-src-container">

<pre class="src src-python" id="sort"><span style="color: #0000FF;">def</span> <span style="color: #006699;">sort</span>(LIST):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">s</span> = <span style="color: #006FE0;">sorted</span>(LIST)
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> s
</pre>
</div>
<pre class="example">
passed test 1
passed test 2
</pre>

<p>
Maybe it would make sense to use unittests, or nose or some other testing framework if it makes writing the tests easier. Another day.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/10/03/A-framework-for-automated-feedback-with-Python-and-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Publication in PCCP on oxide polymorph reactivty]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/09/30/Publication-in-PCCP-on-oxide-polymorph-reactivty" />
    <id>http://jkitchin.github.io/blog/2015/09/30/Publication-in-PCCP-on-oxide-polymorph-reactivty</id>
    <updated>2015-09-30T11:58:57Z</updated>
    <published>2015-09-30T11:58:57Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="news" />
    <category scheme="http://jkitchin.github.io/blog" term="publication" />
    <summary type="html"><![CDATA[Publication in PCCP on oxide polymorph reactivty]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/09/30/Publication-in-PCCP-on-oxide-polymorph-reactivty"><![CDATA[



<p>
We have a new publication in Phys. Chem. Chem. Phys. on the reactivity of different oxide polymorphs. In this work we examine the reactivity of some common BO<sub>2</sub> oxide polymorphs for Ru, Rh, Pt and Ir oxides. These are all normally rutile formers, but it may be possible to synthesize them in other polymorphs as epitaxial films, or under pressure. We examined how the reactivity of the polymorphs would differ from that of the most stable phase, and the impact of those changes on the oxygen evolution reaction. We predict that the reactivity may be improved in some cases. Congratulations Zhongnan!
</p>

<p>
<a href="http://pubs.rsc.org/en/Content/ArticleLanding/2015/CP/C5CP04840K#!divAbstract">http://pubs.rsc.org/en/Content/ArticleLanding/2015/CP/C5CP04840K#!divAbstract</a>
</p>

<div class="org-src-container">

<pre class="src src-bibtex"><span style="color: #006699;">@article</span>{<span style="color: #D0372D;">xu-2015-tunin-oxide</span>,
  <span style="color: #BA36A5;">author</span> =       "Xu, Zhongnan and Kitchin, John R",
  <span style="color: #BA36A5;">title</span> =        {Tuning Oxide Activity Through Modification of the Crystal and
                  Electronic Structure: From Strain To Potential Polymorphs},
  <span style="color: #BA36A5;">journal</span> =      "Phys. Chem. Chem. Phys.",
  <span style="color: #BA36A5;">year</span> =         2015,
  <span style="color: #BA36A5;">doi</span> =          "<span style="color: #006DAF; text-decoration: underline;">10.1039/C5CP04840K</span>",
  <span style="color: #BA36A5;">url</span> =          "<span style="color: #006DAF; text-decoration: underline;">http://dx.doi.org/10.1039/C5CP04840K</span>",
  <span style="color: #BA36A5;">publisher</span> =    "The Royal Society of Chemistry",
  <span style="color: #BA36A5;">abstract</span> =     "Discovering new materials with tailored chemical properties is
                  vital for advancing key technologies in catalysis and energy
                  conversion. One strategy is the modification of a material{'}s
                  crystal structure{,} and new methods allow for the synthesis
                  and stabilization of potential materials in a range of crystal
                  polymorph structures. We assess the potential reactivity of
                  four metastable oxide polymorphs of MO2 (M=Ru{,} Rh{,} Pt{,}
                  Ir) transition metal oxides. In spite of the similar local
                  geometry and coordination between atoms in the metastable
                  polymorphic and stable rutile structure{,} we find that
                  polymorph reactivities cannot be explained by strain alone and
                  offer tunable reactivity and increased stability.
                  Atom-projected density of states reveals that the unique
                  reactivity of polymorphs are caused by a redistribution of
                  energy levels of the t2g-states. This structure-activity
                  relationship is induced by slight distortions to the M-O bonds
                  in polymorphic structures and is unattainable by strain. We
                  predict columbite IrO2 to be more active than rutile IrO2 for
                  oxygen evolution",
}
</pre>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/09/30/publication-in-PCCP-on-oxide-polymorph-reactivty.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>
]]></content>
  </entry>
</feed>
