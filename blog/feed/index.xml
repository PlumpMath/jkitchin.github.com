<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Tue, 08 Apr 2014 01:09:51 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>New publication in JACS</title>
      <link>http://jkitchin.github.io/blog/2014/04/07/New-publication-in-JACS</link>
      <pubDate>Mon, 07 Apr 2014 21:08:42 EDT</pubDate>
      <category><![CDATA[news]]></category>
      <category><![CDATA[publication]]></category>
      <guid isPermaLink="false">vrOr4eMnfYvU3aEf5hQBQVORiDI=</guid>
      <description>New publication in JACS</description>
      <content:encoded><![CDATA[


<p>
<b>Electrocatalytic Oxygen Evolution with an Immobilized TAML Activator</b>
</p>

<p>
Ethan L. Demeter, Shayna L. Hilburg, Newell R. Washburn, Terrence J. Collins, and John R. Kitchin
</p>

<p>
Iron complexes of tetra-amido macrocyclic ligands are important members of the suite of oxidation catalysts known as TAML activators. TAML activators are known to be fast homogeneous water oxidation (WO) catalysts, producing oxygen in the presence of chemical oxidants, e.g., ceric ammonium nitrate. These homogeneous systems exhibited low turnover numbers (TONs). Here we demonstrate immobilization on glassy carbon and carbon paper in an ink composed of the prototype TAML activator, carbon black, and Nafion and the subsequent use of this composition in heterogeneous electrocatalytic WO. The immobilized TAML system is shown to readily produce O2 with much higher TONs than the homogeneous predecessors.
</p>

<p>
<a href="http://pubs.acs.org/doi/full/10.1021/ja5015986">http://pubs.acs.org/doi/full/10.1021/ja5015986</a> 
</p>

<p>
Congratulations Ethan!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/07/New-publication-in-JACS.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Scheduling tasks on a rotating semester basis</title>
      <link>http://jkitchin.github.io/blog/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis</link>
      <pubDate>Thu, 03 Apr 2014 19:29:34 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">JIUKn3h9eOEssmt3Ksbl_5LX7_Q=</guid>
      <description>Scheduling tasks on a rotating semester basis</description>
      <content:encoded><![CDATA[



<p>
Let us say we have a list of tasks labeled task a through k. We want to schedule these tasks on a rotating basis, so that some tasks are done in even years and some tasks are done in odd years. Within those years, some tasks are done in the Fall, and some are done in the spring. This post explores how to code those tasks so we can figure out which tasks should be done in some part of some year. 
</p>

<p>
We break the problem down like this. A year is an even year if <code>mod(year,2)=0</code>, and it is odd if <code>mod(year,2)=1</code>. So for a year, we have a bit of information. Now, since there are two times of the year we will do the tasks, we can assign this as another bit, e.g. <code>FALL=0</code>, and <code>SPRING=1</code>. Now, we have the following possibilities:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="left" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">year</th>
<th scope="col" class="left">time period</th>
<th scope="col" class="right">binary code</th>
<th scope="col" class="right">decimal number</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">2013</td>
<td class="left">Fall</td>
<td class="right">10</td>
<td class="right">2</td>
</tr>

<tr>
<td class="right">2014</td>
<td class="left">Spring</td>
<td class="right">01</td>
<td class="right">1</td>
</tr>

<tr>
<td class="right">2014</td>
<td class="left">Fall</td>
<td class="right">00</td>
<td class="right">0</td>
</tr>

<tr>
<td class="right">2015</td>
<td class="left">Spring</td>
<td class="right">11</td>
<td class="right">3</td>
</tr>
</tbody>
</table>

<p>
And then the cycle will repeat. So, if we code each task with an integer of 0, 1, 2 or 3, we can say in a given year and time period whether a task should be completed. If <code>2 * mod(year, 2) + period_code</code> is equal to the code on the task, then it should be executed.
</p>

<p>
Now, we need to start the task sequence. Let us say we start in the Fall of 2013. That is an odd year, so <code>year % 2 = 1</code>, and we use a tag  of <code>0</code> to represent the Fall semester, giving an overall binary code of <code>10</code> which is equal to 2, so all tasks labeled 2 should be executed. 
</p>

<p>
We will assign the codes to each task by enumerating a string of letters, and giving the task a code of mod(letter index, 4). That will loop through the tasks assigning codes of 0, 1, 2 or 3 to each task. 
</p>

<p>
So to schedule these we will loop through a list of years, calculate the code for each year and time perid, and then filter the list of tasks with that code.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">tasks</span> = [(letter, i % 4) <span style="color: #8b0000;">for</span> i,letter <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">enumerate</span>(<span style="color: #228b22;">'abcdefghijk'</span>)]

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'tasks = '</span>,tasks

<span style="color: #8b008b;">SEMESTERS</span> = ((<span style="color: #228b22;">'FALL'</span>,0), (<span style="color: #228b22;">'SPRING'</span>,1))

<span style="color: #8b0000;">for</span> year <span style="color: #8b0000;">in</span> [2013, 2014, 2015, 2016, 2017, 2018]:
    <span style="color: #8b0000;">for</span> semester,i <span style="color: #8b0000;">in</span> SEMESTERS:
        <span style="color: #8b008b;">N</span> = 2 * (year % 2) + i
        <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} {1:8s}: {2}'</span>.<span style="color: #cd0000;">format</span>(year, semester,
                                    [x[0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> 
                                     <span style="color: #cd0000;">filter</span>(<span style="color: #8b0000;">lambda</span> x: x[1]==N,
                                            tasks)])
</pre>
</div>

<pre class="example">
tasks =  [('a', 0), ('b', 1), ('c', 2), ('d', 3), ('e', 0), ('f', 1), ('g', 2), ('h', 3), ('i', 0), ('j', 1), ('k', 2)]
2013 FALL    : ['c', 'g', 'k']
2013 SPRING  : ['d', 'h']
2014 FALL    : ['a', 'e', 'i']
2014 SPRING  : ['b', 'f', 'j']
2015 FALL    : ['c', 'g', 'k']
2015 SPRING  : ['d', 'h']
2016 FALL    : ['a', 'e', 'i']
2016 SPRING  : ['b', 'f', 'j']
2017 FALL    : ['c', 'g', 'k']
2017 SPRING  : ['d', 'h']
2018 FALL    : ['a', 'e', 'i']
2018 SPRING  : ['b', 'f', 'j']
</pre>

<p>
This leads to each task being completed every other year. We could also write a function and filter by list comprehension.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">tasks</span> = [(letter, i % 4) <span style="color: #8b0000;">for</span> i,letter <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">enumerate</span>(<span style="color: #228b22;">'abcdefghijk'</span>)]

<span style="color: #8b008b;">FALL</span> = 0
<span style="color: #8b008b;">SPRING</span> = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">execute_p</span>(year, semester, task):
    <span style="color: #228b22;">'year is an integer, semester is 0 for fall, 1 for spring, task is a tuple of (label,code)'</span>
    <span style="color: #8b008b;">N</span> = 2 * (year % 2) + semester
    <span style="color: #8b0000;">return</span> task[1] == N

<span style="color: #8b008b;">YEAR</span>, SEMESTER = 2018, FALL
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} {1:8s}: {2}'</span>.<span style="color: #cd0000;">format</span>(YEAR, 
                               <span style="color: #228b22;">'FALL'</span> <span style="color: #8b0000;">if</span> SEMESTER==0 <span style="color: #8b0000;">else</span> <span style="color: #228b22;">'SPRING'</span>,
                               [task[0]  <span style="color: #8b0000;">for</span> task <span style="color: #8b0000;">in</span> tasks
                                <span style="color: #8b0000;">if</span> execute_p(2018, FALL, task)])
</pre>
</div>

<pre class="example">
2018 FALL    : ['a', 'e', 'i']
</pre>

<p>
Now, at any point in the future you can tell what tasks should be done!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/03/Scheduling-tasks-on-a-rotating-semester-basis.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Using pyparsing for search  queries with tags</title>
      <link>http://jkitchin.github.io/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags</link>
      <pubDate>Mon, 31 Mar 2014 13:21:16 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">mEVmGIW1KW6c7S6xFD5nixOWoiA=</guid>
      <description>Using pyparsing for search  queries with tags</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Parsing simple string and generating lisp</a></li>
<li><a href="#sec-2">2. Parsing a search string to generate python set notations</a></li>
</ul>
</div>
</div>

<p>
A few times I  have wanted  to use  a more natural search string like "A and pw and 350 and not  kpt". The trouble  is figuring out how to parse that string and turn it  into search code. There  may  be nested logic,  e.g. "(A xor B)  and  (pw and (200 or 300))". This means we have  to recursively parse  the sstring. Rather  than invent this from  scratch, we  use pyparsing which is designed for that. There is   some code in "Getting started with pyparsing" that provides an example on parsing search strings. I want to see how I can turn the parsed output into search code. Here, we parse the search string and generate something that looks like lisp code. 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Parsing simple string and generating lisp</h2>
<div class="outline-text-2" id="text-1">
<p>
We define  a  hiearchy of classes that codifythe operators, and which print representations of the logic. The grammar we implement is basically words or  strings separatedd by logic operators.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes one operand,e.g. not'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'takes two or more operands, e.g. and, or'</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(AND {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(OR {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #228b22;">' '</span>.join(<span style="color: #cd0000;">str</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands))

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'(NOT {0})'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #228b22;">'represents a termthat is being searched. here just a word'</span>                         
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #8b0000;">self</span>.term

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])


<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue and heavy or red'</span>)[0]
</pre>
</div>

<pre class="example">
(NOT kpt)
(NOT (AND kpt eos))
(OR (AND wood blue) red)
(OR (AND wood blue heavy) red)
</pre>

<p>
That works pretty well, and does not seem overly complicated to me. There is a lot of class definition, but that would presumably get buried in a module as a one time investment, and some function interface would look like this: <code>search('wood and blue or red')</code>.
</p>

<p>
Now, let us try python notation. 
</p>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Parsing a search string to generate python set notations</h2>
<div class="outline-text-2" id="text-2">
<p>
I will use a similar idea as I used before with TAGS. We will use set operations with the binary logical operators to do the actual searching. Finally, we wrap the code in a little function to search a dictionary we previously made.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pyparsing <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">UnaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op, <span style="color: #8b0000;">self</span>.operands = tokens[0]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">BinaryOperation</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.op = tokens[0][1]
        <span style="color: #8b0000;">self</span>.operands = tokens[0][0::2]

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchAnd</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' &amp; '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>
        
<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchOr</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' | '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) +<span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchXor</span>(BinaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'('</span> + <span style="color: #228b22;">' ^ '</span>.join([<span style="color: #228b22;">'{}'</span>.<span style="color: #cd0000;">format</span>(oper) <span style="color: #8b0000;">for</span> oper <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">self</span>.operands]) + <span style="color: #228b22;">')'</span>

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchNot</span>(UnaryOperation):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'all\'] - {}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.operands)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">SearchTerm</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, tokens):
        <span style="color: #8b0000;">self</span>.term = tokens[0]

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__repr__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #228b22;">'instead of just the  term, we represent it as TAGS[term]'</span>
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'TAGS[\'{0}\']'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.term)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the grammar</span>
<span style="color: #8b008b;">and_</span> = CaselessLiteral(<span style="color: #228b22;">"and"</span>)
<span style="color: #8b008b;">or_</span> = CaselessLiteral(<span style="color: #228b22;">"or"</span>)
<span style="color: #8b008b;">xor_</span> = CaselessLiteral(<span style="color: #228b22;">"xor"</span>)
<span style="color: #8b008b;">not_</span> = CaselessLiteral(<span style="color: #228b22;">"not"</span>)

<span style="color: #8b008b;">searchTerm</span> = Word(alphanums) | quotedString.setParseAction(removeQuotes)
searchTerm.setParseAction(SearchTerm)

<span style="color: #8b008b;">searchExpr</span> = operatorPrecedence( searchTerm,
                                 [(not_, 1, opAssoc.RIGHT, SearchNot),
                                  (and_, 2, opAssoc.LEFT, SearchAnd),
                                  (xor_, 2, opAssoc.LEFT, SearchXor),
                                  (or_, 2, opAssoc.LEFT, SearchOr)])

<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not kpt'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'not (kpt and eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'kpt or not eos)'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue or red'</span>)[0]
<span style="color: #8b0000;">print</span> searchExpr.parseString(<span style="color: #228b22;">'wood and blue xor red'</span>)[0]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">check it out on tags.</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">search_tags</span>(srch):
    <span style="color: #228b22;">'function to  search the TAGS  file'</span>
    <span style="color: #8b0000;">import</span> pickle

    <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
        <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())
    
    <span style="color: #8b008b;">s</span> = searchExpr.parseString(srch)[0]
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">eval</span>(<span style="color: #cd0000;">str</span>(s))
<span style="color: #8b0000;">print</span> search_tags(<span style="color: #228b22;">'pw and A and not 300'</span>)
</pre>
</div>

<pre class="example">
TAGS['all'] - TAGS['kpt']
TAGS['all'] - (TAGS['kpt'] &amp; TAGS['eos'])
(TAGS['kpt'] | TAGS['all'] - TAGS['eos'])
((TAGS['wood'] &amp; TAGS['blue']) | TAGS['red'])
((TAGS['wood'] &amp; TAGS['blue']) ^ TAGS['red'])
set(['tags\\A\\pw\\350', 'tags\\A\\pw', 'tags\\A\\pw\\200', 'tags\\A\\pw\\400', 'tags\\A\\pw\\250'])
</pre>

<p>
That is pretty nice. It looks like a nice syntax for queries. One day I will try incorporating this into a database application.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/31/Using-pyparsing-for-search-queries-with-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Searching for directories by tags</title>
      <link>http://jkitchin.github.io/blog/2014/03/29/Searching-for-directories-by-tags</link>
      <pubDate>Sat, 29 Mar 2014 17:41:08 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">WC3gozWMp-EfNx805rBccYbaALc=</guid>
      <description>Searching for directories by tags</description>
      <content:encoded><![CDATA[



<p>
Today I explore searching for directories by using tags. We will create a TAGS table by first walking through the directories and tagging each directory with all of the relative path components. Then, we will use set algebra to identify specific directories.
</p>

<p>
First, let us make a directory setup to use. We will nest some calculations that might be typical. These will be nested directories that might contain planewave (pw) and k-points (kpts) convergence and equation of state (eos) directories, with the sets of calculations inside those. The idea then is that the directory components will form at least some of the tags.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os

os.mkdir(<span style="color: #228b22;">'tags'</span>)

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> c <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'pw'</span>, <span style="color: #228b22;">'kpts'</span>, <span style="color: #228b22;">'eos'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, c))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [1, 2, 3, 4, 5]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'eos'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [200, 250, 300, 350, 400]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'pw'</span>, <span style="color: #cd0000;">str</span>(run)))

<span style="color: #8b0000;">for</span> cmpd <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>, <span style="color: #228b22;">'D'</span>]:
    <span style="color: #8b0000;">for</span> run <span style="color: #8b0000;">in</span> [<span style="color: #228b22;">'2x2x2'</span>, <span style="color: #228b22;">'4x4x4'</span>, <span style="color: #228b22;">'8x8x8'</span>]:
        os.makedirs(os.path.join(<span style="color: #228b22;">'tags'</span>, cmpd, <span style="color: #228b22;">'kpts'</span>, <span style="color: #cd0000;">str</span>(run)))
</pre>
</div>

<p>
Let us just double check what this directory tree looks like for one compound A.
</p>
<div class="org-src-container">

<pre class="src src-sh">ls tags/A/*
</pre>
</div>

<pre class="example">
tags/A/eos:
1
2
3
4
5

tags/A/kpts:
2x2x2
4x4x4
8x8x8

tags/A/pw:
200
250
300
350
400
</pre>

<p>
Now, we will walk through the directories, and split the path components to create a TAGS structure. I will store these as sets within a dictionary. We will save the structure in a pickle file to reuse it later.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">import</span> pickle

<span style="color: #8b008b;">TAGS</span> = {}
<span style="color: #8b008b;">TAGS</span>[<span style="color: #228b22;">'all'</span>] = <span style="color: #cd0000;">set</span>()

<span style="color: #8b0000;">for</span> root, dirs, files <span style="color: #8b0000;">in</span> os.walk(<span style="color: #228b22;">'tags'</span>):
    <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(root)
    TAGS[<span style="color: #228b22;">'all'</span>].add(root)
    <span style="color: #8b0000;">while</span> base:
        <span style="color: #8b0000;">if</span> tail <span style="color: #8b0000;">in</span> TAGS:
            TAGS[tail].add(root)
        <span style="color: #8b0000;">else</span>:
            <span style="color: #8b008b;">TAGS</span>[tail] = <span style="color: #cd0000;">set</span>([root])
        <span style="color: #8b008b;">base</span>, <span style="color: #8b008b;">tail</span> = os.path.split(base)

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'w'</span>) <span style="color: #8b0000;">as</span> f:
    f.write(pickle.dumps(TAGS))

<span style="color: #8b0000;">print</span> TAGS.keys()
</pre>
</div>

<pre class="example">
['A', '1', 'all', 'B', '250', 'pw', '2x2x2', '300', 'C', '400', 'kpts', '8x8x8', 'eos', '3', '2', '5', '4', '350', '200', '4x4x4', 'D']
</pre>

<p>
Now we have a lot of keys that tag each directory. Each tag is a set of directories, and we can do set algebra to get specific results. For example, we can find a result by appropriate differences, intersections and unions of the sets. An advantage of this approach is that order of the tags is not relevant (unlike the path, where each component must be in the right order).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'300'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>].intersection(TAGS[<span style="color: #228b22;">'pw'</span>]).intersection(TAGS[<span style="color: #228b22;">'A'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
set(['tags\\A\\pw\\300'])
</pre>

<p>
The syntax here is a tad heavy because of the chained dot notation operations. You can also use the logical operators like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'300'</span>] &amp; TAGS[<span style="color: #228b22;">'pw'</span>] &amp; TAGS[<span style="color: #228b22;">'A'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300'])
</pre>


<p>
We can get a set of calculations, for example an equation of state like this:
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">300 and pw and A</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\eos', 'tags\\A\\eos\\5', 'tags\\A\\eos\\4', 'tags\\A\\eos\\1', 'tags\\A\\eos\\3', 'tags\\A\\eos\\2'])
</pre>

<p>
Now, let us construct some more complex queries. With sets we use intersections for <code>and</code> and we construct unions of queries that are like an or. We examine different notations to see which one is better.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 3 in eos for B and C</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'3'</span>]
       .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
       .intersection(TAGS[<span style="color: #228b22;">'B'</span>])
       .union
       (TAGS[<span style="color: #228b22;">'3'</span>]
        .intersection(TAGS[<span style="color: #228b22;">'eos'</span>])
        .intersection(TAGS[<span style="color: #228b22;">'C'</span>])))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this notation makes more sense to me. ^ = or</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'3'</span>] &amp; TAGS[<span style="color: #228b22;">'eos'</span>] &amp; (TAGS[<span style="color: #228b22;">'B'</span>] ^ TAGS[<span style="color: #228b22;">'C'</span>])
</pre>
</div>

<pre class="example">
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
set(['tags\\C\\eos\\3', 'tags\\B\\eos\\3'])
</pre>

<p>
You can see the two approaches give the same results. The logical operator syntax is more concise and (I think) more readable. Let us consider a query with "not". We can use a difference operator for that. We subtract all the paths with tag "B" from the set containing "4x4x4", which will give us paths tagged with "4x4x4" but not "B".
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find calculation 4x4x4 but not B</span>
<span style="color: #8b0000;">print</span> (TAGS[<span style="color: #228b22;">'4x4x4'</span>].difference(TAGS[<span style="color: #228b22;">'B'</span>]))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">this makes more sense 4x4x4 but not B, </span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">i.e. subtract paths tagged B from those tagged 4x4x4</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'4x4x4'</span>] -  TAGS[<span style="color: #228b22;">'B'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
set(['tags\\D\\kpts\\4x4x4', 'tags\\A\\kpts\\4x4x4', 'tags\\C\\kpts\\4x4x4'])
</pre>


<p>
Note it is not so obvious how to get results not tagged with "A". We need to subtract the tagged calculations from some set. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'all'</span>] - TAGS[<span style="color: #228b22;">'A'</span>]  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">not A</span>
</pre>
</div>

<pre class="example">
set(['tags\\D\\kpts', 'tags\\D\\pw\\200', 'tags\\D\\pw\\350', 'tags\\D\\pw\\250', 'tags\\D\\kpts\\8x8x8', 'tags\\C\\eos', 'tags\\D\\eos\\2', 'tags\\D\\eos\\3', 'tags\\D\\eos\\4', 'tags\\D\\eos\\5', 'tags\\B\\kpts\\2x2x2', 'tags\\C\\kpts\\4x4x4', 'tags\\C\\eos\\3', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1', 'tags\\C\\kpts\\8x8x8', 'tags\\C\\eos\\5', 'tags\\C\\eos\\4', 'tags\\B\\kpts', 'tags\\C\\pw\\200', 'tags\\B\\eos\\2', 'tags\\B\\pw\\350', 'tags\\B\\eos\\1', 'tags\\B\\kpts\\8x8x8', 'tags\\C\\pw\\300', 'tags\\B\\eos\\4', 'tags\\B\\eos\\5', 'tags\\C\\kpts', 'tags\\D\\pw\\300', 'tags\\B\\kpts\\4x4x4', 'tags\\C\\kpts\\2x2x2', 'tags\\D\\kpts\\4x4x4', 'tags\\B\\pw\\250', 'tags', 'tags\\D\\pw\\400', 'tags\\D\\eos', 'tags\\C\\pw\\400', 'tags\\D\\kpts\\2x2x2', 'tags\\D\\pw', 'tags\\C\\pw\\250', 'tags\\C\\pw\\350', 'tags\\C\\pw', 'tags\\D\\eos\\1', 'tags\\B\\pw\\400', 'tags\\B\\pw', 'tags\\B\\eos', 'tags\\B\\pw\\300', 'tags\\B\\eos\\3', 'tags\\C', 'tags\\B', 'tags\\D', 'tags\\B\\pw\\200'])
</pre>

<p>
We can also look at "or". This is done with the <code>union</code> function, which is the set of elements in either set. The logical operator is <code>|</code>.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>].union(TAGS[<span style="color: #228b22;">'2'</span>])
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'1'</span>] | TAGS[<span style="color: #228b22;">'2'</span>]        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">1 or 2</span>
</pre>
</div>

<pre class="example">
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
set(['tags\\B\\eos\\2', 'tags\\B\\eos\\1', 'tags\\A\\eos\\1', 'tags\\A\\eos\\2', 'tags\\D\\eos\\1', 'tags\\D\\eos\\2', 'tags\\C\\eos\\2', 'tags\\C\\eos\\1'])
</pre>

<p>
There is an <code>xor</code> operator too. xor is not the same as or, it means <code>A xor B</code> means "A or B but not both". The <code>symmetric_difference</code> function gives this behavior. The logical operator is <code>^</code>. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> pickle

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'TAGS.pkl'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">TAGS</span> = pickle.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">I think this is like the xor, A or 2 but not both</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>].symmetric_difference(TAGS[<span style="color: #228b22;">'2'</span>]), <span style="color: #228b22;">'\n'</span>
<span style="color: #8b0000;">print</span> TAGS[<span style="color: #228b22;">'A'</span>] ^ TAGS[<span style="color: #228b22;">'2'</span>]
</pre>
</div>

<pre class="example">
set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200']) 

set(['tags\\A\\pw\\300', 'tags\\A\\pw\\250', 'tags\\A\\eos', 'tags\\B\\eos\\2', 'tags\\A\\eos\\4', 'tags\\A\\kpts\\2x2x2', 'tags\\A\\pw\\400', 'tags\\A\\kpts\\4x4x4', 'tags\\A\\eos\\3', 'tags\\A\\kpts\\8x8x8', 'tags\\A\\pw\\350', 'tags\\A\\eos\\5', 'tags\\D\\eos\\2', 'tags\\A\\kpts', 'tags\\A', 'tags\\C\\eos\\2', 'tags\\A\\eos\\1', 'tags\\A\\pw', 'tags\\A\\pw\\200'])
</pre>



<p>
To summarize, this is one approach to using tags with the technical infrastructure of the set. The advantage is flexibility, that you do not need to know the full path to a result, provided you know the set of tags that refers to it. You can use the tags in any order.
</p>

<p>
There are many alternative approaches to implementing this idea. One could create a sqlite table and do SQL queries. You could also store lists in the dictionary, and use python code to find the matches. The syntax here is varied. Using the functional approach, the syntax gets heavy with all the dot notation. With the logical operators, the syntax is a little lighter. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/29/Searching-for-directories-by-tags.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Literate programming in python with org-mode and noweb</title>
      <link>http://jkitchin.github.io/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb</link>
      <pubDate>Thu, 27 Mar 2014 10:46:55 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">dtkACJfbM4IcXFlFpOD99wiXUng=</guid>
      <description>Literate programming in python with org-mode and noweb</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. imports</a></li>
<li><a href="#sec-2">2. utility function</a></li>
<li><a href="#sec-3">3. class definition</a>
<ul>
<li><a href="#sec-3-1">3.1. some class function</a></li>
</ul>
</li>
<li><a href="#sec-4">4. The main function</a></li>
<li><a href="#sec-5">5. Tangle and run the code</a></li>
<li><a href="#sec-6">6. Summary thoughts</a></li>
</ul>
</div>
</div>
<p>
This post examines a different approach to literate programming with org-mode that uses <a href="http://www.cs.tufts.edu/~nr/noweb/">noweb</a> . I have adapted an example from <a href="http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html">http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html</a> which has some pretty cool ideas in it. 
</p>

<p>
The gist of using noweb is that in your source blocks you have labels like <code>&lt;&lt;imports&gt;&gt;</code>, that refer to other named code blocks that get substituted in place of the label. In the example below, we put labels for a code block of imports, for a function definition, a class definition, and a main function. This code block will get tangled to <a href="/media/2014-03-27-Literate-programming-in-python-with-org-mode-and-noweb/main.py">main.py</a> . The noweb expansion happens at export, so here is the literal code block:
</p>
<pre class="example">
#+BEGIN_SRC python :noweb yes :tangle main.py
&lt;&lt;imports&gt;&gt;

&lt;&lt;some-func&gt;&gt;

&lt;&lt;class-dfn&gt;&gt;

&lt;&lt;main-func&gt;&gt;

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC
</pre>

<p>
You may want to just check out the org-mode source link at the bottom of the post to see all the details.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> sys
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">from</span> argparse <span style="color: #8b0000;">import</span> ArgumentParser

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">utility_func</span>(arg=<span style="color: #cd0000;">None</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'you called a utility function with this arg: {0}'</span>.<span style="color: #cd0000;">format</span>(arg)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">HelloWorld</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, who):
        <span style="color: #8b0000;">self</span>.who = who

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__call__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'Hello {0}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.who)

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">main</span>():
    <span style="color: #8b008b;">parser</span> = ArgumentParser(description=<span style="color: #228b22;">"Say hi"</span>)
    parser.add_argument(<span style="color: #228b22;">"-w"</span>, <span style="color: #228b22;">"--who"</span>, 
                        <span style="color: #cd0000;">type</span>=<span style="color: #cd0000;">str</span>,
                        default=<span style="color: #228b22;">"world"</span>,
                        <span style="color: #cd0000;">help</span>=<span style="color: #228b22;">"Who to say hello to"</span>)
    <span style="color: #8b008b;">args</span> = parser.parse_args()
  
    <span style="color: #8b008b;">who</span> = args.who
  
    <span style="color: #8b008b;">greeter</span> = HelloWorld(who)
    greeter()

    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'test func = '</span>, greeter.test()
  
    <span style="color: #8b0000;">print</span> utility_func()
    <span style="color: #8b0000;">print</span> utility_func(5)

    <span style="color: #8b0000;">return</span> 0

<span style="color: #8b0000;">if</span> <span style="color: #cd0000;">__name__</span> == <span style="color: #228b22;">'__main__'</span>:
    status = main()
    sys.<span style="color: #cd0000;">exit</span>(status)
</pre>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> imports</h2>
<div class="outline-text-2" id="text-1">
<p>
Now, we define a block that gives us the imports. We do not have to use any tangle headers here because noweb will put it in where it belongs.
</p>

<div class="org-src-container">

<pre class="src src-python" id="imports"><span style="color: #8b0000;">import</span> sys
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">from</span> argparse <span style="color: #8b0000;">import</span> ArgumentParser
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> utility function</h2>
<div class="outline-text-2" id="text-2">
<p>
Now we define a function we will want imported from the main file. 
</p>

<div class="org-src-container">

<pre class="src src-python" id="some-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">utility_func</span>(arg=<span style="color: #cd0000;">None</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'you called a utility function with this arg: {0}'</span>.<span style="color: #cd0000;">format</span>(arg)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> class definition</h2>
<div class="outline-text-2" id="text-3">
<p>
Finally, let us define a class. Note we use noweb here too, and we get the indentation correct!
</p>

<div class="org-src-container">

<pre class="src src-python" id="class-dfn"><span style="color: #8b0000;">class</span> <span style="color: #4682b4;">HelloWorld</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, who):
        <span style="color: #8b0000;">self</span>.who = who

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__call__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'Hello {0}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.who)

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
</pre>
</div>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> some class function</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Now, let us make the some-other-func. This block is not indented, but with the noweb syntax above, it seems to get correctly indented. Amazing.
</p>

<div class="org-src-container">

<pre class="src src-python" id="some-other-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> The main function</h2>
<div class="outline-text-2" id="text-4">
<p>
This is a typical function that could be used to make your module into a script, and is only run when the module is used as a script.. 
</p>

<div class="org-src-container">

<pre class="src src-python" id="main-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">main</span>():
    <span style="color: #8b008b;">parser</span> = ArgumentParser(description=<span style="color: #228b22;">"Say hi"</span>)
    parser.add_argument(<span style="color: #228b22;">"-w"</span>, <span style="color: #228b22;">"--who"</span>, 
                        <span style="color: #cd0000;">type</span>=<span style="color: #cd0000;">str</span>,
                        default=<span style="color: #228b22;">"world"</span>,
                        <span style="color: #cd0000;">help</span>=<span style="color: #228b22;">"Who to say hello to"</span>)
    <span style="color: #8b008b;">args</span> = parser.parse_args()
  
    <span style="color: #8b008b;">who</span> = args.who
  
    <span style="color: #8b008b;">greeter</span> = HelloWorld(who)
    greeter()

    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'test func = '</span>, greeter.test()
  
    <span style="color: #8b0000;">print</span> utility_func()
    <span style="color: #8b0000;">print</span> utility_func(5)

    <span style="color: #8b0000;">return</span> 0
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Tangle and run the code</h2>
<div class="outline-text-2" id="text-5">
<p>
This link will extract the code to main.py: <pre>elisp:org-babel-tangle</pre> 
</p>

<p>
We can run the code like this (linux):
</p>
<div class="org-src-container">

<pre class="src src-sh" id="bashrun-helloworld">python main.py --w John 2&gt;&amp;1
true
</pre>
</div>
<pre class="example">
test func =  True
you called a utility function with this arg: None
you called a utility function with this arg: 5
</pre>

<p>
or this (windows, which as no sh)
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> main <span style="color: #8b0000;">import</span> *

main()
</pre>
</div>

<pre class="example">
test func =  True
you called a utility function with this arg: None
you called a utility function with this arg: 5
</pre>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-6">
<p>
The use of noweb syntax is pretty cool. I have not done anything serious with it, but it looks like you could pretty easily create a sophisticated python module this way that is documented in org-mode. </p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>writing VASP calculations to ase.db formats</title>
      <link>http://jkitchin.github.io/blog/2014/03/26/writing-VASP-calculations-to-ase-db-formats</link>
      <pubDate>Wed, 26 Mar 2014 13:22:12 EDT</pubDate>
      <category><![CDATA[vasp]]></category>
      <category><![CDATA[ase]]></category>
      <guid isPermaLink="false">JvzDonDHKGTXceUksn5kMrUkczI=</guid>
      <description>writing VASP calculations to ase.db formats</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. The command-line interface</a></li>
<li><a href="#sec-2">2. Summary thoughts</a></li>
</ul>
</div>
</div>

<p>
The ase development team has created a new database module (<a href="https://wiki.fysik.dtu.dk/ase/ase/db/db.html">https://wiki.fysik.dtu.dk/ase/ase/db/db.html</a> ). In this post, we will examine how to use that in conjunction with <code>jasp</code> to save calculations to a database. To use this you need the latest version of jasp from <a href="http://github.com/jkitchin/jasp">http://github.com/jkitchin/jasp</a> .
</p>

<p>
The idea here is to use the code from <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/20/Finding-VASP-calculations-in-a-directory-tree/">http://kitchingroup.cheme.cmu.edu/blog/2014/03/20/Finding-VASP-calculations-in-a-directory-tree/</a> to add each calculation in that subtree to an ase database. We will use the json format for the database.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *
<span style="color: #8b0000;">from</span> ase.db <span style="color: #8b0000;">import</span> connect
<span style="color: #8b008b;">c</span> = connect(<span style="color: #228b22;">'vaspdb.json'</span>)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">vasp_p</span>(directory):
    <span style="color: #228b22;">'returns True if a finished OUTCAR file exists in the current directory, else False'</span>
    <span style="color: #8b008b;">outcar</span> = os.path.join(directory, <span style="color: #228b22;">'OUTCAR'</span>)
    <span style="color: #8b0000;">if</span> os.path.exists(outcar):
        <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(outcar, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
            <span style="color: #8b008b;">contents</span> = f.read()
            <span style="color: #8b0000;">if</span> <span style="color: #228b22;">'General timing and accounting informations for this job:'</span> <span style="color: #8b0000;">in</span> contents:
                <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">False</span>
            
        
<span style="color: #8b008b;">total_time</span> = 0

<span style="color: #8b0000;">for</span> root, dirs, files <span style="color: #8b0000;">in</span> os.walk(<span style="color: #228b22;">'/home-research/jkitchin/research/rutile-atat'</span>):
    <span style="color: #8b0000;">for</span> d <span style="color: #8b0000;">in</span> dirs:
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">compute absolute path to each directory in the current root</span>
        <span style="color: #8b008b;">absd</span> = os.path.join(root, d)
        <span style="color: #8b0000;">if</span> vasp_p(absd):
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we found a vasp directory, so we can do something in it. </span>
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">here we get the elapsed time from the calculation</span>
            <span style="color: #8b0000;">with</span> jasp(absd) <span style="color: #8b0000;">as</span> calc:
                <span style="color: #8b008b;">atoms</span> = calc.get_atoms()
                <span style="color: #8b008b;">calc.results</span>[<span style="color: #228b22;">'energy'</span>] = atoms.get_potential_energy()
                <span style="color: #8b008b;">calc.results</span>[<span style="color: #228b22;">'forces'</span>] = atoms.get_forces()
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">it is important that this line not be inside the jasp</span>
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">context-manager, because c.write writes in the local</span>
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">dir.</span>
            <span style="color: #8b0000;">print</span> c.write(atoms, [<span style="color: #228b22;">'atat'</span>]), absd
</pre>
</div>

<pre class="example">
1 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/0
2 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/1
3 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/10
4 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/11
5 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/12
6 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/13
7 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/14
8 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/15
9 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/16
10 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/17
11 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/2
12 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/3
13 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/4
14 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/5
15 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/59
16 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/6
17 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/66
18 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/7
19 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/73
20 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/74
21 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/78
22 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/8
23 /home-research/jkitchin/research/rutile-atat/RuTi_O_rutile/9
</pre>

<p>
The result is in this file: <a href="/media/2014-03-26-writing-VASP-calculations-to-ase.db-formats/vaspdb.json">vaspdb.json</a> .
</p>

<p>
We can see the contents of that database like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *
<span style="color: #8b0000;">from</span> ase.db <span style="color: #8b0000;">import</span> connect
<span style="color: #8b008b;">c</span> = connect(<span style="color: #228b22;">'vaspdb.json'</span>)

<span style="color: #8b008b;">g</span> = c.select()  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">g is a generator</span>
<span style="color: #8b0000;">print</span> g.<span style="color: #cd0000;">next</span>()
</pre>
</div>

<pre class="example">
{u'username': u'jkitchin', u'calculator_name': u'vasp', u'tags': array([0, 0, 0, 0, 0, 0]), u'positions': array([[ 1.382,  1.382,  0.   ],
       [ 3.145,  3.145,  0.   ],
       [ 3.646,  0.881,  1.548],
       [ 0.881,  3.646,  1.548],
       [ 0.   ,  0.   ,  0.   ],
       [ 2.263,  2.263,  1.548]]), u'energy': -44.251496, u'calculator_parameters': {u'incar': {u'doc': u'INCAR parameters', u'prec': u'high', u'nbands': 43, u'sigma': 0.1, u'encut': 350.0}, u'doc': u'JSON representation of a VASP calculation.\n\nenergy is in eV\nforces are in eV/\\AA\nstress is in GPa (sxx, syy, szz,  syz, sxz, sxy)\nmagnetic moments are in Bohr-magneton\nThe density of states is reported with E_f at 0 eV.\nVolume is reported in \\AA^3\nCoordinates and cell parameters are reported in \\AA\n\nIf atom-projected dos are included they are in the form:\n{ados:{energy:data, {atom index: {orbital : dos}}}\n', u'potcar': [[u'Ru', u'potpaw_PBE/Ru/POTCAR', u'dee616f2a1e7a5430bb588f1710bfea3001d54ea'], [u'O', u'potpaw_PBE/O/POTCAR', u'9a0489b46120b0cad515d935f44b5fbe3a3b1dfa']], u'input': {u'kpts': array([ 6,  6, 10]), u'reciprocal': False, u'xc': u'PBE', u'kpts_nintersections': None, u'setups': {}, u'txt': u'-', u'gamma': True}, u'atoms': {u'cell': array([[ 4.527,  0.   ,  0.   ],
       [ 0.   ,  4.527,  0.   ],
       [ 0.   ,  0.   ,  3.095]]), u'symbols': [u'O', u'O', u'O', u'O', u'Ru', u'Ru'], u'tags': array([0, 0, 0, 0, 0, 0]), u'pbc': array([ True,  True,  True], dtype=bool), u'positions': array([[ 1.382,  1.382,  0.   ],
       [ 3.145,  3.145,  0.   ],
       [ 3.646,  0.881,  1.548],
       [ 0.881,  3.646,  1.548],
       [ 0.   ,  0.   ,  0.   ],
       [ 2.263,  2.263,  1.548]])}, u'data': {u'stress': array([ 0.088,  0.088,  0.06 , -0.   , -0.   , -0.   ]), u'doc': u'Data from the output of the calculation', u'volume': 63.43221074143486, u'total_energy': -44.251496, u'forces': array([[-0.024, -0.024,  0.   ],
       [ 0.024,  0.024,  0.   ],
       [-0.024,  0.024,  0.   ],
       [ 0.024, -0.024,  0.   ],
       [ 0.   ,  0.   ,  0.   ],
       [ 0.   ,  0.   ,  0.   ]]), u'fermi_level': 5.0374}, u'metadata': {u'date.created': 1395241327.477995, u'uuid': u'7081ee4a-af77-11e3-a6e6-003048f5e49e', u'date.created.ascii': u'Wed Mar 19 11:02:07 2014', u'user.username': u'jkitchin', u'atoms.resort': array([2, 3, 4, 5, 0, 1]), u'user.email': u'jkitchin@andrew.cmu.edu', u'user.fullname': u'John Kitchin', u'O.potential.git_hash': u'9a0489b46120b0cad515d935f44b5fbe3a3b1dfa', u'atoms.tags': array([0, 0, 0, 0, 0, 0]), u'O.potential.path': u'potpaw_PBE/O/POTCAR', u'Ru.potential.path': u'potpaw_PBE/Ru/POTCAR', u'Ru.potential.git_hash': u'dee616f2a1e7a5430bb588f1710bfea3001d54ea'}}, u'cell': array([[ 4.527,  0.   ,  0.   ],
       [ 0.   ,  4.527,  0.   ],
       [ 0.   ,  0.   ,  3.095]]), u'numbers': array([ 8,  8,  8,  8, 44, 44]), u'pbc': array([ True,  True,  True], dtype=bool), u'timestamp': 14.23343757848325, u'keywords': [u'atat'], u'forces': array([[-0.024, -0.024,  0.   ],
       [ 0.024,  0.024,  0.   ],
       [-0.024,  0.024,  0.   ],
       [ 0.024, -0.024,  0.   ],
       [ 0.   ,  0.   ,  0.   ],
       [ 0.   ,  0.   ,  0.   ]]), 'id': 1, u'unique_id': u'123901e31734f14418381a23d1ee1072'}
</pre>

<p>
The data stored there comes from the calc.todict() function written for jasp.
</p>

<p>
We can do some searches like this. Say we want to find all the calculations where there are four oxygen atoms.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *
<span style="color: #8b0000;">from</span> ase.db <span style="color: #8b0000;">import</span> connect
<span style="color: #8b008b;">c</span> = connect(<span style="color: #228b22;">'vaspdb.json'</span>)

<span style="color: #8b008b;">g</span> = c.select(O=4)  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">g is a generator</span>
<span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> g:
    <span style="color: #8b0000;">print</span> c.get_atoms(entry[<span style="color: #228b22;">'id'</span>]), <span style="color: #228b22;">'\n'</span>
</pre>
</div>

<pre class="example">
Atoms(symbols='O4Ru2', positions=..., tags=...,
      cell=[4.526933343669885, 4.526933343669885, 3.095292162609941],
      pbc=[True, True, True], calculator=SinglePointCalculator(...)) 

Atoms(symbols='O4Ti2', positions=..., tags=...,
      cell=[4.614336091353763, 4.614336091353763, 2.9555779409837473],
      pbc=[True, True, True], calculator=SinglePointCalculator(...)) 

Atoms(symbols='O4RuTi', positions=..., tags=...,
      cell=[[-0.0151920891931803, -4.604112035041115, 0.0],
      [-4.604112035041115, -0.0151920891931803, 0.0], [0.0, 0.0,
      -3.0110141191854245]], pbc=[True, True, True],
      calculator=SinglePointCalculator(...))
</pre>

<p>
You can see there are three calculations with that criterion.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The command-line interface</h2>
<div class="outline-text-2" id="text-1">
<p>
There is also a command-line interface.
</p>

<div class="org-src-container">

<pre class="src src-sh">ase-db --help
</pre>
</div>

<pre class="example">
usage: ase-db [-h] [-n] [-c COLUMNS] [--explain] [-y] [-i INSERT_INTO]
              [-k ADD_KEYWORDS] [-K ADD_KEY_VALUE_PAIRS]
              [--delete-keywords DELETE_KEYWORDS]
              [--delete-key-value-pairs DELETE_KEY_VALUE_PAIRS] [--delete]
              [-v] [-q] [-s SORT] [-r] [-l] [--limit LIMIT]
              [-p PYTHON_EXPRESSION]
              name [selection]

positional arguments:
  name
  selection

optional arguments:
  -h, --help            show this help message and exit
  -n, --count
  -c COLUMNS, --columns COLUMNS
                        short/long+row-row
  --explain
  -y, --yes
  -i INSERT_INTO, --insert-into INSERT_INTO
  -k ADD_KEYWORDS, --add-keywords ADD_KEYWORDS
  -K ADD_KEY_VALUE_PAIRS, --add-key-value-pairs ADD_KEY_VALUE_PAIRS
  --delete-keywords DELETE_KEYWORDS
  --delete-key-value-pairs DELETE_KEY_VALUE_PAIRS
  --delete
  -v, --verbose
  -q, --quiet
  -s SORT, --sort SORT
  -r, --reverse
  -l, --long
  --limit LIMIT
  -p PYTHON_EXPRESSION, --python-expression PYTHON_EXPRESSION
</pre>

<p>
It is not obvious all those options are actually supported. For example, it is not clear there is a function that actually deletes keywords in the source code. You can add keywords, but I cannot figure out the syntax to add to one entry.
</p>

<p>
Below are some examples that do work. We can list details of the calculation with id=1.
</p>
<div class="org-src-container">

<pre class="src src-sh">ase-db vaspdb.json <span style="color: #8b008b;">id</span>=1
</pre>
</div>

<pre class="example">
id|age|user    |formula|calc| energy| fmax|pbc|  size|keywords|   mass
 1|9m |jkitchin|O4Ru2  |vasp|-44.251|0.033|111|63.432|atat    |266.138
</pre>

<p>
Get calculations with four oxygen atoms:
</p>
<div class="org-src-container">

<pre class="src src-sh">ase-db vaspdb.json <span style="color: #8b008b;">O</span>=4
</pre>
</div>

<pre class="example">
id|age|user    |formula|calc| energy| fmax|pbc|  size|keywords|   mass
 1|9m |jkitchin|O4Ru2  |vasp|-44.251|0.033|111|63.432|atat    |266.138
 2|9m |jkitchin|O4Ti2  |vasp|-52.970|0.033|111|62.930|atat    |159.758
11|9m |jkitchin|O4RuTi |vasp|-48.115|0.157|111|63.826|atat    |212.948
</pre>

<p>
Get all calculations tagged with atat
</p>
<div class="org-src-container">

<pre class="src src-sh">ase-db vaspdb.json atat
</pre>
</div>

<pre class="example">
id|age|user    |formula  |calc|  energy| fmax|pbc|   size|keywords|   mass
 1|9m |jkitchin|O4Ru2    |vasp| -44.251|0.033|111| 63.432|atat    |266.138
 2|9m |jkitchin|O4Ti2    |vasp| -52.970|0.033|111| 62.930|atat    |159.758
 3|9m |jkitchin|O8Ru2Ti2 |vasp| -96.601|0.086|111|126.719|atat    |425.895
 4|9m |jkitchin|O8RuTi3  |vasp|-100.842|0.075|111|126.846|atat    |372.705
 5|9m |jkitchin|O8Ru3Ti  |vasp| -92.376|0.133|111|127.420|atat    |479.085
 6|9m |jkitchin|O8Ru2Ti2 |vasp| -96.594|0.184|111|127.176|atat    |425.895
 7|9m |jkitchin|O8RuTi3  |vasp|-100.959|0.176|111|126.924|atat    |372.705
 8|9m |jkitchin|O8Ru3Ti  |vasp| -92.314|0.084|111|127.377|atat    |479.085
 9|9m |jkitchin|O8Ru2Ti2 |vasp| -96.612|0.086|111|126.542|atat    |425.895
10|9m |jkitchin|O8RuTi3  |vasp|-100.816|0.080|111|126.557|atat    |372.705
11|9m |jkitchin|O4RuTi   |vasp| -48.115|0.157|111| 63.826|atat    |212.948
12|9m |jkitchin|O8Ru3Ti  |vasp| -92.429|0.163|111|127.291|atat    |479.085
13|9m |jkitchin|O8Ru2Ti2 |vasp| -96.770|0.166|111|126.870|atat    |425.895
14|9m |jkitchin|O8RuTi3  |vasp|-101.014|0.222|111|126.881|atat    |372.705
15|9m |jkitchin|O12Ru4Ti2|vasp|-140.969|0.114|111|190.614|atat    |692.033
16|9m |jkitchin|O8Ru3Ti  |vasp| -92.323|0.125|111|127.541|atat    |479.085
17|9m |jkitchin|O12Ru2Ti4|vasp|-149.516|0.241|111|190.070|atat    |585.653
18|9m |jkitchin|O8Ru2Ti2 |vasp| -96.661|0.064|111|127.038|atat    |425.895
19|9m |jkitchin|O12Ru4Ti2|vasp|-140.472|0.138|111|190.640|atat    |692.033
20|9m |jkitchin|O12Ru3Ti3|vasp|-144.667|0.166|111|190.604|atat    |638.843
21|9m |jkitchin|O12Ru2Ti4|vasp|-148.813|0.055|111|190.084|atat    |585.653
22|9m |jkitchin|O8RuTi3  |vasp|-100.874|0.051|111|126.690|atat    |372.705
23|9m |jkitchin|O8Ru3Ti  |vasp| -92.246|0.102|111|127.383|atat    |479.085
</pre>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-2">
<p>
This is a nice addition to ase. I think it needs some thorough, production work testing to find out exactly how useful it is. We may need to reconsider the calc.todict() function in jasp to remove redundancy, but overall this is a good idea.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/26/writing-VASP-calculations-to-ase.db-formats.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Deleting multiple elements of a list</title>
      <link>http://jkitchin.github.io/blog/2014/03/25/Deleting-multiple-elements-of-a-list</link>
      <pubDate>Tue, 25 Mar 2014 18:40:34 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">BPGq5RdQ9cCvgvQGmG0q8NvfwOM=</guid>
      <description>Deleting multiple elements of a list</description>
      <content:encoded><![CDATA[



<p>
Today someone asked about deleting multiple elements from a list (actually it was about deleting multiple atoms from an ase.Atoms object, but some principles here apply. I will address that actual question later.).
</p>

<p>
Deleting multiple items from a list is not directly possible in one command in Python. There are a few approaches to accomplishing something like it. Which one is best depends on your objective. 
</p>

<p>
One problem is when you delete an item, the indices of every item after it also changes. One strategy then is to delete the elements in descending order, i.e. delete the largest indices first. That way, you do not change the indices of the smaller indices, so you can still delete them. We can sort them in reverse order like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [1, 2, 5, 6, 7]

<span style="color: #8b008b;">ind2remove</span> = [1, 3]

<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">sorted</span>(ind2remove, reverse=<span style="color: #cd0000;">True</span>): 
    <span style="color: #8b0000;">del</span> a[i]

<span style="color: #8b0000;">print</span> a
</pre>
</div>

<pre class="example">
[1, 5, 7]
</pre>

<p>
An alternative approach is to make a new list that only has the elements you want using list comprehension. For example:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [1, 2, 5, 6, 7]

<span style="color: #8b008b;">ind2remove</span> = [1, 3]

<span style="color: #8b008b;">a</span> = [x <span style="color: #8b0000;">for</span> i,x <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">enumerate</span>(a) <span style="color: #8b0000;">if</span> i <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">in</span> ind2remove]

<span style="color: #8b0000;">print</span> a
</pre>
</div>

<pre class="example">
[1, 5, 7]
</pre>

<p>
With numpy arrays you can delete multiple elements like this:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">a</span> = np.array([1, 2, 5, 6, 7])

<span style="color: #8b008b;">ind2remove</span> = [1, 3]

<span style="color: #8b0000;">print</span> np.delete(a, ind2remove)
<span style="color: #8b0000;">print</span> a
</pre>
</div>

<pre class="example">
[1 5 7]
[1 2 5 6 7]
</pre>

<p>
The delete command makes a new object; the original list is unchanged. Numpy arrays are technically immutable, so the only way to do this is to make a copy. Another way is to use a boolean mask that only selects the indices where the mask is True, and not where they are False.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b008b;">a</span> = np.array([1, 2, 5, 6, 7])

<span style="color: #8b008b;">ind2remove</span> = [1, 3]

<span style="color: #8b008b;">mask</span> = np.ones(<span style="color: #cd0000;">len</span>(a), dtype=<span style="color: #cd0000;">bool</span>) 
<span style="color: #8b008b;">mask</span>[ind2remove] = <span style="color: #cd0000;">False</span>
<span style="color: #8b0000;">print</span> a[mask]
<span style="color: #8b0000;">print</span> a
</pre>
</div>

<pre class="example">
[1 5 7]
[1 2 5 6 7]
</pre>

<p>
There might be other ways to do this too. These examples are nearly indistinguishable for small lists. For very large lists (I guess 1000's of elements), you may find one method more efficient than the others. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/25/Deleting-multiple-elements-of-a-list.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Using tags searches on objects in python</title>
      <link>http://jkitchin.github.io/blog/2014/03/24/Using-tags-searches-on-objects-in-python</link>
      <pubDate>Mon, 24 Mar 2014 21:52:13 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">aNT40EcSdDktAGIaeUbBkG6knMQ=</guid>
      <description>Using tags searches on objects in python</description>
      <content:encoded><![CDATA[



<p>
I am exploring the possibility of using tags on python objects in conjunction with searches to find sets of objects. Here I want to explore some syntax and methods for doing that.
</p>

<p>
In org-mode there is a syntax like '+boss+urgent-project1' for <code>and</code> and <code>not</code> operators and 'A|B' for <code>or</code> operators. I think we need <a href="http://pyparsing.wikispaces.com/Examples">pyparsing</a> to untangle this kind of syntax. See <a href="http://pyparsing.wikispaces.com/file/view/simpleBool.py">http://pyparsing.wikispaces.com/file/view/simpleBool.py</a> for an example. Another alternative might be the natural language toolkit (<a href="http://www.nltk.org/">nltk</a> ). Before we dig into those, let us see some python ways of doing the logic.
</p>

<p>
Below we define some lists containing tags (strings). We 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">b</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>]

<span style="color: #8b008b;">c</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">d</span> = [ <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">all_lists</span> = [a, b, c, d]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">get functions with tags A and B</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A and B '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">A not B</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A not B '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">B or C</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'B or C '</span>, [x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x) | (<span style="color: #228b22;">'C'</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">B or C but not both</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'B xor C '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x) ^ (<span style="color: #228b22;">'C'</span> <span style="color: #8b0000;">in</span> x)]
</pre>
</div>

<pre class="example">
A and B  [['A', 'B', 'C'], ['A', 'B']]
A not B  [['A', 'C']]
B or C  [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['B', 'C']]
B xor C  [['A', 'B'], ['A', 'C']]
</pre>

<p>
Those are not too bad. Somehow I would have to get pyparsing to generate that syntax. That will take a lot of studying. There are some other ways to do this too. Let us try that out with itertools.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">b</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>]

<span style="color: #8b008b;">c</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">d</span> = [ <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">all_lists</span> = [a, b, c, d]

<span style="color: #8b0000;">import</span> itertools <span style="color: #8b0000;">as</span> it

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">ifilter returns an iterator</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A and B '</span>, <span style="color: #cd0000;">list</span>(it.ifilter(<span style="color: #8b0000;">lambda</span> x: (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x), all_lists))
</pre>
</div>

<pre class="example">
A and B  [['A', 'B', 'C'], ['A', 'B']]
</pre>

<p>
I do not like this syntax better. The iterator is lazy, so we have to wrap it in a list to get the results.  Eventually, I want to do something like these:
</p>

<pre class="example">
filter('A and B', all_lists)
A or B
A xor B
not A and B
not(A and B)
</pre>

<p>
I think that calls for pyparsing.  I think the syntax above is better (more readable) than this:
</p>

<pre class="example">
filter('A &amp; B', all_lists)
A | B
A ^ B
~A &amp; B
~(A &amp; B)
</pre>

<p>
It is not that obvious though how to get from that syntax to the code I illustrated above though.</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/24/Using-tags-searches-on-objects-in-python.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Mehak Chawla selected as the H. William and Ruth Hamilton Prengle Fellow of Chemical Enginering for 2013-2014</title>
      <link>http://jkitchin.github.io/blog/2014/03/24/Mehak-Chawla-selected-as-the-H-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014</link>
      <pubDate>Mon, 24 Mar 2014 14:30:34 EDT</pubDate>
      <category><![CDATA[news]]></category>
      <guid isPermaLink="false">YRmYX_NRYW1Po209esLgxPEFxLM=</guid>
      <description>Mehak Chawla selected as the H. William and Ruth Hamilton Prengle Fellow of Chemical Enginering for 2013-2014</description>
      <content:encoded><![CDATA[



<p>
This fellowship was established with the generous donation of Dr. H. William and Ruth Prengle to provide tuition for graduate students with outstanding academic records. 
</p>

<p>
Congratulations Mehak!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/24/Mehak-Chawla-selected-as-the-H.-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Make a list of org-files in all the subdirectories of the current working directory</title>
      <link>http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory</link>
      <pubDate>Sun, 23 Mar 2014 15:36:56 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[recursive]]></category>
      <guid isPermaLink="false">ol_gYLGLHCsyZ025rQ_qIKwXg34=</guid>
      <description>Make a list of org-files in all the subdirectories of the current working directory</description>
      <content:encoded><![CDATA[



<p>
It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents. 
</p>

<p>
Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called <code>literate</code> in my computer.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">list contents of the directory</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
<td class="left">..</td>
<td class="left">.</td>
</tr>
</tbody>
</table>

<p>
Note the presence of <code>.</code> and <code>..</code>. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">remove . and ..</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (remove <span style="color: #228b22;">"."</span> 
          (remove <span style="color: #228b22;">".."</span> 
                  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
</tr>
</tbody>
</table>

<p>
Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">print types of files in the directory</span>
(<span style="color: #8b0000;">let</span> ((root <span style="color: #228b22;">"literate"</span>)
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (<span style="color: #8b0000;">lambda</span> (x)
            (<span style="color: #8b0000;">cond</span>
             ((file-directory-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a directory"</span> x)))
             ((file-regular-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a regular file"</span> x)))))
          (remove <span style="color: #228b22;">"."</span> 
                  (remove <span style="color: #228b22;">".."</span> 
                          (directory-files root abspath match nosort)))))
</pre>
</div>

<pre class="example">
"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
</pre>

<p>
Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at <a href="http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html">http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html</a> which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  <span style="color: #228b22;">"recursively walks through directories getting list of absolute paths of files"</span>
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk <span style="color: #228b22;">"literate"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/makefile-main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/literate.org</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/hello.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.mod</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle-area.png</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/a.out</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/Makefile</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/archive/empty-text-file.txt</td>
</tr>
</tbody>
</table>

<p>
Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">;</span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(<span style="color: #8b0000;">require</span> '<span style="color: #cd0000;">cl</span>)

(mapcar 
 (<span style="color: #8b0000;">lambda</span> (x) (princ (format <span style="color: #228b22;">"[[%s][%s]]\n"</span> x (file-relative-name x <span style="color: #228b22;">"."</span>))))
 (remove-if-not 
  (<span style="color: #8b0000;">lambda</span> (x) (string= (file-name-extension x) <span style="color: #228b22;">"org"</span>))
  (os-walk <span style="color: #228b22;">"literate"</span>)))
</pre>
</div>

<p>
<a href="/media/2014-03-23-Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory/literate.org">literate/literate.org</a> 
</p>


<p>
That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
  </channel>
</rss>
