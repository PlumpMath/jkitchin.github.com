<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Tue, 25 Mar 2014 01:53:02 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Using tags searches on objects in python</title>
      <link>http://jkitchin.github.io/blog/2014/03/24/Using-tags-searches-on-objects-in-python</link>
      <pubDate>Mon, 24 Mar 2014 21:52:13 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <guid isPermaLink="false">aNT40EcSdDktAGIaeUbBkG6knMQ=</guid>
      <description>Using tags searches on objects in python</description>
      <content:encoded><![CDATA[



<p>
I am exploring the possibility of using tags on python objects in conjunction with searches to find sets of objects. Here I want to explore some syntax and methods for doing that.
</p>

<p>
In org-mode there is a syntax like '+boss+urgent-project1' for <code>and</code> and <code>not</code> operators and 'A|B' for <code>or</code> operators. I think we need <a href="http://pyparsing.wikispaces.com/Examples">pyparsing</a> to untangle this kind of syntax. See <a href="http://pyparsing.wikispaces.com/file/view/simpleBool.py">http://pyparsing.wikispaces.com/file/view/simpleBool.py</a> for an example. Another alternative might be the natural language toolkit (<a href="http://www.nltk.org/">nltk</a> ). Before we dig into those, let us see some python ways of doing the logic.
</p>

<p>
Below we define some lists containing tags (strings). We 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">b</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>]

<span style="color: #8b008b;">c</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">d</span> = [ <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">all_lists</span> = [a, b, c, d]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">get functions with tags A and B</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A and B '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">A not B</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A not B '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">not</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">B or C</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'B or C '</span>, [x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x) | (<span style="color: #228b22;">'C'</span> <span style="color: #8b0000;">in</span> x)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">B or C but not both</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'B xor C '</span>,[x <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> all_lists <span style="color: #8b0000;">if</span> (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x) ^ (<span style="color: #228b22;">'C'</span> <span style="color: #8b0000;">in</span> x)]
</pre>
</div>

<pre class="example">
A and B  [['A', 'B', 'C'], ['A', 'B']]
A not B  [['A', 'C']]
B or C  [['A', 'B', 'C'], ['A', 'B'], ['A', 'C'], ['B', 'C']]
B xor C  [['A', 'B'], ['A', 'C']]
</pre>

<p>
Those are not too bad. Somehow I would have to get pyparsing to generate that syntax. That will take a lot of studying. There are some other ways to do this too. Let us try that out with itertools.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">a</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">b</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'B'</span>]

<span style="color: #8b008b;">c</span> = [<span style="color: #228b22;">'A'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">d</span> = [ <span style="color: #228b22;">'B'</span>, <span style="color: #228b22;">'C'</span>]

<span style="color: #8b008b;">all_lists</span> = [a, b, c, d]

<span style="color: #8b0000;">import</span> itertools <span style="color: #8b0000;">as</span> it

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">ifilter returns an iterator</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'A and B '</span>, <span style="color: #cd0000;">list</span>(it.ifilter(<span style="color: #8b0000;">lambda</span> x: (<span style="color: #228b22;">'A'</span> <span style="color: #8b0000;">in</span> x) &amp; (<span style="color: #228b22;">'B'</span> <span style="color: #8b0000;">in</span> x), all_lists))
</pre>
</div>

<pre class="example">
A and B  [['A', 'B', 'C'], ['A', 'B']]
</pre>

<p>
I do not like this syntax better. The iterator is lazy, so we have to wrap it in a list to get the results.  Eventually, I want to do something like these:
</p>

<pre class="example">
filter('A and B', all_lists)
A or B
A xor B
not A and B
not(A and B)
</pre>

<p>
I think that calls for pyparsing.  I think the syntax above is better (more readable) than this:
</p>

<pre class="example">
filter('A &amp; B', all_lists)
A | B
A ^ B
~A &amp; B
~(A &amp; B)
</pre>

<p>
It is not that obvious though how to get from that syntax to the code I illustrated above though.</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/24/Using-tags-searches-on-objects-in-python.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Mehak Chawla selected as the H. William and Ruth Hamilton Prengle Fellow of Chemical Enginering for 2013-2014</title>
      <link>http://jkitchin.github.io/blog/2014/03/24/Mehak-Chawla-selected-as-the-H-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014</link>
      <pubDate>Mon, 24 Mar 2014 14:30:34 EDT</pubDate>
      <category><![CDATA[news]]></category>
      <guid isPermaLink="false">YRmYX_NRYW1Po209esLgxPEFxLM=</guid>
      <description>Mehak Chawla selected as the H. William and Ruth Hamilton Prengle Fellow of Chemical Enginering for 2013-2014</description>
      <content:encoded><![CDATA[



<p>
This fellowship was established with the generous donation of Dr. H. William and Ruth Prengle to provide tuition for graduate students with outstanding academic records. 
</p>

<p>
Congratulations Mehak!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/24/Mehak-Chawla-selected-as-the-H.-William-and-Ruth-Hamilton-Prengle-Fellow-of-Chemical-Enginering-for-2013-2014.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Make a list of org-files in all the subdirectories of the current working directory</title>
      <link>http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory</link>
      <pubDate>Sun, 23 Mar 2014 15:36:56 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[recursive]]></category>
      <guid isPermaLink="false">ol_gYLGLHCsyZ025rQ_qIKwXg34=</guid>
      <description>Make a list of org-files in all the subdirectories of the current working directory</description>
      <content:encoded><![CDATA[



<p>
It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents. 
</p>

<p>
Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called <code>literate</code> in my computer.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">list contents of the directory</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
<td class="left">..</td>
<td class="left">.</td>
</tr>
</tbody>
</table>

<p>
Note the presence of <code>.</code> and <code>..</code>. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">remove . and ..</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (remove <span style="color: #228b22;">"."</span> 
          (remove <span style="color: #228b22;">".."</span> 
                  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
</tr>
</tbody>
</table>

<p>
Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">print types of files in the directory</span>
(<span style="color: #8b0000;">let</span> ((root <span style="color: #228b22;">"literate"</span>)
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (<span style="color: #8b0000;">lambda</span> (x)
            (<span style="color: #8b0000;">cond</span>
             ((file-directory-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a directory"</span> x)))
             ((file-regular-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a regular file"</span> x)))))
          (remove <span style="color: #228b22;">"."</span> 
                  (remove <span style="color: #228b22;">".."</span> 
                          (directory-files root abspath match nosort)))))
</pre>
</div>

<pre class="example">
"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
</pre>

<p>
Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at <a href="http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html">http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html</a> which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  <span style="color: #228b22;">"recursively walks through directories getting list of absolute paths of files"</span>
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk <span style="color: #228b22;">"literate"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/makefile-main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/literate.org</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/hello.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.mod</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle-area.png</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/a.out</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/Makefile</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/archive/empty-text-file.txt</td>
</tr>
</tbody>
</table>

<p>
Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">;</span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(<span style="color: #8b0000;">require</span> '<span style="color: #cd0000;">cl</span>)

(mapcar 
 (<span style="color: #8b0000;">lambda</span> (x) (princ (format <span style="color: #228b22;">"[[%s][%s]]\n"</span> x (file-relative-name x <span style="color: #228b22;">"."</span>))))
 (remove-if-not 
  (<span style="color: #8b0000;">lambda</span> (x) (string= (file-name-extension x) <span style="color: #228b22;">"org"</span>))
  (os-walk <span style="color: #228b22;">"literate"</span>)))
</pre>
</div>

<p>
<a href="/media/2014-03-23-Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory/literate.org">literate/literate.org</a> 
</p>


<p>
That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Finding VASP calculations in a directory tree</title>
      <link>http://jkitchin.github.io/blog/2014/03/20/Finding-VASP-calculations-in-a-directory-tree</link>
      <pubDate>Thu, 20 Mar 2014 20:09:26 EDT</pubDate>
      <category><![CDATA[python]]></category>
      <category><![CDATA[vasp]]></category>
      <guid isPermaLink="false">dJVXTxeMC7XkaZ7TwVitwNM_m0Q=</guid>
      <description>Finding VASP calculations in a directory tree</description>
      <content:encoded><![CDATA[



<p>
The goal in this post is to work out a way to find all the directories in some root directory that contain VASP calculations. This is a precursor to doing something with those directories, e.g. creating a summary file, adding entries to a database, doing some analysis, etc&#x2026; For fun, we will just calculate the total elapsed time in the calculations.
</p>

<p>
What is challenging about this problem is that the calculations are often nested in a variety of different subdirectories, and we do not always know the structure. We need to recursively descend into those directories to check if they contain VASP calculations. 
</p>

<p>
We will use a function that returns True or False to tell us if a particular directory is a VASP calculation or not. We can tell that because a completed VASP calculation has specific files in it, and specific content in those files. Notably, there is an OUTCAR file that contains the text "General timing and accounting informations for this job:" near the end of the file.
</p>

<p>
We will also use <a href="http://docs.python.org/2/library/os.html#os.walk">os.walk</a> as the way to recursively descend into the root directory.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> os
<span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">vasp_p</span>(directory):
    <span style="color: #228b22;">'returns True if a finished OUTCAR file exists in the current directory, else False'</span>
    <span style="color: #8b008b;">outcar</span> = os.path.join(directory, <span style="color: #228b22;">'OUTCAR'</span>)
    <span style="color: #8b0000;">if</span> os.path.exists(outcar):
        <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(outcar, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> f:
            <span style="color: #8b008b;">contents</span> = f.read()
            <span style="color: #8b0000;">if</span> <span style="color: #228b22;">'General timing and accounting informations for this job:'</span> <span style="color: #8b0000;">in</span> contents:
                <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">False</span>
            
        
<span style="color: #8b008b;">total_time</span> = 0

<span style="color: #8b0000;">for</span> root, dirs, files <span style="color: #8b0000;">in</span> os.walk(<span style="color: #228b22;">'/home-research/jkitchin/research/rutile-atat'</span>):
    <span style="color: #8b0000;">for</span> d <span style="color: #8b0000;">in</span> dirs:
        <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">compute absolute path to each directory in the current root</span>
        <span style="color: #8b008b;">absd</span> = os.path.join(root, d)
        <span style="color: #8b0000;">if</span> vasp_p(absd):
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we found a vasp directory, so we can do something in it. </span>
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">here we get the elapsed time from the calculation</span>
            <span style="color: #8b0000;">with</span> jasp(absd) <span style="color: #8b0000;">as</span> calc:
                <span style="color: #8b008b;">total_time</span> += calc.get_elapsed_time()

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'Total computational time on this project is {0:1.0f} minutes.'</span>.<span style="color: #cd0000;">format</span>(total_time / 60)
</pre>
</div>

<pre class="example">
Total computational time on this project is 231 minutes.
</pre>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/20/Finding-VASP-calculations-in-a-directory-tree.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Using yasnippet to get completion in ref links</title>
      <link>http://jkitchin.github.io/blog/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links</link>
      <pubDate>Sat, 08 Mar 2014 07:55:54 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">o-a0VyUQdRLKKR9sLjtLpupUsO8=</guid>
      <description>Using yasnippet to get completion in ref links</description>
      <content:encoded><![CDATA[



<p>
This post illustrates an alternative approach to completion in creating ref links compared to the approach shown <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/06/Using-completion-in-ref-links/">here</a> . In this approach we use a dynamic yasnippet to do the completion. We start with similar code that I used before to get a list of labels from the buffer. I used a slightly different regexp to recognize links in this version.
</p>

<p>
<pre>label:code-example</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">get-labels</span> ()
  (interactive)
  (<span style="color: #8b0000;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #8b0000;">let</span> ((matches '()))
      (<span style="color: #8b0000;">while</span> (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-z0-9:-]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)
        (add-to-list 'matches (match-string-no-properties 1) t))
      matches)))
</pre>
</div>

<pre class="example">
get-labels
</pre>

<p>
Let us see that in action:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(get-labels)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">code-example</td>
<td class="left">\\</td>
<td class="left">code:ref-snippet</td>
<td class="left">load-snippets</td>
</tr>
</tbody>
</table>

<p>
I think the <code>\\</code> link is an artifact of the regexp in my get-labels code, and it would not appear in other examples. 
</p>

<p>
Now, we are going to create a yasnippet that uses the list returned from <code>get-labels</code> to provide your choices. See <a href="http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8">http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8</a> for some details. We will tangle this code block into a local snippets directory.
</p>

<p>
<pre>label:code:ref-snippet</pre> 
</p>
<div class="org-src-container">

<pre class="src src-snippet"><span style="color: #ff0000; font-weight: bold;"># -*- mode: snippet -*-</span>
<span style="color: #ff0000; font-weight: bold;"># --</span>
ref:<span style="color: #8b0000;">${</span><span style="color: #ff0000; font-weight: bold;">1</span><span style="color: #8b0000;">:</span>$<span style="color: #0000cd; font-weight: bold;">$(</span>yas-choose-value (get-labels))<span style="color: #8b0000;">}</span> <span style="color: #8b0000;">$</span><span style="color: #228b22;">0</span>
</pre>
</div>

<p>
Now we load the snippets directory.
</p>

<p>
<pre>label:load-snippets</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-load-directory <span style="color: #228b22;">"./snippets"</span>)
</pre>
</div>

<p>
Finally, we can type ref, press tab to complete it, and then select the label you want from a list. Here are some examples:
</p>

<p>
<pre>ref:code-example</pre> 
</p>

<p>
<pre>ref:code:ref-snippet</pre> 
</p>

<p>
That also works! I cannot decide if I like this better than the Emacs completion. yasnippet gives a popup menu, which is not as easy to navigate as the Emacs completion mechanism. It also requires a working yasnippet, which has not made it into my regular work flows too often. I think I like the Emacs completion better (which actually goes through Icicles since I have that installed). I like it better because I do not have to leave the keyboard or use the arrow buttons to choose a label. However, I do need to bind that function to some key to use it, or type in the command name. It turns out I do not use ref links too often, so it is not too burdensome.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Storing label links in org-mode</title>
      <link>http://jkitchin.github.io/blog/2014/03/07/Storing-label-links-in-org-mode</link>
      <pubDate>Fri, 07 Mar 2014 16:13:39 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">NpP6aGRkBlN4BqSNugVcqHPVOog=</guid>
      <description>Storing label links in org-mode</description>
      <content:encoded><![CDATA[



<p>
I am continuing to evolve how I can use org-mode. I have created a label link, which if clicked on checks to see that the label is unique in the buffer. It would be nice to be able to be on a <pre>label:some-label</pre> link, and to store it so we could create a <pre>ref:some-label</pre> later. That ref link is also clickable, and it jumps to the label it refers to, and provides a C-c &amp; option to get back to the ref link. org-mode allows you to create <code>org-PREFIX-store-link</code> functions which store the link information. These functions must determine if they are responsible for storing the link and return nil if not. The first challenge is figuring out if the cursor is on a label link. Here is a function that does that.
</p>

<p>
This was a little challenging. The strategy to determine if the cursor is in a link is to search backward for a regular expression matching a label link. I found this was not sufficient, because it appeared to me that the matched string was only between the beginning of the label link and the point where the cursor was. So, after finding the beginning of the first label link before the cursor, then we search forward to find the whole link. Then we determine if the cursor is between the beginning and end of the match. If it is, then we are on a label link. Here is the code.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">in-label-link</span> ()
  <span style="color: #228b22;">"return label if in a label link, or return nil</span>

<span style="color: #228b22;">we store point, search forward to the first space, and backward to the previous space. then make sure label: is between them."</span>
  (interactive)
  (<span style="color: #8b0000;">let</span> ((current-point (point)))
    (<span style="color: #8b0000;">save-excursion</span>
      (re-search-backward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-z0-9:-]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-min) t)
      (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-Z0-9-:]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)   
      (<span style="color: #8b0000;">if</span> (and (&gt; current-point (match-beginning 0))
               (&lt; current-point (match-end 0)))
          t
        nil))))
</pre>
</div>

<p>
This code works for these kinds of links as far as I can tell. Interestingly, it only works when the cursor is to the right of label:. I am not sure if that is because of the regular expression or not.
</p>

<p>
<pre>label:plain-beginning</pre> 
</p>

<p>
<pre>label:telabel</pre> 
</p>

<p>
<pre>label:fig:test</pre> 
</p>

<p>
<pre>label:bracket-in-line</pre> 
</p>


<p>
Now, we create the code that stores the link. We only execute the code if we pass the function that checks if we are on a label link. If we are, then the label is stored in <code>(match-string 1)</code>, and we create the link and store it. Finally, we add the function to <code>org-store-link-functions</code> so that it will be used when C-c l is pressed.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-label-store-link</span> ()
  <span style="color: #228b22;">"store a link to a label. The output will be a ref to that label"</span>
  <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">First we have to make sure we are on a label link. </span>
  (<span style="color: #8b0000;">when</span> (in-label-link)
    (org-store-link-props
     <span style="color: #cd0000;">:type</span> <span style="color: #228b22;">"ref"</span>
     <span style="color: #cd0000;">:link</span> (concat <span style="color: #228b22;">"ref:"</span> (match-string 1)))))

(add-hook 'org-store-link-functions 'org-label-store-link)
</pre>
</div>

<p>
So, here is the evidence that it worked:
</p>

<p>
<pre>ref:plain-beginning</pre> 
</p>

<p>
<pre>ref:telabel</pre> 
</p>

<p>
<pre>ref:fig:test</pre> 
</p>

<p>
<pre>ref:bracket-in-line</pre> 
</p>

<p>
For each of these, I put the cursor on the labels, pressed C-c l, and then moved the cursor down here and pressed C-c C-l, and pressed enter and PRESTO! I had the reference that I wanted! That seems like a handy trick.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/07/Storing-label-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Using completion in ref links</title>
      <link>http://jkitchin.github.io/blog/2014/03/06/Using-completion-in-ref-links</link>
      <pubDate>Thu, 06 Mar 2014 19:11:07 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">BYDh83A1U3X7fdTRJp_0i4quNyc=</guid>
      <description>Using completion in ref links</description>
      <content:encoded><![CDATA[



<p>
I came across this interesting post on using completion in links: <a href="http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs">http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs</a> . I like the idea, but the type-flow for is not how I usually insert links. For the method there to work, you have to enter a link with C-c C-l, partially enter the link type, press enter, and then partially enter the description, which can be completed with tab. That is a lot of typing to me, compared to what I usually do which is type the link in directly. That habit does not work too well in large documents, and always has the possibility of a typo in the link, which then does not work or export correctly.
</p>

<p>
Here I explore how to make a <pre>ref:label</pre> link using a function that provides all the options available as labels. The idea is to write a function that generates a list of labels in the buffer, which you can make a link to. Let us try an interactive function with a list of arguments. We are first going to generate a list of labels from the buffer. We use this code to get a list of labels in the buffer. You will get to choose which label you want a link to, and the function will insert it for you. Here it is:
</p>

<p>
<pre>label:code-example</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">get-labels</span> ()
  (interactive)
  (<span style="color: #8b0000;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #8b0000;">let</span> ((matches '()))
      (<span style="color: #8b0000;">while</span> (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">.*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)
        (add-to-list 'matches (match-string-no-properties 1) t))
      matches)))

(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-insert-ref-link</span> (<span style="color: #4682b4;">&amp;optional</span> arg)
  (interactive (list (completing-read <span style="color: #228b22;">"label: "</span> (get-labels))))
  (insert (format <span style="color: #228b22;">"ref:%s"</span> arg)))
</pre>
</div>

<pre class="example">
org-insert-ref-link
</pre>

<p>
So, here you run the command with M-x org-insert-ref-link, press tab, and select the label you want to use. A link like this gets inserted in your buffer <pre>ref:code-example</pre> . This is pretty nice. It should reduce the number of ref link mistakes, and make it easier to find the labels in the whole buffer.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/06/Using-completion-in-ref-links.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Creating a transportable zip-archive of an org-file</title>
      <link>http://jkitchin.github.io/blog/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file</link>
      <pubDate>Wed, 05 Mar 2014 10:49:14 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">JHmvc5iQPy-52jQTSAudfK1pe_E=</guid>
      <description>Creating a transportable zip-archive of an org-file</description>
      <content:encoded><![CDATA[



<p>
This post explores a method to save an org-buffer to a zip archive, with all the referencing files. The challenge is that you may want to share the org-file with someone, but the links break if you send them the file, and it is not that trivial to find all the links and change them, and to copy the files to a place where the new links work. 
</p>

<p>
The idea is to export the buffer to an org-file and process all the links to copy the files to a new directory, and change the links to point to these new files. For example, <a href="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/blog.pdf">blog.pdf</a> would be copied to the temporary directory, given a unique name, and then relinked. The text below includes some examples of the links that need to be modified.
</p>

<p>
A figure looks like:
</p>


<div class="figure">
<p><img src="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/cos-plot.png"> 
</p>
</div>

<p>
Alternatively, we might use a <img src="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/eos.png"> to a file. We do not want to change urls, such as this one: <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/">http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/</a> . As in that example, we will create a list of all the links in the buffer, but only modify the links that are files. We can parse the buffer and get the links like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((parsetree (org-element-parse-buffer))
      (counter 0))
  (org-element-map parsetree 'link
    (<span style="color: #8b0000;">lambda</span> (link) 
      (<span style="color: #8b0000;">let</span> ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
        (princ (format <span style="color: #228b22;">"%s %s: %s %s\n"</span> 
                       counter 
                       (plist-get plist '<span style="color: #cd0000;">:type</span>) 
                       (plist-get plist <span style="color: #cd0000;">:path</span>) 
                       content))
        (setq counter (+ counter 1))))))
</pre>
</div>
<pre class="example">
0 file: ./blog.pdf nil
1 file: ./images/cos-plot.png nil
2 file: ./images/eos.png link
3 http: //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ nil
</pre>

<p>
So, our overall strategy will be to create a new directory to store the new versions of the files in. Then, we will copy the files that links point to into that directory, and give them new unique names. We will rename the links to point to these new names. We do this because you may, for some reason have links to files with the same name but in different directories. We want to make sure we do not clobber the files by overwriting them. We use a simple method here, based on unique, temporary filenames. There are other ways to do it to, this way worked first. Finally, we will zip that new directory, and delete the new directory.
</p>


<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directory to save all exports in, using the current date</span>
(setq org-archive (concat <span style="color: #228b22;">"org-archive-"</span> (format-time-string <span style="color: #228b22;">"%Y-%m-%d"</span> (current-time))))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">delete directory and zip file if it exists</span>
(<span style="color: #8b0000;">when</span> (file-exists-p (concat org-archive <span style="color: #228b22;">".zip"</span>)) 
    (delete-file (concat org-archive <span style="color: #228b22;">".zip"</span>) t))

(<span style="color: #8b0000;">when</span> (file-exists-p org-archive) 
    (delete-directory org-archive t))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">make directory</span>
(make-directory org-archive t)

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">get list of links, copy files and save names</span>
(setq link-list (<span style="color: #8b0000;">let</span> ((parsetree (org-element-parse-buffer))
                     (counter 0))
                 (org-element-map parsetree 'link
                   (<span style="color: #8b0000;">lambda</span> (link) 
                     (<span style="color: #8b0000;">let*</span> ((type (nth 0 link))
                            (plist (nth 1 link))
                            (content (nth 2 link))
                            (path (plist-get plist <span style="color: #cd0000;">:path</span>))
                            (type (plist-get plist '<span style="color: #cd0000;">:type</span>))
                            (fname (car (last (split-string path <span style="color: #228b22;">"/"</span>))))
                            (temporary-file-directory org-archive)
                            (new-file)
                            )     
                       (<span style="color: #8b0000;">cond</span>
                        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular file with content</span>
                        ((and (string= type <span style="color: #228b22;">"file"</span>)  content)
                         (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
                                                         (concat <span style="color: #228b22;">"."</span> (file-name-extension fname))))
                         (<span style="color: #8b0000;">with-temp-file</span> new-file
                           (insert-file-contents path))
                         (format <span style="color: #228b22;">"[[./%s][%s]] "</span> (file-name-nondirectory new-file) content))
                        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular file with no content</span>
                        ((and (string= type <span style="color: #228b22;">"file"</span>))
                         (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
                                                         (concat <span style="color: #228b22;">"."</span> (file-name-extension fname))))
                         (<span style="color: #8b0000;">with-temp-file</span> new-file
                           (insert-file-contents path))
                         (format <span style="color: #228b22;">"[[./%s]] "</span> (file-name-nondirectory new-file)))
                        (t nil)))))))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">save current buffer name</span>
(setq current-name (buffer-name))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">create filter for links and export org buffer</span>
(<span style="color: #8b0000;">let</span> ((counter 0))
  (<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">ox-mrkup-filter-link</span> (text back-end info)
    (<span style="color: #8b0000;">let</span> ((link (nth counter link-list)))
      (<span style="color: #8b0000;">if</span> (not (string= link <span style="color: #228b22;">"nil"</span>)) (setq output   (format <span style="color: #228b22;">"%s"</span> link))
        (setq output (format <span style="color: #228b22;">"%s"</span> text)))
      (setq counter (+ counter 1))
      output))

  (<span style="color: #8b0000;">let</span> ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-org-export-as-org)))

(switch-to-buffer <span style="color: #228b22;">"*Org ORG Export*"</span>)
(write-file (expand-file-name current-name org-archive))
(shell-command (concat <span style="color: #228b22;">"zip -R "</span> org-archive <span style="color: #228b22;">".zip  *"</span>))
(rename-file (concat org-archive <span style="color: #228b22;">".zip"</span>) (concat <span style="color: #228b22;">"../"</span>org-archive <span style="color: #228b22;">".zip"</span>))
(kill-buffer)

(switch-to-buffer current-name)
(delete-directory org-archive t)  <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">get rid of temp-dir</span>
</pre>
</div>



<p>
This example works fine! The result is here: <a href="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/org-archive-2014-03-05.zip">org-archive-2014-03-05.zip</a> This code would ideally be put into a function, and cleaned up a little so there are not global variables being set here and there. A subsequent function might make it easy to attach this file to an email. That code might look something like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(mail)
(mail-to)
(insert <span style="color: #228b22;">"jkitchin@andrew.cmu.edu"</span>)
(mml-attach-file <span style="color: #228b22;">"./org-archive-2014-03-05.zip"</span>)
</pre>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Getting a list of figures in an org-buffer</title>
      <link>http://jkitchin.github.io/blog/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer</link>
      <pubDate>Sun, 02 Mar 2014 10:03:00 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">mG7o_GpUxz5PFXAl6lRCneMNgec=</guid>
      <description>Getting a list of figures in an org-buffer</description>
      <content:encoded><![CDATA[



<p>
Similar to the previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer/">example</a> of getting a list of tables, here we examine getting a list of figures. Here are two figure links, one with a label, and one with a caption.
</p>


<div id="fig:cos" class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/cos-plot.png"> 
</p>
</div>


<div class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/eos-uncertainty.png"> 
</p>
<p><span class="figure-number">Figure 1:</span> An equation of state. this is the caption of the figure.</p>
</div>


<div class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/implicit-uncertainty.png"> 
</p>
<p><span class="figure-number">Figure 2:</span> another figure</p>
</div>

<p>
We define a link that will parse the buffer, and create links in a new buffer to the figures. We define a figure as a  link with a :type of "file" that has a path that points to a file ending with png or pdf.  We will improve on the list of tables by making the buffer read-only, and making a local key binding to kill the buffer by pressing "q". Here is our attempted code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">http://www.emacswiki.org/emacs/ElispCookbook#toc4</span>
(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">string/ends-with</span> (s ending)
  <span style="color: #228b22;">"return non-nil if string S ends with ENDING."</span>
  (<span style="color: #8b0000;">cond</span> ((&gt;= (length s) (length ending))
         (<span style="color: #8b0000;">let</span> ((elength (length ending)))
           (string= (substring s (- 0 elength)) ending)))
        (t nil)))

(org-add-link-type 
 <span style="color: #228b22;">"list-of-figures"</span>
 (<span style="color: #8b0000;">lambda</span> (link-string)
   (<span style="color: #8b0000;">let*</span> ((c-b (buffer-name))
          (counter 0)
          (list-of-figures 
           (org-element-map (org-element-parse-buffer) 'link
             (<span style="color: #8b0000;">lambda</span> (link) 
               <span style="color: #228b22;">"create a link for to the figure"</span>
               (<span style="color: #8b0000;">when</span> 
                   (and (string= (org-element-property <span style="color: #cd0000;">:type</span> link) <span style="color: #228b22;">"file"</span>)
                        (string-match-p  
                         <span style="color: #228b22;">"[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">.]*\\.</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">png</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">|</span><span style="color: #228b22;">jpg</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">$"</span>
                         (org-element-property <span style="color: #cd0000;">:path</span> link)))                   
                 (incf counter)
                 
                 (<span style="color: #8b0000;">let*</span> ((start (org-element-property <span style="color: #cd0000;">:begin</span> link))
                        (parent (car (cdr (org-element-property <span style="color: #cd0000;">:parent</span> link))))
                        (caption (caaar (plist-get parent <span style="color: #cd0000;">:caption</span>)))
                        (name (plist-get parent <span style="color: #cd0000;">:name</span>)))
                   (<span style="color: #8b0000;">if</span> caption 
                       (format 
                        <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n"</span> 
                        c-b start counter (or name <span style="color: #228b22;">""</span>) caption)
                     (format 
                      <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n"</span> 
                      c-b start counter (or name <span style="color: #228b22;">""</span>)))))))))
          (switch-to-buffer <span style="color: #228b22;">"*List of Figures*"</span>)
          (org-mode)
          (erase-buffer)
          (insert (mapconcat 'identity list-of-figures <span style="color: #228b22;">""</span>))
          (setq buffer-read-only t)
          (use-local-map (copy-keymap org-mode-map))
          (local-set-key <span style="color: #228b22;">"q"</span> #'(<span style="color: #8b0000;">lambda</span> () (interactive) (kill-buffer)))))
   (<span style="color: #8b0000;">lambda</span> (keyword desc format)
     (<span style="color: #8b0000;">cond</span>
      ((eq format 'latex)
       (format <span style="color: #228b22;">"\\listoffigures"</span>)))))
</pre>
</div>



<p>
This is a test to see if our function works for other image types.
<a href="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/smiley.jpg">smiley.jpg</a> 
</p>

<p>
And a link to test it out: 
</p>

<p>

</p>

<p>
This works too. I am not sure I am getting the figure name and caption in a bulletproof way. They seem to be buried in the :parent of the element, which is a paragraph element. The caption seems to be buried in a few sets of parentheses, hence the use of <code>caaar</code> to get the caption out. I am not sure if the caption is always at that depth or not. As a proof of concept though, this is not too bad. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>Getting a list of tables in an org-buffer</title>
      <link>http://jkitchin.github.io/blog/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer</link>
      <pubDate>Sat, 01 Mar 2014 18:12:15 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <guid isPermaLink="false">P9YWx2BJKQvg3Ywadkpg2rtXkVI=</guid>
      <description>Getting a list of tables in an org-buffer</description>
      <content:encoded><![CDATA[



<p>
In a large document it might be nice to quickly get a list of tables. Preferrably by clicking on a link that generates the list, and exports appropriately, e.g. <code>listoftables</code> for LaTeX. A link like this:
</p>

<p>

</p>

<p>
Before getting to the code that does what we need, let us make some tables. We make three different kinds of tables for fun. A named table, an unnamed table, and a table with a caption. 
</p>

<table id="first-table" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">2</td>
</tr>

<tr>
<td class="right">a</td>
<td class="right">b</td>
</tr>
</tbody>
</table>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">t</td>
<td class="right">y</td>
</tr>

<tr>
<td class="right">5</td>
<td class="right">6</td>
</tr>
</tbody>
</table>


<table id="tbl-with-caption" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> column of numbers</caption>

<colgroup>
<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">34</td>
</tr>

<tr>
<td class="right">6</td>
</tr>

<tr>
<td class="right">6</td>
</tr>
</tbody>
</table>


<p>
We would like a function that creates a buffer with a list of the tables, and links to them. We include the table name, and caption if there is one. We will create an org-buffer, and use org-links to the tables. Here is a link definition that will do that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type 
 <span style="color: #228b22;">"list-of-tables"</span>
 (<span style="color: #8b0000;">lambda</span> (link-string)
   (<span style="color: #8b0000;">let*</span> ((c-b (buffer-name))
          (counter 0)
          (list-of-tables 
           (org-element-map (org-element-parse-buffer 'element) 'table
             (<span style="color: #8b0000;">lambda</span> (table) 
               <span style="color: #228b22;">"create a link for to the table"</span>
               (incf counter)
               (<span style="color: #8b0000;">let</span> ((start (org-element-property <span style="color: #cd0000;">:begin</span> table))
                     (name  (org-element-property <span style="color: #cd0000;">:name</span> table))
                     (caption (caaar (org-element-property <span style="color: #cd0000;">:caption</span> table))))
                 (<span style="color: #8b0000;">if</span> caption 
                     (format 
                      <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]] %s\n"</span> 
                      c-b start counter (or name <span style="color: #228b22;">""</span>) caption)
                   (format 
                    <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][table %s: %s]]\n"</span> 
                    c-b start counter (or name <span style="color: #228b22;">""</span>))))))))
     (switch-to-buffer <span style="color: #228b22;">"*List of Tables*"</span>)
     (org-mode)
     (erase-buffer)
     (insert (mapconcat 'identity list-of-tables <span style="color: #228b22;">""</span>))))
 (<span style="color: #8b0000;">lambda</span> (keyword desc format)
   (<span style="color: #8b0000;">cond</span>
    ((eq format 'latex)
     (format <span style="color: #228b22;">"\\listoftables"</span>)))))
</pre>
</div>

<p>
A list of figures would only be a little trickier. You would map over the links, and find the file type links that have a select number of extensions, e.g. png, jpg, etc&#x2026;
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
  </channel>
</rss>
