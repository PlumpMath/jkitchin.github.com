<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2014-09-23T18:25:55Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A git status Emacs modeline]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/09/19/A-git-status-Emacs-modeline" />
    <id>http://jkitchin.github.io/blog/2014/09/19/A-git-status-Emacs-modeline</id>
    <updated>2014-09-19T09:36:21Z</updated>
    <published>2014-09-19T09:36:21Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="git" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[A git status Emacs modeline]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/09/19/A-git-status-Emacs-modeline"><![CDATA[


<p>
I am using git more and more in Emacs, and I would like a way to know the status of the git repo I am working in by looking at the modeline. I know about <a href="https://github.com/magit/magit">magit</a> , and other git modes, but none of them provide something as easy as useful as say <a href="https://github.com/magicmonty/bash-git-prompt">bash-git-prompt</a> in the bash shell, which is to say I do not want to run a command to see the status (I might as well be in the shell then). Part of this need comes from a project with hundreds of git repos in it, and I want convenient status when I open any one of them.
</p>

<p>
Here, I want to emulate the bash-git-prompt feature in the Emacs modeline where it will show you when you are in a git repo, and then some basic information like what branch you are on, the number of untracked, modified files, and the commit status with respect to a remote. First, we only want this when we are in a git repo. We can check for that like this. The command in this block returns a string that starts with fatal when not in a git repo.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(not (string-match <span style="color: #228b22;">"^fatal"</span> (shell-command-to-string <span style="color: #228b22;">"git rev-parse --git-dir"</span>)))
</pre>
</div>

<pre class="example">
t
</pre>

<p>
Let us wrap that in a nice function so we can use it later..
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">in-git-p</span> ()
  (not (string-match <span style="color: #228b22;">"^fatal"</span> (shell-command-to-string <span style="color: #228b22;">"git rev-parse --git-dir"</span>))))

(in-git-p)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
Next, we would like to know how many untracked, modified and other (e.g. unmerged, deleted, etc&#x2026;) files we have. We can get this from  <code>git status --porcelain</code>. I am going to set these to be red if they are not zero, so they stand out, and be green otherwise. We will also store a list of each file type so we can make a tooltip on the counter to see what is there.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">git-parse-status</span> ()
  (interactive)
  (<span style="color: #8b0000;">let</span> ((U 0)   ; <span style="color: #ff0000; font-weight: bold;">untracked files</span>
        (M 0)   ; <span style="color: #ff0000; font-weight: bold;">modified files</span>
        (O 0)   ; <span style="color: #ff0000; font-weight: bold;">other files</span>
        (U-files <span style="color: #228b22;">""</span>)
        (M-files <span style="color: #228b22;">""</span>)
        (O-files <span style="color: #228b22;">""</span>))
    (<span style="color: #8b0000;">dolist</span> (line (split-string
                   (shell-command-to-string <span style="color: #228b22;">"git status --porcelain"</span>)
                   <span style="color: #228b22;">"\n"</span>))
      (<span style="color: #8b0000;">cond</span>

       ;; <span style="color: #ff0000; font-weight: bold;">ignore empty line at end</span>
       ((string= <span style="color: #228b22;">""</span> line) nil)

       ((string-match <span style="color: #228b22;">"^\\?\\?"</span> line)
        (setq U (+ 1 U))
        (setq U-files (concat U-files <span style="color: #228b22;">"\n"</span> line)))

       ((string-match <span style="color: #228b22;">"^ M"</span> line)
        (setq M (+ 1 M))
        (setq M-files (concat M-files <span style="color: #228b22;">"\n"</span> line))
        )

       (t
        (message <span style="color: #228b22;">"detected other in %s"</span> line)
        (setq O (+ 1 O))
        (setq O-files (concat O-files <span style="color: #228b22;">"\n"</span> line)))))
      
    ;; <span style="color: #ff0000; font-weight: bold;">construct propertized string</span>
    (concat
     <span style="color: #228b22;">"("</span>
     (propertize 
      (format <span style="color: #228b22;">"M:%d"</span> M)
      'face (list '<span style="color: #cd0000;">:foreground</span> (<span style="color: #8b0000;">if</span> (&gt; M 0)
                                   <span style="color: #228b22;">"red"</span>
                                 <span style="color: #228b22;">"forest green"</span>))
      'help-echo M-files)
     <span style="color: #228b22;">"|"</span>
     (propertize 
      (format <span style="color: #228b22;">"U:%d"</span> U)
      'face (list '<span style="color: #cd0000;">:foreground</span> (<span style="color: #8b0000;">if</span> (&gt; U 0)
                                   <span style="color: #228b22;">"red"</span>
                                 <span style="color: #228b22;">"forest green"</span>))
      'help-echo U-files)
     <span style="color: #228b22;">"|"</span>
     (propertize 
      (format <span style="color: #228b22;">"O:%d"</span> O)
      'face (list '<span style="color: #cd0000;">:foreground</span> (<span style="color: #8b0000;">if</span> (&gt; O 0)
                                   <span style="color: #228b22;">"red"</span>
                                 <span style="color: #228b22;">"forest green"</span>))
      'help-echo O-files)                   
      <span style="color: #228b22;">") "</span>)))

(git-parse-status)
</pre>
</div>

<pre class="example">
(M:1|U:2|O:0) 
</pre>

<p>
Finally, let us get the branch we are on, and the commits with respect to a remote. We can do that like this. We use some unicode characters to indicate what direction things go, e.g. an up arrow to indicate you need to push, and a down arrow to indicate you should pull.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">git-remote-status</span> ()
  (interactive)
  (<span style="color: #8b0000;">let*</span> (;; <span style="color: #ff0000; font-weight: bold;">get the branch we are on.</span>
         (branch (s-trim
                  (shell-command-to-string
                   <span style="color: #228b22;">"git rev-parse --abbrev-ref HEAD"</span>)))
         ;; <span style="color: #ff0000; font-weight: bold;">get the remote the branch points to.</span>
         (remote (s-trim
                  (shell-command-to-string
                   (format <span style="color: #228b22;">"git config branch.%s.remote"</span> branch))))
         (remote-branch (s-trim
                         (shell-command-to-string
                          <span style="color: #228b22;">"git for-each-ref --format='%(upstream:short)' $(git symbolic-ref -q HEAD)"</span>)))
         (commits (split-string
                   (s-trim
                    (shell-command-to-string
                     (format
                      <span style="color: #228b22;">"git rev-list --count --left-right HEAD...%s"</span>
                      remote-branch)))))
         (local (nth 0 commits))
         (remotes (nth 1 commits)))
    (concat
     <span style="color: #228b22;">"["</span>
     (propertize
      (format <span style="color: #228b22;">"%s"</span> branch)
      'face (list <span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"magenta"</span>))
     <span style="color: #228b22;">"|"</span>
     (format <span style="color: #228b22;">"&#8593;%s|&#8595;%s"</span> local remotes)
     <span style="color: #228b22;">"]"</span>))) 

(git-remote-status)
</pre>
</div>

<pre class="example">
[source|↑0|↓0]
</pre>

<p>
Now, we can finally put this together in a little minor mode. We add an element to the mode-line-format variable that evaluates those functions. When we turn off the minor mode, we remove the element from the modeline.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">define-minor-mode</span> <span style="color: #8b2323;">git-mode</span>
  <span style="color: #228b22;">"minor mode to put git repo status in modeline"</span>
  nil nil nil
  (<span style="color: #8b0000;">let</span> ((git-modeline '(<span style="color: #cd0000;">:eval</span> (<span style="color: #8b0000;">if</span> (not (in-git-p))
                                  <span style="color: #228b22;">""</span>
                                (concat 
                                 (git-remote-status)
                                 (git-parse-status))))))
    (<span style="color: #8b0000;">if</span> git-mode
        ;; <span style="color: #ff0000; font-weight: bold;">put in modeline</span>
        (push git-modeline mode-line-format)
      ;; <span style="color: #ff0000; font-weight: bold;">remove from modeline</span>
      (setq mode-line-format
            (-remove (<span style="color: #8b0000;">lambda</span> (x)
                       (equal x git-modeline))                                  
                     mode-line-format)))))
</pre>
</div>

<p>
This leads to a modeline that looks like this (when my mouse is hovered over the M):
</p>


<div class="figure">
<p><img src="/media/2014-09-19-A-git-status-Emacs-modeline/git-modeline.png"> 
</p>
</div>

<p>
This seems to have some performance issue, since pretty much everytime I type a key, it updates the modeline, and runs git. That is too often. Let us redefine the mode here so we have a minimum time between updates, say 15 seconds. We will store the last time updated, and the last value of the mode-line. Then each time the modeline updates, if the time since the last update is greater than our interval, then we will run the git commands. Otherwise, we just use the old modeline value.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">git-modeline-last-update</span> (float-time) <span style="color: #228b22;">"Last time we updated"</span>)
(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">git-modeline-update-interval</span> 15 <span style="color: #228b22;">"Minimum time between update in seconds"</span>)
(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">git-modeline</span> <span style="color: #228b22;">""</span> <span style="color: #228b22;">"Last value of the modeline"</span>)

(<span style="color: #8b0000;">define-minor-mode</span> <span style="color: #8b2323;">git-mode</span>
  <span style="color: #228b22;">"minor mode to put git repo status in modeline"</span>
  nil nil nil
  (<span style="color: #8b0000;">let</span> ((git-modeline '(<span style="color: #cd0000;">:eval</span> (<span style="color: #8b0000;">if</span>
                                  (&gt; (- (float-time) git-modeline-last-update)
                                     git-modeline-update-interval)
                                  ;; <span style="color: #ff0000; font-weight: bold;">we are updating                              </span>
                                  (setq git-modeline
                                        (<span style="color: #8b0000;">if</span> (not (in-git-p))
                                            <span style="color: #228b22;">""</span>                                   
                                          (setq  git-modeline-last-update (float-time))
                                          (concat 
                                           (git-remote-status)
                                           (git-parse-status))))
                                
                              ;; <span style="color: #ff0000; font-weight: bold;">use last value of the modeline</span>
                              git-modeline))))
    (<span style="color: #8b0000;">if</span> git-mode
        ;; <span style="color: #ff0000; font-weight: bold;">put in modeline</span>
        (push git-modeline mode-line-format)
      ;; <span style="color: #ff0000; font-weight: bold;">remove from modeline</span>
      (setq mode-line-format
            (-remove (<span style="color: #8b0000;">lambda</span> (x)
                       (equal x git-modeline))                                  
                     mode-line-format)))))
</pre>
</div>

<p>
That does it I think. I don't have any performance issues here now. I have not tested this super thoroughly on many git repos, but it seems to be pretty consistent and correct so far. The remote status code is where there is the most probability for issues. I still do not know that part of git very well.  I wonder if there is a more elegant solution than this, perhaps an idle timer. I notice a little lag in updating the data when I switch to another git repo. That might be a little confusing one day.
</p>


<p>
Otherwise, this seems like a pretty nice solution so far. There are still some things that would be nice to see on here. For example, a pop-up menu on the modeline to switch branches, push or pull, and with actions for the files, e.g. add/commit, etc&#x2026; Those do not seem to hard to </p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/09/19/A-git-status-Emacs-modeline.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Colorized text in Emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/09/14/Colorized-text-in-Emacs" />
    <id>http://jkitchin.github.io/blog/2014/09/14/Colorized-text-in-Emacs</id>
    <updated>2014-09-14T14:33:32Z</updated>
    <published>2014-09-14T14:23:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Colorized text in Emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/09/14/Colorized-text-in-Emacs"><![CDATA[



<p>
As I continue investigating Emacs + org-mode as a platform for creating applications, it has come up a few times that it would be useful to display colored text. For example, in a summary report of a git repo, you might want to see some information in red, e.g. if you have uncommitted changes, and some information in green, e.g. the repo is clean and consistent with a remote.
</p>

<p>
We can set colors on a string in Emacs like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(propertize <span style="color: #228b22;">"Red Text"</span> 'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"red"</span>))
</pre>
</div>

<p>
The only tricky part is that we need to insert the text into a font-locked buffer to see it. That is also a tad tricky to illustrate in a code block, so here is a way to try it:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(re-search-forward <span style="color: #228b22;">"-&gt; "</span>)
(insert
  (propertize <span style="color: #228b22;">"Red Text"</span> 'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"red"</span>)))
</pre>
</div>

<p>
-&gt; Red Text
</p>

<p>
The red text does not show in the HTML post, so this is a screenshot of what it looks like in my buffer:
</p>


<div class="figure">
<p><img src="/media/2014-09-14-Colorized-text-in-Emacs/red-text.png"> 
</p>
</div>

<p>
Now, here is how we might use this in a summary report. Say we have a git repo, and we want to know various facts about it. We can get information about tracked/ untracked and modified files like this:
</p>

<div class="org-src-container">

<pre class="src src-sh">git status --porcelain
</pre>
</div>
<pre class="example">
 M _blog/blog.html
 M _blog/blog.org
A  _blog/images/red-text.png
</pre>

<p>
This shows we have two tracked, but modified files, and on added but not committed file. We can use this code to show if we have any untracked files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((n 0) s)
  (<span style="color: #8b0000;">dolist</span> (line (split-string
                 (shell-command-to-string <span style="color: #228b22;">"git status --porcelain"</span>)
                 <span style="color: #228b22;">"\n"</span>))
    (<span style="color: #8b0000;">when</span> (string-match <span style="color: #228b22;">"^\\?\\?"</span> line)
      (setq n (+ 1 n))))
  (<span style="color: #8b0000;">if</span> (&gt; n 0)
      (setq s (propertize (format <span style="color: #228b22;">"%s untracked files"</span> n)
                          'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"red"</span>)))
    (setq s (propertize <span style="color: #228b22;">"No untracked files"</span> 
                        'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"forest green"</span>))))
  (re-search-forward <span style="color: #228b22;">"-&gt;"</span>)
  (insert s))
</pre>
</div>

<p>
-&gt;No untracked files
</p>

<p>
In HTML (i.e. the blog post) you cannot really see the green text, so here is a screenshot illustrating it.
<img src="/media/2014-09-14-Colorized-text-in-Emacs/git-untracked-files.png"> 
</p>

<p>
Similarly, we can check for modified files. We add a wrinkle and add a tooltip like text that shows the output of the git command.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((n 0)
      (output (shell-command-to-string <span style="color: #228b22;">"git status --porcelain"</span>))
      s)
  (<span style="color: #8b0000;">dolist</span> (line (split-string
                 output
                 <span style="color: #228b22;">"\n"</span>))
    (<span style="color: #8b0000;">when</span> (string-match <span style="color: #228b22;">"^ M"</span> line)
      (setq n (+ 1 n))))
  (<span style="color: #8b0000;">if</span> (&gt; n 0)
      (setq s (propertize (format <span style="color: #228b22;">"%s modified files"</span> n)
                          'help-echo output
                          'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"red"</span>)))
    (setq s (propertize <span style="color: #228b22;">"No modified files"</span> 
                        'font-lock-face '(<span style="color: #cd0000;">:foreground</span> <span style="color: #228b22;">"forest green"</span>))))
  (re-search-forward <span style="color: #228b22;">"-&gt; "</span>)
  (insert s))
</pre>
</div>

<p>
-&gt; 2 modified files
</p>

<p>
That looks like this in emacs:
</p>


<div class="figure">
<p><img src="/media/2014-09-14-Colorized-text-in-Emacs/git-modified.png"> 
</p>
</div>


<p>
That is the main idea in this post. You can create strings with properties, and use code to determine what they e.g. what color the text is, etc&#x2026; There are lots of properties listed at <a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html">http://www.gnu.org/software/emacs/manual/html_node/elisp/Special-Properties.html</a> that might be helpful in an application. Here are some previous posts that examined similar ideas.
</p>

<ul class="org-ul">
<li>Read-only text <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/">http://kitchingroup.cheme.cmu.edu/blog/2014/09/13/Make-some-org-sections-read-only/</a> 
</li>

<li>Tool tips: <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/">http://kitchingroup.cheme.cmu.edu/blog/2013/04/12/Tool-tips-on-text-in-Emacs/</a> 
</li>

<li>Invisible text (this is not exactly a property, but it is similar)
</li>
</ul>
<p>
<a href="http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-emacs/">http://kitchingroup.cheme.cmu.edu/blog/2014/02/06/Invisible-text-in-emacs/</a> </p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/09/14/Colorized-text-in-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Make some org-sections read-only]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/09/13/Make-some-org-sections-read-only" />
    <id>http://jkitchin.github.io/blog/2014/09/13/Make-some-org-sections-read-only</id>
    <updated>2014-09-13T13:50:49Z</updated>
    <published>2014-09-13T13:50:49Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Make some org-sections read-only]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/09/13/Make-some-org-sections-read-only"><![CDATA[


<p>
There are times where I want an org-file to be <i>partly</i> read-only. For example, there might be instructions that should not be modified. In this post we consider how to implement that. For now, we only want an org-section to be read-only, and we will designate those sections by a tag read<sub>only</sub>. Then, the idea is that a hook function would be run when the org-file is loaded, and mark regions of text as read-only before the user can do anything.
</p>

<p>
In Emacs, you can mark a section of text, and set it to have a property of read-only. So, we can just map over the entries, and any heading that is tagged as read<sub>only</sub> can be made read-only!
</p>

<p>
Here we set the first few characters of this buffer to be read-only.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-text-properties 1 8 '(read-only t))
</pre>
</div>

<pre class="example">
t
</pre>

<p>
Emacs is semi-serious about what read-only means. You cannot even change properties of read-only text, unless you set inhibit-read-only as a variable.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((inhibit-read-only t))
 (remove-text-properties 1 8 '(read-only t)))
</pre>
</div>

<pre class="example">
t
</pre>

<p>
Now, we can map over the entries in this buffer, and set any heading tagged read<sub>only</sub> to actually be that way like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-map-entries (<span style="color: #8b0000;">lambda</span> ()
                   (<span style="color: #8b0000;">let*</span> ((element (org-element-at-point))
                          (begin (org-element-property <span style="color: #cd0000;">:begin</span> element))
                          (end (org-element-property <span style="color: #cd0000;">:end</span> element)))
                     (add-text-properties begin end '(read-only t))))
                 <span style="color: #228b22;">"read_only"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">t</td>
</tr>
</tbody>
</table>

<p>
To get this to work when org-mode is turned on, we just wrap it in a function, add the function to a hook, and a function to undo the read-only behavior. I found that if I use the end reported by org-element-at-point, it includes the first character of the next section, we take one away from the end to avoid that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-mark-readonly</span> ()
  (interactive)
  (org-map-entries
   (<span style="color: #8b0000;">lambda</span> ()
     (<span style="color: #8b0000;">let*</span> ((element (org-element-at-point))
            (begin (org-element-property <span style="color: #cd0000;">:begin</span> element))
            (end (org-element-property <span style="color: #cd0000;">:end</span> element)))
       (add-text-properties begin (- end 1) '(read-only t))))
   <span style="color: #228b22;">"read_only"</span>)
 (message <span style="color: #228b22;">"Made readonly!"</span>))


(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-remove-readonly</span> ()
  (interactive)
  (org-map-entries
   (<span style="color: #8b0000;">lambda</span> ()
     (<span style="color: #8b0000;">let*</span> ((element (org-element-at-point))
            (begin (org-element-property <span style="color: #cd0000;">:begin</span> element))
            (end (org-element-property <span style="color: #cd0000;">:end</span> element))
            (inhibit-read-only t))
         (remove-text-properties begin (- end 1) '(read-only t))))
     <span style="color: #228b22;">"read_only"</span>))

(add-hook 'org-mode-hook 'org-mark-readonly)
</pre>
</div>

<p>
That seem to be all there is. After executing the code above, when I open this file, the next section is read-only! I can use the other function to remove that if I need to edit it. Score one for Emacs + org-mode!
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Read-only section&#xa0;&#xa0;&#xa0;<span class="tag"><span class="read_only">read_only</span></span></h2>
<div class="outline-text-2" id="text-1">
<p>
This text is so important, it should be read-only.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Editable section</h2>
<div class="outline-text-2" id="text-2">
<p>
You can do what you want here. Like add text.
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/09/13/Make-some-org-sections-read-only.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using Mac gestures in Emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/08/31/Using-Mac-gestures-in-Emacs" />
    <id>http://jkitchin.github.io/blog/2014/08/31/Using-Mac-gestures-in-Emacs</id>
    <updated>2014-08-31T10:20:46Z</updated>
    <published>2014-08-31T10:20:46Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Using Mac gestures in Emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/08/31/Using-Mac-gestures-in-Emacs"><![CDATA[



<p>
I recently got a MacBook Air, and I have been exploring what you can do with it and Emacs. The Mac trackpad has some interesting gestures that are useful in Emacs. For example, you can scroll the buffer by moving two fingers up or down the trackpad. Or tap the trackpad with two fingers to get the equivalent of a right click. I was curious what other gestures could be used effectively in Emacs. Emacs does not capture all of the trackpad gestures, but it does capture the two finger swipe left and right as a triple-wheel-left or right key. We can use that to switch buffers. Normally one uses C-x leftarrow or right arrow to do that, but with the trackpack we can use a gesture!
</p>

<p>
The gesture triggers a triple-wheel key, which we can bind to an function. This code does that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(global-set-key [triple-wheel-left] 'previous-buffer)
(global-set-key [triple-wheel-right] 'next-buffer)
</pre>
</div>
<pre class="example">
next-buffer
</pre>

<p>
This scrolls through buffers blazingly fast! Almost unusably fast. If you move very slow, you can get some control and switch one buffer at a time. Interestingly, I see these messages while gesturing slowly:
</p>

<pre class="example">
&lt;wheel-left&gt; is undefined
&lt;double-wheel-left&gt; is undefined
&lt;wheel-right&gt; is undefined
&lt;double-wheel-right&gt; is undefined
&lt;wheel-right&gt; is undefined [2 times]
&lt;double-wheel-right&gt; is undefined
</pre>

<p>
We need a custom function that has some kind of delay to slow down the buffer switching. Here is an idea. We will store a value in a global variable, and only switch buffers when it is true. After we switch the buffer we set the variable to nil, and activate a timer to reset the variable to t after a short delay. say one second. Here it is.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">*my-previous-buffer*</span> t
  <span style="color: #228b22;">"can we switch?"</span>)

(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-previous-buffer</span> ()
  (interactive)
  (message <span style="color: #228b22;">"custom prev: *my-previous-buffer*=%s"</span> *my-previous-buffer*)
  (<span style="color: #8b0000;">when</span> *my-previous-buffer*
    (previous-buffer)
    (setq *my-previous-buffer* nil)
    (run-at-time <span style="color: #228b22;">"1 sec"</span> nil (<span style="color: #8b0000;">lambda</span> ()
                               (setq *my-previous-buffer* t)))))

(<span style="color: #8b0000;">defvar</span> <span style="color: #8b008b;">*my-next-buffer*</span> t
  <span style="color: #228b22;">"can we switch?"</span>)

(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-next-buffer</span> ()
  (interactive)
  (message <span style="color: #228b22;">"custom prev: *my-next-buffer*=%s"</span> *my-next-buffer*)
  (<span style="color: #8b0000;">when</span> *my-next-buffer*
    (next-buffer)
    (setq *my-next-buffer* nil)
    (run-at-time <span style="color: #228b22;">"1 sec"</span> nil (<span style="color: #8b0000;">lambda</span> ()
                               (setq *my-next-buffer* t)))))

(global-set-key [triple-wheel-right] 'my-previous-buffer)
(global-set-key [triple-wheel-left] 'my-next-buffer)
</pre>
</div>

<pre class="example">
my-next-buffer
</pre>

<p>
Note I reversed the left/right order. It seems that swiping left triggers the triple-wheel-right key. Go figure. Anyway, this makes the gesture actually usable, as it only changes one buffer at a time, with a short delay before you can change the buffer again. It is not a groundbreaking addition to Emacs, but it satisfied a curiousity itch for the day for me.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/08/31/Using-Mac-gestures-in-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Creating a dynamic menu for Emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/08/20/Creating-a-dynamic-menu-for-Emacs" />
    <id>http://jkitchin.github.io/blog/2014/08/20/Creating-a-dynamic-menu-for-Emacs</id>
    <updated>2014-08-20T20:26:18Z</updated>
    <published>2014-08-20T20:26:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Creating a dynamic menu for Emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/08/20/Creating-a-dynamic-menu-for-Emacs"><![CDATA[


<p>
I have an application where I want a dynamic menu in Emacs, e.g. the menu auto-updates as things change on your computer. Here is a prototype example. We will make a menu that shows entries for each file in the current directory, and opens that entry.
</p>

<p>
We start by creating a menu that is initially empty like this. This menu will be called "My Files" in the menu.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(easy-menu-define jrk-menu global-map <span style="color: #228b22;">"MyMenu"</span>
  '(<span style="color: #228b22;">"My Files"</span>))
</pre>
</div>

<p>
Next, we create this function which will create a submenu with a vector entry for each file in this directory.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">get-menu</span> ()
  (easy-menu-create-menu
   <span style="color: #228b22;">"Files"</span>
   (mapcar (<span style="color: #8b0000;">lambda</span> (x)
             (vector (file-name-nondirectory x)
                     `(<span style="color: #8b0000;">lambda</span> () (interactive) (find-file ,x) t)))
           (f-glob <span style="color: #228b22;">"*"</span>))))
</pre>
</div>

<pre class="example">
get-menu
</pre>

<p>
Next, we add the submenu. This is a one-time addition, which reflects the files in the directory at the time I ran this block.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(easy-menu-add-item jrk-menu '() (get-menu))
</pre>
</div>

<p>
After you do that, the menu looks like this:
</p>


<div class="figure">
<p><img src="/media/2014-08-20-Creating-a-dynamic-menu-for-Emacs/Screen Shot 2014-08-20 at 8.14.00 PM.png"> 
</p>
</div>

<p>
This menu is not yet dynamic. We need to create a function that can update the menu, and then add the function to a hook that runs each time the menu opens. Here is the code. The easy-menu-add-item function will replace the contents of an item by the same name, which we use here to update the menu.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">update-my-file-menu</span> ()
  (easy-menu-add-item jrk-menu '() (get-menu)))

(add-hook 'menu-bar-update-hook 'update-my-file-menu)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">update-my-file-menu</td>
<td class="left">undo-tree-update-menu-bar</td>
<td class="left">menu-bar-update-buffers</td>
</tr>
</tbody>
</table>


<p>
Now, if we run this block to create a file:
</p>

<div class="org-src-container">

<pre class="src src-sh">touch newfile
</pre>
</div>

<p>
Then, after saving this buffer the menu looks like this:
</p>



<div class="figure">
<p><img src="/media/2014-08-20-Creating-a-dynamic-menu-for-Emacs/Screen Shot 2014-08-20 at 8.17.50 PM.png"> 
</p>
</div>

<p>
Now, every time a new file appears in this directory, a new menu item will appear every time you check the menu. That is really dynamic.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/08/20/Creating-a-dynamic-menu-for-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.7c</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using org-mode outside of Emacs - sort of]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/08/11/Using-org-mode-outside-of-Emacs-sort-of" />
    <id>http://jkitchin.github.io/blog/2014/08/11/Using-org-mode-outside-of-Emacs-sort-of</id>
    <updated>2014-08-11T20:22:43Z</updated>
    <published>2014-08-11T20:22:43Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Using org-mode outside of Emacs - sort of]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/08/11/Using-org-mode-outside-of-Emacs-sort-of"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Extracting tables from an org-file</a></li>
<li><a href="#sec-2">2. Running code in an org-file</a></li>
</ul>
</div>
</div>
<p>
I recently posted about using Emacs for scripts (<a href="http://kitchingroup.cheme.cmu.edu/blog/2014/08/06/Writing-scripts-in-Emacs-lisp/">http://kitchingroup.cheme.cmu.edu/blog/2014/08/06/Writing-scripts-in-Emacs-lisp/</a> ). Someone was probably wondering, why would you do that, when you could use shell, python or perl? A good reason is to write scripts that can access data or code inside an org-file! This would allow you to leverage the extensive support for org-mode in Emacs, without a user necessarily even needing to use Emacs. Let us consider some examples. 
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Extracting tables from an org-file</h2>
<div class="outline-text-2" id="text-1">
<p>
If tables are named in org-mode, it is possible to extract the contents. Here is a table:
</p>

<table id="data-1" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="right">x</th>
<th scope="col" class="right">y</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">1</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">4</td>
</tr>

<tr>
<td class="right">3</td>
<td class="right">9</td>
</tr>
</tbody>
</table>

<p>
Another table might look like
</p>

<table id="data-2" border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">a</td>
<td class="right">b</td>
</tr>

<tr>
<td class="right">1</td>
<td class="right">1</td>
</tr>

<tr>
<td class="right">2</td>
<td class="right">8</td>
</tr>

<tr>
<td class="right">3</td>
<td class="right">27</td>
</tr>
</tbody>
</table>


<p>
It would be convenient to have a command-line utility that could extract the data from that table with a syntax like:
</p>

<div class="org-src-container">

<pre class="src src-sh">extract-org-table tblname orgfile --format lisp|csv|tab
</pre>
</div>


<p>
Here is one way to do it:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; org-table tblname orgfile lisp|csv|tab

(let ((tblname (pop command-line-args-left))
      (org-file (pop command-line-args-left))
      (format)
      (table)
      (content))
  (when command-line-args-left
    (setq format (pop command-line-args-left)))
  (find-file org-file)
  (setq table 
	(org-element-map (org-element-parse-buffer) 'table 
	  (lambda (element)
	    (when (string= tblname (org-element-property :name element))
	      element))
	  nil ;info
	  t )) ; first-match

  (unless table
    (error "no table found for %s" tblname))

  (when table
    (goto-char (org-element-property :contents-begin table))
    (let ((contents (org-table-to-lisp)))
      (if (string= format "lisp")
	  (print contents)
	;else      
	(dolist (row contents)
	  (unless (eq row 'hline)
	    (cond
	     ((string= format "csv")
	      (princ (mapconcat 'identity row ",")))
	     ((string= format "tab")
	      (princ (mapconcat 'identity row "\t")))
	     (t
	      (error "unsupported format: %s" format)))
	    (princ "\n")))))))
</pre>
</div>

<p>
Let us try it out. <a href="org-babel-tangle">org-babel-tangle</a>
</p>

<div class="org-src-container">

<pre class="src src-sh">./extract-org-table data-2 org-outside-emacs.org lisp
</pre>
</div>

<pre class="example">
(("a" "b") ("1" "1") ("2" "8") ("3" "27"))
</pre>

<div class="org-src-container">

<pre class="src src-sh">./extract-org-table data-1 org-outside-emacs.org csv
</pre>
</div>

<pre class="example">
x,y
1,1
2,4
3,9
</pre>

<div class="org-src-container">

<pre class="src src-sh">./extract-org-table data-2 org-outside-emacs.org tab
</pre>
</div>

<pre class="example">
a       b
1       1
2       8
3       27
</pre>

<p>
That looks pretty reasonable, and you could even pipe the output to another classic unix command like cut to get a single column. Let us get the second column here.
</p>

<div class="org-src-container">

<pre class="src src-sh">./extract-org-table data-1 org-outside-emacs.org csv | cut -d , -f 2
</pre>
</div>

<pre class="example">
y
1
4
9
</pre>

<p>
That is starting to look like using data from an org-file, but outside of org. Of course, we are using org-mode, via emacs, but the point is a user might not have to know that, as long as a fairly recent Emacs and org-mode was installed on their system.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Running code in an org-file</h2>
<div class="outline-text-2" id="text-2">
<p>
It may be that there is code in an org-file that you might want to use, but for some reason choose not to cut and paste from the org-file to some script. Here is a simple code block:
</p>

<div class="org-src-container">

<pre class="src src-python" id="python-block">import time
with open('results.dat', 'w') as f:
    f.write(time.asctime())
</pre>
</div>

<p>
To call this externally we have to find the block and then run it.
</p>


<div class="org-src-container">

<pre class="src src-emacs-lisp">;; org-run blockname org-file
;; run a code block in an org file
(let ((blockname (pop command-line-args-left))
      (org-file (pop command-line-args-left))
      (src))
  (find-file org-file)
  (setq src
	(org-element-map (org-element-parse-buffer) 'src-block
	  (lambda (element)
	    (when (string= blockname (org-element-property :name element))
	      element))
	  nil ;info
	  t )) ; first-match
  (when src
     (goto-char (org-element-property :begin src))
     ;; since we start with a fresh emacs, we have to configure some things.
     (org-babel-do-load-languages
      'org-babel-load-languages
      '((python . t)))
     (let ((org-confirm-babel-evaluate nil))
       (org-babel-execute-src-block))))
</pre>
</div>

<p>
<a href="org-babel-tangle">org-babel-tangle</a>
</p>

<div class="org-src-container">

<pre class="src src-sh">./org-call.el python-block org-outside-emacs.org
cat results.dat
</pre>
</div>

<pre class="example">
Mon Aug 11 20:17:01 2014
</pre>

<p>
That demonstrates it is possible to call source blocks, but this is pretty limited in capability. You can only call a block; we did not capture any output from the block, only its side effects, e.g. it changed a file that we can examine. We have limited capability to set data into the block, other than through files. It might be possible to hack up something that runs org-babel-execute-src-block with constructed arguments that enables something like a var to be passed in. That is beyond today's post. When I get around to it, here is a reminder of how it might be possible to feed stdin to an emacs script: <a href="http://stackoverflow.com/questions/2879746/idomatic-batch-processing-of-text-in-emacs">http://stackoverflow.com/questions/2879746/idomatic-batch-processing-of-text-in-emacs</a> .
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/08/11/Using-org-mode-outside-of-Emacs---sort-of.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Writing scripts in Emacs-lisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/08/06/Writing-scripts-in-Emacs-lisp" />
    <id>http://jkitchin.github.io/blog/2014/08/06/Writing-scripts-in-Emacs-lisp</id>
    <updated>2014-08-07T16:39:32Z</updated>
    <published>2014-08-06T14:27:58Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Writing scripts in Emacs-lisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/08/06/Writing-scripts-in-Emacs-lisp"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Addition based on Trevor's comment</a></li>
</ul>
</div>
</div>

<p>
I have written lots of script commands, mostly in Python, occasionally in bash. Today I learned you can also write them in emacs-lisp (<a href="http://www.emacswiki.org/emacs/EmacsScripts">http://www.emacswiki.org/emacs/EmacsScripts</a> ). There is an interesting wrinkle on the first line which specifies how to run the command, which is explained in the emacswiki page.
</p>

<p>
Here is an example script that just prints some information about Emacs and the command line args you pass to it. We use some Local variables at the end to make the script open in emacs-lisp mode for editing. $0 in shell language is the name of the script being run, so the header here simply loads the script into emacs, and then runs the main function. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">:;exec emacs -batch -l "$0" -f main "$@"

(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

;; Local Variables:
;; mode: emacs-lisp
;; End:
</pre>
</div>

<p>
We need to tangle this code block to get the script. 
<a href="org-babel-tangle">org-babel-tangle</a>
</p>

<p>
Since we do not have a regular shebang, we manually change the mode to make it executable, and then call the script with some arguments.
</p>

<div class="org-src-container">

<pre class="src src-sh">chmod +x test.el
./test.el arg1 arg2
</pre>
</div>

<pre class="example">
"GNU Emacs 22.1.1 (mac-apple-darwin)
 of 2014-06-05 on osx105.apple.com"

"I did it. you passed in (arg1 arg2)"
</pre>

<p>
Hahah! I guess the emacs on my path is an old one! Ironically, the Emacs I am writing in is much more modern (but not on the path).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(version)
</pre>
</div>

<pre class="example">
GNU Emacs 24.3.1 (x86_64-apple-darwin, NS apple-appkit-1038.36)
 of 2013-03-13 on bob.porkrind.org
</pre>

<p>
And it is evidence I wrote this on a Mac. First Mac post ever.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Addition based on Trevor's comment</h2>
<div class="outline-text-2" id="text-1">
<p>
Also according to <a href="http://www.emacswiki.org/emacs/EmacsScripts">http://www.emacswiki.org/emacs/EmacsScripts</a> , there is the following option:
</p>

<pre class="example">
#!emacs --script
</pre>

<p>
as the shebang line. That did not work on my mac, but a small variation did with the absolute path to emacs. You still define the function in the script file, but you finally have to call the function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(main)
;; Local Variables:
;; mode: emacs-lisp
;; End:
</pre>
</div>


<div class="org-src-container">

<pre class="src src-sh">./test2.el arg1 arg2 arg3
</pre>
</div>

<pre class="example">
"GNU Emacs 22.1.1 (mac-apple-darwin)
 of 2014-06-05 on osx105.apple.com"

"Called with (/usr/bin/emacs --no-splash -scriptload ./test2.el arg1 arg2 arg3)"

"I did it. you passed in (arg1 arg2 arg3)"
</pre>

<p>
Now, how do you do this python style so one file is a script and library at once? In python that is done with:
</p>

<div class="org-src-container">

<pre class="src src-python">def main ():
    ... put some module code here

if __name__ == '__main__':
    main()
</pre>
</div>

<p>
We can check the command line-args to see if there is a clue there.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun main ()
  (print (version))
  (print (format "Called with %s" command-line-args))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(main)
;; Local Variables:
;; mode: emacs-lisp
;; End:
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">./test3.el arg1
</pre>
</div>

<pre class="example">
"GNU Emacs 22.1.1 (mac-apple-darwin)
 of 2014-06-05 on osx105.apple.com"

"Called with (/usr/bin/emacs --no-splash -scriptload ./test3.el arg1)"

"I did it. you passed in (arg1)"
</pre>

<p>
And apparently, this means when called with &#x2013;script, we see "-scriptload" as a command line arg. Strange, but workable. We just look for that, and if we see it run as a script, and if not do nothing.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun main ()
  (print (version))
  (print (format "Called with %s" command-line-args))
  (print (format "I did it. you passed in %s" command-line-args-left)))

(when (member "-scriptload" command-line-args)
  (main))
</pre>
</div>

<p>
Here we run as a script.
</p>

<div class="org-src-container">

<pre class="src src-sh">./test4.el arg1
</pre>
</div>

<pre class="example">
"GNU Emacs 22.1.1 (mac-apple-darwin)
 of 2014-06-05 on osx105.apple.com"

"Called with (/usr/bin/emacs --no-splash -scriptload ./test4.el arg1)"

"I did it. you passed in (arg1)"
</pre>

<p>
Now, we try loading the file, and calling our function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(load-file "test4.el")
(main)
</pre>
</div>

<pre class="example">
I did it. you passed in nil
</pre>

<p>
Sweet. An emacs script and library in one. Now, I just need to get my modern emacs on the path!
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/08/06/Writing-scripts-in-Emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Another parsing of links for citations with pre and post text.]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text" />
    <id>http://jkitchin.github.io/blog/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text</id>
    <updated>2014-06-26T20:16:43Z</updated>
    <published>2014-06-26T20:16:43Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="org-ref" />
    <summary type="html"><![CDATA[Another parsing of links for citations with pre and post text.]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text"><![CDATA[



<p>
Some LaTeX citations look like \cite[pretext][post text]{key}. Here I explore parsing a link like <a href="#(pre text)(post text)key">(pre text)(post text)key</a>. Note you cannot use [] inside the link, as it breaks the link syntax. Also, these links must be wrapped in <code>[[]]</code> because of the parentheses and spaces in the parentheses. This is a very different approach than used <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/05/19/Exporting-citations-with-biblatex/">here</a> which used the description of the link to define the pre and post text. The disadvantage of that approach is that the key is hidden, whereas in this approach it is not; you can see the key and pre/post text.
</p>

<p>
The basic strategy will be to use a regexp to parse the link path. The regexp below is pretty hairy, but basically it looks for optional text in () and uses numbered groups to store what is found. Then, we use what we found to construct the LaTeX syntax. We redefine the function in org-ref that gets the key for clicking, and we redefine the cite format function. The result is that we retain the click functionality that shows us what the key refers to.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-parse-key (s)
  "return pretext, posttext and bibtex key from a string like \"(pre text)(post text)bibtexkey\""
  (string-match "\\(?1:(\\(?2:[^)]*\\))\\)?\\(?3:(\\(?4:[^]]*\\))\\)?\\(?5:.*\\)" s)
  ;; return pretext postext key
  (list (match-string 2 s) (match-string 4 s) (match-string 5 s)))

(defun org-ref-get-bibtex-key-and-file (&amp;optional key)
  "returns the bibtex key and file that it is in. If no key is provided, get one under point"
 (interactive)
 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       (file))
   (unless key
     ;; get the key
     (setq key (nth 2 (org-ref-parse-key (org-ref-get-bibtex-key-under-cursor)))))
   (setq file     (catch 'result
		    (loop for file in org-ref-bibliography-files do
			  (if (org-ref-key-in-file-p key (file-truename file)) 
			      (throw 'result file)))))
   (cons key file)))

(defun org-ref-format-cite (keyword desc format)
   (cond
    ((eq format 'latex)
     (let* ((results (org-ref-parse-key keyword))
	    (pretext (nth 0 results))
	    (posttext (nth 1 results))
	    (key (nth 2 results)))
       (concat "\\cite" 
	       (when pretext (format "[%s]" pretext))
	       (when posttext (format "[%s]" posttext))
	       (format "{%s}" key))))))
</pre>
</div>

<pre class="example">
org-ref-format-cite
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "(pre text)(post text)key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite[pre text][post text]{key}
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "(pre text)key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite[pre text]{key}
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite{key}
</pre>

<p>
It looks like they all work! Let us test the links: <a href="#mehta-2014-ident-poten">mehta-2014-ident-poten</a>, <a href="#(pre text)mehta-2014-ident-poten">(pre text)mehta-2014-ident-poten</a> and <a href="#(pre text)(post text)biskup-2014-insul-ferrom-films">(pre text)(post text)biskup-2014-insul-ferrom-films</a>. a multiple citation <a href="#mehta-2014-ident-poten">mehta-2014-ident-poten</a>,<a href="#thompson-2014-co2-react">thompson-2014-co2-react</a>,<a href="#calle-vallejo-2013-number">calle-vallejo-2013-number</a>.
</p>

<p>
This seems to work from an export point of view. You can not mix multiple citations with this syntax, and I did not define the html export above. Otherwise, it looks like this might be a reasonable addition to org-ref.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text..org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using org-files like el-files]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/06/24/Using-org-files-like-el-files" />
    <id>http://jkitchin.github.io/blog/2014/06/24/Using-org-files-like-el-files</id>
    <updated>2014-06-24T21:34:15Z</updated>
    <published>2014-06-24T21:32:58Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Using org-files like el-files]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/06/24/Using-org-files-like-el-files"><![CDATA[


<p>
I wrote some emacs-lisp code in org-mode, and load them with org-babel-load-file. I thought it would be nice if there was load path for org-files, similar to the one for lisp files. Here I document what it might look like.
</p>

<p>
We need a load path to search for the org-file.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-load-path '("~/Dropbox/kitchingroup/jmax/"))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">~/Dropbox/kitchingroup/jmax/</td>
</tr>
</tbody>
</table>

<p>
Next, we need the function to do the loading. We need to find the org-file, and then load it.
</p>



<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (org-babel-load-file path)))


(org-require 'org-ref)
</pre>
</div>

<pre class="example">
Loaded ~/Dropbox/kitchingroup/jmax/org-ref.el
</pre>

<p>
That looks pretty simple. You do need write access to the location where the org-file is though. Let us look at a version that copies the file to a temporary directory. For some reason, I am not able to use org-babel-load-file with this. But, it does look like I can tangle the file, and assuming (big assumption) that the file tangles to a regularly named .el file, this seems to work too.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
        (el-file (concat (symbol-name orgfile) ".el"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (copy-file path temporary-file-directory t)

  (org-babel-tangle-file (concat temporary-file-directory (file-name-nondirectory path)))
  (load-file (concat temporary-file-directory el-file))
))

(org-require 'org-ref)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
This actually seems pretty reasonable. I have not thought about complications but for simple cases, e.g. single org-file, it looks ok.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/06/24/Using-org-files-like-el-files.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Automatic downloading of a pdf from a journal site]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site" />
    <id>http://jkitchin.github.io/blog/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site</id>
    <updated>2014-05-23T11:44:11Z</updated>
    <published>2014-05-23T11:44:11Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Automatic downloading of a pdf from a journal site]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site"><![CDATA[


<p>
Many bibliography software packages can automatically download a pdf for you. In this post, we explore how that can be done from emacs. The principle idea is that the pdf is obtained from a url, and that you can calculate the url by some method. Then you can download the file. 
</p>

<p>
For example, consider this article in Phys. Rev. Lett. <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105</a> . There is a link to get the pdf for this article at <a href="http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105</a> . It is not difficult to construct that url; you just replace <code>/abstract/</code> with <code>/pdf/</code>.
</p>

<p>
The trick is how to get the first url. We have previously seen that we can construct a bibtex entry from a doi. In fact, we can use the doi to get the url above. If you visit <a href="http://dx.doi.org/10.1103/PhysRevLett.99.016105">http://dx.doi.org/10.1103/PhysRevLett.99.016105</a> , you will be redirected to the url. It so happens that you can use code to get the redirected url. In emacs-lisp it is a little convoluted; you have to use url-retrieve, and provide a callback that sets the redirect. Here is an example. It appears you need to run this block twice to get the right variable setting. That seems like some kind of error in what I have set up, but I cannot figure out why.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defvar *doi-utils-redirect*)

(defun callback (&amp;optional status)
 (when status ;  is nil if there none
   (setq *doi-utils-redirect* (plist-get status :redirect))))

(url-retrieve 
  "http://dx.doi.org/10.1103/PhysRevLett.99.016105"
  'callback)

(print *doi-utils-redirect*)
</pre>
</div>

<pre class="example">
"http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105"
</pre>

<p>
From there, creating the pdf url is as simple as
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(replace-regexp-in-string "prl/abstract" "prl/pdf" "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105")
</pre>
</div>

<pre class="example">
http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105
</pre>

<p>
And finally we download the file with
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(url-copy-file "http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105" "PhysRevLett.99.016105.pdf" nil)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
So that is the gist of automating pdf downloads. You do these steps:
</p>
<ol class="org-ol">
<li>Get the DOI
</li>
<li>Get the url that the DOI redirects to
</li>
<li>Calculate the link to the pdf
</li>
<li>Download the pdf
</li>
</ol>

<p>
Each publisher does something a little bit different, so you have to work this out for each one. I have worked alot of them out at <a href="https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el">https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el</a> . That file is a work in progress, but it is a project I intend to use on a regular basis.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
</feed>
