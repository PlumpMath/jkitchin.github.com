<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Thu, 07 Aug 2014 16:07:30 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Writing scripts in Emacs-lisp</title>
      <link>http://jkitchin.github.io/blog/2014/08/06/Writing-scripts-in-Emacs-lisp</link>
      <pubDate>Wed, 06 Aug 2014 14:27:58 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">iieEkUEkddZfQuXdXlfU2eB92PA=</guid>
      <description>Writing scripts in Emacs-lisp</description>
      <content:encoded><![CDATA[



<p>
I have written lots of script commands, mostly in Python, occasionally in bash. Today I learned you can also write them in emacs-lisp (<a href="http://www.emacswiki.org/emacs/EmacsScripts">http://www.emacswiki.org/emacs/EmacsScripts</a> ). There is an interesting wrinkle on the first line which specifies how to run the command, which is explained in the emacswiki page.
</p>

<p>
Here is an example script that just prints some information about Emacs and the command line args you pass to it. We use some Local variables at the end to make the script open in emacs-lisp mode for editing. $0 in shell language is the name of the script being run, so the header here simply loads the script into emacs, and then runs the main function. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">:;exec emacs -batch -l "$0" -f main "$@"

(defun main ()
  (print (version))
  (print (format "I did it. you passed in %s" command-line-args-left)))

;; Local Variables:
;; mode: emacs-lisp
;; End:
</pre>
</div>

<p>
We need to tangle this code block to get the script. 
<a href="org-babel-tangle">org-babel-tangle</a>
</p>

<p>
Since we do not have a regular shebang, we manually change the mode to make it executable, and then call the script with some arguments.
</p>

<div class="org-src-container">

<pre class="src src-sh">chmod +x test.el
./test.el arg1 arg2
</pre>
</div>

<pre class="example">
"GNU Emacs 22.1.1 (mac-apple-darwin)
 of 2014-06-05 on osx105.apple.com"

"I did it. you passed in (arg1 arg2)"
</pre>

<p>
Hahah! I guess the emacs on my path is an old one! Ironically, the Emacs I am writing in is much more modern (but not on the path).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(version)
</pre>
</div>

<pre class="example">
GNU Emacs 24.3.1 (x86_64-apple-darwin, NS apple-appkit-1038.36)
 of 2013-03-13 on bob.porkrind.org
</pre>


<p>
And it is evidence I wrote this on a Mac. First Mac post ever.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/08/06/Writing-scripts-in-Emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Another parsing of links for citations with pre and post text.</title>
      <link>http://jkitchin.github.io/blog/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text</link>
      <pubDate>Thu, 26 Jun 2014 20:16:43 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[org-ref]]></category>
      <guid isPermaLink="false">y0RRshHWnJDYrR30xt8Gha-MeNc=</guid>
      <description>Another parsing of links for citations with pre and post text.</description>
      <content:encoded><![CDATA[



<p>
Some LaTeX citations look like \cite[pretext][post text]{key}. Here I explore parsing a link like <a href="#(pre text)(post text)key">(pre text)(post text)key</a>. Note you cannot use [] inside the link, as it breaks the link syntax. Also, these links must be wrapped in <code>[[]]</code> because of the parentheses and spaces in the parentheses. This is a very different approach than used <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/05/19/Exporting-citations-with-biblatex/">here</a> which used the description of the link to define the pre and post text. The disadvantage of that approach is that the key is hidden, whereas in this approach it is not; you can see the key and pre/post text.
</p>

<p>
The basic strategy will be to use a regexp to parse the link path. The regexp below is pretty hairy, but basically it looks for optional text in () and uses numbered groups to store what is found. Then, we use what we found to construct the LaTeX syntax. We redefine the function in org-ref that gets the key for clicking, and we redefine the cite format function. The result is that we retain the click functionality that shows us what the key refers to.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-parse-key (s)
  "return pretext, posttext and bibtex key from a string like \"(pre text)(post text)bibtexkey\""
  (string-match "\\(?1:(\\(?2:[^)]*\\))\\)?\\(?3:(\\(?4:[^]]*\\))\\)?\\(?5:.*\\)" s)
  ;; return pretext postext key
  (list (match-string 2 s) (match-string 4 s) (match-string 5 s)))

(defun org-ref-get-bibtex-key-and-file (&amp;optional key)
  "returns the bibtex key and file that it is in. If no key is provided, get one under point"
 (interactive)
 (let ((org-ref-bibliography-files (org-ref-find-bibliography))
       (file))
   (unless key
     ;; get the key
     (setq key (nth 2 (org-ref-parse-key (org-ref-get-bibtex-key-under-cursor)))))
   (setq file     (catch 'result
		    (loop for file in org-ref-bibliography-files do
			  (if (org-ref-key-in-file-p key (file-truename file)) 
			      (throw 'result file)))))
   (cons key file)))

(defun org-ref-format-cite (keyword desc format)
   (cond
    ((eq format 'latex)
     (let* ((results (org-ref-parse-key keyword))
	    (pretext (nth 0 results))
	    (posttext (nth 1 results))
	    (key (nth 2 results)))
       (concat "\\cite" 
	       (when pretext (format "[%s]" pretext))
	       (when posttext (format "[%s]" posttext))
	       (format "{%s}" key))))))
</pre>
</div>

<pre class="example">
org-ref-format-cite
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "(pre text)(post text)key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite[pre text][post text]{key}
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "(pre text)key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite[pre text]{key}
</pre>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-format-cite "key" nil 'latex)
</pre>
</div>

<pre class="example">
\cite{key}
</pre>

<p>
It looks like they all work! Let us test the links: <a href="#mehta-2014-ident-poten">mehta-2014-ident-poten</a>, <a href="#(pre text)mehta-2014-ident-poten">(pre text)mehta-2014-ident-poten</a> and <a href="#(pre text)(post text)biskup-2014-insul-ferrom-films">(pre text)(post text)biskup-2014-insul-ferrom-films</a>. a multiple citation <a href="#mehta-2014-ident-poten">mehta-2014-ident-poten</a>,<a href="#thompson-2014-co2-react">thompson-2014-co2-react</a>,<a href="#calle-vallejo-2013-number">calle-vallejo-2013-number</a>.
</p>

<p>
This seems to work from an export point of view. You can not mix multiple citations with this syntax, and I did not define the html export above. Otherwise, it looks like this might be a reasonable addition to org-ref.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/06/26/Another-parsing-of-links-for-citations-with-pre-and-post-text..org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Using org-files like el-files</title>
      <link>http://jkitchin.github.io/blog/2014/06/24/Using-org-files-like-el-files</link>
      <pubDate>Tue, 24 Jun 2014 21:32:58 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">nb1TWbf4Ve04dTZL_8IMeWVea0A=</guid>
      <description>Using org-files like el-files</description>
      <content:encoded><![CDATA[


<p>
I wrote some emacs-lisp code in org-mode, and load them with org-babel-load-file. I thought it would be nice if there was load path for org-files, similar to the one for lisp files. Here I document what it might look like.
</p>

<p>
We need a load path to search for the org-file.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-load-path '("~/Dropbox/kitchingroup/jmax/"))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">~/Dropbox/kitchingroup/jmax/</td>
</tr>
</tbody>
</table>

<p>
Next, we need the function to do the loading. We need to find the org-file, and then load it.
</p>



<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (org-babel-load-file path)))


(org-require 'org-ref)
</pre>
</div>

<pre class="example">
Loaded ~/Dropbox/kitchingroup/jmax/org-ref.el
</pre>

<p>
That looks pretty simple. You do need write access to the location where the org-file is though. Let us look at a version that copies the file to a temporary directory. For some reason, I am not able to use org-babel-load-file with this. But, it does look like I can tangle the file, and assuming (big assumption) that the file tangles to a regularly named .el file, this seems to work too.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-require (orgfile)
  "orgfile is a symbol to be loaded"
  (let ((org-file (concat (symbol-name orgfile) ".org"))
        (el-file (concat (symbol-name orgfile) ".el"))
	(path))

  ;; find the org-file
  (catch 'result
    (loop for dir in org-load-path do
	  (when (file-exists-p
		 (setq path
		       (concat
			(directory-file-name dir)
			"/"
			org-file)))
	    (throw 'result path))))
  (copy-file path temporary-file-directory t)

  (org-babel-tangle-file (concat temporary-file-directory (file-name-nondirectory path)))
  (load-file (concat temporary-file-directory el-file))
))

(org-require 'org-ref)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
This actually seems pretty reasonable. I have not thought about complications but for simple cases, e.g. single org-file, it looks ok.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/06/24/Using-org-files-like-el-files.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Automatic downloading of a pdf from a journal site</title>
      <link>http://jkitchin.github.io/blog/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site</link>
      <pubDate>Fri, 23 May 2014 11:44:11 EDT</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[bibtex]]></category>
      <guid isPermaLink="false">UWmVnxHyixLN3IL5WLWxQNP6n_g=</guid>
      <description>Automatic downloading of a pdf from a journal site</description>
      <content:encoded><![CDATA[


<p>
Many bibliography software packages can automatically download a pdf for you. In this post, we explore how that can be done from emacs. The principle idea is that the pdf is obtained from a url, and that you can calculate the url by some method. Then you can download the file. 
</p>

<p>
For example, consider this article in Phys. Rev. Lett. <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105</a> . There is a link to get the pdf for this article at <a href="http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105">http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105</a> . It is not difficult to construct that url; you just replace <code>/abstract/</code> with <code>/pdf/</code>.
</p>

<p>
The trick is how to get the first url. We have previously seen that we can construct a bibtex entry from a doi. In fact, we can use the doi to get the url above. If you visit <a href="http://dx.doi.org/10.1103/PhysRevLett.99.016105">http://dx.doi.org/10.1103/PhysRevLett.99.016105</a> , you will be redirected to the url. It so happens that you can use code to get the redirected url. In emacs-lisp it is a little convoluted; you have to use url-retrieve, and provide a callback that sets the redirect. Here is an example. It appears you need to run this block twice to get the right variable setting. That seems like some kind of error in what I have set up, but I cannot figure out why.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defvar *doi-utils-redirect*)

(defun callback (&amp;optional status)
 (when status ;  is nil if there none
   (setq *doi-utils-redirect* (plist-get status :redirect))))

(url-retrieve 
  "http://dx.doi.org/10.1103/PhysRevLett.99.016105"
  'callback)

(print *doi-utils-redirect*)
</pre>
</div>

<pre class="example">
"http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105"
</pre>

<p>
From there, creating the pdf url is as simple as
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(replace-regexp-in-string "prl/abstract" "prl/pdf" "http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.99.016105")
</pre>
</div>

<pre class="example">
http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105
</pre>

<p>
And finally we download the file with
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(url-copy-file "http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.99.016105" "PhysRevLett.99.016105.pdf" nil)
</pre>
</div>

<pre class="example">
t
</pre>

<p>
So that is the gist of automating pdf downloads. You do these steps:
</p>
<ol class="org-ol">
<li>Get the DOI
</li>
<li>Get the url that the DOI redirects to
</li>
<li>Calculate the link to the pdf
</li>
<li>Download the pdf
</li>
</ol>

<p>
Each publisher does something a little bit different, so you have to work this out for each one. I have worked alot of them out at <a href="https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el">https://github.com/jkitchin/jmax/blob/master/user/doi-utils.el</a> . That file is a work in progress, but it is a project I intend to use on a regular basis.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/23/Automatic-downloading-of-a-pdf-from-a-journal-site.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Using org-ref to keep your bibtex files in order</title>
      <link>http://jkitchin.github.io/blog/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order</link>
      <pubDate>Thu, 15 May 2014 10:59:19 EDT</pubDate>
      <category><![CDATA[bibtex]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">F76lZEkWpqEQm1tOI153NwJwZpA=</guid>
      <description>Using org-ref to keep your bibtex files in order</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. "cleaning" a bibtex entry</a></li>
<li><a href="#sec-2">2. Validating your bibliography</a></li>
<li><a href="#sec-3">3. Sorting your bibtex file</a></li>
<li><a href="#sec-4">4. Make a full bibliography pdf</a></li>
<li><a href="#sec-5">5. Finding bad citation links</a></li>
<li><a href="#sec-6">6. Extracting citations entries</a></li>
<li><a href="#sec-7">7. Summary</a></li>
<li><a href="#sec-8">8. References</a></li>
<li><a href="#sec-9">9. Bibtex entries</a></li>
</ul>
</div>
</div>

<p>
Maintaining an accurate, useful bibliography of references is critical for scientific writing. It is also not trivial. While it is easy to download and copy bibliographic entries to your database, these entries are often incomplete, not consistently formatted, and can contain invalid characters. org-ref provides several utility functions to help with this.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> "cleaning" a bibtex entry</h2>
<div class="outline-text-2" id="text-1">
<p>
Consider this bibtex entry from <a href="http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j">http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j</a> .
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{doi:10.1021/ie500588j,
author = {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami and Takeda, Yohei and Minamisawa, Hikari M. and Haeiwa, Tetsuji and Sakai, Toshio and Mishima, Shozi},
title = {Magnetic Rattle-Type Coreâ€“Shell Particles Containing Iron Compounds with Acid Tolerance by Dense Silica},
journal = {Industrial &amp; Engineering Chemistry Research},
volume = {0},
number = {0},
pages = {null},
year = {0},
doi = {10.1021/ie500588j},

URL = {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie500588j}
}
</pre>
</div>

<p>
On the surface it looks fine, but there are the following issues with it:
</p>

<ol class="org-ol">
<li>The bibtex key is hard to remember. I like systematically named keys.
</li>
<li>There is a bare &amp; in the journal title, which is not legal in LaTeX.
</li>
<li>There is no year entry, even though it is a 2014 entry. The pages, volume, and number are also problematic, but this is an ASAP article and the reference does not have those yet.
</li>
<li>It is hard to see, but the dash between core and shell is a non-ascii character, which can cause problems in LaTeX.
</li>
<li>The entry is not very nicely aligned or indented.
</li>
</ol>

<p>
You can fix these problems by putting your cursor on the bibtex entry, and typing M-x org-ref-clean-bibtex-entry. This will fix the bibtex key to a standard form, align and indent the entry, escape the &amp; so it is legal syntax, prompt you for a year, and show you the non-ascii characters so you can replace them. The resulting, nicely formatted entry is shown below.
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{okada-2014-magnet-rattl,
  author =	 {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami
                  and Takeda, Yohei and Minamisawa, Hikari M. and
                  Haeiwa, Tetsuji and Sakai, Toshio and Mishima,
                  Shozi},
  title =	 {Magnetic Rattle-Type Core-Shell Particles Containing
                  Iron Compounds with Acid Tolerance by Dense Silica},
  journal =	 {Industrial \&amp; Engineering Chemistry Research},
  volume =	 0,
  pages =	 {null},
  year =	 2014,
  doi =		 {10.1021/ie500588j},
  number =	 0,
  url =		 {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
  eprint =	 {http://pubs.acs.org/doi/pdf/10.1021/ie500588j},
}
</pre>
</div>

<p>
The key formatting comes from these definitions:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
;; this usually makes a legitimate filename to store pdfs under.
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
</pre>
</div>

<p>
You should develop a discipline to clean each entry as you add them, and before you cite them. It is a pain to change the key, and then find and change all the places you used that key before. Now that you have a systematic key, go ahead and download the pdf for the article, and save it in your pdf directory by that key name. Set the variable org-ref-pdf-directory to this directory, and later when you click on citations you will be able to open the pdf easily.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Validating your bibliography</h2>
<div class="outline-text-2" id="text-2">
<p>
<pre>elisp:bibtex-validate</pre> will check your bibliography for valid syntax. This is a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Sorting your bibtex file</h2>
<div class="outline-text-2" id="text-3">
<p>
It is a good idea to keep your bibtex file sorted. This will facilitate finding duplicate entries, and will make it easier to find things. I usually add entries to the top of the file, and then clean them. Then run the command <pre>elisp:bibtex-sort-buffer</pre> . This will sort the entries for you. This is also a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Make a full bibliography pdf</h2>
<div class="outline-text-2" id="text-4">
<p>
A good way to check your bibliography for duplicates, spelling errors, and invalid formats is to make a pdf containing all the entries. Open your bibtex file, and run <pre>elisp:org-ref-build-full-bibliography</pre> . If all goes well, you will get a pdf of your bibliography that you can check for accuracy. If there are errors, you will have to fix them until the pdf is generated.
</p>

<p>
Try it out: <a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Finding bad citation links</h2>
<div class="outline-text-2" id="text-5">
<p>
Sometimes you will get bad citation links in your document. Maybe there is no corresponding entry, maybe you typed in the wrong key, maybe you changed the key. Either way, you need to find them and fix them. Run the command <pre>elisp:org-ref-find-bad-citations</pre> to find them. <pre>cite:test</pre> 
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Extracting citations entries</h2>
<div class="outline-text-2" id="text-6">
<p>
You will often work from your default bibliography for your own work. Eventually you will need to extract the entries cited so you can send them to someone. The command  <pre>elisp:org-ref-extract-bibtex-entries</pre> will do that for you. If I have cited something <pre>cite:calle-vallejo-2010-trend-stabil</pre> .
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Summary</h2>
<div class="outline-text-2" id="text-7">
<p>
You can see a screen cast of this post here: <a href="http://screencast.com/t/yZCOdO6kJ">http://screencast.com/t/yZCOdO6kJ</a> 
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> References</h2>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Bibtex entries</h2>
<div class="outline-text-2" id="text-9">
<p>
#+BEGIN<sub>SRC</sub>: text :tangle extract-bib7108tYg.bib
@article{calle-vallejo-2010-trend-stabil,
  author =         {Calle-Vallejo, F. and Martinez, J. I. and Garcia-
                  Lastra, J. M. and Mogensen, M. and Rossmeisl, J.},
  title =         {Trends in Stability of Perovskite Oxides},
  journal =         "Angewandte Chemie-International Edition",
  volume =         49,
  number =         42,
  pages =         {7699-7701},
  year =         2010,
  doi =                 {10.1002/anie.201002301},
  keyword =         {density functional calculations heats of formation
                  perovskites thermochemistry transition-metals
                  catalysts ferroelectricity},
}
#+END<sub>SRC</sub>
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Using org-ref for citations and references</title>
      <link>http://jkitchin.github.io/blog/2014/05/13/Using-org-ref-for-citations-and-references</link>
      <pubDate>Tue, 13 May 2014 11:25:24 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">0cXdRm9M5p4qE915ukRqSAsoI98=</guid>
      <description>Using org-ref for citations and references</description>
      <content:encoded><![CDATA[



<p>
<a href="https://github.com/jkitchin/jmax/blob/master/org-ref.org">org-ref</a> is an emacs-lisp module to handle bibliographic citations, and references to figures, tables and sections in org-mode. It was written first for use in org-mode, and for reasonable export to LaTeX. It does not work well for any other export (eg HTML) for now. The goal of org-ref is to make it easy to add citations, and that the citations be useful, clickable links. Below, I illustrate some of those features.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Installation</h2>
<div class="outline-text-2" id="text-1">
<p>
You can get the source here: <a href="https://github.com/jkitchin/jmax/blob/master/org-ref.org">https://github.com/jkitchin/jmax/blob/master/org-ref.org</a> . This is an org-mode file, and you can load it with
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-babel-load-file "org-ref.org")
</pre>
</div>

<p>
That should be all you need for basic usage.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Basic usage for citations</h2>
<div class="outline-text-2" id="text-2">
<p>
org-ref was written with bibtex in mind. We will discuss customization to use biblatex later.
</p>

<p>
The first thing you should do is add a <pre>bibliography</pre> link to your document. This link is usually put at the end of the document, where you want the bibliography to be printed in a LaTeX export. Use the filename of the bibliography with its extension in the link, and you can use multiple files if they are separated by commas. The bibliography link is clickable, and it will open the bibliography that you clicked on. Depending on the LaTeX class you are exporting to, you may also need to set a bibliographystye.
</p>

<p>
Out of the box, org-ref binds the key "C-c ]" to insert a citation. That key runs the command org-ref-insert-cite-link, which will prompt you for a regular expression to search your bibliographies for. The search is done using reftex, so you can mark several entries at once, and they will be added as a citation link. The actual kind of link used is dependent on the value of org-ref-default-citation-link, which defaults to cite. 
</p>

<p>
If your cursor is on a citation link, or at the end of the link, you can run the command again to append new citations to the link. The new entries are separated by commas. The links are clickable, and when you click on them you will see a message in the minibuffer with the citation, and options to open the entry, open a pdf (if you have it), open the url (if the entry has one), or to open notes about the entry. You get this menu for the entry that you clicked on.
</p>

<p>
If you want a different type of citation, type C-u C-c ]. You will be prompted for a format, and you can choose a different type of link format. Most bibtex formats are supported, and some biblatex formats are supported.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Basic usage for references</h2>
<div class="outline-text-2" id="text-3">
<p>
The other use of org-ref is for references to labels in your document. You can put labels in figure and table captions, and then reference them in your document. The label link is clickable, and when you click on it there will be a message in the minibuffer telling you how many labels of that name were found (it should be one).
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> An uninteresting table. <pre>ref:tab-boring</pre> </caption>

<colgroup>
<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">0</td>
<td class="right">3</td>
</tr>

<tr>
<td class="right">4</td>
<td class="right">7</td>
</tr>
</tbody>
</table>

<p>
You can then refer to Table <pre>eqref:eq-exp</pre> . The ref links are also clickable, and they take you to the spot where the label is defined. You can enter ref links with completion. Press C-c C-l, type ref, press enter, and then press tab. You will get a list of the labels defined in the buffer you can choose from. There are many things you can make a ref to including a tblname, a label link, an explicit \label{}, and an org-mode #+label: line.
</p>

<p>
There is an eqref link that is used for equations. You must use LaTeX labels in the equation for this.
</p>

<p>
\[e^x = 4 \label{eq-exp} \]
</p>

<p>
You can see in <pre>list-of-tables:lot</pre> the problem to solve.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Miscellaneous links</h2>
<div class="outline-text-2" id="text-4">
<p>
There are two link types for generating a LateX list of tables and list of figures. These links are clickable, and they open a temporary buffer with a list of the tables or figures that you can click on. They export to \listoftables and \listoffigures
</p>

<p>

</p>

<p>

</p>

<p>
You can run these as commands, <pre>list-of-figures:lof</pre> and <pre>elisp:org-ref-list-of-tables</pre> if you do not want a list of those things in your exported document.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Customization</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Default bibliography, pdf directory,</h3>
<div class="outline-text-3" id="text-5-1">
<p>
This is an optional configuration, but it is handy to define a default bibliography so that you can add citations to an org-file without defining a bibliography link. I store all pdfs of bibtex entries in the directory defined by org-ref-pdf-directory, and by the name of the bibtex entry label. This enables org-ref to open the pdf if it can find it. The notes file is optional, I create org-entries for each bibtex entry, which I have experimented with various ways of organizing them with tags, and in topical headings.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-ref-bibliography-notes "~/Dropbox/bibliography/notes.org"
      org-ref-default-bibliography '("~/Dropbox/bibliography/references.bib")
      org-ref-pdf-directory "~/Dropbox/bibliography/bibtex-pdfs/")
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> New key binding</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The default key binding to insert a citation is C-c ]. I chose that because I do not like pressing shift to get ). However, this key binding usurps an org-mode agenda file command. To change this, set this variable
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-ref-insert-cite-key "C-c )")
</pre>
</div>

<ul class="org-ul">
<li>You may have to restart emacs to get C-c ] back.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Default link type</h3>
<div class="outline-text-3" id="text-5-3">
<p>
If you use another citation type alot, you may change the default link type. For example, you may prefer autocite links by default. Just set it like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(setq org-ref-default-citation-link "autocite")
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> New citation types</h3>
<div class="outline-text-3" id="text-5-4">
<p>
There are so many citation types between bibtex and biblatex. I did not try to add them all. You can add new citation links yourself in your init file. Here, we add a new cite link called citez, and assign a reftex menu key of z to it. This function automatically adds the new link to org-mode, with the citation menu functionality, creates the completion function, and adds the citation to the list of known types.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-ref-define-citation-link "citez" ?z)
</pre>
</div>

<p>
It is assumed that this will be exported as \citez[optional stuff]{label}. If you need more flexibility than that, you will have to define everything manually.
</p>

<p>
For example, the original cite link was defined like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun org-ref-cite-link-format (keyword desc format)
   (cond
    ((eq format 'html) (format "(&lt;cite&gt;%s&lt;/cite&gt;)" path))
    ((eq format 'latex)
     (concat "\\cite" (when desc (format "[%s]" desc)) "{"
	     (mapconcat (lambda (key) key) (org-ref-split-and-strip-string keyword) ",")
	     "}"))))

(org-add-link-type
 "cite"
 'org-ref-cite-onclick-minibuffer-menu ;; clicking function
 'org-ref-cite-link-format) ;; formatting function
</pre>
</div>

<p>
You should also add your new citation type to the list of org-ref-cite-types.
</p>
</div>
</div>
</div>


<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">
<p>
This covers most of the basic org-ref functionality. There are also several utility functions for interacting with org-buffers and bibtex files that will be described later.
</p>


<p>

</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/13/Using-org-ref-for-citations-and-references.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Autogenerating functions in emacs-lisp</title>
      <link>http://jkitchin.github.io/blog/2014/05/12/Autogenerating-functions-in-emacs-lisp</link>
      <pubDate>Mon, 12 May 2014 18:05:45 EDT</pubDate>
      <category><![CDATA[emacs-lisp]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">d3hbFuxiIuGrO08l_vmlhTqDbrI=</guid>
      <description>Autogenerating functions in emacs-lisp</description>
      <content:encoded><![CDATA[



<p>
I have a need to generate a lot of similar functions, and I do not want to cut and paste the code. I want to generate the functions with code. This seems to be what macros are for in emacs lisp. 
</p>

<p>
As a prototype example, we will make functions that raise a number to a power. We want functions like power-3 and power-4 that raise numbers to the third and fourth powers. We will define functions like this for the numbers 0-9.
</p>

<p>
Here we define the macro. i do not want to get into the nitty gritty details of macro definitions here.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(make-power-n 4)

(power-4 4)
</pre>
</div>

<pre class="example">
256
</pre>

<p>
Now we use the macro and mapcar on it onto a list of numbers. We have to eval the macro in the mapcar lambda function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defmacro make-power-n (n)
 `(defun ,(intern (format "power-%s" n)) (arg) (expt arg ,n)))

(mapcar (lambda (x) (eval `(make-power-n ,x))) '(0 1 2 3 4 5 6 7 8 9))
 
;; example of a few functions
(list (power-0 3) (power-1 3) (power-2 3))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<tbody>
<tr>
<td class="right">1</td>
<td class="right">3</td>
<td class="right">9</td>
</tr>
</tbody>
</table>

<p>
It works! We created 10 functions in a little bit of code. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/12/Autogenerating-functions-in-emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content:encoded>
    </item>
    <item>
      <title>Make a list of org-files in all the subdirectories of the current working directory</title>
      <link>http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory</link>
      <pubDate>Sun, 23 Mar 2014 15:36:56 EDT</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[recursive]]></category>
      <guid isPermaLink="false">ol_gYLGLHCsyZ025rQ_qIKwXg34=</guid>
      <description>Make a list of org-files in all the subdirectories of the current working directory</description>
      <content:encoded><![CDATA[



<p>
It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents. 
</p>

<p>
Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called <code>literate</code> in my computer.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">list contents of the directory</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
<td class="left">..</td>
<td class="left">.</td>
</tr>
</tbody>
</table>

<p>
Note the presence of <code>.</code> and <code>..</code>. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">remove . and ..</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (remove <span style="color: #228b22;">"."</span> 
          (remove <span style="color: #228b22;">".."</span> 
                  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
</tr>
</tbody>
</table>

<p>
Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">print types of files in the directory</span>
(<span style="color: #8b0000;">let</span> ((root <span style="color: #228b22;">"literate"</span>)
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (<span style="color: #8b0000;">lambda</span> (x)
            (<span style="color: #8b0000;">cond</span>
             ((file-directory-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a directory"</span> x)))
             ((file-regular-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a regular file"</span> x)))))
          (remove <span style="color: #228b22;">"."</span> 
                  (remove <span style="color: #228b22;">".."</span> 
                          (directory-files root abspath match nosort)))))
</pre>
</div>

<pre class="example">
"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
</pre>

<p>
Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at <a href="http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html">http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html</a> which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  <span style="color: #228b22;">"recursively walks through directories getting list of absolute paths of files"</span>
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk <span style="color: #228b22;">"literate"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/makefile-main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/literate.org</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/hello.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.mod</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle-area.png</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/a.out</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/Makefile</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/archive/empty-text-file.txt</td>
</tr>
</tbody>
</table>

<p>
Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">;</span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(<span style="color: #8b0000;">require</span> '<span style="color: #cd0000;">cl</span>)

(mapcar 
 (<span style="color: #8b0000;">lambda</span> (x) (princ (format <span style="color: #228b22;">"[[%s][%s]]\n"</span> x (file-relative-name x <span style="color: #228b22;">"."</span>))))
 (remove-if-not 
  (<span style="color: #8b0000;">lambda</span> (x) (string= (file-name-extension x) <span style="color: #228b22;">"org"</span>))
  (os-walk <span style="color: #228b22;">"literate"</span>)))
</pre>
</div>

<p>
<a href="/media/2014-03-23-Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory/literate.org">literate/literate.org</a> 
</p>


<p>
That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>yasnippets for jasp, ase and python</title>
      <link>http://jkitchin.github.io/blog/2014/02/17/yasnippets-for-jasp-ase-and-python</link>
      <pubDate>Mon, 17 Feb 2014 09:03:50 EST</pubDate>
      <category><![CDATA[emacs]]></category>
      <category><![CDATA[ase]]></category>
      <category><![CDATA[jasp]]></category>
      <guid isPermaLink="false">5IQtbu_TyyiAG1EcGdlxi4IDXtc=</guid>
      <description>yasnippets for jasp, ase and python</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Tangle the snippets, and add them to yasnippet</a></li>
<li><a href="#sec-2">2. Using the snippets</a></li>
<li><a href="#sec-3">3. Appendix</a>
<ul>
<li><a href="#sec-3-1">3.1. jasp snippets</a></li>
<li><a href="#sec-3-2">3.2. ase snippets</a></li>
<li><a href="#sec-3-3">3.3. python snippets</a></li>
</ul>
</li>
</ul>
</div>
</div>

<p>
In using [[<a href="http://github.com/jkitchin/jasp">http://github.com/jkitchin/jasp</a> for calculations, I find there are lots of small python phrases I use over and over. Today I will examine using <a href="http://capitaomorte.github.io/yasnippet/index.html">yasnippet</a> to save time and keystrokes. yasnippet is a template expansion module, where you type a small set of characters, press <code>Tab</code>, and the
characters "expand" to the full text. It is pretty sophisticated, and allows you to define "tab-stops" which you interactively fill in, and tab between like filling in a form.
</p>

<p>
All the snippets are defined in the <pre>*Appendix</pre> .
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Tangle the snippets, and add them to yasnippet</h2>
<div class="outline-text-2" id="text-1">
<p>
Each snippet definition belongs in a file in a directory. The main directory is called "snippets". Since I anticipate using these snippets in org-mode, each snippet is defined in a directory within snippets called "org-mode". First, we make the directory here. I also want to use the snippets in python mode, so we also create a python-mode directory here. We do not have to duplicate the snippets. We can create a file called <a href="http://capitaomorte.github.io/yasnippet/snippet-organization.html">.yas-parents</a> , with one line in it containing "org-mode".
</p>

<div class="org-src-container">

<pre class="src src-sh">mkdir -p snippets/org-mode
mkdir -p snippets/python-mode
<span style="color: #cd0000;">echo</span> <span style="color: #228b22;">"org-mode"</span> &gt; snippets/python-mode/.yas-parents
</pre>
</div>

<p>
Each snippet is defined in a src block with  a <code>:tangle</code> header. So, we can extract them all in one command here.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-babel-tangle)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">snippets/org-mode/iase</td>
<td class="left">snippets/org-mode/imp</td>
<td class="left">snippets/org-mode/inp</td>
<td class="left">snippets/org-mode/ij</td>
<td class="left">snippets/org-mode/pl</td>
<td class="left">snippets/org-mode/pyl</td>
<td class="left">snippets/org-mode/pxl</td>
<td class="left">snippets/org-mode/pp</td>
<td class="left">snippets/org-mode/npa</td>
<td class="left">snippets/org-mode/awt</td>
<td class="left">snippets/org-mode/avw</td>
<td class="left">snippets/org-mode/agf</td>
<td class="left">snippets/org-mode/ape</td>
<td class="left">snippets/org-mode/atms</td>
<td class="left">snippets/org-mode/atm</td>
<td class="left">snippets/org-mode/cga</td>
<td class="left">snippets/org-mode/cc</td>
<td class="left">snippets/org-mode/wjn</td>
<td class="left">snippets/org-mode/wjl</td>
</tr>
</tbody>
</table>

<p>
We also need to add our new directory to yasnippets. This is done by adding the directory to the <code>yas-snippet-dirs</code> variable. You could add this to your init.el file to permanently add these snippets.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'yas-snippet-dirs <span style="color: #228b22;">"c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/_blog/snippets"</span>)
</pre>
</div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/snippets</td>
<td class="left">~/.emacs.d/snippets</td>
<td class="left">c:/users/jkitchin/Dropbox/kitchingroup/jmax/elpa/yasnippet-20140106.1009/snippets</td>
</tr>
</tbody>
</table>

<p>
Finally, we reload all the snippet definitions, so our new definitions are ready to use.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-reload-all)
</pre>
</div>

<pre class="example">
[yas] Reloaded everything (snippets will load just-in-time)... (some errors, check *Messages*).
</pre>

<p>
Alternatively, you might just load this directory.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-load-directory <span style="color: #228b22;">"./snippets"</span>)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Using the snippets</h2>
<div class="outline-text-2" id="text-2">
<p>
Each of these snippets is for a python phrase, but I usually write my python blocks in org-mode. You would use these by typing the shortcut name, and then pressing tab. Below I show what each shortcut expands to.
</p>

<p>
wjl &rarr; <code>with jasp('') as calc:</code>
</p>

<p>
wjn &rarr; <code>with jasp('',) as calc:</code>
    <code>calc.calculate(atoms)</code>
</p>

<p>
cc  &rarr; <code>calc.calculate(atoms)</code>
</p>

<p>
cga &rarr; <code>atoms = calc.get_atoms()</code>
</p>

<p>
atm &rarr; <code>Atom('', )</code>
</p>

<p>
atms &rarr; <code>atoms = Atoms([], cell</code>)=
</p>

<p>
ape &rarr; <code>atoms.get_potential_energy()</code>
</p>

<p>
agf &rarr; <code>atoms.get_forces()</code>
</p>

<p>
avw &rarr; <code>from ase.visualize import view</code>
<code>view(atoms)</code>
</p>

<p>
awt &rarr; <code>from ase.io import write</code>
<code>write('.png', atoms, show_unit_cell=2)</code>
</p>

<p>
npa &rarr; <code>np.array()</code>
</p>

<p>
pp &rarr; <code>plt.plot(, )</code>
</p>

<p>
pxl &rarr; <code>plt.xlabel()</code>
</p>

<p>
pyl &rarr; <code>plt.ylabel()</code>
</p>

<p>
pl &rarr; <code>plt.legend()</code>
</p>

<p>
ij &rarr; <code>from jasp import *</code>
</p>

<p>
inp &rarr; <code>import numpy as np</code>
</p>

<p>
imp &rarr; <code>import matplotlib.pyplot as plt</code>
</p>

<p>
iase &rarr; <code>from ase import Atom, Atoms</code>
</p>

<p>
What other snippets would be handy?
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Appendix</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> jasp snippets</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
with jasp('$1') as calc:
    $0
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
with jasp('$1',$0) as calc:
    calc.calculate(atoms)
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
calc.calculate(atoms)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
atoms = calc.get_atoms()
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> ase snippets</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Template for an ase.Atom
</p>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
Atom('$1', $2)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
atoms = Atoms([$1], cell=$2)
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
atoms.get_potential_energy()
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
atoms.get_forces()
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
from ase.visualize import view
view(${1:atoms})
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
from ase.io import write
write('$1.png', ${2:atoms}, show_unit_cell=${3:2})
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> python snippets</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
import numpy as np
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
import matplotlib.pyplot as plt
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
from ase import Atom, Atoms
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
np.array($0)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
plt.plot($1, $2)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
plt.xlabel($1)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
plt.ylabel($1)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
plt.legend($1)
</pre>
</div>


<div class="org-src-container">

<pre class="src src-snippet"># -*- mode: snippet -*-
# --
from jasp import *
</pre>
</div>
</div>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/02/17/yasnippets-for-jasp,-ase-and-python.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
    <item>
      <title>A dynamic snippet for a task due 7 days from now</title>
      <link>http://jkitchin.github.io/blog/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now</link>
      <pubDate>Sun, 16 Feb 2014 13:50:27 EST</pubDate>
      <category><![CDATA[org-mode]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">Tx9jFOYH5plEncsdx7wUpo9okjg=</guid>
      <description>A dynamic snippet for a task due 7 days from now</description>
      <content:encoded><![CDATA[



<p>
I have been playing with yasnippets. A pretty cool feature is that you can run elisp code in the template to generate text. Below, I define a snippet that will create a todo item due 7 days from the time you define it. This is an unconventional way to define a snippet, but I did not want to save it to a file just to try it out. So, I put it in a temporary buffer, and load it from there. When you run this block, it will note it is a new snippet, and ask if you want to save it. You can say no. 
</p>

<p>
We will use the code we developed <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/02/05/Add-time-to-a-deadline/">here</a> to create a timestamp from the
current time plus seven days.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-global-mode)
(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert <span style="color: #228b22;">"# name : todo-followup</span>
<span style="color: #228b22;"># --</span>

<span style="color: #228b22;">*************** TODO $1</span>
<span style="color: #228b22;">${2:             DEADLINE: `(let ((seven-days (seconds-to-time (* 7 24 60 60))))</span>
<span style="color: #228b22;">  (format-time-string \"&lt;%Y-%m-%d %a&gt;\" (time-add (current-time) seven-days)))`}$0</span>
<span style="color: #228b22;">*************** END </span>
<span style="color: #228b22;">"</span>)
  (yas-load-snippet-buffer-and-close 'org-mode))
</pre>
</div>

<p>
Now, you will have a new entry in the YASnippet menu that is called todo-followup. If you put the cursor on a blank line, and select that entry you get this below (after you fill in the text for the headline, of course!):
</p>

<pre class="example">
*************** TODO see how many times this was viewed
		DEADLINE: &lt;2014-02-23 Sun&gt;
*************** END
</pre>



<p>
That is pretty nice, as it saves a lot of keystrokes for that
particular kind of task. Let us up the ante, and see if we can make it
interactive so you can enter the number of days from now the task is
due.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-global-mode)
(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert <span style="color: #228b22;">"# name : todo-followup</span>
<span style="color: #228b22;"># --</span>

<span style="color: #228b22;">*************** TODO $1</span>
<span style="color: #228b22;">${2:             DEADLINE: `(let ((ndays (seconds-to-time (* (string-to-int (read-from-minibuffer \"Days until due: \")) 24 60 60))))</span>
<span style="color: #228b22;">  (format-time-string \"&lt;%Y-%m-%d %a&gt;\" (time-add (current-time) ndays)))`}$0</span>
<span style="color: #228b22;">*************** END </span>
<span style="color: #228b22;">"</span>)
  (yas-load-snippet-buffer-and-close 'org-mode))
</pre>
</div>

<pre class="example">
*************** TODO sweet!
		DEADLINE: &lt;2014-02-26 Wed&gt;
*************** END
</pre>
<p>
Well, that made it just a bit sweeter! I was prompted for the "Days
until due:", entered 10 days, and a date 10 days from now was
automatically entered!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/02/16/A-dynamic-snippet-for-a-task-due-7-days-from-now.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content:encoded>
    </item>
  </channel>
</rss>
