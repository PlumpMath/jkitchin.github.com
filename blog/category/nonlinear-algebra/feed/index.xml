<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Mon, 15 Feb 2016 01:15:34 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Coupled nonlinear equations</title>
      <link>http://jkitchin.github.io/blog/2013/09/02/Coupled-nonlinear-equations</link>
      <pubDate>Mon, 02 Sep 2013 15:21:24 EDT</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">Oumw3EcR3iH2rik3sHzqmqgXhc8=</guid>
      <description>Coupled nonlinear equations</description>
      <content:encoded><![CDATA[


<p>
Suppose we seek the solution to this set of equations:
</p>

\begin{align}
y &=& x^2 \\
y &=& 8 - x^2
\end{align}

<p>
To solve this we need to setup a function that is equal to zero at the solution. We have two equations, so our function must return two values. There are two variables, so the argument to our function will be an array of values. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(X):
    <span style="color: #8b008b;">x</span>, <span style="color: #8b008b;">y</span> = X            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">unpack the array in the argument</span>
    <span style="color: #8b008b;">z1</span> = y - x**2       <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">first equation</span>
    <span style="color: #8b008b;">z2</span> = y - 8 + x**2   <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">second equation</span>
    <span style="color: #8b0000;">return</span> [z1, z2]     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">list of zeros</span>

<span style="color: #8b008b;">x0</span>, <span style="color: #8b008b;">y0</span> = 1, 1           <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guesses</span>
<span style="color: #8b008b;">guess</span> = [x0, y0]
<span style="color: #8b008b;">sol</span> = fsolve(objective, guess)
<span style="color: #8b0000;">print</span> sol

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">of course there may be more than one solution</span>
<span style="color: #8b008b;">x0</span>, <span style="color: #8b008b;">y0</span> = -1, -1           <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guesses</span>
<span style="color: #8b008b;">guess</span> = [x0, y0]
<span style="color: #8b008b;">sol</span> = fsolve(objective, guess)
<span style="color: #8b0000;">print</span> sol
</pre>
</div>

<pre class="example">
[ 2.  4.]
[-2.  4.]
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/09/02/Coupled-nonlinear-equations.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Finding the nth root of a periodic function</title>
      <link>http://jkitchin.github.io/blog/2013/03/05/Finding-the-nth-root-of-a-periodic-function</link>
      <pubDate>Tue, 05 Mar 2013 14:06:04 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">TjQQYRtTLiik-QWmqbwfFnxpj5M=</guid>
      <description>Finding the nth root of a periodic function</description>
      <content:encoded><![CDATA[



<p>
There is a heat transfer problem where one needs to find the n^th root of the following equation: \(x J_1(x) - Bi J_0(x)=0\) where \(J_0\) and \(J_1\) are the Bessel functions of zero and first order, and \(Bi\) is the Biot number. We examine an approach to finding these roots. 
</p>

<p>
First,  we plot the function.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

X = np.linspace(0, 30, 200)
plt.plot(X, f(X))
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/heat-transfer-roots-1.png"><p>

<p>
You can see there are many roots to this equation, and we want to be sure we get the n^{th} root. This function is pretty well behaved, so if you make a good guess about the solution you will get an answer, but if you make a bad guess, you may get the wrong root. We examine next a way to do it without guessing the solution. What we want is the solution to \(f(x) = 0\), but we want all the solutions in a given interval. We derive a new equation, \(f'(x) = 0\), with initial condition \(f(0) = f0\), and integrate the ODE with an event function that identifies all zeros of \(f\) for us. The derivative of our function is \(df/dx = d/dx(x J_1(x)) - Bi J'_0(x)\). It is known (<a href="http://www.markrobrien.com/besselfunct.pdf" >http://www.markrobrien.com/besselfunct.pdf</a>) that \(d/dx(x J_1(x)) = x J_0(x)\), and \(J'_0(x) = -J_1(x)\). All we have to do now is set up the problem and run it.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> *  <span style="color: #ff0000; font-weight: bold;"># contains the ode integrator with events</span>

<span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #228b22;">"function we want roots for"</span>
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fprime</span>(f, x):
    <span style="color: #228b22;">"df/dx"</span>
    <span style="color: #8b0000;">return</span> x * jn(0, x) - Bi * (-jn(1, x))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">e1</span>(f, x):
    <span style="color: #228b22;">"event function to find zeros of f"</span>
    isterminal = <span style="color: #8b0000;">False</span>
    value = f
    direction = 0
    <span style="color: #8b0000;">return</span> value, isterminal, direction

f0 = f(0)
xspan = np.linspace(0, 30, 200)

x, fsol, XE, FE, IE = odelay(fprime, f0, xspan, events=[e1])

plt.plot(x, fsol, <span style="color: #228b22;">'.-'</span>, label=<span style="color: #228b22;">'Numerical solution'</span>)
plt.plot(xspan, f(xspan), <span style="color: #228b22;">'--'</span>, label=<span style="color: #228b22;">'Analytical function'</span>)
plt.plot(XE, FE, <span style="color: #228b22;">'ro'</span>, label=<span style="color: #228b22;">'roots'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-2.png'</span>)

<span style="color: #8b0000;">for</span> i, root <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(XE):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'root {0} is at {1}'</span>.format(i, root)

plt.show()
</pre>
</div>

<pre class="example">
root 0 is at 1.25578377377
root 1 is at 4.07947743741
root 2 is at 7.15579904465
root 3 is at 10.2709851256
root 4 is at 13.3983973869
root 5 is at 16.5311587137
root 6 is at 19.6667276775
root 7 is at 22.8039503455
root 8 is at 25.9422288192
root 9 is at 29.081221492
</pre>

<p><img src="/img/./images/heat-transfer-roots-2.png"><p>

<p>
You can work this out once, and then you have all the roots in the interval and you can select the one you want.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/05/Finding-the-nth-root-of-a-periodic-function.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Method of continuity for solving nonlinear equations - Part II</title>
      <link>http://jkitchin.github.io/blog/2013/03/01/Method-of-continuity-for-solving-nonlinear-equations-Part-II</link>
      <pubDate>Fri, 01 Mar 2013 18:17:16 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">4_-S1D6ejDJUeABaeRUHhVajP_M=</guid>
      <description>Method of continuity for solving nonlinear equations - Part II</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/02/method-of-continuity-for-solving-nonlinear-equations-part-ii-2/" >Matlab post</a>
Yesterday in Post 1324 we looked at a way to solve nonlinear equations that takes away some of the burden of initial guess generation. The idea was to reformulate the equations with a new variable \(\lambda\), so that at \(\lambda=0\) we have a simpler problem we know how to solve, and at \(\lambda=1\) we have the original set of equations. Then, we derive a set of ODEs on how the solution changes with \(\lambda\), and solve them.
</p>

<p>
Today we look at a simpler example and explain a little more about what is going on. Consider the equation: \(f(x) = x^2 - 5x + 6 = 0\), which has two roots, \(x=2\) and \(x=3\). We will use the method of continuity to solve this equation to illustrate a few ideas. First, we introduce a new variable \(\lambda\) as: \(f(x; \lambda) = 0\). For example, we could write \(f(x;\lambda) = \lambda x^2 - 5x + 6 = 0\). Now, when \(\lambda=0\), we hve the simpler equation \(- 5x + 6 = 0\), with the solution \(x=6/5\). The question now is, how does \(x\) change as \(\lambda\) changes? We get that from the total derivative of how \(f(x,\lambda)\) changes with \(\lambda\). The total derivative is:
</p>

<p>
$$\frac{df}{d\lambda} = \frac{\partial f}{\partial \lambda} + \frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}=0$$
</p>

<p>
We can calculate two of those quantities: \(\frac{\partial f}{\partial \lambda}\) and \(\frac{\partial f}{\partial x}\) analytically from our equation and solve for \(\frac{\partial x}{\partial \lambda}\) as
</p>

<p>
$$ \frac{\partial x}{\partial \lambda} = -\frac{\partial f}{\partial \lambda}/\frac{\partial f}{\partial x}$$
</p>

<p>
That defines an ordinary differential equation that we can solve by integrating from \(\lambda=0\) where we know the solution to \(\lambda=1\) which is the solution to the real problem. For this problem: \(\frac{\partial f}{\partial \lambda}=x^2\) and \(\frac{\partial f}{\partial x}=-5 + 2\lambda x\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dxdL</span>(x, Lambda):
    <span style="color: #8b0000;">return</span> -x**2 / (-5.0 + 2 * Lambda * x)

x0 = 6.0/5.0
Lspan = np.linspace(0, 1)
x = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #228b22;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #228b22;">'x'</span>)
plt.savefig(<span style="color: #228b22;">'images/nonlin-contin-II-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/nonlin-contin-II-1.png"><p>

<p>
We found one solution at x=2. What about the other solution? To get that we have to introduce \(\lambda\) into the equations in another way. We could try: \(f(x;\lambda) = x^2 + \lambda(-5x + 6)\), but this leads to an ODE that is singular at the initial starting point. Another approach is \(f(x;\lambda) = x^2 + 6 + \lambda(-5x)\), but now the solution at \(\lambda=0\) is imaginary, and we do not have a way to integrate that! What we can do instead is add and subtract a number like this: \(f(x;\lambda) = x^2 - 4 + \lambda(-5x + 6 + 4)\). Now at \(\lambda=0\), we have a simple equation with roots at \(\pm 2\), and we already know that \(x=2\) is a solution. So, we create our ODE on \(dx/d\lambda\) with initial condition \(x(0) = -2\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dxdL</span>(x, Lambda):
    <span style="color: #8b0000;">return</span> (5 * x - 10) / (2 * x - 5 * Lambda)

x0 = -2
Lspan = np.linspace(0, 1)
x = odeint(dxdL, x0, Lspan)

plt.plot(Lspan, x)
plt.xlabel(<span style="color: #228b22;">'$\lambda$'</span>)
plt.ylabel(<span style="color: #228b22;">'x'</span>)
plt.savefig(<span style="color: #228b22;">'images/nonlin-contin-II-2.png'</span>)
</pre>
</div>

<p><img src="/img/./images/nonlin-contin-II-2.png"><p>

<p>
Now we have the other solution. Note if you choose the other root, \(x=2\), you find that 2 is a root, and learn nothing new. You could choose other values to add, e.g., if you chose to add and subtract 16, then you would find that one starting point leads to one root, and the other starting point leads to the other root. This method does not solve all problems associated with nonlinear root solving, namely, how many roots are there, and which one is &ldquo;best&rdquo; or physically reasonable? But it does give a way to solve an equation where you have no idea what an initial guess should be. You can see, however, that just like you can get different answers from different initial guesses, here you can get different answers by setting up the equations differently.</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/01/Method-of-continuity-for-solving-nonlinear-equations---Part-II.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Finding equilibrium conversion</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Finding-equilibrium-conversion</link>
      <pubDate>Wed, 27 Feb 2013 10:48:49 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">7OZbOjq6F2CU8OgxePmWoJ-0njU=</guid>
      <description>Finding equilibrium conversion</description>
      <content:encoded><![CDATA[



<p>
A common problem to solve in reaction engineering is finding the equilibrium conversion.<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> A typical problem to solve is the following nonlinear equation:
</p>

<p>
\(1.44 = \frac{X_e^2}{(1-X_e)^2}\)
</p>

<p>
To solve this we create a function:
</p>

<p>
\(f(X_e)=0=1.44 - \frac{X_e^2}{(1-X_e)^2}\)
</p>

<p>
and use a nonlinear solver to find the value of \(X_e\) that makes this function equal to zero. We have to provide an initial guess. Chemical intuition suggests that the solution must be between 0 and 1, and mathematical intuition suggests the solution might be near 0.5 (which would give a ratio near 1).
</p>

<p>
Here is our solution.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Xe):
    z = 1.44 - (Xe**2)/(1-Xe)**2
    <span style="color: #8b0000;">return</span> z

X0 = 0.5
Xe, = fsolve(func, X0)
<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The equilibrium conversion is X = {0:1.2f}'</span>.format(Xe))
</pre>
</div>

<pre class="example">
The equilibrium conversion is X = 0.55
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Finding-equilibrium-conversion.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Counting roots</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Counting-roots</link>
      <pubDate>Wed, 27 Feb 2013 10:13:59 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">2u2JDmduFdGVKGPniycHK0-Dlwo=</guid>
      <description>Counting roots</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/10/counting-roots/" >Matlab post</a>
The goal here is to determine how many roots there are in a nonlinear function we are interested in solving. For this example, we use a cubic polynomial because we know there are three roots.
</p>

<p>
$$f(x) = x^3 + 6x^2 - 4x -24$$
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Use roots for this polynomial</h2>
<div class="outline-text-2" id="text-1">
<p>
This ony works for a polynomial, it does not work for any other nonlinear function.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">print</span> np.roots([1, 6, -4, -24])
</pre>
</div>

<pre class="example">
[-6.  2. -2.]
</pre>

<p>
Let us plot the function to see where the roots are.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

x = np.linspace(-8, 4)
y = x**3 + 6 * x**2 - 4*x - 24
plt.plot(x, y)
plt.savefig(<span style="color: #228b22;">'images/count-roots-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/count-roots-1.png"><p>

<p>
Now we consider several approaches to counting the number of roots in this interval. Visually it is pretty easy, you just look for where the function crosses zero. Computationally, it is tricker.
</p>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> method 1</h2>
<div class="outline-text-2" id="text-2">
<p>
Count the number of times the sign changes in the interval. What we have to do is multiply neighboring elements together, and look for negative values. That indicates a sign change. For example the product of two positive or negative numbers is a positive number. You only get a negative number from the product of a positive and negative number, which means the sign changed.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

x = np.linspace(-8, 4)
y = x**3 + 6 * x**2 - 4*x - 24

<span style="color: #8b0000;">print</span> np.sum(y[0:-2] * y[1:-1] &lt; 0)
</pre>
</div>

<pre class="example">
3
</pre>

<p>
This method gives us the number of roots, but not where the roots are. 
</p>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Method 2</h2>
<div class="outline-text-2" id="text-3">
<p>
Using events in an ODE solver python can identify events in the solution to an ODE, for example, when a function has a certain value, e.g. f(x) = 0. We can take advantage of this to find the roots and number of roots in this case. We take the derivative of our function, and integrate it from an initial starting point, and define an event function that counts zeros.
</p>

<p>
$$f'(x) = 3x^2 + 12x - 4$$
</p>

<p>
with f(-8) = -120
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> odelay

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fprime</span>(f, x):
    <span style="color: #8b0000;">return</span> 3.0 * x**2 + 12.0*x - 4.0

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">event</span>(f, x):
    value = f <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we want f = 0</span>
    isterminal = <span style="color: #8b0000;">False</span>
    direction = 0
    <span style="color: #8b0000;">return</span> value, isterminal, direction

xspan = np.linspace(-8, 4)
f0 = -120

X, F, TE, YE, IE = odelay(fprime, f0, xspan, events=[event])
<span style="color: #8b0000;">for</span> te, ye <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(TE, YE):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'root found at x = {0: 1.3f}, f={1: 1.3f}'</span>.format(te, ye)
</pre>
</div>

<pre class="example">
root found at x = -6.000, f=-0.000
root found at x = -2.000, f=-0.000
root found at x =  2.000, f= 0.000
</pre>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Counting-roots.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Method of continuity for nonlinear equation solving</title>
      <link>http://jkitchin.github.io/blog/2013/02/22/Method-of-continuity-for-nonlinear-equation-solving</link>
      <pubDate>Fri, 22 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">ByVVx4yMiOd9-aKU5QugcG9fGbk=</guid>
      <description>Method of continuity for nonlinear equation solving</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/11/01/method-of-continuity-for-nonlinear-equation-solving/" >Matlab post</a>

Adapted from Perry's Chemical Engineers Handbook, 6th edition 2-63.
</p>

<p>
We seek the solution to the following nonlinear equations:
</p>

<p>
\(2 + x + y - x^2 + 8 x y + y^3 = 0\)
</p>

<p>
\(1 + 2x - 3y + x^2 + xy - y e^x = 0\)
</p>

<p>
In principle this is easy, we simply need some initial guesses and a nonlinear solver. The challenge here is what would you guess? There could be many solutions. The equations are implicit, so it is not easy to graph them, but let us give it a shot, starting on the x range -5 to 5. The idea is set a value for x, and then solve for y in each equation.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x, y):
    <span style="color: #8b0000;">return</span> 2 + x + y - x**2 + 8*x*y + y**3;

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">g</span>(x, y):
    <span style="color: #8b0000;">return</span> 1 + 2*x - 3*y + x**2 + x*y - y*np.exp(x)

x = np.linspace(-5, 5, 500)

<span style="color: #8b0000;">@np</span>.vectorize
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fy</span>(x):
    x0 = 0.0
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">tmp</span>(y):
        <span style="color: #8b0000;">return</span> f(x, y)
    y1, = fsolve(tmp, x0)
    <span style="color: #8b0000;">return</span> y1

<span style="color: #8b0000;">@np</span>.vectorize
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">gy</span>(x):
    x0 = 0.0
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">tmp</span>(y):
        <span style="color: #8b0000;">return</span> g(x, y)
    y1, = fsolve(tmp, x0)
    <span style="color: #8b0000;">return</span> y1


plt.plot(x, fy(x), x, gy(x))
plt.xlabel(<span style="color: #228b22;">'x'</span>)
plt.ylabel(<span style="color: #228b22;">'y'</span>)
plt.legend([<span style="color: #228b22;">'fy'</span>, <span style="color: #228b22;">'gy'</span>])
plt.savefig(<span style="color: #228b22;">'images/continuation-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... ... ... ... &gt;&gt;&gt; ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; /opt/kitchingroup/enthought/epd-7.3-2-rh5-x86_64/lib/python2.7/site-packages/scipy/optimize/minpack.py:152: RuntimeWarning: The iteration is not making good progress, as measured by the 
  improvement from the last ten iterations.
  warnings.warn(msg, RuntimeWarning)
/opt/kitchingroup/enthought/epd-7.3-2-rh5-x86_64/lib/python2.7/site-packages/scipy/optimize/minpack.py:152: RuntimeWarning: The iteration is not making good progress, as measured by the 
  improvement from the last five Jacobian evaluations.
  warnings.warn(msg, RuntimeWarning)
[&lt;matplotlib.lines.Line2D object at 0x1a0c4990&gt;, &lt;matplotlib.lines.Line2D object at 0x1a0c4a90&gt;]
&lt;matplotlib.text.Text object at 0x19d5e390&gt;
&lt;matplotlib.text.Text object at 0x19d61d90&gt;
&lt;matplotlib.legend.Legend object at 0x189df850&gt;
</pre>

<p><img src="/img/./images/continuation-1.png"><p>

<p>
You can see there is a solution near x = -1, y = 0, because both functions equal zero there. We can even use that guess with fsolve. It is disappointly easy! But, keep in mind that in 3 or more dimensions, you cannot perform this visualization, and another method could be required.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(X):
    x,y = X
    <span style="color: #8b0000;">return</span> [f(x, y), g(x, y)]

<span style="color: #8b0000;">print</span> fsolve(func, [-2, -2])
</pre>
</div>

<pre class="example">
... ... &gt;&gt;&gt; [ -1.00000000e+00   1.28730858e-15]
</pre>


<p>
We explore a method that bypasses this problem today. The principle is to introduce a new variable, \(\lambda\), which will vary from 0 to 1. at \(\lambda=0\) we will have a simpler equation, preferrably a linear one, which can be easily solved, or which can be analytically solved. At \(\lambda=1\), we have the original equations. Then, we create a system of differential equations that start at the easy solution, and integrate from \(\lambda=0\) to \(\lambda=1\), to recover the final solution.
</p>

<p>
We rewrite the equations as:
</p>

<p>
\(f(x,y) = (2 + x + y) + \lambda(- x^2 + 8 x y + y^3) = 0\)
</p>

<p>
\(g(x,y) = (1 + 2x - 3y) + \lambda(x^2 + xy - y e^x) = 0\)
</p>

<p>
Now, at \(\lambda=0\) we have the simple linear equations:
</p>

<p>
\(x + y = -2\)
</p>

<p>
\(2x - 3y = -1\)
</p>

<p>
These equations are trivial to solve:
</p>

<div class="org-src-container">

<pre class="src src-python">x0 = np.linalg.solve([[1., 1.], [2., -3.]],[ -2, -1])
<span style="color: #8b0000;">print</span> x0
</pre>
</div>

<pre class="example">
[-1.4 -0.6]
</pre>

<p>
We form the system of ODEs by differentiating the new equations with respect to \(\lambda\). Why do we do that? The solution, (x,y) will be a function of \(\lambda\). From calculus, you can show that:
</p>

<p>
\(\frac{\partial f}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial f}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial f}{\partial \lambda}\)
</p>

<p>
\(\frac{\partial g}{\partial x}\frac{\partial x}{\partial \lambda}+\frac{\partial g}{\partial y}\frac{\partial y}{\partial \lambda}=-\frac{\partial g}{\partial \lambda}\)
</p>

<p>
Now, solve this for \(\frac{\partial x}{\partial \lambda}\) and \(\frac{\partial y}{\partial \lambda}\). You can use Cramer's rule to solve for these to yield:
</p>

\begin{eqnarray} \
\frac{\partial x}{\partial \lambda} &=& \frac{\partial f/\partial y \partial g/\partial \lambda - \partial f/\partial \lambda \partial g/\partial y}{\partial f/\partial x \partial g/\partial y - \partial f/\partial y \partial g/\partial x } \\\\
\frac{\partial y}{\partial \lambda} &=& \frac{\partial f/\partial \lambda \partial g/\partial x - \partial f/\partial x \partial g/\partial \lambda}{\partial f/\partial x \partial g/\partial y - \partial f/\partial y \partial g/\partial x } \end{eqnarray} 

For this set of equations: 

\begin{eqnarray} \
\partial f/\partial x &=& 1 - 2\lambda x + 8\lambda y \\\\ 
\partial f/\partial y &=& 1 + 8 \lambda x + 3 \lambda y^2 \\\\
\partial g/\partial x &=& 2 + 2 \lambda x + \lambda y - \lambda y e^x\\\\ 
\partial g/\partial y &=& -3 + \lambda x - \lambda e^x 
\end{eqnarray} 

<p>
Now, we simply set up those two differential equations on \(\frac{\partial x}{\partial \lambda}\) and \(\frac{\partial y}{\partial \lambda}\), with the initial conditions at \(\lambda = 0\) which is the solution of the simpler linear equations, and integrate to \(\lambda = 1\), which is the final solution of the original equations!
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ode</span>(X, LAMBDA):
    x,y = X
    pfpx = 1.0 - 2.0 * LAMBDA * x + 8 * LAMBDA * y
    pfpy = 1.0 + 8.0 * LAMBDA * x + 3.0 * LAMBDA * y**2
    pfpLAMBDA = -x**2 + 8.0 * x * y + y**3;
    pgpx = 2. + 2. * LAMBDA * x + LAMBDA * y - LAMBDA * y * np.exp(x)
    pgpy = -3. + LAMBDA * x - LAMBDA * np.exp(x)
    pgpLAMBDA = x**2 + x * y - y * np.exp(x);
    dxdLAMBDA = (pfpy * pgpLAMBDA - pfpLAMBDA * pgpy) / (pfpx * pgpy - pfpy * pgpx)
    dydLAMBDA = (pfpLAMBDA * pgpx - pfpx * pgpLAMBDA) / (pfpx * pgpy - pfpy * pgpx) 
    dXdLAMBDA = [dxdLAMBDA, dydLAMBDA]
    <span style="color: #8b0000;">return</span> dXdLAMBDA


<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint

lambda_span = np.linspace(0, 1, 100)

X = odeint(ode, x0, lambda_span)

xsol, ysol = X[-1]
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The solution is at x={0:1.3f}, y={1:1.3f}'</span>.format(xsol, ysol)
<span style="color: #8b0000;">print</span> f(xsol, ysol), g(xsol, ysol)
</pre>
</div>

<pre class="example">
... ... ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; The solution is at x=-1.000, y=0.000
-1.27746598808e-06 -1.15873819107e-06
</pre>

<p>
You can see the solution is somewhat approximate; the true solution is x = -1, y = 0. The approximation could be improved by lowering the tolerance on the ODE solver. The functions evaluate to a small number, close to zero. You have to apply some judgment to determine if that is sufficiently accurate. For instance if the units on that answer are kilometers, but you need an answer accurate to a millimeter, this may not be accurate enough.
</p>

<p>
This is a fair amount of work to get a solution! The idea is to solve a simple problem, and then gradually turn on the hard part by the lambda parameter. What happens if there are multiple solutions? The answer you finally get will depend on your \(\lambda=0\)  starting point, so it is possible to miss solutions this way. For problems with lots of variables, this would be a good approach if you can identify the easy problem.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/22/Method-of-continuity-for-nonlinear-equation-solving.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Calculating a bubble point pressure of a mixture</title>
      <link>http://jkitchin.github.io/blog/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture</link>
      <pubDate>Mon, 18 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">pRZlFP3yQwJs7jwDKG2E5hSQrsU=</guid>
      <description>Calculating a bubble point pressure of a mixture</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/15/calculating-a-bubble-point-pressure/" >Matlab post</a>
</p>

<p>
Adapted from <a href="http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm" >http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm</a> (dead link)
</p>

<p>
We previously learned to read a datafile containing lots of Antoine coefficients into a database, and use the coefficients to estimate vapor pressure of a single compound. Here we use those coefficents to compute a bubble point pressure of a mixture. 
</p>

<p>
The bubble point is the temperature at which the sum of the component vapor pressures is equal to the the total pressure. This is where a bubble of vapor will first start forming, and the mixture starts to boil.
</p>

<p>
Consider an equimolar mixture of benzene, toluene, chloroform, acetone and methanol. Compute the bubble point at 760 mmHg, and the gas phase composition. The gas phase composition is given by: \(y_i = x_i*P_i/P_T\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #ff0000; font-weight: bold;"># load our thermodynamic data</span>
data = np.loadtxt(<span style="color: #228b22;">'data/antoine_data.dat'</span>,
                  dtype=[(<span style="color: #228b22;">'id'</span>, np.int),
                         (<span style="color: #228b22;">'formula'</span>, <span style="color: #228b22;">'S8'</span>),
                         (<span style="color: #228b22;">'name'</span>, <span style="color: #228b22;">'S28'</span>),
                         (<span style="color: #228b22;">'A'</span>, np.float),
                         (<span style="color: #228b22;">'B'</span>, np.float),
                         (<span style="color: #228b22;">'C'</span>, np.float),
                         (<span style="color: #228b22;">'Tmin'</span>, np.float),
                         (<span style="color: #228b22;">'Tmax'</span>, np.float),
                         (<span style="color: #228b22;">'??'</span>, <span style="color: #228b22;">'S4'</span>),
                         (<span style="color: #228b22;">'?'</span>, <span style="color: #228b22;">'S4'</span>)],
                  skiprows=7)

compounds = [<span style="color: #228b22;">'benzene'</span>, <span style="color: #228b22;">'toluene'</span>, <span style="color: #228b22;">'chloroform'</span>, <span style="color: #228b22;">'acetone'</span>, <span style="color: #228b22;">'methanol'</span>]

<span style="color: #ff0000; font-weight: bold;"># extract the data we want</span>
A = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'A'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
B = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'B'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
C = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'C'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
Tmin = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'Tmin'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
Tmax = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'Tmax'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])


<span style="color: #ff0000; font-weight: bold;"># we have an equimolar mixture</span>
x = np.array([0.2, 0.2, 0.2, 0.2, 0.2])

<span style="color: #ff0000; font-weight: bold;"># Given a T, we can compute the pressure of each species like this:</span>

T = 67 <span style="color: #ff0000; font-weight: bold;"># degC</span>
P = 10**(A - B / (T + C))
<span style="color: #8b0000;">print</span> P
<span style="color: #8b0000;">print</span> np.dot(x, P)  <span style="color: #ff0000; font-weight: bold;"># total mole-fraction weighted pressure</span>

Tguess = 67
Ptotal = 760

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(T):
    P = 10**(A - B / (T + C))
    <span style="color: #8b0000;">return</span> Ptotal - np.dot(x, P)
    
Tbubble, = fsolve(func, Tguess)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The bubble point is {0:1.2f} degC'</span>.format(Tbubble)

<span style="color: #ff0000; font-weight: bold;"># double check answer is in a valid T range</span>
<span style="color: #8b0000;">if</span> np.any(Tbubble &lt; Tmin) <span style="color: #8b0000;">or</span> np.any(Tbubble &gt; Tmax):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'T_bubble is out of range!'</span>

<span style="color: #ff0000; font-weight: bold;"># print gas phase composition</span>
y = x * 10**(A - B / (Tbubble + C))/Ptotal

<span style="color: #8b0000;">for</span> cmpd, yi <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(compounds, y):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'y_{0:&lt;10s} = {1:1.3f}'</span>.format(cmpd, yi)
</pre>
</div>

<pre class="example">
[  498.4320267    182.16010994   898.31061294  1081.48181768   837.88860027]
699.654633507
The bubble point is 69.46 degC
y_benzene    = 0.142
y_toluene    = 0.053
y_chloroform = 0.255
y_acetone    = 0.308
y_methanol   = 0.242
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Solving CSTR design equations</title>
      <link>http://jkitchin.github.io/blog/2013/02/18/Solving-CSTR-design-equations</link>
      <pubDate>Mon, 18 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">BW3kShDPxaW0cPOTB-sgqJTkv8M=</guid>
      <description>Solving CSTR design equations</description>
      <content:encoded><![CDATA[



<p>
Given a continuously stirred tank reactor with a volume of 66,000 dm^3 where the reaction \(A \rightarrow B\) occurs, at a rate of \(-r_A = k C_A^2\) (\(k=3\) L/mol/h), with an entering molar flow of F_{A0} = 5 mol/h and a volumetric flowrate of 10 L/h, what is the exit concentration of A?
</p>

<p>
From a mole balance we know that at steady state \(0 = F_{A0} - F_A + V r_A\). That equation simply states the sum of the molar flow of A in in minus the molar flow of A out  plus the molar rate A is generated is equal to zero at steady state. This is directly the equation we need to solve. We need the following relationship:
</p>

<ol>
<li>\(F_A = v0 C_A\)
</li>
</ol>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

Fa0 = 5.0
v0 = 10.

V = 66000.0  <span style="color: #ff0000; font-weight: bold;"># reactor volume L^3</span>
k = 3.0      <span style="color: #ff0000; font-weight: bold;"># rate constant L/mol/h</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(Ca):
    <span style="color: #228b22;">"Mole balance for a CSTR. Solve this equation for func(Ca)=0"</span>
    Fa = v0 * Ca     <span style="color: #ff0000; font-weight: bold;"># exit molar flow of A</span>
    ra = -k * Ca**2  <span style="color: #ff0000; font-weight: bold;"># rate of reaction of A L/mol/h</span>
    <span style="color: #8b0000;">return</span> Fa0 - Fa + V * ra

<span style="color: #ff0000; font-weight: bold;"># CA guess that that 90 % is reacted away</span>
CA_guess = 0.1 * Fa0 / v0
CA_sol, = fsolve(func, CA_guess)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The exit concentration is {0} mol/L'</span>.format(CA_sol)
</pre>
</div>

<pre class="example">
The exit concentration is 0.005 mol/L
</pre>

<p>
It is a little confusing why it is necessary to put a comma after the CA_sol in the fsolve command. If you do not put it there, you get brackets around the answer.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Solving-CSTR-design-equations.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Computing a pipe diameter</title>
      <link>http://jkitchin.github.io/blog/2013/02/12/Computing-a-pipe-diameter</link>
      <pubDate>Tue, 12 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">MwL0NFhpVR7fMeQObtSTJCEFmBI=</guid>
      <description>Computing a pipe diameter</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/27/compute-pipe-diameter/" >Matlab post</a>
A heat exchanger must handle 2.5 L/s of water through a smooth pipe with length of 100 m. The pressure drop cannot exceed 103 kPa at 25 degC. Compute the minimum pipe diameter required for this application.
</p>

<p>
Adapted from problem 8.8 in Problem solving in chemical and Biochemical Engineering with Polymath, Excel, and Matlab. page 303.
</p>

<p>
We need to estimate the Fanning friction factor for these conditions so we can estimate the frictional losses that result in a pressure drop for a uniform, circular pipe. The frictional forces are given by \(F_f = 2f_F \frac{\Delta L v^2}{D}\), and the corresponding pressure drop is given by \(\Delta P = \rho F_f\). In these equations, \(\rho\) is the fluid density, \(v\) is the fluid velocity, \(D\) is the pipe diameter, and \(f_F\) is the Fanning friction factor. The average fluid velocity is given by \(v = \frac{q}{\pi D^2/4}\).
</p>

<p>
For laminar flow, we estimate \(f_F = 16/Re\), which is a linear equation, and for turbulent flow (\(Re > 2100\)) we have the implicit equation \(\frac{1}{\sqrt{f_F}}=4.0 \log(Re \sqrt{f_F})-0.4\). Of course, we define \(Re = \frac{D v\rho}{\mu}\) where \(\mu\) is the viscosity of the fluid.
</p>

<p>
It is known that \(\rho(T) = 46.048 + 9.418 T -0.0329 T^2 +4.882\times10^{-5}-2.895\times10^{-8}T^4\) and \(\mu = \exp\left({-10.547 + \frac{541.69}{T-144.53}}\right)\) where \(\rho\) is in kg/m^3 and \(\mu\) is in kg/(m*s).
</p>

<p>
The aim is to find \(D\) that solves: \(\Delta p = \rho 2 f_F \frac{\Delta L v^2}{D}\). This is a nonlinear equation in \(D\), since D affects the fluid velocity, the Re, and the Fanning friction factor. Here is the solution
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

T = 25 + 273.15
Q = 2.5e-3       <span style="color: #ff0000; font-weight: bold;"># m^3/s</span>
deltaP = 103000  <span style="color: #ff0000; font-weight: bold;"># Pa</span>
deltaL = 100     <span style="color: #ff0000; font-weight: bold;"># m</span>

<span style="color: #ff0000; font-weight: bold;">#Note these correlations expect dimensionless T, where the magnitude</span>
<span style="color: #ff0000; font-weight: bold;"># of T is in K</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">rho</span>(T):
    <span style="color: #8b0000;">return</span> 46.048 + 9.418 * T -0.0329 * T**2 +4.882e-5 * T**3 - 2.895e-8 * T**4

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">mu</span>(T):
    <span style="color: #8b0000;">return</span> np.exp(-10.547 + 541.69 / (T - 144.53))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fanning_friction_factor_</span>(Re):
    <span style="color: #8b0000;">if</span> Re &lt; 2100:
        <span style="color: #8b0000;">raise</span> <span style="color: #cd0000;">Exception</span>(<span style="color: #228b22;">'Flow is probably not turbulent, so this correlation is not appropriate.'</span>)
    <span style="color: #ff0000; font-weight: bold;"># solve the Nikuradse correlation to get the friction factor</span>
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fz</span>(f): <span style="color: #8b0000;">return</span> 1.0/np.sqrt(f) - (4.0*np.log10(Re*np.sqrt(f))-0.4)
    sol, = fsolve(fz, 0.01)
    <span style="color: #8b0000;">return</span> sol

fanning_friction_factor = np.vectorize(fanning_friction_factor_)

Re = np.linspace(2200, 9000)
f = fanning_friction_factor(Re)

plt.plot(Re, f)
plt.xlabel(<span style="color: #228b22;">'Re'</span>)
plt.ylabel(<span style="color: #228b22;">'fanning friction factor'</span>)
<span style="color: #ff0000; font-weight: bold;"># You can see why we use 0.01 as an initial guess for solving for the</span>
<span style="color: #ff0000; font-weight: bold;"># Fanning friction factor; it falls in the middle of ranges possible</span>
<span style="color: #ff0000; font-weight: bold;"># for these Re numbers.</span>
plt.savefig(<span style="color: #228b22;">'images/pipe-diameter-1.png'</span>)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(D):
    v = Q / (np.pi * D**2 / 4)
    Re = D * v * rho(T) / mu(T)

    fF = fanning_friction_factor(Re)

    <span style="color: #8b0000;">return</span> deltaP - 2 * fF * rho(T) * deltaL * v**2 / D
    
D, = fsolve(objective, 0.04)

<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The minimum pipe diameter is {0} m\n'</span>.format(D))
</pre>
</div>

<pre class="example">
The minimum pipe diameter is 0.0389653369531 m
</pre>
<p>
Any pipe diameter smaller than that value will result in a larger pressure drop at the same volumetric flow rate, or a smaller volumetric flowrate at the same pressure drop. Either way, it will not meet the design specification.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/12/Computing-a-pipe-diameter.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Water gas shift equilibria via the NIST Webbook</title>
      <link>http://jkitchin.github.io/blog/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook</link>
      <pubDate>Fri, 01 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">UNXZFGY95kClSkAbwA38je-lnT0=</guid>
      <description>Water gas shift equilibria via the NIST Webbook</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/12/water-gas-shift-equilibria-via-the-nist-webbook/" >Matlab post</a>
</p>

<p>
The <a href="http://webbook.nist.gov/chemistry/" >NIST webbook</a> provides parameterized models of the enthalpy, entropy and heat capacity of many molecules. In this example, we will examine how to use these to compute the equilibrium constant for the water gas shift reaction \(CO + H_2O \rightleftharpoons CO_2 + H_2\) in the temperature range of 500K to 1000K.
</p>

<p>
Parameters are provided for:
</p>

<p>
Cp = heat capacity (J/mol*K)
H = standard enthalpy (kJ/mol)
S = standard entropy (J/mol*K)
</p>

<p>
with models in the form: \(Cp^\circ = A + B*t + C*t^2 + D*t^3 + E/t^2\)
</p>

<p>
\(H^\circ - H^\circ_{298.15}= A*t + B*t^2/2 + C*t^3/3 + D*t^4/4 - E/t + F - H\)
</p>

<p>
\(S^\circ = A*ln(t) + B*t + C*t^2/2 + D*t^3/3 - E/(2*t^2) + G\)
</p>

<p>
where \(t=T/1000\), and \(T\) is the temperature in Kelvin. We can use this data to calculate equilibrium constants in the following manner. First, we have heats of formation at standard state for each compound; for elements, these are zero by definition, and for non-elements, they have values available from the NIST webbook. There are also values for the absolute entropy at standard state. Then, we have an expression for the change in enthalpy from standard state as defined above, as well as the absolute entropy. From these we can derive the reaction enthalpy, free energy and entropy at standard state, as well as at other temperatures.
</p>

<p>
We will examine the water gas shift enthalpy, free energy and equilibrium constant from 500K to 1000K, and finally compute the equilibrium composition of a gas feed containing 5 atm of CO and H_2 at 1000K.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

T = np.linspace(500,1000) <span style="color: #ff0000; font-weight: bold;"># degrees K</span>
t = T/1000;
</pre>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> hydrogen</h2>
<div class="outline-text-2" id="text-1">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C1333740&Units=SI&Mask=1#Thermo-Gas}
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># T = 298-1000K valid temperature range</span>
A =  33.066178
B = -11.363417
C =  11.432816
D = -2.772874
E = -0.158558
F = -9.980797
G =  172.707974
H =  0.0

Hf_29815_H2 = 0.0 <span style="color: #ff0000; font-weight: bold;"># kJ/mol</span>
S_29815_H2 = 130.68 <span style="color: #ff0000; font-weight: bold;"># J/mol/K</span>

dH_H2 = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
S_H2 = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> H_{2}O</h2>
<div class="outline-text-2" id="text-2">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=1#Thermo-Gas}
</p>

<p>
Note these parameters limit the temperature range we can examine, as these parameters are not valid below 500K. There is another set of parameters for lower temperatures, but we do not consider them here.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># 500-1700 K valid temperature range</span>
A =   30.09200
B =   6.832514
C =   6.793435
D =  -2.534480
E =   0.082139
F =  -250.8810
G =   223.3967
H =  -241.8264

Hf_29815_H2O = -241.83 <span style="color: #ff0000; font-weight: bold;">#this is Hf.</span>
S_29815_H2O = 188.84

dH_H2O = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
S_H2O = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> CO</h2>
<div class="outline-text-2" id="text-3">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C630080&Units=SI&Mask=1#Thermo-Gas}
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># 298. - 1300K valid temperature range</span>
A =   25.56759
B =   6.096130
C =   4.054656
D =  -2.671301
E =   0.131021
F =  -118.0089
G =   227.3665
H = -110.5271

Hf_29815_CO = -110.53 <span style="color: #ff0000; font-weight: bold;">#this is Hf kJ/mol.</span>
S_29815_CO = 197.66

dH_CO = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
S_CO = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> CO_{2}</h2>
<div class="outline-text-2" id="text-4">
<p>
\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C124389&Units=SI&Mask=1#Thermo-Gas}
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># 298. - 1200.K valid temperature range</span>
A =   24.99735
B =   55.18696
C =  -33.69137
D =   7.948387
E =  -0.136638
F =  -403.6075
G =   228.2431
H =  -393.5224

Hf_29815_CO2 = -393.51 <span style="color: #ff0000; font-weight: bold;"># this is Hf.</span>
S_29815_CO2 = 213.79

dH_CO2 = A*t + B*t**2/2 + C*t**3/3 + D*t**4/4 - E/t + F - H;
S_CO2 = (A*np.log(t) + B*t + C*t**2/2 + D*t**3/3 - E/(2*t**2) + G);
</pre>
</div>
</div>
</div>
<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Standard state heat of reaction</h2>
<div class="outline-text-2" id="text-5">
<p>
We compute the enthalpy and free energy of reaction at 298.15 K for the following reaction \(CO + H2O \rightleftharpoons H2 + CO2\).
</p>

<div class="org-src-container">

<pre class="src src-python">Hrxn_29815 = Hf_29815_CO2 + Hf_29815_H2 - Hf_29815_CO - Hf_29815_H2O;
Srxn_29815 = S_29815_CO2 + S_29815_H2 - S_29815_CO - S_29815_H2O;
Grxn_29815 = Hrxn_29815 - 298.15*(Srxn_29815)/1000;

<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'deltaH = {0:1.2f}'</span>.format(Hrxn_29815))
<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'deltaG = {0:1.2f}'</span>.format(Grxn_29815))
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; deltaH = -41.15
deltaG = -28.62
</pre>
</div>
</div>
<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Non-standard state \(\Delta H\) and \(\Delta G\)</h2>
<div class="outline-text-2" id="text-6">
<p>
We have to correct for temperature change away from standard state. We only correct the enthalpy for this temperature change. The correction looks like this:
</p>

<p>
$$ \Delta H_{rxn}(T) = \Delta H_{rxn}(T_{ref}) + \sum_i \nu_i (H_i(T)-H_i(T_{ref}))$$
</p>

<p>
Where \(\nu_i\) are the stoichiometric coefficients of each species, with appropriate sign for reactants and products, and \((H_i(T)-H_i(T_{ref})\) is precisely what is calculated for each species with the equations
</p>

<p>
The entropy is on an absolute scale, so we directly calculate entropy at each temperature. Recall that H is in kJ/mol and S is in J/mol/K, so we divide S by 1000 to make the units match.
</p>
<div class="org-src-container">

<pre class="src src-python">Hrxn = Hrxn_29815 + dH_CO2 + dH_H2 - dH_CO - dH_H2O
Grxn = Hrxn - T*(S_CO2 + S_H2 - S_CO - S_H2O)/1000
</pre>
</div>
</div>
</div>
<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Plot how the \(\Delta G\) varies with temperature</h2>
<div class="outline-text-2" id="text-7">
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.figure(); plt.clf()
plt.plot(T,Grxn, label=<span style="color: #228b22;">'$\Delta G_{rxn}$'</span>)
plt.plot(T,Hrxn, label=<span style="color: #228b22;">'$\Delta H_{rxn}$'</span>)
plt.xlabel(<span style="color: #228b22;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #228b22;">'(kJ/mol)'</span>)
plt.legend( loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/wgs-nist-1.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x04199CF0&gt;
[&lt;matplotlib.lines.Line2D object at 0x0429BF30&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0427DFB0&gt;]
&lt;matplotlib.text.Text object at 0x041B79F0&gt;
&lt;matplotlib.text.Text object at 0x040CEF70&gt;
&lt;matplotlib.legend.Legend object at 0x043CB5F0&gt;
</pre>

<p><img src="/img/./images/wgs-nist-1.png"><p>

<p>
Over this temperature range the reaction is exothermic, although near 1000K it is just barely exothermic. At higher temperatures we expect the reaction to become endothermic.
</p>
</div>
</div>
<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Equilibrium constant calculation</h2>
<div class="outline-text-2" id="text-8">
<p>
Note the equilibrium constant starts out high, i.e. strongly favoring the formation of products, but drops very quicky with increasing temperature.
</p>

<div class="org-src-container">

<pre class="src src-python">R = 8.314e-3 <span style="color: #ff0000; font-weight: bold;"># kJ/mol/K</span>
K = np.exp(-Grxn/R/T);

plt.figure()
plt.plot(T,K)
plt.xlim([500, 1000])
plt.xlabel(<span style="color: #228b22;">'Temperature (K)'</span>)
plt.ylabel(<span style="color: #228b22;">'Equilibrium constant'</span>)
plt.savefig(<span style="color: #228b22;">'images/wgs-nist-2.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x044DBE90&gt;
[&lt;matplotlib.lines.Line2D object at 0x045A53F0&gt;]
(500, 1000)
&lt;matplotlib.text.Text object at 0x04577470&gt;
&lt;matplotlib.text.Text object at 0x0457F410&gt;
</pre>

<p><img src="/img/./images/wgs-nist-2.png"><p>
</div>
</div>
<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Equilibrium yield of WGS</h2>
<div class="outline-text-2" id="text-9">
<p>
Now let us suppose we have a reactor with a feed of H_2O and CO at 10atm at 1000K. What is the equilibrium yield of H_2? Let \(\epsilon\) be the extent of reaction, so that \(F_i = F_{i,0} + \nu_i \epsilon\). For reactants, \(\nu_i\) is negative, and for products, \(\nu_i\) is positive. We have to solve for the extent of reaction that satisfies the equilibrium condition.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.interpolate <span style="color: #8b0000;">import</span> interp1d
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #ff0000; font-weight: bold;"># </span>
<span style="color: #ff0000; font-weight: bold;"># A = CO</span>
<span style="color: #ff0000; font-weight: bold;"># B = H2O</span>
<span style="color: #ff0000; font-weight: bold;"># C = H2</span>
<span style="color: #ff0000; font-weight: bold;"># D = CO2</span>

Pa0 = 5; Pb0 = 5; Pc0 = 0; Pd0 = 0;  <span style="color: #ff0000; font-weight: bold;"># pressure in atm</span>
R = 0.082;
Temperature = 1000;

<span style="color: #ff0000; font-weight: bold;"># we can estimate the equilibrium like this. We could also calculate it</span>
<span style="color: #ff0000; font-weight: bold;"># using the equations above, but we would have to evaluate each term. Above</span>
<span style="color: #ff0000; font-weight: bold;"># we simply computed a vector of enthalpies, entropies, etc... Here we interpolate</span>
K_func = interp1d(T,K);
K_Temperature = K_func(1000)


<span style="color: #ff0000; font-weight: bold;"># If we let X be fractional conversion then we have $C_A = C_{A0}(1-X)$,</span>
<span style="color: #ff0000; font-weight: bold;"># $C_B = C_{B0}-C_{A0}X$, $C_C = C_{C0}+C_{A0}X$, and $C_D =</span>
<span style="color: #ff0000; font-weight: bold;"># C_{D0}+C_{A0}X$. We also have $K(T) = (C_C C_D)/(C_A C_B)$, which finally</span>
<span style="color: #ff0000; font-weight: bold;"># reduces to $0 = K(T) - Xeq^2/(1-Xeq)^2$ under these conditions.</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(X):
    <span style="color: #8b0000;">return</span> K_Temperature - X**2/(1-X)**2;

x0 = 0.5
Xeq, = fsolve(f, x0)

<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The equilibrium conversion for these feed conditions is: {0:1.2f}'</span>.format(Xeq))
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... &gt;&gt;&gt; ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.54504291144
The equilibrium conversion for these feed conditions is: 0.55
</pre>
</div>
</div>
<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> Compute gas phase pressures of each species</h2>
<div class="outline-text-2" id="text-10">
<p>
Since there is no change in moles for this reaction, we can directly calculation the pressures from the equilibrium conversion and the initial pressure of gases. you can see there is a slightly higher pressure of H_2 and CO_2 than the reactants, consistent with the equilibrium constant of about 1.44 at 1000K. At a lower temperature there would be a much higher yield of the products. For example, at 550K the equilibrium constant is about 58, and the pressure of H_2 is 4.4 atm due to a much higher equilibrium conversion of 0.88.
</p>

<div class="org-src-container">

<pre class="src src-python">P_CO = Pa0*(1-Xeq)
P_H2O = Pa0*(1-Xeq)
P_H2 = Pa0*Xeq
P_CO2 = Pa0*Xeq

<span style="color: #8b0000;">print</span> P_CO,P_H2O, P_H2, P_CO2
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 2.2747854428 2.2747854428 2.7252145572 2.7252145572
</pre>
</div>
</div>
<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> Compare the equilibrium constants</h2>
<div class="outline-text-2" id="text-11">
<p>
We can compare the equilibrium constant from the Gibbs free energy and the one from the ratio of pressures. They should be the same!
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> K_Temperature
<span style="color: #8b0000;">print</span> (P_CO2*P_H2)/(P_CO*P_H2O)
</pre>
</div>

<pre class="example">
1.43522674762
1.43522674762
</pre>

<p>
They are the same.
</p>
</div>
</div>
<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Summary</h2>
<div class="outline-text-2" id="text-12">
<p>
The NIST Webbook provides a plethora of data for computing thermodynamic properties. It is a little tedious to enter it all into Matlab, and a little tricky to use the data to estimate temperature dependent reaction energies. A limitation of the Webbook is that it does not tell you have the thermodynamic properties change with pressure. Luckily, those changes tend to be small.
</p>

<p>
I noticed a different behavior in interpolation between scipy.interpolate.interp1d and Matlab's interp1. The scipy function returns an interpolating function, whereas the Matlab function directly interpolates new values, and returns the actual interpolated data. 
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/01/Water-gas-shift-equilibria-via-the-NIST-Webbook.org">org-mode source</a><p>]]></content:encoded>
    </item>
  </channel>
</rss>
