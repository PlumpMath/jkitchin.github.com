<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2014-04-28T14:15:05Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A popup menu for citation links in org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode</id>
    <updated>2014-04-28T10:13:17Z</updated>
    <published>2014-04-28T10:13:17Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A popup menu for citation links in org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode"><![CDATA[



<p>
I have been exploring ways to get more information out of links in org-mode. I have considered <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/">popups</a> , and <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/">right-clicking</a> . Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.
</p>

<p>
Here is the function. We use <a href="https://github.com/auto-complete/popup-el">https://github.com/auto-complete/popup-el</a> , and some code from <a href="https://github.com/jkitchin/jmax/blob/master/jorg-bib.el">https://github.com/jkitchin/jmax/blob/master/jorg-bib.el</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string) 
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu* 
	    (list (popup-make-item (if 
				       (progn
					 (let ((cb (current-buffer)) result)					
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)					  
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item 
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")       
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")   
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))
       
      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")   
       (find-file bibfile)
       (bibtex-search-entry key)       
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))	
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)  
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(&lt;cite&gt;%s&lt;/cite&gt;)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
</pre>
</div>


<p>
<pre>cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2</pre> 
</p>


<p>

</p>



<p>
Here you can see an example of a menu where I have the PDF:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-1.png"> 
</p>
</div>

<p>
Here is an example menu of a key with no entry:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-2.png"> 
</p>

<p>
And, and entry with no PDF:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-3.png"> 
</p>

<p>
Here is the simple citation:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-4.png"> 
</p>
</div>

<p>
And a reference from the other bibliography:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-5.png"> 
</p>
</div>

<p>
Not bad! I will probably replace the cite link in jorg-bib with something like this.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/28/A-popup-menu-for-citation-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A better insert citation function for org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode</id>
    <updated>2014-04-27T14:40:45Z</updated>
    <published>2014-04-27T14:40:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A better insert citation function for org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode"><![CDATA[



<p>
I have setup a reftex citation format that inserts a cite link using reftex like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
</pre>
</div>

<p>
I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
</pre>
</div>

<p>
That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    (if (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
</pre>
</div>

<p>
That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/27/A-better-insert-citation-function-for-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Putting link references to lines of code in a source block]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block" />
    <id>http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block</id>
    <updated>2014-04-22T20:59:30Z</updated>
    <published>2014-04-22T20:59:30Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Putting link references to lines of code in a source block]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block"><![CDATA[


<p>
I keep forgetting about this interesting gem of a feature in org-mode code blocks. You can put references to specific lines of code outside the block!
<a href="http://orgmode.org/manual/Literal-examples.html#Literal-examples">http://orgmode.org/manual/Literal-examples.html#Literal-examples</a> 
</p>

<p>
The following code block has some references in it that we can refer to later:
</p>
<pre class="example">
#+BEGIN_SRC emacs-lisp -n -r
<span id="coderef-sc" class="coderef-off">(save-excursion (sc)</span>
<span id="coderef-jump" class="coderef-off">  (goto-char (point-min))) (jump)</span>
#+END_SRC
</pre>


<div class="org-src-container">

<pre class="src src-emacs-lisp"><span id="coderef-sc" class="coderef-off"><span class="linenr">1: </span>(<span style="color: #8b0000;">save-excursion</span></span>
<span id="coderef-jump" class="coderef-off"><span class="linenr">2: </span>  (goto-char (point-min)))</span>
</pre>
</div>


<p>
In line <pre>(sc)</pre> we remember the current position. <pre>(jump)</pre> jumps to point-min.
</p>

<p>
To make this work with python we have to make a slight change to the reference format in the header.
</p>

<pre class="example">
#+BEGIN_SRC python -n -r -l "#(ref:%s)"
<span id="coderef-for" class="coderef-off">for i in range(5):                # (for)</span>
<span id="coderef-body" class="coderef-off">    print i                       # (body)</span>
#+END_SRC
</pre>

<div class="org-src-container">

<pre class="src src-python"><span id="coderef-for" class="coderef-off"><span class="linenr">1: </span><span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #cd0000;">range</span>(5):</span>
<span id="coderef-body" class="coderef-off"><span class="linenr">2: </span>    <span style="color: #8b0000;">print</span> i</span>
</pre>
</div>

<pre class="example">
0
1
2
3
4
</pre>


<p>
In line <pre>(for)</pre> we initialize the loop, and in line <pre>(body)</pre> we run it.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/22/Putting-link-references-to-lines-of-code-in-a-source-block.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Literate programming in python with org-mode and noweb]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb" />
    <id>http://jkitchin.github.io/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb</id>
    <updated>2014-03-27T11:07:15Z</updated>
    <published>2014-03-27T10:46:55Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="python" />
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Literate programming in python with org-mode and noweb]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. imports</a></li>
<li><a href="#sec-2">2. utility function</a></li>
<li><a href="#sec-3">3. class definition</a>
<ul>
<li><a href="#sec-3-1">3.1. some class function</a></li>
</ul>
</li>
<li><a href="#sec-4">4. The main function</a></li>
<li><a href="#sec-5">5. Tangle and run the code</a></li>
<li><a href="#sec-6">6. Summary thoughts</a></li>
</ul>
</div>
</div>
<p>
This post examines a different approach to literate programming with org-mode that uses <a href="http://www.cs.tufts.edu/~nr/noweb/">noweb</a> . I have adapted an example from <a href="http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html">http://home.fnal.gov/~neilsen/notebook/orgExamples/org-examples.html</a> which has some pretty cool ideas in it. 
</p>

<p>
The gist of using noweb is that in your source blocks you have labels like <code>&lt;&lt;imports&gt;&gt;</code>, that refer to other named code blocks that get substituted in place of the label. In the example below, we put labels for a code block of imports, for a function definition, a class definition, and a main function. This code block will get tangled to <a href="/media/2014-03-27-Literate-programming-in-python-with-org-mode-and-noweb/main.py">main.py</a> . The noweb expansion happens at export, so here is the literal code block:
</p>
<pre class="example">
#+BEGIN_SRC python :noweb yes :tangle main.py
&lt;&lt;imports&gt;&gt;

&lt;&lt;some-func&gt;&gt;

&lt;&lt;class-dfn&gt;&gt;

&lt;&lt;main-func&gt;&gt;

if __name__ == '__main__':
    status = main()
    sys.exit(status)
#+END_SRC
</pre>

<p>
You may want to just check out the org-mode source link at the bottom of the post to see all the details.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> sys
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">from</span> argparse <span style="color: #8b0000;">import</span> ArgumentParser

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">utility_func</span>(arg=<span style="color: #cd0000;">None</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'you called a utility function with this arg: {0}'</span>.<span style="color: #cd0000;">format</span>(arg)

<span style="color: #8b0000;">class</span> <span style="color: #4682b4;">HelloWorld</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, who):
        <span style="color: #8b0000;">self</span>.who = who

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__call__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'Hello {0}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.who)

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">main</span>():
    <span style="color: #8b008b;">parser</span> = ArgumentParser(description=<span style="color: #228b22;">"Say hi"</span>)
    parser.add_argument(<span style="color: #228b22;">"-w"</span>, <span style="color: #228b22;">"--who"</span>, 
                        <span style="color: #cd0000;">type</span>=<span style="color: #cd0000;">str</span>,
                        default=<span style="color: #228b22;">"world"</span>,
                        <span style="color: #cd0000;">help</span>=<span style="color: #228b22;">"Who to say hello to"</span>)
    <span style="color: #8b008b;">args</span> = parser.parse_args()
  
    <span style="color: #8b008b;">who</span> = args.who
  
    <span style="color: #8b008b;">greeter</span> = HelloWorld(who)
    greeter()

    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'test func = '</span>, greeter.test()
  
    <span style="color: #8b0000;">print</span> utility_func()
    <span style="color: #8b0000;">print</span> utility_func(5)

    <span style="color: #8b0000;">return</span> 0

<span style="color: #8b0000;">if</span> <span style="color: #cd0000;">__name__</span> == <span style="color: #228b22;">'__main__'</span>:
    status = main()
    sys.<span style="color: #cd0000;">exit</span>(status)
</pre>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> imports</h2>
<div class="outline-text-2" id="text-1">
<p>
Now, we define a block that gives us the imports. We do not have to use any tangle headers here because noweb will put it in where it belongs.
</p>

<div class="org-src-container">

<pre class="src src-python" id="imports"><span style="color: #8b0000;">import</span> sys
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">from</span> argparse <span style="color: #8b0000;">import</span> ArgumentParser
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> utility function</h2>
<div class="outline-text-2" id="text-2">
<p>
Now we define a function we will want imported from the main file. 
</p>

<div class="org-src-container">

<pre class="src src-python" id="some-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">utility_func</span>(arg=<span style="color: #cd0000;">None</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'you called a utility function with this arg: {0}'</span>.<span style="color: #cd0000;">format</span>(arg)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> class definition</h2>
<div class="outline-text-2" id="text-3">
<p>
Finally, let us define a class. Note we use noweb here too, and we get the indentation correct!
</p>

<div class="org-src-container">

<pre class="src src-python" id="class-dfn"><span style="color: #8b0000;">class</span> <span style="color: #4682b4;">HelloWorld</span>(<span style="color: #cd0000;">object</span>):
    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__init__</span>(<span style="color: #8b0000;">self</span>, who):
        <span style="color: #8b0000;">self</span>.who = who

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">__call__</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #228b22;">'Hello {0}'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #8b0000;">self</span>.who)

    <span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
        <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
</pre>
</div>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> some class function</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Now, let us make the some-other-func. This block is not indented, but with the noweb syntax above, it seems to get correctly indented. Amazing.
</p>

<div class="org-src-container">

<pre class="src src-python" id="some-other-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">test</span>(<span style="color: #8b0000;">self</span>):
    <span style="color: #8b0000;">return</span> <span style="color: #cd0000;">True</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> The main function</h2>
<div class="outline-text-2" id="text-4">
<p>
This is a typical function that could be used to make your module into a script, and is only run when the module is used as a script.. 
</p>

<div class="org-src-container">

<pre class="src src-python" id="main-func"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">main</span>():
    <span style="color: #8b008b;">parser</span> = ArgumentParser(description=<span style="color: #228b22;">"Say hi"</span>)
    parser.add_argument(<span style="color: #228b22;">"-w"</span>, <span style="color: #228b22;">"--who"</span>, 
                        <span style="color: #cd0000;">type</span>=<span style="color: #cd0000;">str</span>,
                        default=<span style="color: #228b22;">"world"</span>,
                        <span style="color: #cd0000;">help</span>=<span style="color: #228b22;">"Who to say hello to"</span>)
    <span style="color: #8b008b;">args</span> = parser.parse_args()
  
    <span style="color: #8b008b;">who</span> = args.who
  
    <span style="color: #8b008b;">greeter</span> = HelloWorld(who)
    greeter()

    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'test func = '</span>, greeter.test()
  
    <span style="color: #8b0000;">print</span> utility_func()
    <span style="color: #8b0000;">print</span> utility_func(5)

    <span style="color: #8b0000;">return</span> 0
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Tangle and run the code</h2>
<div class="outline-text-2" id="text-5">
<p>
This link will extract the code to main.py: <pre>elisp:org-babel-tangle</pre> 
</p>

<p>
We can run the code like this (linux):
</p>
<div class="org-src-container">

<pre class="src src-sh" id="bashrun-helloworld">python main.py --w John 2&gt;&amp;1
true
</pre>
</div>
<pre class="example">
test func =  True
you called a utility function with this arg: None
you called a utility function with this arg: 5
</pre>

<p>
or this (windows, which as no sh)
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> main <span style="color: #8b0000;">import</span> *

main()
</pre>
</div>

<pre class="example">
test func =  True
you called a utility function with this arg: None
you called a utility function with this arg: 5
</pre>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary thoughts</h2>
<div class="outline-text-2" id="text-6">
<p>
The use of noweb syntax is pretty cool. I have not done anything serious with it, but it looks like you could pretty easily create a sophisticated python module this way that is documented in org-mode. </p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/27/Literate-programming-in-python-with-org-mode-and-noweb.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Make a list of org-files in all the subdirectories of the current working directory]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory" />
    <id>http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory</id>
    <updated>2014-03-23T15:36:56Z</updated>
    <published>2014-03-23T15:36:56Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <category scheme="http://jkitchin.github.io/blog" term="recursive" />
    <summary type="html"><![CDATA[Make a list of org-files in all the subdirectories of the current working directory]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory"><![CDATA[



<p>
It would be helpful to get a listing of org-files in a directory tree in the form of clickable links. This would be useful, for example, to find all files associated with a project in a directory with a particular extension, or to do some action on all files that match a pattern. To do this, we will have to recursively walk through the directories and examine their contents. 
</p>

<p>
Let us examine some of the commands we will need to use. One command is to get the contents of a directory. We will explore the contents of a directory called <code>literate</code> in my computer.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">list contents of the directory</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
<td class="left">..</td>
<td class="left">.</td>
</tr>
</tbody>
</table>

<p>
Note the presence of <code>.</code> and <code>..</code>. Those stand for current directory and one directory up. We should remove those from the list. We can do that like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">remove . and ..</span>
(<span style="color: #8b0000;">let</span> ((abspath nil)
      (match nil)
      (nosort t))
  (remove <span style="color: #228b22;">"."</span> 
          (remove <span style="color: #228b22;">".."</span> 
                  (directory-files <span style="color: #228b22;">"literate"</span> abspath match nosort))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">makefile-main</td>
<td class="left">Makefile</td>
<td class="left">main.o</td>
<td class="left">main.f90</td>
<td class="left">main</td>
<td class="left">literate.org</td>
<td class="left">hello.f90</td>
<td class="left">circle.o</td>
<td class="left">circle.mod</td>
<td class="left">circle.f90</td>
<td class="left">circle-area.png</td>
<td class="left">archive</td>
<td class="left">a.out</td>
</tr>
</tbody>
</table>

<p>
Next, we need to know if a given entry in the directory files is a file or a directory. Emacs-lisp has a few functions for that. We use absolute filenames here since the paths are relative to the  "molecules" directory. Note we could use absolute paths in directory-files, but that makes it hard to remove "." and "..".
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">print types of files in the directory</span>
(<span style="color: #8b0000;">let</span> ((root <span style="color: #228b22;">"literate"</span>)
      (abspath nil)
      (match nil)
      (nosort t))
  (mapcar (<span style="color: #8b0000;">lambda</span> (x)
            (<span style="color: #8b0000;">cond</span>
             ((file-directory-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a directory"</span> x)))
             ((file-regular-p (expand-file-name x root))
              (print (format <span style="color: #228b22;">"%s is a regular file"</span> x)))))
          (remove <span style="color: #228b22;">"."</span> 
                  (remove <span style="color: #228b22;">".."</span> 
                          (directory-files root abspath match nosort)))))
</pre>
</div>

<pre class="example">
"makefile-main is a regular file"

"Makefile is a regular file"

"main.o is a regular file"

"main.f90 is a regular file"

"main is a regular file"

"literate.org is a regular file"

"hello.f90 is a regular file"

"circle.o is a regular file"

"circle.mod is a regular file"

"circle.f90 is a regular file"

"circle-area.png is a regular file"

"archive is a directory"

"a.out is a regular file"
</pre>

<p>
Now, we are at the crux of this problem. We can differentiate between files and directories. For each directory in this directory, we need to recurse into it, and list the contents. There is some code at <a href="http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html">http://turingmachine.org/bl/2013-05-29-recursively-listing-directories-in-elisp.html</a> which does this, but I found that I had to modify the code to not list directories, and here I want to show a simpler recursive code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  <span style="color: #228b22;">"recursively walks through directories getting list of absolute paths of files"</span>
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(os-walk <span style="color: #228b22;">"literate"</span>)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/makefile-main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/main</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/literate.org</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/hello.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.o</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.mod</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle.f90</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/circle-area.png</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/a.out</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/Makefile</td>
<td class="left">c:/Users/jkitchin/Dropbox/blogofile-jkitchin.github.com/<sub>blog</sub>/literate/archive/empty-text-file.txt</td>
</tr>
</tbody>
</table>

<p>
Nice, that gives us a recursive listing of all the files in this directory tree. Let us take this a step further, and apply a function to that list to filter out a list of the org files. We will also create org-links out of these files.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">os-walk</span> (root)
  (<span style="color: #8b0000;">let</span> ((files '()) <span style="color: #ff0000; font-weight: bold;">;</span><span style="color: #ff0000; font-weight: bold;">empty list to store results</span>
        (current-list (directory-files root t)))
    <span style="color: #ff0000; font-weight: bold;">;;</span><span style="color: #ff0000; font-weight: bold;">process current-list</span>
    (<span style="color: #8b0000;">while</span> current-list
      (<span style="color: #8b0000;">let</span> ((fn (car current-list))) <span style="color: #ff0000; font-weight: bold;">; </span><span style="color: #ff0000; font-weight: bold;">get next entry</span>
        (<span style="color: #8b0000;">cond</span> 
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular files</span>
         ((file-regular-p fn)
          (add-to-list 'files fn))
         <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directories</span>
         ((and
           (file-directory-p fn)
           <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">ignore . and ..</span>
           (not (string-equal <span style="color: #228b22;">".."</span> (substring fn -2)))
           (not (string-equal <span style="color: #228b22;">"."</span> (substring fn -1))))
          <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">we have to recurse into this directory</span>
          (setq files (append files (os-walk fn))))
        )
      <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">cut list down by an element</span>
      (setq current-list (cdr current-list)))
      )
    files))

(<span style="color: #8b0000;">require</span> '<span style="color: #cd0000;">cl</span>)

(mapcar 
 (<span style="color: #8b0000;">lambda</span> (x) (princ (format <span style="color: #228b22;">"[[%s][%s]]\n"</span> x (file-relative-name x <span style="color: #228b22;">"."</span>))))
 (remove-if-not 
  (<span style="color: #8b0000;">lambda</span> (x) (string= (file-name-extension x) <span style="color: #228b22;">"org"</span>))
  (os-walk <span style="color: #228b22;">"literate"</span>)))
</pre>
</div>

<p>
<a href="/media/2014-03-23-Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory/literate.org">literate/literate.org</a> 
</p>


<p>
That is certainly functional. It might be nice to format the links a bit nicer to show their structure in a table of contents way, or to sort them in a nice order if there were many of these files. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/23/Make-a-list-of-org-files-in-all-the-subdirectories-of-the-current-working-directory.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using yasnippet to get completion in ref links]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links" />
    <id>http://jkitchin.github.io/blog/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links</id>
    <updated>2014-03-08T07:55:54Z</updated>
    <published>2014-03-08T07:55:54Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Using yasnippet to get completion in ref links]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links"><![CDATA[



<p>
This post illustrates an alternative approach to completion in creating ref links compared to the approach shown <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/06/Using-completion-in-ref-links/">here</a> . In this approach we use a dynamic yasnippet to do the completion. We start with similar code that I used before to get a list of labels from the buffer. I used a slightly different regexp to recognize links in this version.
</p>

<p>
<pre>label:code-example</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">get-labels</span> ()
  (interactive)
  (<span style="color: #8b0000;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #8b0000;">let</span> ((matches '()))
      (<span style="color: #8b0000;">while</span> (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-z0-9:-]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)
        (add-to-list 'matches (match-string-no-properties 1) t))
      matches)))
</pre>
</div>

<pre class="example">
get-labels
</pre>

<p>
Let us see that in action:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(get-labels)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">code-example</td>
<td class="left">\\</td>
<td class="left">code:ref-snippet</td>
<td class="left">load-snippets</td>
</tr>
</tbody>
</table>

<p>
I think the <code>\\</code> link is an artifact of the regexp in my get-labels code, and it would not appear in other examples. 
</p>

<p>
Now, we are going to create a yasnippet that uses the list returned from <code>get-labels</code> to provide your choices. See <a href="http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8">http://capitaomorte.github.io/yasnippet/snippet-development.html#sec-3-8</a> for some details. We will tangle this code block into a local snippets directory.
</p>

<p>
<pre>label:code:ref-snippet</pre> 
</p>
<div class="org-src-container">

<pre class="src src-snippet"><span style="color: #ff0000; font-weight: bold;"># -*- mode: snippet -*-</span>
<span style="color: #ff0000; font-weight: bold;"># --</span>
ref:<span style="color: #8b0000;">${</span><span style="color: #ff0000; font-weight: bold;">1</span><span style="color: #8b0000;">:</span>$<span style="color: #0000cd; font-weight: bold;">$(</span>yas-choose-value (get-labels))<span style="color: #8b0000;">}</span> <span style="color: #8b0000;">$</span><span style="color: #228b22;">0</span>
</pre>
</div>

<p>
Now we load the snippets directory.
</p>

<p>
<pre>label:load-snippets</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(yas-load-directory <span style="color: #228b22;">"./snippets"</span>)
</pre>
</div>

<p>
Finally, we can type ref, press tab to complete it, and then select the label you want from a list. Here are some examples:
</p>

<p>
<pre>ref:code-example</pre> 
</p>

<p>
<pre>ref:code:ref-snippet</pre> 
</p>

<p>
That also works! I cannot decide if I like this better than the Emacs completion. yasnippet gives a popup menu, which is not as easy to navigate as the Emacs completion mechanism. It also requires a working yasnippet, which has not made it into my regular work flows too often. I think I like the Emacs completion better (which actually goes through Icicles since I have that installed). I like it better because I do not have to leave the keyboard or use the arrow buttons to choose a label. However, I do need to bind that function to some key to use it, or type in the command name. It turns out I do not use ref links too often, so it is not too burdensome.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/08/Using-yasnippet-to-get-completion-in-ref-links.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Storing label links in org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/07/Storing-label-links-in-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/03/07/Storing-label-links-in-org-mode</id>
    <updated>2014-03-07T16:13:39Z</updated>
    <published>2014-03-07T16:13:39Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Storing label links in org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/07/Storing-label-links-in-org-mode"><![CDATA[



<p>
I am continuing to evolve how I can use org-mode. I have created a label link, which if clicked on checks to see that the label is unique in the buffer. It would be nice to be able to be on a <pre>label:some-label</pre> link, and to store it so we could create a <pre>ref:some-label</pre> later. That ref link is also clickable, and it jumps to the label it refers to, and provides a C-c &amp; option to get back to the ref link. org-mode allows you to create <code>org-PREFIX-store-link</code> functions which store the link information. These functions must determine if they are responsible for storing the link and return nil if not. The first challenge is figuring out if the cursor is on a label link. Here is a function that does that.
</p>

<p>
This was a little challenging. The strategy to determine if the cursor is in a link is to search backward for a regular expression matching a label link. I found this was not sufficient, because it appeared to me that the matched string was only between the beginning of the label link and the point where the cursor was. So, after finding the beginning of the first label link before the cursor, then we search forward to find the whole link. Then we determine if the cursor is between the beginning and end of the match. If it is, then we are on a label link. Here is the code.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">in-label-link</span> ()
  <span style="color: #228b22;">"return label if in a label link, or return nil</span>

<span style="color: #228b22;">we store point, search forward to the first space, and backward to the previous space. then make sure label: is between them."</span>
  (interactive)
  (<span style="color: #8b0000;">let</span> ((current-point (point)))
    (<span style="color: #8b0000;">save-excursion</span>
      (re-search-backward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-z0-9:-]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-min) t)
      (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">[a-zA-Z0-9-:]*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)   
      (<span style="color: #8b0000;">if</span> (and (&gt; current-point (match-beginning 0))
               (&lt; current-point (match-end 0)))
          t
        nil))))
</pre>
</div>

<p>
This code works for these kinds of links as far as I can tell. Interestingly, it only works when the cursor is to the right of label:. I am not sure if that is because of the regular expression or not.
</p>

<p>
<pre>label:plain-beginning</pre> 
</p>

<p>
<pre>label:telabel</pre> 
</p>

<p>
<pre>label:fig:test</pre> 
</p>

<p>
<pre>label:bracket-in-line</pre> 
</p>


<p>
Now, we create the code that stores the link. We only execute the code if we pass the function that checks if we are on a label link. If we are, then the label is stored in <code>(match-string 1)</code>, and we create the link and store it. Finally, we add the function to <code>org-store-link-functions</code> so that it will be used when C-c l is pressed.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-label-store-link</span> ()
  <span style="color: #228b22;">"store a link to a label. The output will be a ref to that label"</span>
  <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">First we have to make sure we are on a label link. </span>
  (<span style="color: #8b0000;">when</span> (in-label-link)
    (org-store-link-props
     <span style="color: #cd0000;">:type</span> <span style="color: #228b22;">"ref"</span>
     <span style="color: #cd0000;">:link</span> (concat <span style="color: #228b22;">"ref:"</span> (match-string 1)))))

(add-hook 'org-store-link-functions 'org-label-store-link)
</pre>
</div>

<p>
So, here is the evidence that it worked:
</p>

<p>
<pre>ref:plain-beginning</pre> 
</p>

<p>
<pre>ref:telabel</pre> 
</p>

<p>
<pre>ref:fig:test</pre> 
</p>

<p>
<pre>ref:bracket-in-line</pre> 
</p>

<p>
For each of these, I put the cursor on the labels, pressed C-c l, and then moved the cursor down here and pressed C-c C-l, and pressed enter and PRESTO! I had the reference that I wanted! That seems like a handy trick.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/07/Storing-label-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using completion in ref links]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/06/Using-completion-in-ref-links" />
    <id>http://jkitchin.github.io/blog/2014/03/06/Using-completion-in-ref-links</id>
    <updated>2014-03-06T19:11:07Z</updated>
    <published>2014-03-06T19:11:07Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Using completion in ref links]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/06/Using-completion-in-ref-links"><![CDATA[



<p>
I came across this interesting post on using completion in links: <a href="http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs">http://draketo.de/light/english/free-software/custom-link-completion-org-mode-25-lines-emacs</a> . I like the idea, but the type-flow for is not how I usually insert links. For the method there to work, you have to enter a link with C-c C-l, partially enter the link type, press enter, and then partially enter the description, which can be completed with tab. That is a lot of typing to me, compared to what I usually do which is type the link in directly. That habit does not work too well in large documents, and always has the possibility of a typo in the link, which then does not work or export correctly.
</p>

<p>
Here I explore how to make a <pre>ref:label</pre> link using a function that provides all the options available as labels. The idea is to write a function that generates a list of labels in the buffer, which you can make a link to. Let us try an interactive function with a list of arguments. We are first going to generate a list of labels from the buffer. We use this code to get a list of labels in the buffer. You will get to choose which label you want a link to, and the function will insert it for you. Here it is:
</p>

<p>
<pre>label:code-example</pre> 
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">get-labels</span> ()
  (interactive)
  (<span style="color: #8b0000;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #8b0000;">let</span> ((matches '()))
      (<span style="color: #8b0000;">while</span> (re-search-forward <span style="color: #228b22;">"label:</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">.*</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">"</span> (point-max) t)
        (add-to-list 'matches (match-string-no-properties 1) t))
      matches)))

(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">org-insert-ref-link</span> (<span style="color: #4682b4;">&amp;optional</span> arg)
  (interactive (list (completing-read <span style="color: #228b22;">"label: "</span> (get-labels))))
  (insert (format <span style="color: #228b22;">"ref:%s"</span> arg)))
</pre>
</div>

<pre class="example">
org-insert-ref-link
</pre>

<p>
So, here you run the command with M-x org-insert-ref-link, press tab, and select the label you want to use. A link like this gets inserted in your buffer <pre>ref:code-example</pre> . This is pretty nice. It should reduce the number of ref link mistakes, and make it easier to find the labels in the whole buffer.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/06/Using-completion-in-ref-links.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Creating a transportable zip-archive of an org-file]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file" />
    <id>http://jkitchin.github.io/blog/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file</id>
    <updated>2014-03-05T12:31:34Z</updated>
    <published>2014-03-05T10:49:14Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Creating a transportable zip-archive of an org-file]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file"><![CDATA[



<p>
This post explores a method to save an org-buffer to a zip archive, with all the referencing files. The challenge is that you may want to share the org-file with someone, but the links break if you send them the file, and it is not that trivial to find all the links and change them, and to copy the files to a place where the new links work. 
</p>

<p>
The idea is to export the buffer to an org-file and process all the links to copy the files to a new directory, and change the links to point to these new files. For example, <a href="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/blog.pdf">blog.pdf</a> would be copied to the temporary directory, given a unique name, and then relinked. The text below includes some examples of the links that need to be modified.
</p>

<p>
A figure looks like:
</p>


<div class="figure">
<p><img src="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/cos-plot.png"> 
</p>
</div>

<p>
Alternatively, we might use a <img src="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/eos.png"> to a file. We do not want to change urls, such as this one: <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/">http://kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/</a> . As in that example, we will create a list of all the links in the buffer, but only modify the links that are files. We can parse the buffer and get the links like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">let</span> ((parsetree (org-element-parse-buffer))
      (counter 0))
  (org-element-map parsetree 'link
    (<span style="color: #8b0000;">lambda</span> (link) 
      (<span style="color: #8b0000;">let</span> ((type (nth 0 link))
            (plist (nth 1 link))
            (content (nth 2 link)))
        (princ (format <span style="color: #228b22;">"%s %s: %s %s\n"</span> 
                       counter 
                       (plist-get plist '<span style="color: #cd0000;">:type</span>) 
                       (plist-get plist <span style="color: #cd0000;">:path</span>) 
                       content))
        (setq counter (+ counter 1))))))
</pre>
</div>
<pre class="example">
0 file: ./blog.pdf nil
1 file: ./images/cos-plot.png nil
2 file: ./images/eos.png link
3 http: //kitchingroup.cheme.cmu.edu/blog/2013/09/28/Changing-links-to-files-so-they-work-in-a-blog/ nil
</pre>

<p>
So, our overall strategy will be to create a new directory to store the new versions of the files in. Then, we will copy the files that links point to into that directory, and give them new unique names. We will rename the links to point to these new names. We do this because you may, for some reason have links to files with the same name but in different directories. We want to make sure we do not clobber the files by overwriting them. We use a simple method here, based on unique, temporary filenames. There are other ways to do it to, this way worked first. Finally, we will zip that new directory, and delete the new directory.
</p>


<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">directory to save all exports in, using the current date</span>
(setq org-archive (concat <span style="color: #228b22;">"org-archive-"</span> (format-time-string <span style="color: #228b22;">"%Y-%m-%d"</span> (current-time))))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">delete directory and zip file if it exists</span>
(<span style="color: #8b0000;">when</span> (file-exists-p (concat org-archive <span style="color: #228b22;">".zip"</span>)) 
    (delete-file (concat org-archive <span style="color: #228b22;">".zip"</span>) t))

(<span style="color: #8b0000;">when</span> (file-exists-p org-archive) 
    (delete-directory org-archive t))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">make directory</span>
(make-directory org-archive t)

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">get list of links, copy files and save names</span>
(setq link-list (<span style="color: #8b0000;">let</span> ((parsetree (org-element-parse-buffer))
                     (counter 0))
                 (org-element-map parsetree 'link
                   (<span style="color: #8b0000;">lambda</span> (link) 
                     (<span style="color: #8b0000;">let*</span> ((type (nth 0 link))
                            (plist (nth 1 link))
                            (content (nth 2 link))
                            (path (plist-get plist <span style="color: #cd0000;">:path</span>))
                            (type (plist-get plist '<span style="color: #cd0000;">:type</span>))
                            (fname (car (last (split-string path <span style="color: #228b22;">"/"</span>))))
                            (temporary-file-directory org-archive)
                            (new-file)
                            )     
                       (<span style="color: #8b0000;">cond</span>
                        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular file with content</span>
                        ((and (string= type <span style="color: #228b22;">"file"</span>)  content)
                         (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
                                                         (concat <span style="color: #228b22;">"."</span> (file-name-extension fname))))
                         (<span style="color: #8b0000;">with-temp-file</span> new-file
                           (insert-file-contents path))
                         (format <span style="color: #228b22;">"[[./%s][%s]] "</span> (file-name-nondirectory new-file) content))
                        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">regular file with no content</span>
                        ((and (string= type <span style="color: #228b22;">"file"</span>))
                         (setq new-file  (make-temp-file (file-name-sans-extension fname) nil 
                                                         (concat <span style="color: #228b22;">"."</span> (file-name-extension fname))))
                         (<span style="color: #8b0000;">with-temp-file</span> new-file
                           (insert-file-contents path))
                         (format <span style="color: #228b22;">"[[./%s]] "</span> (file-name-nondirectory new-file)))
                        (t nil)))))))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">save current buffer name</span>
(setq current-name (buffer-name))

<span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">create filter for links and export org buffer</span>
(<span style="color: #8b0000;">let</span> ((counter 0))
  (<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">ox-mrkup-filter-link</span> (text back-end info)
    (<span style="color: #8b0000;">let</span> ((link (nth counter link-list)))
      (<span style="color: #8b0000;">if</span> (not (string= link <span style="color: #228b22;">"nil"</span>)) (setq output   (format <span style="color: #228b22;">"%s"</span> link))
        (setq output (format <span style="color: #228b22;">"%s"</span> text)))
      (setq counter (+ counter 1))
      output))

  (<span style="color: #8b0000;">let</span> ((org-export-filter-link-functions '(ox-mrkup-filter-link)))
    (org-org-export-as-org)))

(switch-to-buffer <span style="color: #228b22;">"*Org ORG Export*"</span>)
(write-file (expand-file-name current-name org-archive))
(shell-command (concat <span style="color: #228b22;">"zip -R "</span> org-archive <span style="color: #228b22;">".zip  *"</span>))
(rename-file (concat org-archive <span style="color: #228b22;">".zip"</span>) (concat <span style="color: #228b22;">"../"</span>org-archive <span style="color: #228b22;">".zip"</span>))
(kill-buffer)

(switch-to-buffer current-name)
(delete-directory org-archive t)  <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">get rid of temp-dir</span>
</pre>
</div>



<p>
This example works fine! The result is here: <a href="/media/2014-03-05-Creating-a-transportable-zip-archive-of-an-org-file/org-archive-2014-03-05.zip">org-archive-2014-03-05.zip</a> This code would ideally be put into a function, and cleaned up a little so there are not global variables being set here and there. A subsequent function might make it easy to attach this file to an email. That code might look something like this:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(mail)
(mail-to)
(insert <span style="color: #228b22;">"jkitchin@andrew.cmu.edu"</span>)
(mml-attach-file <span style="color: #228b22;">"./org-archive-2014-03-05.zip"</span>)
</pre>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/05/Creating-a-transportable-zip-archive-of-an-org-file.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a list of figures in an org-buffer]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer" />
    <id>http://jkitchin.github.io/blog/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer</id>
    <updated>2014-03-03T14:50:40Z</updated>
    <published>2014-03-02T10:03:00Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <summary type="html"><![CDATA[Getting a list of figures in an org-buffer]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer"><![CDATA[



<p>
Similar to the previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/01/Getting-a-list-of-tables-in-an-org-buffer/">example</a> of getting a list of tables, here we examine getting a list of figures. Here are two figure links, one with a label, and one with a caption.
</p>


<div id="fig:cos" class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/cos-plot.png"> 
</p>
</div>


<div class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/eos-uncertainty.png"> 
</p>
<p><span class="figure-number">Figure 1:</span> An equation of state. this is the caption of the figure.</p>
</div>


<div class="figure">
<p><img src="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/implicit-uncertainty.png"> 
</p>
<p><span class="figure-number">Figure 2:</span> another figure</p>
</div>

<p>
We define a link that will parse the buffer, and create links in a new buffer to the figures. We define a figure as a  link with a :type of "file" that has a path that points to a file ending with png or pdf.  We will improve on the list of tables by making the buffer read-only, and making a local key binding to kill the buffer by pressing "q". Here is our attempted code. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp"><span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">http://www.emacswiki.org/emacs/ElispCookbook#toc4</span>
(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">string/ends-with</span> (s ending)
  <span style="color: #228b22;">"return non-nil if string S ends with ENDING."</span>
  (<span style="color: #8b0000;">cond</span> ((&gt;= (length s) (length ending))
         (<span style="color: #8b0000;">let</span> ((elength (length ending)))
           (string= (substring s (- 0 elength)) ending)))
        (t nil)))

(org-add-link-type 
 <span style="color: #228b22;">"list-of-figures"</span>
 (<span style="color: #8b0000;">lambda</span> (link-string)
   (<span style="color: #8b0000;">let*</span> ((c-b (buffer-name))
          (counter 0)
          (list-of-figures 
           (org-element-map (org-element-parse-buffer) 'link
             (<span style="color: #8b0000;">lambda</span> (link) 
               <span style="color: #228b22;">"create a link for to the figure"</span>
               (<span style="color: #8b0000;">when</span> 
                   (and (string= (org-element-property <span style="color: #cd0000;">:type</span> link) <span style="color: #228b22;">"file"</span>)
                        (string-match-p  
                         <span style="color: #228b22;">"[</span><span style="color: #228b22;">^</span><span style="color: #228b22;">.]*\\.</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">(</span><span style="color: #228b22;">png</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">|</span><span style="color: #228b22;">jpg</span><span style="color: #228b22; font-weight: bold;">\\</span><span style="color: #228b22; font-weight: bold;">)</span><span style="color: #228b22;">$"</span>
                         (org-element-property <span style="color: #cd0000;">:path</span> link)))                   
                 (incf counter)
                 
                 (<span style="color: #8b0000;">let*</span> ((start (org-element-property <span style="color: #cd0000;">:begin</span> link))
                        (parent (car (cdr (org-element-property <span style="color: #cd0000;">:parent</span> link))))
                        (caption (caaar (plist-get parent <span style="color: #cd0000;">:caption</span>)))
                        (name (plist-get parent <span style="color: #cd0000;">:name</span>)))
                   (<span style="color: #8b0000;">if</span> caption 
                       (format 
                        <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]] %s\n"</span> 
                        c-b start counter (or name <span style="color: #228b22;">""</span>) caption)
                     (format 
                      <span style="color: #228b22;">"[[elisp:(progn (switch-to-buffer \"%s\")(goto-char %s))][figure %s: %s]]\n"</span> 
                      c-b start counter (or name <span style="color: #228b22;">""</span>)))))))))
          (switch-to-buffer <span style="color: #228b22;">"*List of Figures*"</span>)
          (org-mode)
          (erase-buffer)
          (insert (mapconcat 'identity list-of-figures <span style="color: #228b22;">""</span>))
          (setq buffer-read-only t)
          (use-local-map (copy-keymap org-mode-map))
          (local-set-key <span style="color: #228b22;">"q"</span> #'(<span style="color: #8b0000;">lambda</span> () (interactive) (kill-buffer)))))
   (<span style="color: #8b0000;">lambda</span> (keyword desc format)
     (<span style="color: #8b0000;">cond</span>
      ((eq format 'latex)
       (format <span style="color: #228b22;">"\\listoffigures"</span>)))))
</pre>
</div>



<p>
This is a test to see if our function works for other image types.
<a href="/media/2014-03-02-Getting-a-list-of-figures-in-an-org-buffer/smiley.jpg">smiley.jpg</a> 
</p>

<p>
And a link to test it out: 
</p>

<p>

</p>

<p>
This works too. I am not sure I am getting the figure name and caption in a bulletproof way. They seem to be buried in the :parent of the element, which is a paragraph element. The caption seems to be buried in a few sets of parentheses, hence the use of <code>caaar</code> to get the caption out. I am not sure if the caption is always at that depth or not. As a proof of concept though, this is not too bad. 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/03/02/Getting-a-list-of-figures-in-an-org-buffer.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
</feed>
