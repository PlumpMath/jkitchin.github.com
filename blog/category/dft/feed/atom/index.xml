<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2014-02-10T12:43:37Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Sharing data via JSON files]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/10/22/Sharing-data-via-JSON-files" />
    <id>http://jkitchin.github.io/blog/2013/10/22/Sharing-data-via-JSON-files</id>
    <updated>2013-10-22T14:39:56Z</updated>
    <published>2013-10-22T14:39:56Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="dft" />
    <category scheme="http://jkitchin.github.io/blog" term="ase" />
    <summary type="html"><![CDATA[Sharing data via JSON files]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/10/22/Sharing-data-via-JSON-files"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Summary</a></li>
</ul>
</div>
</div>
<p>
In a previous <a href="http://jkitchin.github.io/blog/2013/10/19/Serializing-jasp-calculations-as-json-data/">post</a> I discussed how to represent a single DFT calculation in a JSON file that could easily be shared, and reanalyzed. Here I look at sharing a series of calculations. I had previously run calculations to analyze an equation of state for Cu. Here we create a list of the JSON representations of each calculation, and save it in one overall JSON file. We will give the data some structure and documentation. JSON represents dictionaries very well, so we build a dictionary of the results and then "dump" that dictionary to a JSON file.
</p>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> jasp <span style="color: #8b0000;">import</span> *

<span style="color: #8b008b;">LC</span> = [3.5, 3.55, 3.6, 3.65, 3.7, 3.75]

<span style="color: #8b008b;">data</span> = {<span style="color: #228b22;">'doc'</span>:<span style="color: #228b22;">'JSON file containing a set of calculations for the equation of state of Cu'</span>}

<span style="color: #8b008b;">data</span>[<span style="color: #228b22;">'calculations'</span>] = []

<span style="color: #8b0000;">for</span> a <span style="color: #8b0000;">in</span> LC:
    <span style="color: #8b0000;">with</span> jasp(<span style="color: #228b22;">'../bulk/Cu-{0}'</span>.<span style="color: #cd0000;">format</span>(a)) <span style="color: #8b0000;">as</span> calc:
        data[<span style="color: #228b22;">'calculations'</span>].append(calc.<span style="color: #cd0000;">dict</span>)

<span style="color: #8b0000;">import</span> json
<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'eos.json'</span>, <span style="color: #228b22;">'wb'</span>) <span style="color: #8b0000;">as</span> f:
    f.write(json.dumps(data))
</pre>
</div>

<p>
Now, you can view this <a href="/media/2013-10-22-Sharing-data-via-JSON-files/eos.json">eos.json</a> file, and analyze it yourself as follows. In python we read the file in and convert it to a data structure using the <code>json</code> module.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> json

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'eos.json'</span>, <span style="color: #228b22;">'rb'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">d</span> = json.loads(f.read())

<span style="color: #8b008b;">volumes</span> =  [entry[<span style="color: #228b22;">'data'</span>][<span style="color: #228b22;">'volume'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> d[<span style="color: #228b22;">'calculations'</span>]]
<span style="color: #8b008b;">energies</span> = [entry[<span style="color: #228b22;">'data'</span>][<span style="color: #228b22;">'total_energy'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> d[<span style="color: #228b22;">'calculations'</span>]]

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
plt.plot(volumes, energies)
plt.xlabel(<span style="color: #228b22;">'Volume ($\AA$)'</span>)
plt.ylabel(<span style="color: #228b22;">'Total energy (eV)'</span>)
plt.savefig(<span style="color: #228b22;">'eos-from-json.png'</span>)
plt.show()
</pre>
</div>

<p>
If you wanted to do further analysis you could. Suppose you wanted to know more detail about how that calculation was done? You can retrieve the INCAR, KPOINT, and POTCAR details for each calculation. Any parameter not listed here was not specified in the calculations.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> json

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'eos.json'</span>, <span style="color: #228b22;">'rb'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">d</span> = json.loads(f.read())

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">print details for the first calculation in the list</span>
<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'incar'</span>]
<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'input'</span>]
<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'potcar'</span>]
</pre>
</div>

<pre class="example">
{u'doc': u'INCAR parameters', u'nbands': 9, u'encut': 350.0, u'prec': u'Normal'}
{u'kpts': [8, 8, 8], u'reciprocal': False, u'xc': u'PBE', u'kpts_nintersections': None, u'setups': None, u'txt': u'-', u'gamma': False}
[[u'Cu', u'potpaw_PBE/Cu/POTCAR', u'a44c591415026f53deb16a99ca3f06b1e69be10b']]
</pre>

<p>
The POTCAR information contains the species, the path to the POTCAR, and a git-hash of the POTCAR file. That way you can tell if you used exactly the same file that I did. You can compute a git hash like <a href="http://git-scm.com/book/en/Git-Internals-Git-Objects#Object-Storage">this</a> :
</p>

<div class="org-src-container">

<pre class="src src-sh">cat /home-research/jkitchin/src/vasp/potpaw_PBE/Cu/POTCAR | git hash-object --stdin
</pre>
</div>

<pre class="example">
a44c591415026f53deb16a99ca3f06b1e69be10b
</pre>

<p>
If you want to get the details of the geometry of some calculation, you do it this way:
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> json

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'eos.json'</span>, <span style="color: #228b22;">'rb'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">d</span> = json.loads(f.read())

<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'atoms'</span>].keys()
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'cell = '</span>, d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'atoms'</span>][<span style="color: #228b22;">'cell'</span>]
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'syms = '</span>, d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'atoms'</span>][<span style="color: #228b22;">'symbols'</span>]
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'cpos = '</span>, d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'atoms'</span>][<span style="color: #228b22;">'positions'</span>]
</pre>
</div>

<pre class="example">
[u'cell', u'symbols', u'positions', u'pbc', u'tags']
cell =  [[1.75, 1.75, 0.0], [0.0, 1.75, 1.75], [1.75, 0.0, 1.75]]
syms =  [u'Cu']
cpos =  [[0.0, 0.0, 0.0]]
</pre>

<p>
You can do further analysis from there.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
This looks ok as a data sharing mechanism. The json file here is pretty small (6.8 kb), and pretty easy to work with. Clearly some thought must go into how the data is structured so you know what to get, and how you get it. That could even be documented in the json file itself. For instance, each calculator has a doc element that describes what is in it. The json file we made above also has that data. 
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> json

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'eos.json'</span>, <span style="color: #228b22;">'rb'</span>) <span style="color: #8b0000;">as</span> f:
    <span style="color: #8b008b;">d</span> = json.loads(f.read())

<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'doc'</span>]
<span style="color: #8b0000;">print</span>
<span style="color: #8b0000;">print</span> d[<span style="color: #228b22;">'calculations'</span>][0][<span style="color: #228b22;">'doc'</span>]
</pre>
</div>

<pre class="example">
JSON file containing a set of calculations for the equation of state of Cu

JSON representation of a VASP calculation.

energy is in eV
forces are in eV/\AA
stress is in GPa (sxx, syy, szz,  syz, sxz, sxy)
magnetic moments are in Bohr-magneton
The density of states is reported with E_f at 0 eV.
Volume is reported in \AA^3
Coordinates and cell parameters are reported in \AA

If atom-projected dos are included they are in the form:
{ados:{energy:data, {atom index: {orbital : dos}}}
</pre>

<p>
For archival purposes you may want to put a creation date, contact data, etc&#x2026; in the file too.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/10/22/Sharing-data-via-JSON-files.org">org-mode source</a><p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Integrating the Fermi distribution to compute entropy]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy" />
    <id>http://jkitchin.github.io/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy</id>
    <updated>2013-03-06T09:47:19Z</updated>
    <published>2013-03-06T09:39:42Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="dft" />
    <category scheme="http://jkitchin.github.io/blog" term="gotcha" />
    <category scheme="http://jkitchin.github.io/blog" term="integration" />
    <summary type="html"><![CDATA[Integrating the Fermi distribution to compute entropy]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy"><![CDATA[



<p>
The Fermi distribution is defined by \(f(\epsilon) = \frac{1}{e^{(\epsilon - \mu)/(k T)} + 1}\). This function describes the occupation of energy levels at temperatures above absolute zero. We use this function to compute electronic entropy in a metal, which contains an integral of \(\int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon\), where \(n(\epsilon)\) is the electronic density of states. Here we plot the Fermi distribution function. It shows that well below the Fermi level the states are fully occupied, and well above the Fermi level, they are unoccupied. Near the Fermi level, the states go from occupied to unoccupied smoothly.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.linspace(-10, 10, 200)
plt.plot(espan, f(espan))
plt.ylim([-0.1, 1.1])
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/fermi-entropy-integrand-1.png"><p>

<p>
Let us consider a simple density of states function, just a parabola. This could represent a s-band for example. We will use this function to explore the integral.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dos</span>(e):
    d = (np.ones(e.shape) - 0.03 * e**2) 
    <span style="color: #8b0000;">return</span> d * (d &gt; 0)
espan = np.linspace(-10, 10)

plt.plot(espan, dos(espan), label=<span style="color: #228b22;">'Total dos'</span>)
plt.plot(espan, f(espan) * dos(espan), label=<span style="color: #228b22;">'Occupied states'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-2.png'</span>)
</pre>
</div>

<p>
<p><img src="/img/./images/fermi-entropy-integrand-2.png"><p>
Now, we consider the integral to compute the electronic entropy. The entropy is proportional to this integral.
</p>

<p>
\( \int n(\epsilon) (f \ln f + (1 - f) \ln (1-f)) d\epsilon \)
</p>

<p>
It looks straightforward to compute, but it turns out there is a wrinkle. Evaluating the integrand leads to <code>nan</code> elements because the ln(0) is -&infin;. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
mu = 0
k = 8.6e-5
T = 100

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fermi</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

espan = np.array([-20, -10, -5, 0.0, 5, 10])
f = fermi(espan)

<span style="color: #8b0000;">print</span> f * np.log(f)
<span style="color: #8b0000;">print</span> (1 - f) * np.log(1 - f)
</pre>
</div>

<pre class="example">
[  0.00000000e+000   0.00000000e+000   0.00000000e+000  -3.46573590e-001
  -1.85216532e-250               nan]
[        nan         nan         nan -0.34657359  0.          0.        ]
</pre>

<p>
In this case, these <code>nan</code> elements should be equal to zero (x ln(x) goes to zero as x goes to zero). So, we can just ignore those elements in the integral. Here is how to do that.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

mu = 0
k = 8.6e-5
T = 1000

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fermi</span>(e):
    <span style="color: #8b0000;">return</span> 1.0 / (np.exp((e - mu)/(k*T)) + 1)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">dos</span>(e):
    d = (np.ones(e.shape) - 0.03 * e**2) 
    <span style="color: #8b0000;">return</span> d * (d &gt; 0)

espan = np.linspace(-20, 10)
f = fermi(espan)
n = dos(espan)

g = n * (f * np.log(f) + (1 - f) * np.log(1 - f))

<span style="color: #8b0000;">print</span> np.trapz(espan, g) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">nan because of the nan in the g vector</span>
<span style="color: #8b0000;">print</span> g

plt.plot(espan, g)
plt.savefig(<span style="color: #228b22;">'images/fermi-entropy-integrand-3.png'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">find the elements that are not nan</span>
ind = np.logical_not(np.isnan(g))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">evaluate the integrand for only those points</span>
<span style="color: #8b0000;">print</span> np.trapz(espan[ind], g[ind])
</pre>
</div>

<pre class="example">
nan
[             nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
              nan              nan              nan              nan
  -9.75109643e-14  -1.05987106e-10  -1.04640574e-07  -8.76265644e-05
  -4.92684641e-02  -2.91047740e-01  -7.75652579e-04  -1.00962241e-06
  -1.06972936e-09  -1.00527877e-12  -8.36436686e-16  -6.48930917e-19
  -4.37946336e-22  -2.23285389e-25  -1.88578082e-29   0.00000000e+00
   0.00000000e+00   0.00000000e+00   0.00000000e+00   0.00000000e+00
   0.00000000e+00   0.00000000e+00]
0.208886080897
</pre>

<p><img src="/img/./images/fermi-entropy-integrand-3.png"><p>

<p>
The integrand is pretty well behaved in the figure above. You do not see the full range of the x-axis, because the integrand evaluates to <code>nan</code> for very negative numbers. This causes the <code>trapz</code> function to return <code>nan</code> also. We can solve the problem by only integrating the parts that are not <code>nan</code>. We have to use numpy.logical<sub>not</sub> to get an element-wise array of which elements are not <code>nan</code>. In this example, the integrand is not well sampled, so the area under that curve may not be very accurate. 
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Integrating-the-Fermi-distribution-to-compute-entropy.org">org-mode source</a><p>]]></content>
  </entry>
</feed>
