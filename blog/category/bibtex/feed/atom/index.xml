<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2014-05-19T11:33:45Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Creating bibliographies in other formats with org-ref]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref" />
    <id>http://jkitchin.github.io/blog/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref</id>
    <updated>2014-05-18T11:55:34Z</updated>
    <published>2014-05-18T10:11:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Creating bibliographies in other formats with org-ref]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref"><![CDATA[



<p>
org-ref automatically generates bibliographies in LaTeX export, and it does a reasonable job automatically generating HTML bibliographies (ox-bibtex probably does this better, but it relies on an external program, whereas this approach is all elisp). Here we illustrate how to generate other formats, e.g. plain text, or org-mode formatted.
</p>

<p>
org-ref provides a convenient function that generates a bibliography entry for a key formatted according to the variable org-ref-bibliography-entry-format. This variable is a string that uses the reftex percent escapes to create an entry. The default is setup for an HTML entry like this:
</p>

<pre class="example">
  "%a, %t, &lt;i&gt;%j&lt;/i&gt;, &lt;b&gt;%v(%n)&lt;/b&gt;, %p (%y). &lt;a href=\"%U\"&gt;link&lt;/a&gt;. &lt;a href=\"http://dx.doi.org/%D\"&gt;doi&lt;/a&gt;."
</pre>

<p>
We can redefine it temporarily to get other formats. Here is an example of getting an org-formatted entry with some italics and bold text.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(let ((org-ref-bibliography-entry-format "%a, %t, /%j/, *%v(%n)*, %p (%y). [[%U][link]]. [[http://dx.doi.org/%D][doi]]."))
(org-ref-get-bibtex-entry-citation "andriotis-2014-infor"))
</pre>
</div>

<p>
"Andriotis, Mpourmpakis, , Broderick, Rajan, Datta, Somnath, Sunkara \&amp; Menon, Informatics guided discovery of surface  structure-chemistry relationships in catalytic  nanoparticles, <i>The Journal of Chemical Physics</i>, <b>140(9)</b>, 094705 (2014). <a href="http://scitation.aip.org/content/aip/journal/jcp/140/9/10.1063/1.4867010">link</a> . <a href="http://dx.doi.org/10.1063/1.4867010">doi</a> .
</p>

<p>
Now, we put some citations of various types in for water splitting <a href="#mccrory-2013-bench-heter">mccrory-2013-bench-heter</a>, CO<sub>2</sub> capture <a href="#alesi-2012-evaluat-primar">alesi-2012-evaluat-primar</a>, and microfluidic devices <a href="#voicu-2014-microf-studies">voicu-2014-microf-studies</a>. We will convert these links to a bibliography shortly.
</p>

<p>
Next, we generate an org-formatted bibliography. We will create a bracketed label at the beginning of the entry, and the org-format after that. This is a functional enough bibliography to be useful I think, and it illustrates the ideas. We will do some light transforming to replace escaped &amp; with regular &amp; in the bibliography.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; temorarily redefine the format
(let ((org-ref-bibliography-entry-format "%a, %t, /%j/, *%v(%n)*, %p (%y). [[%U][link]]. [[http://dx.doi.org/%D][doi]]."))

  (mapconcat 
   (lambda (key)
     (format "[%s] %s" key 
	     (replace-regexp-in-string 
	      "\\\\&amp;" 
	      "&amp;" (org-ref-get-bibtex-entry-citation key))))
   (org-ref-get-bibtex-keys) "\n\n"))
</pre>
</div>

<p>
[alesi-2012-evaluat-primar] Alesi &amp; Kitchin, Evaluation of a Primary Amine-Functionalized  Ion-Exchange Resin for \ce{CO_2} Capture, <i>Industrial &amp; Engineering Chemistry Research</i>, <b>51(19)</b>, 6907-6915 (2012). <a href="http://dx.doi.org/10.1021/ie300452c">link</a> . <a href="http://dx.doi.org/10.1021/ie300452c">doi</a> .
</p>

<p>
[mccrory-2013-bench-heter] McCrory, Jung, Peters, Jonas &amp; Jaramillo, Benchmarking Heterogeneous Electrocatalysts for the  Oxygen Evolution Reaction, <i>J. Am. Chem. Soc.</i>, <b>135(45)</b>, 16977&#x2013;16987 (2013). <a href="http://dx.doi.org/10.1021/ja407115p">link</a> . <a href="http://dx.doi.org/10.1021/ja407115p">doi</a> .
</p>

<p>
[voicu-2014-microf-studies] Voicu, Abolhasani, Choueiri, Rachelle, Lestari, Seiler, , Menard, Greener, Guenther, Axel, Stephan &amp; Kumacheva, Microfluidic Studies of \ce{CO_2} Sequestration by  Frustrated {L}ewis Pairs, <i>Journal of the American Chemical Society</i>, <b>0(0)</b>, null (2014). [[][link]]. <a href="http://dx.doi.org/10.1021/ja411601a">doi</a> .
</p>

<p>
You can see some minor issues with the formatting, e.g. sometimes the link is empty, if there is no url in the bibtex entry. There is no easy way to fix that. The 0 and null values in the last entry are because that is an ASAP article, and that is what is in the bibtex entry. I do not try to expand the latex code, and do not plan to do that. I do not know why there appears to be a blank author in the last entry, or why the author full names are not used. Those are reftex issues and  low priority to fix for me. They do not exist in the LaTeX export. The main point here is to get a reasonably useful bibliography that you can adapt as you want.
</p>


<p>
<h1>Bibliography</h1>
<ul><li><a id="alesi-2012-evaluat-primar">[alesi-2012-evaluat-primar] Alesi \& Kitchin, Evaluation of a Primary Amine-Functionalized  Ion-Exchange Resin for \ce{CO_2} Capture, <i>Industrial \& Engineering Chemistry Research</i>, <b>51(19)</b>, 6907-6915 (2012). <a href="http://dx.doi.org/10.1021/ie300452c">link</a>. <a href="http://dx.doi.org/10.1021/ie300452c">doi</a>.</a></li>
<li><a id="mccrory-2013-bench-heter">[mccrory-2013-bench-heter] McCrory, Jung, Peters, Jonas \& Jaramillo, Benchmarking Heterogeneous Electrocatalysts for the  Oxygen Evolution Reaction, <i>J. Am. Chem. Soc.</i>, <b>135(45)</b>, 16977--16987 (2013). <a href="http://dx.doi.org/10.1021/ja407115p">link</a>. <a href="http://dx.doi.org/10.1021/ja407115p">doi</a>.</a></li>
<li><a id="voicu-2014-microf-studies">[voicu-2014-microf-studies] Voicu, Abolhasani, Choueiri, Rachelle, Lestari, Seiler, , Menard, Greener, Guenther, Axel, Stephan \& Kumacheva, Microfluidic Studies of \ce{CO_2} Sequestration by  Frustrated {L}ewis Pairs, <i>Journal of the American Chemical Society</i>, <b>0(0)</b>, null (2014). <a href="">link</a>. <a href="http://dx.doi.org/10.1021/ja411601a">doi</a>.</a></li>
</ul>
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/18/Creating-bibliographies-in-other-formats-with-org-ref.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Using org-ref to keep your bibtex files in order]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order" />
    <id>http://jkitchin.github.io/blog/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order</id>
    <updated>2014-05-15T12:19:49Z</updated>
    <published>2014-05-15T10:59:19Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Using org-ref to keep your bibtex files in order]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. "cleaning" a bibtex entry</a></li>
<li><a href="#sec-2">2. Validating your bibliography</a></li>
<li><a href="#sec-3">3. Sorting your bibtex file</a></li>
<li><a href="#sec-4">4. Make a full bibliography pdf</a></li>
<li><a href="#sec-5">5. Finding bad citation links</a></li>
<li><a href="#sec-6">6. Extracting citations entries</a></li>
<li><a href="#sec-7">7. Summary</a></li>
<li><a href="#sec-8">8. References</a></li>
<li><a href="#sec-9">9. Bibtex entries</a></li>
</ul>
</div>
</div>

<p>
Maintaining an accurate, useful bibliography of references is critical for scientific writing. It is also not trivial. While it is easy to download and copy bibliographic entries to your database, these entries are often incomplete, not consistently formatted, and can contain invalid characters. org-ref provides several utility functions to help with this.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> "cleaning" a bibtex entry</h2>
<div class="outline-text-2" id="text-1">
<p>
Consider this bibtex entry from <a href="http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j">http://pubs.acs.org/action/showCitFormats?doi=10.1021%2Fie500588j</a> .
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{doi:10.1021/ie500588j,
author = {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami and Takeda, Yohei and Minamisawa, Hikari M. and Haeiwa, Tetsuji and Sakai, Toshio and Mishima, Shozi},
title = {Magnetic Rattle-Type Coreâ€“Shell Particles Containing Iron Compounds with Acid Tolerance by Dense Silica},
journal = {Industrial &amp; Engineering Chemistry Research},
volume = {0},
number = {0},
pages = {null},
year = {0},
doi = {10.1021/ie500588j},

URL = {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
eprint = {http://pubs.acs.org/doi/pdf/10.1021/ie500588j}
}
</pre>
</div>

<p>
On the surface it looks fine, but there are the following issues with it:
</p>

<ol class="org-ol">
<li>The bibtex key is hard to remember. I like systematically named keys.
</li>
<li>There is a bare &amp; in the journal title, which is not legal in LaTeX.
</li>
<li>There is no year entry, even though it is a 2014 entry. The pages, volume, and number are also problematic, but this is an ASAP article and the reference does not have those yet.
</li>
<li>It is hard to see, but the dash between core and shell is a non-ascii character, which can cause problems in LaTeX.
</li>
<li>The entry is not very nicely aligned or indented.
</li>
</ol>

<p>
You can fix these problems by putting your cursor on the bibtex entry, and typing M-x org-ref-clean-bibtex-entry. This will fix the bibtex key to a standard form, align and indent the entry, escape the &amp; so it is legal syntax, prompt you for a year, and show you the non-ascii characters so you can replace them. The resulting, nicely formatted entry is shown below.
</p>

<div class="org-src-container">

<pre class="src src-bibtex">@article{okada-2014-magnet-rattl,
  author =	 {Okada, Tomohiko and Ozono, Shoya and Okamoto, Masami
                  and Takeda, Yohei and Minamisawa, Hikari M. and
                  Haeiwa, Tetsuji and Sakai, Toshio and Mishima,
                  Shozi},
  title =	 {Magnetic Rattle-Type Core-Shell Particles Containing
                  Iron Compounds with Acid Tolerance by Dense Silica},
  journal =	 {Industrial \&amp; Engineering Chemistry Research},
  volume =	 0,
  pages =	 {null},
  year =	 2014,
  doi =		 {10.1021/ie500588j},
  number =	 0,
  url =		 {http://pubs.acs.org/doi/abs/10.1021/ie500588j},
  eprint =	 {http://pubs.acs.org/doi/pdf/10.1021/ie500588j},
}
</pre>
</div>

<p>
The key formatting comes from these definitions:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">;; variables that control bibtex key format for auto-generation
;; I want firstauthor-year-title-words
;; this usually makes a legitimate filename to store pdfs under.
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator "-"
      bibtex-autokey-year-title-separator "-"
      bibtex-autokey-titleword-separator "-"
      bibtex-autokey-titlewords 2
      bibtex-autokey-titlewords-stretch 1
      bibtex-autokey-titleword-length 5)
</pre>
</div>

<p>
You should develop a discipline to clean each entry as you add them, and before you cite them. It is a pain to change the key, and then find and change all the places you used that key before. Now that you have a systematic key, go ahead and download the pdf for the article, and save it in your pdf directory by that key name. Set the variable org-ref-pdf-directory to this directory, and later when you click on citations you will be able to open the pdf easily.
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Validating your bibliography</h2>
<div class="outline-text-2" id="text-2">
<p>
<pre>elisp:bibtex-validate</pre> will check your bibliography for valid syntax. This is a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Sorting your bibtex file</h2>
<div class="outline-text-2" id="text-3">
<p>
It is a good idea to keep your bibtex file sorted. This will facilitate finding duplicate entries, and will make it easier to find things. I usually add entries to the top of the file, and then clean them. Then run the command <pre>elisp:bibtex-sort-buffer</pre> . This will sort the entries for you. This is also a bibtex command.
</p>

<p>
<a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Make a full bibliography pdf</h2>
<div class="outline-text-2" id="text-4">
<p>
A good way to check your bibliography for duplicates, spelling errors, and invalid formats is to make a pdf containing all the entries. Open your bibtex file, and run <pre>elisp:org-ref-build-full-bibliography</pre> . If all goes well, you will get a pdf of your bibliography that you can check for accuracy. If there are errors, you will have to fix them until the pdf is generated.
</p>

<p>
Try it out: <a href="/media/2014-05-15-Using-org-ref-to-keep-your-bibtex-files-in-order/org-bib.bib">org-bib.bib</a> 
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Finding bad citation links</h2>
<div class="outline-text-2" id="text-5">
<p>
Sometimes you will get bad citation links in your document. Maybe there is no corresponding entry, maybe you typed in the wrong key, maybe you changed the key. Either way, you need to find them and fix them. Run the command <pre>elisp:org-ref-find-bad-citations</pre> to find them. <pre>cite:test</pre> 
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Extracting citations entries</h2>
<div class="outline-text-2" id="text-6">
<p>
You will often work from your default bibliography for your own work. Eventually you will need to extract the entries cited so you can send them to someone. The command  <pre>elisp:org-ref-extract-bibtex-entries</pre> will do that for you. If I have cited something <pre>cite:calle-vallejo-2010-trend-stabil</pre> .
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Summary</h2>
<div class="outline-text-2" id="text-7">
<p>
You can see a screen cast of this post here: <a href="http://screencast.com/t/yZCOdO6kJ">http://screencast.com/t/yZCOdO6kJ</a> 
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> References</h2>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> Bibtex entries</h2>
<div class="outline-text-2" id="text-9">
<p>
#+BEGIN<sub>SRC</sub>: text :tangle extract-bib7108tYg.bib
@article{calle-vallejo-2010-trend-stabil,
  author =         {Calle-Vallejo, F. and Martinez, J. I. and Garcia-
                  Lastra, J. M. and Mogensen, M. and Rossmeisl, J.},
  title =         {Trends in Stability of Perovskite Oxides},
  journal =         "Angewandte Chemie-International Edition",
  volume =         49,
  number =         42,
  pages =         {7699-7701},
  year =         2010,
  doi =                 {10.1002/anie.201002301},
  keyword =         {density functional calculations heats of formation
                  perovskites thermochemistry transition-metals
                  catalysts ferroelectricity},
}
#+END<sub>SRC</sub>
</p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/05/15/Using-org-ref-to-keep-your-bibtex-files-in-order.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A popup menu for citation links in org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode</id>
    <updated>2014-04-28T10:13:17Z</updated>
    <published>2014-04-28T10:13:17Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A popup menu for citation links in org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/28/A-popup-menu-for-citation-links-in-org-mode"><![CDATA[



<p>
I have been exploring ways to get more information out of links in org-mode. I have considered <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/04/12/Popup-tips-on-bibtex-links-in-org-mode/">popups</a> , and <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/10/21/Enabling-right-clicks-in-org-mode-links/">right-clicking</a> . Here I show how to get a popup menu on a citation link. The idea is that clicking or opening the ditation link should give you a menu. The menu should give you some context, e.g. if the bibtex key even exists. If it does, you should be able to get a quick view of the citation in the minibuffer. You should be able to open the entry in the bibtex file from the menu. If you have a pdf of the reference, you should have an option to open it. You should be able to open the url associated with the entry from the menu too.
</p>

<p>
Here is the function. We use <a href="https://github.com/auto-complete/popup-el">https://github.com/auto-complete/popup-el</a> , and some code from <a href="https://github.com/jkitchin/jmax/blob/master/jorg-bib.el">https://github.com/jkitchin/jmax/blob/master/jorg-bib.el</a> .
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-add-link-type
 "cite"
 ;; this function is run when you click on the link
 (lambda (link-string) 
   (let* ((menu-choice)
         ;; this is in jorg-bib.el
         (results (get-bibtex-key-and-file))
	 (key (car results))
	 (cb (current-buffer))
         (pdf-file (format (concat jorg-bib-pdf-directory "%s.pdf") key))
         (bibfile (cdr results)))
     (setq menu-choice
	   (popup-menu* 
	    (list (popup-make-item (if 
				       (progn
					 (let ((cb (current-buffer)) result)					
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       "Simple citation"
				     "No key found")  :value "cite")
		  (popup-make-item (if
				       (progn
					 (let ((cb (current-buffer)) result)					  
					   (find-file bibfile)
					   (setq result (bibtex-search-entry key))
					   (switch-to-buffer cb)
					   result))
				       (format "Open %s in %s" key bibfile)
				     "No key found") :value "bib")
		  (popup-make-item 
		   ;; check if pdf exists.jorg-bib-pdf-directory is a user defined directory.
                   ;; pdfs are stored by bibtex key in that directory
		   (if (file-exists-p pdf-file)
		       (format "Open PDF for %s" key)
		     "No pdf found") :value "pdf")
		  (popup-make-item "Open URL" :value "web")
		  (popup-make-item "Open Notes" :value "notes")
		  )))

     (cond
      ;; goto entry in bibfile
      ((string= menu-choice "bib")       
       (find-file bibfile)
       (bibtex-search-entry key))

      ;; goto entry and try opening the url
      ((string= menu-choice "web")   
       (let ((cb (current-buffer)))
	 (save-excursion
	   (find-file bibfile)
	   (bibtex-search-entry key)
	   (bibtex-url))
	 (switch-to-buffer cb)))
       
      ;; goto entry and open notes, create notes entry if there is none
      ((string= menu-choice "notes")   
       (find-file bibfile)
       (bibtex-search-entry key)       
       (jorg-bib-open-bibtex-notes))

     ;; open the pdf file if it exists
     ((string= menu-choice "pdf")
      (when (file-exists-p pdf-file)
	  (org-open-file pdf-file)))

     ;; print citation to minibuffer
     ((string= menu-choice "cite")
      (let ((cb (current-buffer)))	
	(message "%s" (save-excursion (find-file bibfile)
				      (bibtex-search-entry key)  
				      (jorg-bib-citation)))
	(switch-to-buffer cb))))))
 ;; formatting
(lambda (keyword desc format)
   (cond
    ((eq format 'html) (format "(&lt;cite&gt;%s&lt;/cite&gt;)" path))
    ((eq format 'latex)
     (concat "\\cite{"
	     (mapconcat (lambda (key) key) (cite-split-keys keyword) ",")
	     "}")))))
</pre>
</div>


<p>
<pre>cite:daza-2014-carbon-dioxid,mehta-2014-ident-poten,test,ahuja-2001-high-ruo2</pre> 
</p>


<p>

</p>



<p>
Here you can see an example of a menu where I have the PDF:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-1.png"> 
</p>
</div>

<p>
Here is an example menu of a key with no entry:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-2.png"> 
</p>

<p>
And, and entry with no PDF:
<img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-3.png"> 
</p>

<p>
Here is the simple citation:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-4.png"> 
</p>
</div>

<p>
And a reference from the other bibliography:
</p>


<div class="figure">
<p><img src="/media/2014-04-28-A-popup-menu-for-citation-links-in-org-mode/cite-menu-5.png"> 
</p>
</div>

<p>
Not bad! I will probably replace the cite link in jorg-bib with something like this.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/28/A-popup-menu-for-citation-links-in-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[A better insert citation function for org-mode]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode" />
    <id>http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode</id>
    <updated>2014-04-27T14:40:45Z</updated>
    <published>2014-04-27T14:40:45Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[A better insert citation function for org-mode]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/27/A-better-insert-citation-function-for-org-mode"><![CDATA[



<p>
I have setup a reftex citation format that inserts a cite link using reftex like this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(eval-after-load 'reftex-vars
  '(progn
      (add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l"))))))
</pre>
</div>

<p>
I mostly like this, but it does not let me add citations to an existing citation; doing that leads to the insertion of an additional cite within the citation, which is an error. One way to make this simple is to add another cite format which simple returns the selected keys. You would use this with the cursor at the end of the link, and it will just append the results.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'reftex-cite-format-builtin
                   '(org "Org-mode citation"
                         ((?\C-m . "cite:%l")
			  (?a . ",%l"))))
</pre>
</div>

<p>
That actually works nicely. I would like a better approach though, that involves less keywork. Ideally, a single function that does what I want, which is when on a link, append to it, and otherwise insert a new citation link. Today I will develop a function that fixes that problem. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(defun insert-cite-link ()
  (interactive)
  (let* ((object (org-element-context))
	 (link-string-beginning (org-element-property :begin object))
	 (link-string-end (org-element-property :end object))
	 (path (org-element-property :path object)))    
    (if (and (equal (org-element-type object) 'link) 
               (equal (org-element-property :type object) "cite"))
	(progn
	  (goto-char link-string-end)
	  (insert (concat "," (mapconcat 'identity (reftex-citation t ?a) ","))))
      (insert (concat "cite:" (mapconcat 'identity (reftex-citation t) ",")))
      )))
</pre>
</div>

<p>
That function is it! Org-mode just got a lot better. That function only puts a cite link in, but since that is all I use 99.99+% of the time, it works fine for me!
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/27/A-better-insert-citation-function-for-org-mode.org">org-mode source</a><p><p>Org-mode version = 8.2.6</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Multiple search criteria to find bibtex entries]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries" />
    <id>http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries</id>
    <updated>2014-04-08T20:45:35Z</updated>
    <published>2014-04-08T20:45:35Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Multiple search criteria to find bibtex entries]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries"><![CDATA[



<p>
I have been thinking about ways to search my bibtex file with multiple criteria. Eventually, I want a decent natural language search like "au=kitchin and alloy" to find papers authored by me about alloys. For now, I am going to settle with a way to find these. This strategy will create a search function that prints the entries that are found. Here is the prototype idea:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">my-search</span> (key start end)
  (<span style="color: #8b0000;">when</span> (and (re-search-forward <span style="color: #228b22;">"kitchin"</span> end t)
           (re-search-forward <span style="color: #228b22;">"alloy"</span> end t))
      (princ (format <span style="color: #228b22;">"%s\n"</span> (buffer-substring start end)))))

(<span style="color: #8b0000;">with-temp-buffer</span>
  (insert-file-contents <span style="color: #228b22;">"../../bibliography/references.bib"</span>)
  (bibtex-map-entries  'my-search))
</pre>
</div>

<pre class="example">
@ARTICLE{inoglu-2011-ident-sulfur,
  pdf =		 {[[file:bibtex-pdfs/inoglu-2011-ident-sulfur.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::inoglu-2011-ident-sulfur]]},
  author =	 {Inoglu, Nilay and Kitchin, John R.},
  title =	 {Identification of Sulfur-Tolerant Bimetallic
                  Surfaces Using {DFT} Parametrized Models and
                  Atomistic Thermodynamics},
  journal =	 {ACS Catalysis},
  year =	 2011,
  pages =	 {399--407},
  abstract =	 {The identification of sulfur-tolerant alloys for
                  catalytic applications is difficult due to the
                  combinatorially large number of alloy compositions
                  and surface structures that may be
                  considered. Density functional theory calculations
                  (DFT) are not fast enough to enumerate all the
                  possible structures and their sulfur tolerance. In
                  this work, a DFT parametrized algebraic model that
                  accounts for structure and composition was used to
                  estimate the d-band properties and sulfur adsorption
                  energies of 370 transition metal-based bimetallic
                  alloy surfaces.  The estimated properties were
                  validated by DFT calculations for 110 of the surface
                  structures. We then utilized an atomistic
                  thermodynamic framework that includes surface
                  segregation, the presence of adsorbates, and effects
                  of environmental conditions to identify alloy
                  compositions and structures with enhanced sulfur
                  tolerance that are likely to be stable under the
                  environmental conditions. As a case study, we show
                  how this database can be used to identify
                  sulfur-tolerant Cu-based catalysts and compare the
                  results with what is known about these catalysts
                  experimentally.},
  doi =		 {10.1021/cs200039t},
  issn =	 {null},
  type =	 {Journal Article}
}
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
@ARTICLE{tierney-2009-hydrog-dissoc,
  pdf =		 {[[file:bibtex-pdfs/tierney-2009-hydrog-dissoc.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::tierney-2009-hydrog-dissoc]]},
  author =	 {Tierney, H. L. and Baber, A. E. and Kitchin,
                  J. R. and Sykes, E.  C. H.},
  title =	 {Hydrogen Dissociation and Spillover on Individual
                  Isolated Palladium Atoms},
  journal =	 {Physical Review Letters},
  year =	 2009,
  volume =	 103,
  number =	 24,
  abstract =	 {Using a combination of low-temperature scanning
                  tunneling microscopy and density functional theory
                  it is demonstrated how the nature of an inert host
                  metal of an alloy can affect the thermodynamics and
                  kinetics of a reaction pathway in a much more
                  profound way than simply a dilution, electronic, or
                  geometric effect. This study reveals that
                  individual, isolated Pd atoms can promote H-2
                  dissociation and spillover onto a Cu(111) surface,
                  but that the same mechanism is not observed for an
                  identical array of Pd atoms in Au(111).},
  pages =	 246102,
  doi =		 {10.1103/PhysRevLett.103.246102},
  issn =	 {0031-9007},
  url =		 {http://prl.aps.org/abstract/PRL/v103/i24/e246102},
  type =	 {Journal Article}
}
</pre>

<p>
That is not too bad. If I had a parser like <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/03/31/Using-pyparsing-for-search-queries-with-tags/">this one</a> , I could do some reasonable searches. I could try integrating it with reftex or something similar for selecting citations. I would like that a lot.
</p>

<p>
What if I wanted to find articles with Kitchin as an author, and alloy in the title? This is my best effort at doing that, where I explicitly match the fields in the bibtex entries.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end) 
                      (<span style="color: #8b0000;">let*</span> ((entry (bibtex-parse-entry))
                             (title (cdr (assoc <span style="color: #228b22;">"title"</span> entry)))
                             (authors (cdr (assoc <span style="color: #228b22;">"author"</span> entry))))
                        (<span style="color: #8b0000;">when</span> (and title (string-match <span style="color: #228b22;">"alloy"</span> title) 
                                   authors (string-match <span style="color: #228b22;">"kitchin"</span> authors))
                          (princ (buffer-substring start end)))))))
</pre>
</div>

<pre class="example">
@ARTICLE{kitchin-2008-alloy,
  pdf =		 {[[file:bibtex-pdfs/kitchin-2008-alloy.pdf]]},
  org-notes =
                  {[[file:~/Dropbox/bibliography/notes.org::kitchin-2008-alloy]]},
  author =	 {Kitchin, J. R. and Reuter, K. and Scheffler, M.},
  title =	 {Alloy surface segregation in reactive environments:
                  First-principles atomistic thermodynamics study of
                  \ce{Ag_3Pd}(111) in oxygen atmospheres},
  journal =	 {Physical Review B},
  year =	 2008,
  volume =	 77,
  number =	 7,
  abstract =	 {We present a first-principles atomistic
                  thermodynamics framework to describe the structure,
                  composition, and segregation profile of an alloy
                  surface in contact with a (reactive)
                  environment. The method is illustrated with the
                  application to a Ag3Pd(111) surface in an oxygen
                  atmosphere, and we analyze trends in segregation,
                  adsorption, and surface free energies. We observe a
                  wide range of oxygen adsorption energies on the
                  various alloy surface configurations, including
                  binding that is stronger than on a Pd(111) surface
                  and weaker than that on a Ag(111) surface. This and
                  the consideration of even small amounts of
                  nonstoichiometries in the ordered bulk alloy are
                  found to be crucial to accurately model the Pd
                  surface segregation occurring in increasingly O-rich
                  gas phases.},
  doi =		 {http://dx.doi.org/10.1103/PhysRevB.77.075437},
  pages =	 075437,
  issn =	 {1098-0121},
  type =	 {Journal Article}
}
</pre>

<p>
This is a more precise search, which yields only one entry. That is not exactly nimble searching, but it does provide precision. I need to think about this some more.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/04/08/Multiple-search-criteria-to-find-bibtex-entries.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Extracting bibtex file from an org-buffer]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/02/19/Extracting-bibtex-file-from-an-org-buffer" />
    <id>http://jkitchin.github.io/blog/2014/02/19/Extracting-bibtex-file-from-an-org-buffer</id>
    <updated>2014-02-19T19:27:20Z</updated>
    <published>2014-02-19T18:45:27Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="org-mode" />
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Extracting bibtex file from an org-buffer]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/02/19/Extracting-bibtex-file-from-an-org-buffer"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Bibtex entries</a></li>
</ul>
</div>
</div>

<p>
We use citation links a lot in our org-files, like this: <pre>cite:thompson-2014-co2-react</pre> . Sometimes there are multiple citations like this <pre>cite:mehta-2014-ident-poten,hallenbeck-2013-effec-o2</pre> . It would be convenient at times to extract a bibtex file from these citations. That way we could easily share files. This is possible in RefTeX from a LaTeX file. Org makes it easy to export to LaTeX, so this seems like it should be easy. It would be easy, if I always put the bibliography link in the file. I usually do not, so let us check if that is the case, and if it is not add the bibliography to the end before we export. Then, with the LaTeX file in hand, we open it, and call the RefTeX functions to get the bibliography. Finally, we will create a link to the actual created file, and add it as a source block that can be tangled at the end of the file.
</p>

<p>
Here is a function that does the extraction and some house cleaning. We actually take the contents of the buffer and save it in a temporary file, so that we do not accidentally clobber a tex or bibtex file here.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">kg-extract-bibtex</span> ()
  <span style="color: #228b22;">"create bibtex file of entries cited in this buffer"</span>

  (<span style="color: #8b0000;">let*</span> ((tempname (make-temp-file <span style="color: #228b22;">"extract-bib"</span>))
         (contents (buffer-string))
         (cb (current-buffer))
         basename texfile bibfile results)
    
    (find-file tempname)
    (insert contents)
    (setq basename (file-name-sans-extension 
                    (file-name-nondirectory buffer-file-name))
          texfile (concat basename <span style="color: #228b22;">".tex"</span>)
          bibfile (concat basename <span style="color: #228b22;">".bib"</span>))

  (<span style="color: #8b0000;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #8b0000;">unless</span> (re-search-forward <span style="color: #228b22;">"^bibliography:"</span> (point-max) 'end)
      (insert (format <span style="color: #228b22;">"\nbibliography:%s"</span> (mapconcat 'identity reftex-default-bibliography <span style="color: #228b22;">","</span>)))))

    (org-latex-export-to-latex)
    (find-file texfile)
    (reftex-parse-all)
    (reftex-create-bibtex-file bibfile)
    (setq results (buffer-string))
    (kill-buffer bibfile)
    (kill-buffer texfile)
    (delete-file texfile)
    (delete-file tempname)

    (switch-to-buffer cb)
    (<span style="color: #8b0000;">save-excursion</span>
      (goto-char (point-max))
      (insert (format <span style="color: #228b22;">"</span>

<span style="color: #228b22;">** Bibtex entries</span>

<span style="color: #228b22;">#+BEGIN_EXAMPLE: </span>
<span style="color: #228b22;">%s</span>
<span style="color: #228b22;">#+END_EXAMPLE"</span> results)))))

(kg-extract-bibtex)
</pre>
</div>

<p>
There it is! The src block does not render in HTML very well, since it appears to be simple text. It looks fine in the org file though.
</p>

<p>
It might be a good idea to replace the bibliography line with the new file, but I will leave that as an exercise for later.
</p>




<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Bibtex entries</h2>
<div class="outline-text-2" id="text-1">
<p>
#+BEGIN<sub>EXAMPLE</sub>: 
@article{hallenbeck-2013-effec-o2,
  author =         "Hallenbeck, Alexander P. and Kitchin, John R.",
  title =         "Effects of \ce{O_2} and \ce{SO_2} on the Capture
                  Capacity of a Primary-Amine Based Polymeric
                  \ce{CO_2} Sorbent",
  year =         2013,
  doi =                 "10.1021/ie400582a",
  eprint =         "<a href="http://pubs.acs.org/doi/pdf/10.1021/ie400582a">http://pubs.acs.org/doi/pdf/10.1021/ie400582a</a> ",
  journal =         "Industrial \&amp; Engineering Chemistry Research",
  pages =         "10788-10794",
  url =                 "<a href="http://pubs.acs.org/doi/abs/10.1021/ie400582a">http://pubs.acs.org/doi/abs/10.1021/ie400582a</a> ",
}
</p>

<p>
@article{mehta-2014-ident-poten,
  author =         {Mehta, Prateek and Salvador, Paul A. and Kitchin,
                  John R.},
  title =         {Identifying Potential BO2 Oxide Polymorphs for
                  Epitaxial Growth Candidates},
  journal =         {ACS Applied Materials \&amp; Interfaces},
  volume =         0,
  number =         0,
  pages =         {null},
  year =         2014,
  doi =                 {10.1021/am4059149},
  URL =                 {<a href="http://pubs.acs.org/doi/abs/10.1021/am4059149">http://pubs.acs.org/doi/abs/10.1021/am4059149</a> },
  eprint =         {<a href="http://pubs.acs.org/doi/pdf/10.1021/am4059149">http://pubs.acs.org/doi/pdf/10.1021/am4059149</a> }
}
</p>

<p>
@Article{thompson-2014-co2-react,
  author =         {Thompson, Robert L. and Albenze, Erik and Shi, Wei
                  and Hopkinson, David and Damodaran, Krishnan and
                  Lee, Anita and Kitchin, John and Luebke, David
                  Richard and Nulwala, Hunaid},
  title =         {\ce{CO_2} Reactive Ionic Liquids: Effects of
                  functional groups on the anion and its influence on
                  the physical properties},
  journal =         {RSC Adv.},
  year =         2014,
  pages =         "-",
  publisher =         {The Royal Society of Chemistry},
  doi =                 {10.1039/C3RA47097K},
  url =                 {<a href="http://dx.doi.org/10.1039/C3RA47097K">http://dx.doi.org/10.1039/C3RA47097K</a> },
  abstract =         "Next generation of gas separation materials are
                  needed to alleviate issues faced in energy and
                  environmental area. Ionic liquids (ILs) are
                  promising class of material for CO2 separations. In
                  this work{,} CO2 reactive triazolides ILs were
                  synthesized and characterized with the aim of
                  developing deeper understanding on how structural
                  changes affect the overall properties for CO2
                  separation. Important insights were gained
                  illustrating the effects of substituents on the
                  anion. It was found that substituents play a crucial
                  role in dictating the overall physical properties of
                  reactive ionic liquids. Depending upon the
                  electronic and steric nature of the substituent{,}
                  CO2 capacities between 0.07-0.4 mol CO2/mol IL were
                  observed. Detailed spectroscopic{,} CO2
                  absorption{,} rheological{,} and simulation studies
                  were carried out to understand the nature and
                  influence of these substituents. The effect of water
                  content was also evaluated{,} and it was found that
                  water had an unexpected impact on the properties of
                  these materials{,} resulting in an increased
                  viscosity{,} but little change in the CO2
                  reactivity."
}
#+END<sub>EXAMPLE</sub></p>
</div>
</div>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/02/19/Extracting-bibtex-file-from-an-org-buffer.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Merging bibtex files and avoiding duplicates]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/02/10/Merging-bibtex-files-and-avoiding-duplicates" />
    <id>http://jkitchin.github.io/blog/2014/02/10/Merging-bibtex-files-and-avoiding-duplicates</id>
    <updated>2014-02-10T07:42:49Z</updated>
    <published>2014-02-10T07:42:49Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Merging bibtex files and avoiding duplicates]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/02/10/Merging-bibtex-files-and-avoiding-duplicates"><![CDATA[


<p>
I usually advocate to have a master bibtex file with all entries in it. Emacs is helpful at avoiding duplicate entries as you enter them. Sometimes though, you have more than one bibtex file. Maybe you started one for a new project, or someone sent you one. In any case, you want to merge the files into one file. Bibtex requires each entry to have a unique key. 
</p>

<p>
Let us begin. I have two bibtex files I exported from Endnote. I have
already removed all the non-ascii characters and cleaned them up
pretty well. We start with some analysis. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser
<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries1</span> = bp.get_entry_list()

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} entries in file 1'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">len</span>(entries1))

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/perovskite-strain/perovskite-strain.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries2</span> = bp.get_entry_list()

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0} entries in file 2'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">len</span>(entries2))
</pre>
</div>

<pre class="example">
100 entries in file 1
129 entries in file 2
</pre>

<p>
Now, let see how many duplicates there are. It is easy to use sets for this.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">store keys to check for duplicates</span>
<span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser
<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries1</span> = bp.get_entry_list()

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/perovskite-strain/perovskite-strain.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries2</span> = bp.get_entry_list()

<span style="color: #8b008b;">entry1_keys</span> = <span style="color: #cd0000;">set</span>([entry[<span style="color: #228b22;">'id'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries1])
<span style="color: #8b008b;">entry2_keys</span> = <span style="color: #cd0000;">set</span>([entry[<span style="color: #228b22;">'id'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries2])

<span style="color: #8b008b;">duplicates</span> = entry1_keys &amp; entry2_keys
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'There are {0} duplicates'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">len</span>(duplicates))
<span style="color: #8b0000;">print</span> duplicates
</pre>
</div>

<pre class="example">
There are 20 duplicates
set(['nolan-2008-vacan-co', 'giocondi-2001-spatial', 'giocondi-2001-spatial-batio3', 'wang-2006-oxidat-gga', 'piskunov-2008-elect-lamno3', 'pala-2007-modif-oxidat', 'chretien-2006-densit-funct', 'giocondi-2008-sr2nb-batio3', 'kushima-2010-compet-lacoo3', 'pala-2009-co-ti', 'giocondi-2007-srtio3', 'lee-2009-ab-labo3', 'balasubramanian-2005-epitax-phase', 'mastrikov-2010-pathw-oxygen', 'shapovalov-2007-catal', 'evarestov-2005-compar-lcao', 'choi-2007-comput-study', 'havelia-2009-nucleat-growt', 'lee-2009-ab-defec', 'lee-2009-predic-surfac'])
</pre>

<p>
Ok, now we make a function to format each entry. We take that code from this <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/02/09/Sorting-fields-in-bibtex-entries/">this post</a> and turn it into a function. Then we add all the entries from the first file. Then, we add entries from the second file as long as the key is not in the list from the first file.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser
<span style="color: #8b0000;">import</span> os, textwrap

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">format_bibtex_entry</span>(entry):
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">field, format, wrap or not</span>
    <span style="color: #8b008b;">field_order</span> = [(u<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'title'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'journal'</span>,<span style="color: #228b22;">'"{0}",\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'volume'</span>,<span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'number'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'pages'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'year'</span>, <span style="color: #228b22;">'{0},\n'</span>, <span style="color: #cd0000;">True</span>),
                   (u<span style="color: #228b22;">'doi'</span>,<span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">False</span>),
                   (u<span style="color: #228b22;">'url'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>),
                   (u<span style="color: #228b22;">'link'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>)]
    
    <span style="color: #8b008b;">keys</span> = <span style="color: #cd0000;">set</span>(entry.keys())

    <span style="color: #8b008b;">extra_fields</span> = keys.difference([f[0] <span style="color: #8b0000;">for</span> f <span style="color: #8b0000;">in</span> field_order])
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we do not want these in our entry</span>
    extra_fields.remove(<span style="color: #228b22;">'type'</span>)
    extra_fields.remove(<span style="color: #228b22;">'id'</span>)

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Now build up our entry string</span>
    <span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'@{type}{{{id},\n'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">type</span>=entry[<span style="color: #228b22;">'type'</span>].upper(),
                                  <span style="color: #cd0000;">id</span>=entry[<span style="color: #228b22;">'id'</span>])

    <span style="color: #8b0000;">for</span> field, fmt, wrap <span style="color: #8b0000;">in</span> field_order:
        <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
            <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
            <span style="color: #8b008b;">s2</span> = fmt.<span style="color: #cd0000;">format</span>(entry[field])
            <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{1}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
            <span style="color: #8b0000;">if</span> wrap:
                <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">fill seems to remove trailing '\n'</span>
                <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
            <span style="color: #8b008b;">s</span> += s3  

    <span style="color: #8b0000;">for</span> field <span style="color: #8b0000;">in</span> extra_fields:
        <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
            <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
            <span style="color: #8b008b;">s2</span> = entry[field]
            <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{{{1}}}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
            <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
            <span style="color: #8b008b;">s</span> += s3  

    <span style="color: #8b008b;">s</span> += <span style="color: #228b22;">'}\n\n'</span>
    <span style="color: #8b0000;">return</span> s

<span style="color: #8b0000;">if</span> os.path.exists(<span style="color: #228b22;">'merged.bib'</span>): os.unlink(<span style="color: #228b22;">'merged.bib'</span>)    

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries1</span> = bp.get_entry_list()

<span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries1:
    <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'merged.bib'</span>, <span style="color: #228b22;">'a'</span>) <span style="color: #8b0000;">as</span> f:
        f.write(format_bibtex_entry(entry))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">store keys to check for duplicates</span>
<span style="color: #8b008b;">entry1_keys</span> = [entry[<span style="color: #228b22;">'id'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries1]

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/perovskite-strain/perovskite-strain.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries2</span> = bp.get_entry_list()

<span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries2:
    <span style="color: #8b0000;">if</span> <span style="color: #8b0000;">not</span> entry[<span style="color: #228b22;">'id'</span>] <span style="color: #8b0000;">in</span> entry1_keys:
        <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'merged.bib'</span>, <span style="color: #228b22;">'a'</span>) <span style="color: #8b0000;">as</span> f:
            f.write(format_bibtex_entry(entry))
</pre>
</div>

<p>
Here is the merged file: <a href="/media/2014-02-10-Merging-bibtex-files-and-avoiding-duplicates/merged.bib">merged.bib</a> and the corresponding bibliography <a href="/media/2014-02-10-Merging-bibtex-files-and-avoiding-duplicates/merged.pdf">merged.pdf</a> . There are 209 entries in it, which is what we expected given that there were 20 duplicates. There are no doubt other programs that merge bibtex files, but I like this approach for the following reasons:
</p>
<ol class="org-ol">
<li>I learned a new python module that parses bibtex files.
</li>
<li>I got my entries formatted exactly the way I wanted them.
</li>
<li>I defined what constituted a duplicate.
</li>
</ol>

<p>
Of course, here we only eliminate entries with duplicate keys. If the same entry has different keys, they will be merged. This is a very hard problem to get right, since there are many possible ways to abbreviate author names, journal names, and multiple ways to write the title. That is a problem best solved by using a systematic way of generating the keys, so that you minimize the possibility of duplicates that way.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/02/10/Merging-bibtex-files-and-avoiding-duplicates.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Sorting fields in bibtex entries]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/02/09/Sorting-fields-in-bibtex-entries" />
    <id>http://jkitchin.github.io/blog/2014/02/09/Sorting-fields-in-bibtex-entries</id>
    <updated>2014-02-09T15:22:18Z</updated>
    <published>2014-02-09T15:22:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Sorting fields in bibtex entries]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/02/09/Sorting-fields-in-bibtex-entries"><![CDATA[



<p>
I like consistency. In particular, for bibtex entries, I would like
all the fields to be in the same order, and in all caps. Why? Because then I know where to look, and incorrect entries stand out more easily. My current
bibtex file does not look like this! That is a result of adding bibtex
entries from various journals, which all have different
conventions. Today, I am going to look at a way to achieve what I
want.
</p>

<p>
The principle idea is that we will parse the bibtex file into a list
of entries represented by a convenient data structure. Then, we will
format each entry the way we want, and print the result back out to a
new file. I will use <a href="https://bibtexparser.readthedocs.org/en/latest/index.html">bibtexparser</a> and python to do this. 
</p>

<p>
Let us examine what bibtexparser does for us. Here we read in a file
and get the entries. Each entry is represented as a dictionary.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries</span> = bp.get_entry_list()

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">look at the first entry</span>
<span style="color: #8b0000;">print</span> entries[0]
</pre>
</div>

<pre class="example">
{u'title': u'Effect of growth conditions on formation of TiO2-II\nthin films in atomic layer deposition process', u'journal': u'Journal of Crystal Growth', u'author': u'Aarik, J. and Aidla, A. and Sammelselg, V. and\nUustare, T.', u'number': u'3', 'id': 'aarik-1997-effec-tio2', u'volume': u'181', u'link': u'&lt;Go to ISI&gt;://A1997YD52700011', u'year': u'1997', 'type': u'article', u'pages': u'259-264'}
</pre>


<p>
Let us take a moment to analyze our bibtex file. Let us see how many
types of entries we have. That gives a chance to practice <a href="http://kitchingroup.cheme.cmu.edu/blog/2013/05/29/Getting-a-dictionary-of-counts/">counting</a> .
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries</span> = bp.get_entry_list()

<span style="color: #8b008b;">types</span> = [entry[<span style="color: #228b22;">'type'</span>] <span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries]
<span style="color: #8b0000;">print</span> <span style="color: #cd0000;">dict</span>((typ, types.count(typ)) <span style="color: #8b0000;">for</span> typ <span style="color: #8b0000;">in</span> types)
</pre>
</div>

<pre class="example">
{u'inbook': 2, u'article': 90, u'book': 4, u'misc': 3, u'phdthesis': 1}
</pre>

<p>
Indeed, there are a lot of entries that we do not want to do by hand. Here is the order I would like the fields to be for articles. A similar order for the other types would be fine too.
</p>

<pre class="example">
AUTHOR
TITLE
JOURNAL
VOLUME
ISSUE
PAGES
YEAR
DOI
URL or link
other fields
</pre>

<p>
Bibtex lets you define arbitrary fields, and we do not want to lose
these in the entries. I have for example defined fields for the path to a pdf, or to a notes file in some files. We will use python sets to handle this for
us. With sets, we can conveniently compute the difference in fields between our ordered list, and the entry. Here is an example. We have a master list of keys, and an entry
with extra keys. We use the <code>difference</code> function to get the list of
extra keys. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">entry</span> = <span style="color: #cd0000;">set</span>([<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'title'</span>, <span style="color: #228b22;">'journal'</span>, <span style="color: #228b22;">'field1'</span>])
<span style="color: #8b008b;">master</span> = <span style="color: #cd0000;">set</span>([<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'title'</span>])

<span style="color: #8b0000;">print</span> entry.difference(master)
</pre>
</div>

<pre class="example">
set(['journal', 'field1'])
</pre>

<p>
So, we will use the list we want the order of, and then add the rest
of the keys.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries</span> = bp.get_entry_list()

<span style="color: #8b008b;">field_order</span> = [<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'title'</span>, <span style="color: #228b22;">'journal'</span>, <span style="color: #228b22;">'volume'</span>, <span style="color: #228b22;">'issue'</span> <span style="color: #228b22;">'pages'</span>, <span style="color: #228b22;">'year'</span>, <span style="color: #228b22;">'doi'</span>, <span style="color: #228b22;">'url'</span>, <span style="color: #228b22;">'link'</span>]

<span style="color: #8b008b;">entry_keys</span> = <span style="color: #cd0000;">set</span>(entries[0].keys())
<span style="color: #8b0000;">print</span> entry_keys.difference(field_order)
</pre>
</div>
<pre class="example">
set([u'number', 'id', 'type', u'pages'])
</pre>

<p>
You can see a subtlety here, the pages key is a unicode string, but
our field<sub>order</sub> is a regular string. Also, number is a unicode
string. It appears that all the keys are unicode except type and id. In the next block we will address that. 
</p>

<p>
You should probably go ahead and <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/01/08/Finding-bibtex-entries-with-non-ascii-characters/">remove non-ascii characters</a> from your bib-file. We got lucky with this entry, but some entries have non-ascii characters and these cause errors. 
</p>

<p>
So we need to specify the order of fields, how they should be formatted, and whether we should wrap the field contents into a nice block. We do that in the next block. Note that in the formats we use double {{ to get a literal { when we use string formatting. We use the formats to wrap the fields in brackets or quotes as needed. We use the textwrap module to neatly wrap multiline fields with indentation of the second line and beyond. By some iteration, I have made this print an entry that emacs-bibtex likes, and does not need to further reformat.
</p>

<p>
WARNING: The code below creates new files, and deletes files. Make sure you pay attention to this to avoid losing your own files. You do keep your bib-file under version control right ;).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser
<span style="color: #8b0000;">import</span> textwrap

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries</span> = bp.get_entry_list()

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">field, format, wrap or not</span>
<span style="color: #8b008b;">field_order</span> = [(u<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'title'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'journal'</span>,<span style="color: #228b22;">'"{0}",\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'volume'</span>,<span style="color: #228b22;">'{0},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'number'</span>, <span style="color: #228b22;">'{0},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'pages'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'year'</span>, <span style="color: #228b22;">'{0},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'doi'</span>,<span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">False</span>),
               (u<span style="color: #228b22;">'url'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>),
               (u<span style="color: #228b22;">'link'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">pick an entry, this time second to last one</span>
<span style="color: #8b008b;">entry</span> = entries[-2]
<span style="color: #8b008b;">keys</span> = <span style="color: #cd0000;">set</span>(entry.keys())

<span style="color: #8b008b;">extra_fields</span> = keys.difference([f[0] <span style="color: #8b0000;">for</span> f <span style="color: #8b0000;">in</span> field_order])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we do not want these in our entry, they go in the "header"</span>
extra_fields.remove(<span style="color: #228b22;">'type'</span>)
extra_fields.remove(<span style="color: #228b22;">'id'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Now build up our entry string</span>
<span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'@{type}{{{id},\n'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">type</span>=entry[<span style="color: #228b22;">'type'</span>].upper(),
                              <span style="color: #cd0000;">id</span>=entry[<span style="color: #228b22;">'id'</span>])

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Now handle the ordered fields, then the extra fields</span>
<span style="color: #8b0000;">for</span> field, fmt, wrap <span style="color: #8b0000;">in</span> field_order:
    <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
        <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
        <span style="color: #8b008b;">s2</span> = fmt.<span style="color: #cd0000;">format</span>(entry[field])
        <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{1}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
        <span style="color: #8b0000;">if</span> wrap:
            <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">fill seems to remove trailing '\n'</span>
            <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
        <span style="color: #8b008b;">s</span> += s3  

<span style="color: #8b0000;">for</span> field <span style="color: #8b0000;">in</span> extra_fields:
    <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
        <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
        <span style="color: #8b008b;">s2</span> = entry[field]
        <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{{{1}}}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
        <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
        <span style="color: #8b008b;">s</span> += s3  

<span style="color: #8b008b;">s</span> += <span style="color: #228b22;">'}\n\n'</span>

<span style="color: #8b0000;">print</span> s
</pre>
</div>

<pre class="example">
@ARTICLE{yang-2008-anatas-tio2,
  AUTHOR =       {Yang, H. G. and Sun, C. H. and Qiao, S. Z. and Zou,
                  J. and Liu, G. and Smith, S. C. and Cheng, H. M. and
                  Lu, G. Q.},
  TITLE =        {Anatase \ce{TiO_2} single crystals with a large
                  percentage of reactive facets},
  JOURNAL =      "Nature",
  VOLUME =       453,
  NUMBER =       7195,
  PAGES =        {638-U4},
  YEAR =         2008,
  DOI =          {10.1038/nature06964},
  LINK =         {\url{http://www.nature.com/nature/journal/v453/n7195/pdf/nature06964.pdf}},
  KEYWORD =      {TOTAL-ENERGY CALCULATIONS WAVE BASIS-SET
                  HYDROTHERMAL CONDITIONS TITANIUM-DIOXIDE SURFACE
                  OXIDE NANOSTRUCTURES NANOPARTICLES NANOCRYSTALS
                  EFFICIENCY}
}
</pre>

<p>
That looks pretty good. Now, we are ready to try the whole file. We simply loop through all the entries, and append the string to a file for each entry. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> bibtexparser.bparser <span style="color: #8b0000;">import</span> BibTexParser
<span style="color: #8b0000;">import</span> os, textwrap

<span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'../../CMU/proposals/link-to-2014/bo2-polymorphs/bo2-polymorphs.bib'</span>, <span style="color: #228b22;">'r'</span>) <span style="color: #8b0000;">as</span> bibfile:
    <span style="color: #8b008b;">bp</span> = BibTexParser(bibfile)
    <span style="color: #8b008b;">entries</span> = bp.get_entry_list()

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">field, format, wrap or not</span>
<span style="color: #8b008b;">field_order</span> = [(u<span style="color: #228b22;">'author'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'title'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'journal'</span>,<span style="color: #228b22;">'"{0}",\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'volume'</span>,<span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'number'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'pages'</span>, <span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'year'</span>, <span style="color: #228b22;">'{0},\n'</span>, <span style="color: #cd0000;">True</span>),
               (u<span style="color: #228b22;">'doi'</span>,<span style="color: #228b22;">'{{{0}}},\n'</span>, <span style="color: #cd0000;">False</span>),
               (u<span style="color: #228b22;">'url'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>),
               (u<span style="color: #228b22;">'link'</span>,<span style="color: #228b22;">'{{\url{{{0}}}}},\n'</span>, <span style="color: #cd0000;">False</span>)]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">rm file if it exists. this is a new file, not our bibliography!</span>
<span style="color: #8b0000;">if</span> os.path.exists(<span style="color: #228b22;">'bib.bib'</span>): os.unlink(<span style="color: #228b22;">'bib.bib'</span>)

<span style="color: #8b0000;">for</span> entry <span style="color: #8b0000;">in</span> entries:
    
    <span style="color: #8b008b;">keys</span> = <span style="color: #cd0000;">set</span>(entry.keys())

    <span style="color: #8b008b;">extra_fields</span> = keys.difference([f[0] <span style="color: #8b0000;">for</span> f <span style="color: #8b0000;">in</span> field_order])
    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we do not want these in our entry</span>
    extra_fields.remove(<span style="color: #228b22;">'type'</span>)
    extra_fields.remove(<span style="color: #228b22;">'id'</span>)

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Now build up our entry string</span>
    <span style="color: #8b008b;">s</span> = <span style="color: #228b22;">'@{type}{{{id},\n'</span>.<span style="color: #cd0000;">format</span>(<span style="color: #cd0000;">type</span>=entry[<span style="color: #228b22;">'type'</span>].upper(),
                                  <span style="color: #cd0000;">id</span>=entry[<span style="color: #228b22;">'id'</span>])

    <span style="color: #8b0000;">for</span> field, fmt, wrap <span style="color: #8b0000;">in</span> field_order:
        <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
            <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
            <span style="color: #8b008b;">s2</span> = fmt.<span style="color: #cd0000;">format</span>(entry[field])
            <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{1}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
            <span style="color: #8b0000;">if</span> wrap:
                <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">fill seems to remove trailing '\n'</span>
                <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
            <span style="color: #8b008b;">s</span> += s3  

    <span style="color: #8b0000;">for</span> field <span style="color: #8b0000;">in</span> extra_fields:
        <span style="color: #8b0000;">if</span> field <span style="color: #8b0000;">in</span> entry:
            <span style="color: #8b008b;">s1</span> = <span style="color: #228b22;">'  {0} ='</span>.<span style="color: #cd0000;">format</span>(field.upper())
            <span style="color: #8b008b;">s2</span> = entry[field]
            <span style="color: #8b008b;">s3</span> = <span style="color: #228b22;">'{0:17s}{{{1}}}'</span>.<span style="color: #cd0000;">format</span>(s1, s2)
            <span style="color: #8b008b;">s3</span> = textwrap.fill(s3, subsequent_indent=<span style="color: #228b22;">' '</span>*18, width=70) + <span style="color: #228b22;">'\n'</span>
            <span style="color: #8b008b;">s</span> += s3  

    <span style="color: #8b008b;">s</span> += <span style="color: #228b22;">'}\n\n'</span>

    <span style="color: #8b0000;">with</span> <span style="color: #cd0000;">open</span>(<span style="color: #228b22;">'bib.bib'</span>, <span style="color: #228b22;">'a'</span>) <span style="color: #8b0000;">as</span> f:
        f.write(s)
</pre>
</div>

<p>
This results in <a href="/media/2014-02-09-Sorting-fields-in-bibtex-entries/bib.bib">bib.bib</a> with 100 entries, which according to emacs is a syntactically correct bibtex file, and which builds this bibliography <a href="/media/2014-02-09-Sorting-fields-in-bibtex-entries/bib.pdf">bib.pdf</a> , which also has 100 entries. That usually means everything is in order (minor intention of pun there). More importantly, the fields are ordered the way I want them! 
</p>

<p>
Getting to this point was an iterative process. You will want to make sure the original bib file is under version control or backed up someway, in case something happens during this transformation! 
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/02/09/Sorting-fields-in-bibtex-entries.org">org-mode source</a><p><p>Org-mode version = 8.2.5h</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding bibtex entries with no downloaded pdf]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf" />
    <id>http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf</id>
    <updated>2014-01-08T10:41:40Z</updated>
    <published>2014-01-08T10:27:29Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Finding bibtex entries with no downloaded pdf]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf"><![CDATA[


<p>
We use bibtex for bibiliography management in our group. Almost every journal provides a utility to download bibtex entries, and you can pretty easily download bibtex entries from citeulike. It doesn't take too long though before you have a few hundred entries. You need some tools to interact with that database.
</p>

<p>
Bibtex-mode in Emacs provides some tools for working with your bibtex files. For example, you can (bibtex-validate) to check if entries are correct, and (bibtex-sort-buffer) to sort them by key. 
</p>

<p>
I have a specific workflow to entering new entries. This is what I prefer to do:
</p>

<ol class="org-ol">
<li>Go to journal, get bibtex entry, paste into bibtex file.
</li>
<li>delete the key that is used, if any
</li>
<li>type C-c C-c to autogenerate a key of my style
</li>
<li>Copy the key, download the pdf, and save the pdf as (format "%s.pdf" key) in my pdfs directory.
</li>
<li>Make an entry in a notes file for that reference. These entries are initially tagged as TODO to remind me to organize them.
</li>
</ol>

<p>
Doing this has some payoffs; my org-mode cite links can open either the bibtex entry, or the pdf file directly from the org-file! The notes file is also an org-file, which I can organize as I see fit. 
</p>

<p>
Sometimes I am lazy, and do not get all these steps done, especially the pdf download step. I like to have local copies of the pdf files so I can read them even if I am offline, and because I often annotate them using a tablet PC. It also makes it easy to send them to my students if I need to. Periodically, I like to go through my bibtex database to do some maintenance, download missing files, and notes entries etc&#x2026; The problem is how do I know which entries have downloaded pdfs or note entries? It is not that difficult with a bit of elisp. 
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end) 
                      (<span style="color: #8b0000;">let</span> ((type  (cdr (car (bibtex-parse-entry)))))                        
                        (<span style="color: #8b0000;">unless</span> (file-exists-p 
                                 (format <span style="color: #228b22;">"~/Dropbox/bibliography/bibtex-pdfs/%s.pdf"</span> bibtex-key))
                          (princ (format <span style="color: #228b22;">"%10s:  cite:%s has no pdf\n"</span> type bibtex-key))))))
</pre>
</div>

<pre class="example">
      Book:  cite:ambrose-2010-how-learn-works has no pdf
   article:  cite:gerken-2010-fluor-modul has no pdf
      Book:  cite:gray-1973-chemic-bonds has no pdf
   ARTICLE:  cite:kitchin-2003-tio2 has no pdf
   ARTICLE:  cite:kitchin-2012-prefac has no pdf
      Book:  cite:kittel-2005-introd-solid has no pdf
   ARTICLE:  cite:mccormick-2003-tio2-pd has no pdf
   ARTICLE:  cite:mhadeshwar-2004-nh3-ru has no pdf
      Misc:  cite:ni-website has no pdf
   ARTICLE:  cite:norskov-2006-respon has no pdf
      Book:  cite:reif-1965-fundam-statis has no pdf
   article:  cite:risch-2012-water-oxidat has no pdf
   ARTICLE:  cite:shultz-1995-prepar-and has no pdf
   ARTICLE:  cite:shultz-1997-prepar has no pdf
   ARTICLE:  cite:song-2002-h3pw1 has no pdf
</pre>

<p>
Using that list, I can click on those links, which takes me to the entry in file. That entry probably has a url or doi that makes it easy to navigate to the journal page where I can download the pdf file. You could improve on the code above by filtering out only articles, for example.  
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/08/Finding-bibtex-entries-with-no-downloaded-pdf.org">org-mode source</a><p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Finding bibtex entries with non-ascii characters]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-non-ascii-characters" />
    <id>http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-non-ascii-characters</id>
    <updated>2014-01-08T09:49:39Z</updated>
    <published>2014-01-08T09:49:39Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="bibtex" />
    <summary type="html"><![CDATA[Finding bibtex entries with non-ascii characters]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2014/01/08/Finding-bibtex-entries-with-non-ascii-characters"><![CDATA[


<p>
I have found that some journals cannot handle bibtex entries with non-ascii characters in them. Unfortunately, when you paste bibtex entries into your reference file from the web, there are often non-ascii characters in them. Emacs usually shows those characters just fine, so it is difficult to find them. Here is a little recipe to go through each entry to find entries with non-ascii characters. These range from accented characters, greek letters, degree symbols, dashes, fancy quotes, etc&#x2026; Since they are hard to see by eye, we can let Emacs find them for us, and then replace them with the corresponding ascii LaTeX commands. 
</p>

<p>
I found a function to find non-ascii characters here: <a href="http://www.emacswiki.org/emacs/FindingNonAsciiCharacters">http://www.emacswiki.org/emacs/FindingNonAsciiCharacters</a> . Now, we use a modified version of this on each entry in a bibtex file. If we find a character, we will print an org-mode link to make it easy to get right to the entry.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #8b0000;">defun</span> <span style="color: #8b2323;">contains-non-ascii-char-p</span> ()
  <span style="color: #228b22;">"tests if buffer contains non-ascii character"</span>
  (interactive)
  (<span style="color: #8b0000;">let</span> (point)
    (<span style="color: #8b0000;">save-excursion</span>
      (setq point
            (<span style="color: #8b0000;">catch</span> '<span style="color: #cd0000;">non-ascii</span>
              (<span style="color: #8b0000;">while</span> (not (eobp))
                (or (eq (char-charset (following-char))
                        'ascii)
                    (<span style="color: #8b0000;">throw</span> '<span style="color: #cd0000;">non-ascii</span> (point)))
                (forward-char 1)))))
    (<span style="color: #8b0000;">if</span> point
        (goto-char point)
      nil)))


(find-file <span style="color: #228b22;">"~/Dropbox/bibliography/references.bib"</span>)
(bibtex-map-entries (<span style="color: #8b0000;">lambda</span> (bibtex-key start end)                        
                      (<span style="color: #8b0000;">save-restriction</span>
                        <span style="color: #ff0000; font-weight: bold;">;; </span><span style="color: #ff0000; font-weight: bold;">narrow so we only look at this entry. save-restriction will rewiden</span>
                        (bibtex-narrow-to-entry)
                        (<span style="color: #8b0000;">when</span> (contains-non-ascii-char-p) (princ (format <span style="color: #228b22;">"cite:%s"</span> bibtex-key)))))))
</pre>
</div>

<pre class="example">
cite:suntivich-2011-perov-oxide
</pre>

<p>
You can see I only had one reference in that file with a non-ascii character. I think it is best practice to replace these with pure LaTeX commands. See <a href="http://en.wikibooks.org/wiki/LaTeX/Special_Characters">http://en.wikibooks.org/wiki/LaTeX/Special_Characters</a> for a good reference on what commands are used for the accented characters.
</p>
<p>Copyright (C) 2014 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2014/01/08/Finding-bibtex-entries-with-non-ascii-characters.org">org-mode source</a><p>]]></content>
  </entry>
</feed>
