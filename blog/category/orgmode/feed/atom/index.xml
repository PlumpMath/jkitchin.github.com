<?xml version="1.0" encoding="UTF-8"?>
<feed
  xmlns="http://www.w3.org/2005/Atom"
  xmlns:thr="http://purl.org/syndication/thread/1.0"
  xml:lang="en"
   >
  <title type="text">The Kitchin Research Group</title>
  <subtitle type="text">Chemical Engineering at Carnegie Mellon University</subtitle>

  <updated>2015-06-29T20:14:13Z</updated>
  <generator uri="http://blogofile.com/">Blogofile</generator>

  <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog" />
  <id>http://jkitchin.github.io/blog/feed/atom/</id>
  <link rel="self" type="application/atom+xml" href="http://jkitchin.github.io/blog/feed/atom/" />
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Integrating swish-e and Emacs]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs" />
    <id>http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs</id>
    <updated>2015-06-25T11:10:22Z</updated>
    <published>2015-06-25T10:37:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Integrating swish-e and Emacs]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/25/Integrating-swish-e-and-Emacs"><![CDATA[



<p>
<a href="http://swish-e.org">swish-e</a> is a software package that indexes files on your computer, and then allows you to search the index. Spotlight on my Mac is not working too well (sometimes not at all), and I want some more flexibility so today we try getting swish-e up and running and integrated with Emacs. I don't know that swish-e is the best tool for this available, but it has been on my radar a <i>long</i> time (probably since 2003 from this <a href="http://joshr.com/src/docs/HowToIndexAnything.pdf">article</a> ), and it was easy to setup and use.
</p>

<p>
I use homebrew, so installation was this simple:
</p>

<div class="org-src-container">

<pre class="src src-sh">brew install swish-e
</pre>
</div>

<p>
To test things out, I will only index org-files. I have these all over the place, and they are not all in my org-mode agenda. So, finding them quickly would be awesome.
</p>

<div class="org-src-container">

<pre class="src src-text"># Example configuration file

# Tell Swish-e what to directories to index
IndexDir /Users/jkitchin/Dropbox
IndexDir "/Users/jkitchin/Box Sync"
IndexDir /Users/jkitchin/blogofile-jkitchin.github.com

# where to save the index
IndexFile /Users/jkitchin/.swish-e/index.swish-e

# What to index
IndexOnly .org

# Tell Swish-e that .txt files are to use the text parser.
IndexContents TXT* .org

# Otherwise, use the HTML parser
DefaultContents HTML*

# Ask libxml2 to report any parsing errors and warnings or
# any UTF-8 to 8859-1 conversion errors
ParserWarnLevel 9
</pre>
</div>

<p>
Now, we create our index.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -c ~/.swish-e/swish.conf
</pre>
</div>

<pre class="example">
Indexing Data Source: "File-System"
Indexing "/Users/jkitchin/Dropbox"
Indexing "/Users/jkitchin/Box Sync"
Indexing "/Users/jkitchin/blogofile-jkitchin.github.com"
Removing very common words...
no words removed.
Writing main index...
Sorting words ...
Sorting 130,109 words alphabetically
Writing header ...
Writing index entries ...
  Writing word text: ...  Writing word text:  10%  Writing word text:  20%  Writing word text:  30%  Writing word text:  40%  Writing word text:  50%  Writing word text:  60%  Writing word text:  70%  Writing word text:  80%  Writing word text:  90%  Writing word text: 100%  Writing word text: Complete
  Writing word hash: ...  Writing word hash:  10%  Writing word hash:  20%  Writing word hash:  30%  Writing word hash:  40%  Writing word hash:  50%  Writing word hash:  60%  Writing word hash:  70%  Writing word hash:  80%  Writing word hash:  90%  Writing word hash: 100%  Writing word hash: Complete
  Writing word data: ...  Writing word data:   9%  Writing word data:  19%  Writing word data:  29%  Writing word data:  39%  Writing word data:  49%  Writing word data:  59%  Writing word data:  69%  Writing word data:  79%  Writing word data:  89%  Writing word data:  99%  Writing word data: Complete
130,109 unique words indexed.
Sorting property: swishdocpath                            Sorting property: swishtitle                              Sorting property: swishdocsize                            Sorting property: swishlastmodified                       4 properties sorted.
3,208 files indexed.  54,104,974 total bytes.  8,038,594 total words.
Elapsed time: 00:00:16 CPU time: 00:00:13
Indexing done!
</pre>


<p>
Now an example search. I have been looking into the Energy frontier research centers, and I want to find my notes on it. Here is a little query. I use a special output format to keep things simple for the parsing later, just the rank and path, separated by a tab.
</p>

<div class="org-src-container">

<pre class="src src-sh">swish-e -f ~/.swish-e/index.swish-e -x <span style="color: #008000;">'%r\t%p\n'</span> -w efrc
</pre>
</div>
<pre class="example">
# SWISH format: 2.4.7
# Search words: efrc
# Removed stopwords:
# Number of hits: 2
# Search time: 0.000 seconds
# Run time: 0.008 seconds
1000	/Users/jkitchin/Dropbox/org-mode/journal.org
471	/Users/jkitchin/Dropbox/org-mode/proposals.org
.
</pre>

<p>
Now, for the integration with Emacs. We just get that output in a string, split it, and get the parts we want.  I think I will use helm to provide a selection buffer to these results. We need a list of cons cells (string . candidate). Then we write an interactive helm function. We provide two sources. One for the initial query, and another to start a new search, in case you don't find what you want.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e-candidates</span> (query)
  <span style="color: #036A07;">"Generate a list of cons cells (swish-e result . path)."</span>
  (<span style="color: #0000FF;">let*</span> ((result (shell-command-to-string
                  (format <span style="color: #008000;">"swish-e -f ~/.swish-e/index.swish-e -x \"%%r\t%%p\n\" -w %s"</span>
                          (shell-quote-argument query))))
         (lines (s-split <span style="color: #008000;">"\n"</span> result t))
         (candidates '()))
    (<span style="color: #0000FF;">loop</span> for line in lines
          unless (<span style="color: #0000FF;">or</span>  (s-starts-with? <span style="color: #008000;">"#"</span> line)
                      (s-starts-with? <span style="color: #008000;">"."</span> line))
          collect (cons line (cdr (s-split <span style="color: #008000;">"\t"</span> line))))))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">helm-swish-e</span> (query)
  <span style="color: #036A07;">"Run a swish-e query and provide helm selection buffer of the results."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sQuery: "</span>)
  (helm <span style="color: #006FE0;">:sources</span> `(((name . ,(format <span style="color: #008000;">"swish-e: %s"</span> query))
                    (candidates . ,(helm-swish-e-candidates query))
                    (action . ((<span style="color: #008000;">"open"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                           (find-file (car f)))))))
                   ((name . <span style="color: #008000;">"New search"</span>)
                    (dummy)
                    (action . ((<span style="color: #008000;">"search"</span> . (<span style="color: #0000FF;">lambda</span> (f)
                                             (helm-swish-e helm-pattern)))))))))
</pre>
</div>

<pre class="example">
helm-swish-e
</pre>

<p>
Now I can run M-x helm-swish-e and enter "efrc AND computing infrastructure" to find org files containing those words, then press enter to find the file. Nice and easy. I have not tested the query syntax very fully, but so far it is working fine!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/25/Integrating-swish-e-and-Emacs.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Clickable org-contacts in text files]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files" />
    <id>http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files</id>
    <updated>2015-06-22T13:07:03Z</updated>
    <published>2015-06-22T13:07:03Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="contacts" />
    <summary type="html"><![CDATA[Clickable org-contacts in text files]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/22/Clickable-org-contacts-in-text-files"><![CDATA[



<p>
Continuing my adventures with clickable text (See <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/21/Clickable-email-addresses-in-emacs/">clickable email addresses</a> and <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/03/18/Clickable-links-for-Twitter-handles-in-Emacs/">clickable twitter handles</a> ), here we consider how to get clickable names that are also in my org-contacts database. The goal is to have these names highlighted and clickable so that when I click on them I get a hydra menu of actions, e.g. to open the contact, email them, etc&#x2026; We will again use button-lock to do the action. We will construct a fairly large regexp to match all the names in the org-contacts database. This turns out to be very easy using the regexp-opt function.
</p>

<p>
First, I formalize the code I used last time to get text around the point that has a text-property. We will use that to get the text that has been highlighted by button-lock.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-surrounding-text-with-property</span> (property)
  <span style="color: #036A07;">"Return text surrounding point with the text-property PROPERTY."</span>
  (<span style="color: #0000FF;">let</span> ((start) (end))
    (<span style="color: #0000FF;">when</span> (get-text-property (point) property)
      (<span style="color: #0000FF;">save-excursion</span>
        (<span style="color: #0000FF;">while</span> (get-text-property (point) property)
          (backward-char))
        (forward-char)
        (<span style="color: #0000FF;">setq</span> start (point))
        (<span style="color: #0000FF;">while</span> (get-text-property (point) property)
          (forward-char))
        (<span style="color: #0000FF;">setq</span> end (point)))
      (buffer-substring start end))))
</pre>
</div>

<pre class="example">
get-surrounding-text-with-property
</pre>

<p>
I want to use nicknames that are defined in my org-contacts database. We first try to return an assoc lookup, then the slower approach of looping through the entries to find a matching nickname.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">get-contact-from-name-or-nickname</span> (name-or-nickname)
  <span style="color: #036A07;">"Return a contact from the org-contacts database for NAME-OR-NICKNAME."</span>
  (<span style="color: #0000FF;">or</span>
   (assoc name-or-nickname (org-contacts-db))
   <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">no assoc, so now we have to find a nickname</span>
   (<span style="color: #0000FF;">catch</span> '<span style="color: #D0372D;">contact</span>
     (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
       (<span style="color: #0000FF;">when</span> (-contains? (s-split <span style="color: #008000;">","</span> (<span style="color: #0000FF;">or</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))) <span style="color: #008000;">" "</span>)) name-or-nickname)
         (<span style="color: #0000FF;">throw</span> '<span style="color: #D0372D;">contact</span> contact))))))
</pre>
</div>

<pre class="example">
get-contact-from-name-or-nickname
</pre>

<p>
Now, let us write a hydra function that will be our menu of actions. For some reason, when you click on a highlighted text the mouse moves to the end of the text, so in our hydra function we move back a char, and then get the info. Basically, we get the name, then get the contact, and extract what we need from there. Here we provide functionality to open a contact, email a contact or open the url of the contact (if it exists). I also want a conditional hydra, which doesn't seem to be an option yet, so we we roll our own here. Basically, we construct the code for a hydra, and only add a menu option to open the url if we find one in the contact. We will have to eval the code returned from this function to get the hydra body, and then call the body function in the action function for the highlighted text.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">conditional-hydra-actions</span> ()
  <span style="color: #036A07;">"Construct code to create a hydra with conditional options."</span>
  (<span style="color: #0000FF;">let</span> ((code  '(defhydra org-contacts (<span style="color: #006FE0;">:color</span> blue)
                  <span style="color: #008000;">"Org contacts"</span>)))
    (<span style="color: #0000FF;">setq</span> code
          (append
           code
           '((<span style="color: #008000;">"o"</span> (<span style="color: #0000FF;">progn</span>
                    (backward-char)
                    (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                           (contact (get-contact-from-name-or-nickname name))
                           (contact-marker (nth 1 contact)))
                      (switch-to-buffer (marker-buffer contact-marker))
                      (goto-char (marker-position contact-marker))
                      (show-subtree)))
              <span style="color: #008000;">"Open contact"</span>))))

    (<span style="color: #0000FF;">setq</span> code
          (append
           code '((<span style="color: #008000;">"e"</span> (<span style="color: #0000FF;">progn</span>
                         (backward-char)
                         (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                                (contact (get-contact-from-name-or-nickname name))
                                (email (cdr (assoc <span style="color: #008000;">"EMAIL"</span> (caddr contact))))))
                         (mu4e~compose-mail email))
                   <span style="color: #008000;">"Email contact"</span>))))

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">conditional menu for opening a URL</span>
    (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
           (contact (assoc name (org-contacts-db)))
           (url (cdr (assoc <span style="color: #008000;">"URL"</span> (caddr contact)))))
      (<span style="color: #0000FF;">when</span> url
        (<span style="color: #0000FF;">setq</span> code
              (append
               code '((<span style="color: #008000;">"w"</span> (<span style="color: #0000FF;">progn</span>
                             (backward-char)
                             (<span style="color: #0000FF;">let*</span> ((name (get-surrounding-text-with-property 'org-contact))
                                    (contact (get-contact-from-name-or-nickname name))
                                    (url (cdr (assoc <span style="color: #008000;">"URL"</span> (caddr contact)))))
                               (<span style="color: #0000FF;">if</span> url
                                   (browse-url url)
                                 (message <span style="color: #008000;">"No url found."</span>))))
                       <span style="color: #008000;">"Open in browser"</span>))))))
    code))
</pre>
</div>

<pre class="example">
conditional-hydra-actions
</pre>

<p>
I also want to have nicknames in this list, because sometimes I don't use the full names in my contact database. These are stored in a comma-separated property called NICKNAMES in entries that have them. A subtle point here is that it complicates looking up the contact in the database. Normally, I can get this by a simple assoc lookup. For the nicknames, that will fail, so we need a back up method. Now, the highlighting code. You can make the regexp by passing a list of strings to match to regexp-opt. We get our list of strings from:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(append
 (mapcar 'car (org-contacts-db))
 (<span style="color: #0000FF;">let</span> ((nicknames '()))
   (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
     (<span style="color: #0000FF;">when</span> (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))
       (<span style="color: #0000FF;">setq</span> nicknames
             (append nicknames (s-split <span style="color: #008000;">","</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))))))))
   nicknames))
</pre>
</div>

<p>
I am not going to show them here to protect my contacts ;). Now, we create the function that highlights the contacts. and add it as a hook function to text-mode-hook.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">highlight-org-contacts</span> ()
  (button-lock-set-button
   (regexp-opt
    (append
     (mapcar 'car (org-contacts-db))
     (<span style="color: #0000FF;">let</span> ((nicknames '()))
       (<span style="color: #0000FF;">dolist</span> (contact (org-contacts-db))
         (<span style="color: #0000FF;">when</span> (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))
           (<span style="color: #0000FF;">setq</span> nicknames
                 (append
                  nicknames
                  (s-split <span style="color: #008000;">","</span> (cdr (assoc <span style="color: #008000;">"NICKNAMES"</span> (caddr contact))))))))
       nicknames)))
   (<span style="color: #0000FF;">lambda</span> ()
     (<span style="color: #0000FF;">interactive</span>)
     (eval (conditional-hydra-actions))
     (org-contacts/body))
   <span style="color: #006FE0;">:face</span> '((<span style="color: #006FE0;">:background</span> <span style="color: #008000;">"MistyRose1"</span>)
           (<span style="color: #006FE0;">:underline</span> t))
   <span style="color: #006FE0;">:help-echo</span> (format <span style="color: #008000;">"An org contact"</span>)
   <span style="color: #006FE0;">:keyboard-binding</span> (kbd <span style="color: #008000;">"RET"</span>)
   <span style="color: #006FE0;">:additional-property</span> 'org-contact))

(add-hook 'text-mode-hook 'highlight-org-contacts)
</pre>
</div>

<p>
That does it. Now, whenever I open a text-based file, the names that are in my contacts are highlighted and actionable. This should be useful for meeting notes, etc&#x2026;
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/22/Clickable-org-contacts-in-text-files.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[ox-pandoc - org-mode + org-ref to docx with bibliographies]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies" />
    <id>http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies</id>
    <updated>2015-06-12T11:19:37Z</updated>
    <published>2015-06-11T12:58:07Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="docx" />
    <category scheme="http://jkitchin.github.io/blog" term="pandoc" />
    <summary type="html"><![CDATA[ox-pandoc - org-mode + org-ref to docx with bibliographies]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/11/ox-pandoc-org-mode-+-org-ref-to-docx-with-bibliographies"><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. The setup</a></li>
<li><a href="#sec-2">2. The document</a></li>
<li><a href="#sec-3">3. Summary</a></li>
</ul>
</div>
</div>
<p>
There is a new org-mode exporter: <a href="https://github.com/kawabata/ox-pandoc">ox-pandoc</a> . It seems like it makes it easy to convert org-mode to other formats, including docx, and including references in a bibliography. Let us try it out.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The setup</h2>
<div class="outline-text-2" id="text-1">
<p>
<del>We  have to modify org-ref</del> org-ref modifies helm-bibtex to insert citation links. We have to undo that here to insert LaTeX style citations. We do that here so that the key binding for inserting references from org-ref inserts the LaTeX citations. This is necessary for pandoc to convert the reference citations to the bibliography in the docx format. If you do not use org-ref, this is probably not necessary.
</p>


<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">setq</span> helm-bibtex-format-citation-functions
      '((org-mode . (<span style="color: #0000FF;">lambda</span> (x) (insert (concat
                                         <span style="color: #008000;">"\\cite{"</span>
                                         (mapconcat 'identity x <span style="color: #008000;">","</span>)
                                         <span style="color: #008000;">"}"</span>)) <span style="color: #008000;">""</span>))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">org-mode</td>
<td class="left">lambda</td>
<td class="left">(x)</td>
<td class="left">(insert (concat \cite{ (mapconcat (quote identity) x ,) }))</td>
</tr>
</tbody>
</table>

<p>
We have to add ox-pandoc and require it.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(add-to-list 'load-path (expand-file-name <span style="color: #008000;">"ox-pandoc"</span> starter-kit-dir))
(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">ox-pandoc</span>)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> The document</h2>
<div class="outline-text-2" id="text-2">
<p>
Now, for some text. Grindy wrote this nice paper on approaching chemical accuracy with density functional  calculations \cite{grindy-2013-approac}. Two other interesting papers include these ones \cite{guldner-1961,guerrini-2008-effec-feo}.
</p>

<p>
An equation: \(e^x = 4\).
</p>

<p>
And a figure with a caption:
</p>


<div class="figure">
<p><img src="/media/2015-06-11-ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies/bib.png"> 
</p>
<p><span class="figure-number">Figure 1:</span> Make sure this is in your org-file.</p>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Summary</h2>
<div class="outline-text-2" id="text-3">
<p>
This is better than what I have seen in the past. ox-pandoc has some options that might tailor the bibliography to specific formats. You lose some functionality of org-ref cite links by using raw LaTeX, but if that is not a deal breaker this might be a good way to go for some purposes.
</p>

<p>
Here is the word document that results from this file: <a href="/media/2015-06-11-ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies/test-doc.docx">test-doc.docx</a> 
</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/11/ox-pandoc---org-mode-+-org-ref-to-docx-with-bibliographies.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed" />
    <id>http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed</id>
    <updated>2015-06-09T07:29:08Z</updated>
    <published>2015-06-09T07:29:08Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Converting a DOI to other scientific identifiers in Pubmed]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed"><![CDATA[



<p>
Sometimes it is useful to convert a DOI to another type of identifier. For example, in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI/">post</a> we converted a DOI to a Scopus EID, and in this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI/">one</a> we got the WOS accession number from a DOI. Today, we consider how to get Pubmed identifiers. Pubmed provides an API for this purpose:
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/">http://www.ncbi.nlm.nih.gov/pmc/tools/id-converter-api/</a> 
</p>

<p>
We will use the DOI tool. According to the documentation, we need to form a URL like this:
</p>

<p>
DOI: <a href="http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195">http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=my_tool&email=my_email@example.com&ids=10.1093/nar/gks1195</a> 
</p>

<p>
We will call our tool "org-ref" and use the value of user-mail-address. The URL above returns XML, so we can parse it, and then extract the identifiers. This is a simple http GET request, which we can construct using url-retrieve-synchronously. Here is what we get.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max)))))
xml)
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">((pmcids
  ((status . <span style="color: #008000;">"ok"</span>))
  <span style="color: #008000;">"\n"</span>
  (request
   ((idtype . <span style="color: #008000;">"doi"</span>)
    (dois . <span style="color: #008000;">""</span>)
    (versions . <span style="color: #008000;">"yes"</span>)
    (showaiid . <span style="color: #008000;">"no"</span>))
   <span style="color: #008000;">"\n"</span>
   (echo nil <span style="color: #008000;">"tool=org-ref;email=jkitchin%40andrew.cmu.edu;ids=10.1093%2Fnar%2Fgks1195"</span>)
   <span style="color: #008000;">"\n"</span>)
  <span style="color: #008000;">"\n"</span>
  (record
   ((requested-id . <span style="color: #008000;">"10.1093/NAR/GKS1195"</span>)
    (pmcid . <span style="color: #008000;">"PMC3531190"</span>)
    (pmid . <span style="color: #008000;">"23193287"</span>)
    (doi . <span style="color: #008000;">"10.1093/nar/gks1195"</span>))
   (versions nil
             (version
              ((pmcid . <span style="color: #008000;">"PMC3531190.1"</span>)
               (current . <span style="color: #008000;">"true"</span>)))))
  <span style="color: #008000;">"\n"</span>))
</pre>
</div>

<p>
The parsed xml is now just an emacs-lisp data structure. We need to get the record, and then get the attributes of it to extract the identifiers. Next, we create a plist of the identifiers. For fun, we add the Scopus EID and WOS accession number from the previous posts too.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
       (doi<span style="color: #008000;">"10.1093/nar/gks1195"</span>)
       (my-tool <span style="color: #008000;">"org-ref"</span>)
       (url (format <span style="color: #008000;">"http://www.ncbi.nlm.nih.gov/pmc/utils/idconv/v1.0/?tool=%s&amp;email=%s&amp;ids=%s"</span>
                    my-tool
                    user-mail-address
                    doi))
       (xml (car (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                   (xml-parse-region url-http-end-of-headers (point-max)))))
       (record (first  (xml-get-children xml 'record)))
       (doi (xml-get-attribute record 'doi))
       (pmcid (xml-get-attribute record 'pmcid))
       (pmid (xml-get-attribute record 'pmid)))
  (list <span style="color: #006FE0;">:doi</span> doi <span style="color: #006FE0;">:pmid</span> pmid <span style="color: #006FE0;">:pmcid</span> pmcid <span style="color: #006FE0;">:eid</span> (scopus-doi-to-eid doi) <span style="color: #006FE0;">:wos</span> (wos-doi-to-accession-number doi)))
</pre>
</div>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #006FE0;">:doi</span> <span style="color: #008000;">"10.1093/nar/gks1195"</span> <span style="color: #006FE0;">:pmid</span> <span style="color: #008000;">"23193287"</span> <span style="color: #006FE0;">:pmcid</span> <span style="color: #008000;">"PMC3531190"</span> <span style="color: #006FE0;">:eid</span> <span style="color: #008000;">"2-s2.0-80053651587"</span> <span style="color: #006FE0;">:wos</span> <span style="color: #008000;">"000312893300006"</span>)
</pre>
</div>

<p>
Well, there you have it, four new scientific document ids from one DOI. <i>Of course</i> we have defined org-mode links for each one of these:
</p>

<p>
<a href="http://dx.doi.org/10.1093/nar/gks1195">doi:10.1093/nar/gks1195</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/mid/23193287">pmid:23193287</a>
</p>

<p>
<a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC3531190">pmcid:PMC3531190</a>
</p>

<p>
<a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-80053651587&origin=resultslist">eid:2-s2.0-80053651587</a>
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000312893300006">wos:000312893300006</a>
</p>

<p>
I have not tested this on too many DOIs yet. Not all of them are indexed by Pubmed.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/09/Converting-a-DOI-to-other-scientific-identifiers-in-Pubmed.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI</id>
    <updated>2015-06-09T07:25:39Z</updated>
    <published>2015-06-08T11:23:33Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a WOS Accession number from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI"><![CDATA[


<p>
I have been slowly working on getting alternative identifiers to the DOI for scientific literature. The DOI is great for getting a bibtex entry, and getting to the article page, but other identifiers, e.g. from Pubmed, Scopus or Web of Science provide links to additional information. Here, I examine an approach to get a Web of Science identifier from a DOI.
</p>

<p>
In a previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2014/11/04/Accessing-web-of-science-entry-citing-and-related-articles-from-a-doi-in-emacs/">post</a> we showed how to use the Web of Science OpenURL services to derive links to articles from the DOI. It turns out that if you follow that link, you get redirected to a URL that has the WOS Accession number in it. For example, this link: <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:doi/10.1021/jp047349j</a> is redirected to
<a href="http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44">http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&SrcApp=PARTNER_APP&SrcAuth=LinksAMR&KeyUT=WOS:000225079300029&DestLinkType=FullRecord&DestApp=ALL_WOS&UsrCustomerID=8703b88d69db6b417a9c0dc510538f44</a> . You can see the <a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">wos:000225079300029</a> in that URL, so all we need to do is extract it. We use some url functions in emacs lisp to to that. They are a little convoluted, but they work. Previously I used a regular expression to do this.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(cdr (assoc <span style="color: #008000;">"KeyUT"</span> (url-parse-query-string (url-filename (url-generic-parse-url  <span style="color: #008000;">"http://gateway.webofknowledge.com/gateway/Gateway.cgi?GWVersion=2&amp;SrcApp=PARTNER_APP&amp;SrcAuth=LinksAMR&amp;KeyUT=WOS:000225079300029&amp;DestLinkType=FullRecord&amp;DestApp=ALL_WOS&amp;UsrCustomerID=8703b88d69db6b417a9c0dc510538f44"</span>)))))
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left"><a href="000225079300029">000225079300029</a></td>
</tr>
</tbody>
</table>

<p>
It is a tad tricky to get the redirected URL. We have to use the most basic url-retrieve, which works asynchronously, and we need a callback function to handle the response. I use a trick with global variables to note that the function is waiting, and to sleep briefly until it is ready. We want the last redirect (this seems to get redirected twice).
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-redirect*</span> nil)
(<span style="color: #0000FF;">defvar</span> <span style="color: #BA36A5;">*wos-waiting*</span> nil)

(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-get-wos-redirect</span> (url)
  <span style="color: #036A07;">"Return final redirect url for open-url"</span>
  (<span style="color: #0000FF;">setq</span> *wos-waiting* t)
  (url-retrieve
   url
   (<span style="color: #0000FF;">lambda</span> (status)
     (<span style="color: #0000FF;">setq</span> *wos-redirect* (car (last status)))
     (<span style="color: #0000FF;">setq</span> *wos-waiting* nil)))
  (<span style="color: #0000FF;">while</span> *wos-waiting* (sleep-for 0.1))
  (url-unhex-string *wos-redirect*))


(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">wos-doi-to-accession-number</span> (doi)
  <span style="color: #036A07;">"Return a WOS Accession number for a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((open-url (concat <span style="color: #008000;">"http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&amp;rft_id=info:doi/"</span> doi))
         (redirect (wos-get-wos-redirect open-url)))
    (substring  (cadr
                 (assoc
                  <span style="color: #008000;">"KeyUT"</span>
                  (url-parse-query-string
                   (url-filename
                    (url-generic-parse-url redirect)))))
    4)))

(concat <span style="color: #008000;">"wos:"</span> (wos-doi-to-accession-number <span style="color: #008000;">"10.1021/jp047349j"</span>))
</pre>
</div>

<pre class="example">
wos:000225079300029
</pre>

<p>
I am not super crazy about this approach, but until I figure out the WOK API, this is surprisingly simple! And, now you can use the Accession number in a url like these examples:
</p>

<p>
<a href="http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029">http://onlinelibrary.wiley.com/resolve/reference/ISI?id=000225079300029</a> 
</p>

<p>
<a href="http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029">http://ws.isiknowledge.com/cps/openurl/service?url_ver=Z39.88-2004&rft_id=info:ut/000225079300029</a> 
</p>

<p>
That might turn out to be handy at some point.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/08/Getting-a-WOS-Accession-number-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Getting a Scopus EID from a DOI]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI" />
    <id>http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI</id>
    <updated>2015-06-07T16:54:38Z</updated>
    <published>2015-06-07T16:29:05Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="ref" />
    <summary type="html"><![CDATA[Getting a Scopus EID from a DOI]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/06/07/Getting-a-Scopus-EID-from-a-DOI"><![CDATA[


<p>
<a href="http://www.scopus.com">Scopus</a> is a scientific literature indexing and search engine service run by Elsevier. I have been integrating Scopus workflows into Emacs  and org-ref. Scopus seems to work with their own digital identifiers, known as an EID. I usually have a DOI to work with. Here, we develop a way to get an EID from a DOI using the Scopus API. You need to get your own Scopus API key here: <a href="http://dev.elsevier.com/myapikey.html">http://dev.elsevier.com/myapikey.html</a> and set <b>scopus-api-key</b> in Emacs to use this code.
</p>

<p>
Once we have an EID, here are a few interesting things we can do with them. This is an EID: 2-s2.0-84881394200, for this reference:
</p>

<p>
Hallenbeck, Alexander P. and Kitchin, John R., "Effects of \ce{O_2} and \ce{SO_2} on the capture capacity of a  primary-amine based polymeric \ce{CO_2} sorbent", Industrial &amp; Engineering Chemistry Research, 52:10788-10794 (2013)
</p>

<p>
With the EID, we can construct a URL to the Scopus document page:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/record/display.url?eid=%s&amp;origin=resultslist"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&amp;origin=resultslist
</pre>

<p>
We can construct a URL to citing documents:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format <span style="color: #008000;">"http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=%s&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage"</span> eid))
</pre>
</div>

<pre class="example">
http://www.scopus.com/results/citedbyresults.url?sort=plf-f&amp;cite=2-s2.0-84881394200&amp;src=s&amp;imp=t&amp;sot=cite&amp;sdt=a&amp;sl=0&amp;origin=recordpage
</pre>

<p>
And there are three types of related document urls we can create: by author, keyword or references.
</p>

<p>
By authors:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=aut&amp;zone=relatedDocuments"</span>)
            eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=aut&zone=relatedDocuments</a> 
</p>

<p>
By keywords:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url"</span>
                  <span style="color: #008000;">"?eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                  <span style="color: #008000;">"&amp;method=key&amp;zone=relatedDocuments"</span>)
          eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=key&zone=relatedDocuments</a> 
</p>

<p>
And by references:
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let</span> ((eid <span style="color: #008000;">"2-s2.0-84881394200"</span>))
  (format (concat  <span style="color: #008000;">"http://www.scopus.com/search/submit/mlt.url?"</span>
                   <span style="color: #008000;">"eid=%s&amp;src=s&amp;all=true&amp;origin=recordpage"</span>
                   <span style="color: #008000;">"&amp;method=ref&amp;zone=relatedDocuments"</span>)
           eid))
</pre>
</div>

<p>
<a href="http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments">http://www.scopus.com/search/submit/mlt.url?eid=2-s2.0-84881394200&src=s&all=true&origin=recordpage&method=ref&zone=relatedDocuments</a> 
</p>

<p>
We can generate all those on the fly if we have an EID. The problem is that we usually have the DOI, <i>not</i> the EID. So, here we use the Scopus API to retrieve that. Basically, we just do a search on the DOI, assume one and only one is found, and get the EID from the results. The DOI we have for the reference considered here is <a href="http://dx.doi.org/10.1021/ie400582a">doi:10.1021/ie400582a</a>.
</p>

<p>
The gist of what we will do is send an http request to Scopus with our API key, and data specifying what to get. Scopus will return data to us in either json or xml, depending on what we ask for.
</p>

<p>
I find json easiest to deal with, so we first work it out in json. We use the Scopus search API and query on the doi here. We get back json data which we read as an emacs-lisp plist, and extract the eid from it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (json-object-type 'plist)
       (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                    (json-read-from-string
                     (buffer-substring url-http-end-of-headers (point-max))))))
 (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
That is the EID we were looking for. Here, we just wrap that code in a function so it is easier to reuse.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid-json</span> (doi)
  <span style="color: #036A07;">"Return a parsed xml from the Scopus article retrieval api for DOI.</span>
<span style="color: #036A07;">This does not always seem to work for the most recent DOIs."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/json"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (json-object-type 'plist)
         (json-data (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                      (json-read-from-string
                       (buffer-substring url-http-end-of-headers (point-max))))))
    (plist-get (elt (plist-get (plist-get json-data <span style="color: #006FE0;">:search-results</span>) <span style="color: #006FE0;">:entry</span>) 0) <span style="color: #006FE0;">:eid</span>)))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<p>
XML is the native format in the Scopus API. They say that json works most of the time, but some XML cannot be rendered as json. Here we use the XML returned to get the EID. It is less intuitive to me, but mostly because I have used it less. I don't think you can specify and XPATH like you can in Python.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">let*</span> ((doi <span style="color: #008000;">"10.1021/ie400582a"</span>)
       (url-request-method <span style="color: #008000;">"GET"</span>)
       (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
       (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                         '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
       (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
       (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
              (xml-parse-region url-http-end-of-headers (point-max))))
       (results (car xml))
       (entry (car (xml-get-children results 'entry))))
  (car (xml-node-children (car (xml-get-children entry 'eid)))))
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
Now we wrap this in a function for reusability.
</p>
<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">scopus-doi-to-eid</span> (doi)
  <span style="color: #036A07;">"Get a Scopus eid from a DOI."</span>
  (<span style="color: #0000FF;">let*</span> ((url-request-method <span style="color: #008000;">"GET"</span>)
         (url-mime-accept-string <span style="color: #008000;">"application/xml"</span>)
         (url-request-extra-headers  (list (cons <span style="color: #008000;">"X-ELS-APIKey"</span> *scopus-api-key*)
                                           '(<span style="color: #008000;">"field"</span> . <span style="color: #008000;">"eid"</span>)))
         (url (format  <span style="color: #008000;">"http://api.elsevier.com/content/search/scopus?query=doi(%s)"</span> doi))
         (xml (<span style="color: #0000FF;">with-current-buffer</span>  (url-retrieve-synchronously url)
                (xml-parse-region url-http-end-of-headers (point-max))))
         (results (car xml))
         (entry (car (xml-get-children results 'entry))))
    (car (xml-node-children (car (xml-get-children entry 'eid))))))

(scopus-doi-to-eid <span style="color: #008000;">"10.1021/ie400582a"</span>)
</pre>
</div>

<pre class="example">
2-s2.0-84881394200
</pre>

<p>
This code is wrapped up in <a href="https://github.com/jkitchin/org-ref/blob/master/scopus.el">org-ref/scopus.el</a> . It provides a new org-mode eid link, e.g. <a href=" http://www.scopus.com/record/display.url?eid=2-s2.0-84881394200&origin=resultslist">eid:2-s2.0-84881394200</a> which is functional and provides access to the citing and related article Scopus pages for that eid.
</p>

<p>
There are also new links and functions for a <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=b&sdt=b&sl=35&s=TITLE-ABS-KEY%28alloy%20Au%20segregation%29&origin=searchbasic">alloy Au segregation</a> and <a href="http://www.scopus.com/results/results.url?sort=plf-f&src=s&sot=a&sdt=a&sl=48&s=auth%28kitchin%29%20and%20title%28segregation%29&origin=searchadvanced">auth(kitchin) and title(segregation)</a>.
</p>

<p>
Let's not forget the <a href="http://www.scopus.com/authid/detail.url?origin=AuthorProfile&authorId=7004212771">scopusid:7004212771</a> link to Scopus Author pages.
</p>

<p>
Now you can use org-mode for reproducible scientific literature searching in Scopus!
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/06/07/Getting-a-Scopus-EID-from-a-DOI.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Another approach to embedding org-source in html]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html" />
    <id>http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html</id>
    <updated>2015-05-10T09:34:55Z</updated>
    <published>2015-05-09T19:19:10Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="data" />
    <summary type="html"><![CDATA[Another approach to embedding org-source in html]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/09/Another-approach-to-embedding-org-source-in-html"><![CDATA[


<p>
In this <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts/">post</a> I examined a way to embed the org-source in a comment in the html of the post, and developed a reasonably convenient way to extract the source in emacs. One downside of the approach was the need to escape at least the dashes, and then unescape them on extraction. I came across another idea, which is to put the org-source in base64 encoded form in a <a href="http://en.wikipedia.org/wiki/Data_URI_scheme">data uri</a> .
</p>

<p>
First let us see what the encoding means:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(base64-encode-string <span style="color: #008000;">"&lt;!-- test--&gt;"</span>)
</pre>
</div>
<pre class="example">
PCEtLSB0ZXN0LS0+
</pre>

<p>
And decoding:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(base64-decode-string <span style="color: #008000;">"PCEtLSB0ZXN0LS0+"</span>)
</pre>
</div>

<pre class="example">
&lt;!-- test--&gt;
</pre>

<p>
The encoding looks random, but it is reversible. More importantly, it probably will not have any html like characters in it that need escaped. The idea of a data uri is that the data it serves is embedded in the URL href attribute. This is basically how to make a data uri. We give the url here a class so we can find it later.
</p>
<pre class="example">
&lt;a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+"&gt;source&lt;/a&gt;
</pre>

<p>
Here is the actual html for the browser. If you click on it, your browser automatically decodes it for you!
</p>
<a class="some-org-source" href="data:text/plain;charset=US-ASCII;base64,PCEtLSB0ZXN0LS0+">source</a>

<p>
So, during the blog publish step, we just need to add this little step to the html generation, and it will be included as a data uri. Here is the function that generates the data uri for us, and example of using it. The encoded source is not at all attractive to look at it, but you almost never need to look at it, it is invisible in the browser. Interestingly, if you click on the link, you will see the org source right in your browser!
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">source-data-uri</span> (source)
  <span style="color: #036A07;">"Encode the string in SOURCE to a data uri."</span>
  (format
   <span style="color: #008000;">"&lt;a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,%s\"&gt;source&lt;/a&gt;"</span>
   (base64-encode-string source)))

(source-data-uri (buffer-string))
</pre>
</div>

<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBBbm90aGVyIGFwcHJvYWNoIHRvIGVtYmVkZGluZyBvcmctc291cmNlIGluIGh0bWwKSW4gdGhp
cyBbW2h0dHA6Ly9raXRjaGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4t
YWx0ZXJuYXRpdmUtYXBwcm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0
cy9dW3Bvc3RdXSBJIGV4YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEg
Y29tbWVudCBpbiB0aGUgaHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFi
bHkgY29udmVuaWVudCB3YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93
bnNpZGUgb2YgdGhlIGFwcHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhl
IGRhc2hlcywgYW5kIHRoZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNy
b3NzIGFub3RoZXIgaWRlYSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2
NCBlbmNvZGVkIGZvcm0gaW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9V
Uklfc2NoZW1lXVtkYXRhIHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGlu
ZyBtZWFuczoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8
IS0tIHRlc3QtLT4iKQojK0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFu
ZCBkZWNvZGluZzoKCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5n
ICJQQ0V0TFNCMFpYTjBMUzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+
CgpBbmQgdGhpcyBpcyBiYXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0
aGUgdXJsIGhlcmUgYSBjbGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFN
UExFCjxhIGNsYXNzPSJvcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9FWEFNUExF
CgpIZXJlIGlzIHRoZSBhY3R1YWwgaHRtbCBmb3IgdGhlIGJyb3dzZXI6IAojK0JFR0lOX0hUTUwK
PGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFT
Q0lJO2Jhc2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0hUTUwKClNvLCBk
dXJpbmcgdGhlIGJsb2cgcHVibGlzaCBzdGVwLCB3ZSBqdXN0IG5lZWQgdG8gYWRkIHRoaXMgbGl0
dGxlIHN0ZXAgdG8gdGhlIGh0bWwgZ2VuZXJhdGlvbiwgYW5kIGl0IHdpbGwgYmUgaW5jbHVkZWQg
YXMgYSBkYXRhIHVyaS4gSGVyZSBpcyB0aGUgZnVuY3Rpb24gdGhhdCBnZW5lcmF0ZXMgdGhlIGRh
dGEgdXJpIGZvciB1cywgYW5kIGV4YW1wbGUgb2YgdXNpbmcgaXQ6CgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIiBkb3dubG9hZD1cInNvdXJjZS5vcmdcIj5zb3VyY2U8L2E+IiAK
ICAgKGJhc2U2NC1lbmNvZGUtc3RyaW5nIHNvdXJjZSkpKQoKKHNvdXJjZS1kYXRhLXVyaSAoYnVm
ZmVyLXN0cmluZykpCiMrRU5EX1NSQwoKCgoKCgoK" download="source.org">source</a>

<p>
Now, we integrate it into the blogofile function:
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">bf-get-post-html</span> ()
  <span style="color: #036A07;">"Return a string containing the YAML header, the post html, my</span>
<span style="color: #036A07;">copyright line, and a link to the org-source code."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((org-source (buffer-string))
        (url-to-org (bf-get-url-to-org-source))
        (yaml (bf-get-YAML-heading))
        (body (bf-get-HTML)))

    (<span style="color: #0000FF;">with-temp-buffer</span>
      (insert yaml)
      (insert body)
      (insert
       (format <span style="color: #008000;">"&lt;p&gt;Copyright (C) %s by John Kitchin. See the &lt;a href=\"/copying.html\"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;"</span>
               (format-time-string <span style="color: #008000;">"%Y"</span>)))
      (insert (format <span style="color: #008000;">"&lt;p&gt;&lt;a href=\"%s\"&gt;org-mode source&lt;/a&gt;&lt;p&gt;"</span>
                      url-to-org))
      (insert (format <span style="color: #008000;">"&lt;p&gt;Org-mode version = %s&lt;/p&gt;"</span> (org-version)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is the only new code we need to add.</span>
      (insert (source-data-uri org-source))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return value</span>
      (buffer-string))))
</pre>
</div>

<p>
Now we need a new adaptation of the grab-org-source function. We still need a regexp search to get the source, and we still need to decode it.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">grab-org-source</span> (url)
  <span style="color: #036A07;">"Extract org-source from URL to a buffer named *grab-org-source*."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sURL: "</span>)
  (switch-to-buffer (get-buffer-create <span style="color: #008000;">"*grab-org-source*"</span>))
  (erase-buffer)
  (org-mode)
  (insert
   (<span style="color: #0000FF;">with-current-buffer</span>
       (url-retrieve-synchronously url)
     (<span style="color: #0000FF;">let</span> (start)
       (re-search-forward
        <span style="color: #008000;">"&lt;a class=\"org-source\" href=\"data:text/plain;charset=US-ASCII;base64,</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">(</span><span style="color: #008000;">[</span><span style="color: #008000;">^</span><span style="color: #008000;">\"]*</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">)</span><span style="color: #008000;">\\\"&gt;"</span> nil t)
       (base64-decode-string  (match-string 1))))))
</pre>
</div>

<p>
What else could we do with this? One idea would be to generate data uris for each code block that you could open in your browser. For example, here we generate a list of data uris for each code block in the buffer. We don't take care to label them or make it easy to see what they are, but if you click on one, you should see a plain text version of the block. If this is done a lot, it might even make sense to change the mime type to download the code in some native app.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(org-element-map (org-element-parse-buffer) 'src-block
  (<span style="color: #0000FF;">lambda</span> (src-block)
    (source-data-uri (org-element-property <span style="color: #006FE0;">:value</span> src-block))))
</pre>
</div>

(<a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBMUzArIikK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIHNvdXJjZS1kYXRhLXVyaSAoc291cmNlKQogICJFbmNvZGUgdGhlIHN0cmluZyBpbiBT
T1VSQ0UgdG8gYSBkYXRhIHVyaS4iCiAgKGZvcm1hdAogICAiPGEgY2xhc3M9XCJvcmctc291cmNl
XCIgaHJlZj1cImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jhc2U2NCwlc1wiPnNv
dXJjZTwvYT4iCiAgIChiYXNlNjQtZW5jb2RlLXN0cmluZyBzb3VyY2UpKSkKCihzb3VyY2UtZGF0
YS11cmkgKGJ1ZmZlci1zdHJpbmcpKQo=">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGJmLWdldC1wb3N0LWh0bWwgKCkKICAiUmV0dXJuIGEgc3RyaW5nIGNvbnRhaW5pbmcg
dGhlIFlBTUwgaGVhZGVyLCB0aGUgcG9zdCBodG1sLCBteQpjb3B5cmlnaHQgbGluZSwgYW5kIGEg
bGluayB0byB0aGUgb3JnLXNvdXJjZSBjb2RlLiIKICAoaW50ZXJhY3RpdmUpCiAgKGxldCAoKG9y
Zy1zb3VyY2UgKGJ1ZmZlci1zdHJpbmcpKQoJKHVybC10by1vcmcgKGJmLWdldC11cmwtdG8tb3Jn
LXNvdXJjZSkpCgkoeWFtbCAoYmYtZ2V0LVlBTUwtaGVhZGluZykpCgkoYm9keSAoYmYtZ2V0LUhU
TUwpKSkKCiAgICAod2l0aC10ZW1wLWJ1ZmZlcgogICAgICAoaW5zZXJ0IHlhbWwpCiAgICAgIChp
bnNlcnQgYm9keSkKICAgICAgKGluc2VydAogICAgICAgKGZvcm1hdCAiPHA+Q29weXJpZ2h0IChD
KSAlcyBieSBKb2huIEtpdGNoaW4uIFNlZSB0aGUgPGEgaHJlZj1cIi9jb3B5aW5nLmh0bWxcIj5M
aWNlbnNlPC9hPiBmb3IgaW5mb3JtYXRpb24gYWJvdXQgY29weWluZy48cD4iCgkgICAgICAgKGZv
cm1hdC10aW1lLXN0cmluZyAiJVkiKSkpCiAgICAgIChpbnNlcnQgKGZvcm1hdCAiPHA+PGEgaHJl
Zj1cIiVzXCI+b3JnLW1vZGUgc291cmNlPC9hPjxwPiIKCQkgICAgICB1cmwtdG8tb3JnKSkKICAg
ICAgKGluc2VydCAoZm9ybWF0ICI8cD5PcmctbW9kZSB2ZXJzaW9uID0gJXM8L3A+IiAob3JnLXZl
cnNpb24pKSkKICAgICAgOzsgdGhpcyBpcyB0aGUgb25seSBuZXcgY29kZSB3ZSBuZWVkIHRvIGFk
ZC4KICAgICAgKGluc2VydCAoc291cmNlLWRhdGEtdXJpIG9yZy1zb3VyY2UpKQogICAgICA7OyBy
ZXR1cm4gdmFsdWUKICAgICAgKGJ1ZmZlci1zdHJpbmcpKSkpCg==">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KGRlZnVuIGdyYWItb3JnLXNvdXJjZSAodXJsKQogICJFeHRyYWN0IG9yZy1zb3VyY2UgZnJvbSBV
UkwgdG8gYSBidWZmZXIgbmFtZWQgKmdyYWItb3JnLXNvdXJjZSouIgogIChpbnRlcmFjdGl2ZSAi
c1VSTDogIikKICAoc3dpdGNoLXRvLWJ1ZmZlciAoZ2V0LWJ1ZmZlci1jcmVhdGUgIipncmFiLW9y
Zy1zb3VyY2UqIikpCiAgKGVyYXNlLWJ1ZmZlcikKICAob3JnLW1vZGUpCiAgKGluc2VydAogICAo
d2l0aC1jdXJyZW50LWJ1ZmZlcgogICAgICAgKHVybC1yZXRyaWV2ZS1zeW5jaHJvbm91c2x5IHVy
bCkKICAgICAobGV0IChzdGFydCkKICAgICAgIChyZS1zZWFyY2gtZm9yd2FyZAoJIjxhIGNsYXNz
PVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1VUy1BU0NJSTti
YXNlNjQsXFwoW15cIl0qXFwpXFxcIj4iIG5pbCB0KQogICAgICAgKGJhc2U2NC1kZWNvZGUtc3Ry
aW5nICAobWF0Y2gtc3RyaW5nIDEpKSkpKSkK">source</a> <a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KG9yZy1lbGVtZW50LW1hcCAob3JnLWVsZW1lbnQtcGFyc2UtYnVmZmVyKSAnc3JjLWJsb2NrCiAg
KGxhbWJkYSAoc3JjLWJsb2NrKQogICAgKHNvdXJjZS1kYXRhLXVyaSAob3JnLWVsZW1lbnQtcHJv
cGVydHkgOnZhbHVlIHNyYy1ibG9jaykpKSkK">source</a>)


<p>
I am not sure if this is better or worse than the other approach. I have not tested it very thoroughly, but it seems like it should work pretty generally. I imagine you could also embed other kinds of files in the html, if for some reason you did not want to put the files on your server. Overall this seems to lack some elegance in searching for data, e.g. like <a href="http://en.wikipedia.org/wiki/Embedded_RDF">RDF</a> or <a href="http://en.wikipedia.org/wiki/RDFa">RDFa</a> is supposed to enable, but it might be a step in that direction, using org-mode and Emacs as the editor.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/09/Another-approach-to-embedding-org-source-in-html.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p><a class="org-source" href="data:text/plain;charset=US-ASCII;base64,KiBET05FIEFub3RoZXIgYXBwcm9hY2ggdG8gZW1iZWRkaW5nIG9yZy1zb3VyY2UgaW4gaHRtbAog
IENMT1NFRDogWzIwMTUtMDUtMDkgU2F0IDE5OjE5XQogIDpQUk9QRVJUSUVTOgogIDpkYXRlOiAg
ICAgMjAxNS8wNS8wOSAxOToxOToxMAogIDp1cGRhdGVkOiAgMjAxNS8wNS8xMCAwOTozNDo1NQog
IDpjYXRlZ29yaWVzOiBvcmdtb2RlLCBkYXRhCiAgOkVORDoKSW4gdGhpcyBbW2h0dHA6Ly9raXRj
aGluZ3JvdXAuY2hlbWUuY211LmVkdS9ibG9nLzIwMTUvMDUvMDkvQW4tYWx0ZXJuYXRpdmUtYXBw
cm9hY2gtdG8taW5jbHVkaW5nLW9yZy1zb3VyY2UtaW4tYmxvZy1wb3N0cy9dW3Bvc3RdXSBJIGV4
YW1pbmVkIGEgd2F5IHRvIGVtYmVkIHRoZSBvcmctc291cmNlIGluIGEgY29tbWVudCBpbiB0aGUg
aHRtbCBvZiB0aGUgcG9zdCwgYW5kIGRldmVsb3BlZCBhIHJlYXNvbmFibHkgY29udmVuaWVudCB3
YXkgdG8gZXh0cmFjdCB0aGUgc291cmNlIGluIGVtYWNzLiBPbmUgZG93bnNpZGUgb2YgdGhlIGFw
cHJvYWNoIHdhcyB0aGUgbmVlZCB0byBlc2NhcGUgYXQgbGVhc3QgdGhlIGRhc2hlcywgYW5kIHRo
ZW4gdW5lc2NhcGUgdGhlbSBvbiBleHRyYWN0aW9uLiBJIGNhbWUgYWNyb3NzIGFub3RoZXIgaWRl
YSwgd2hpY2ggaXMgdG8gcHV0IHRoZSBvcmctc291cmNlIGluIGJhc2U2NCBlbmNvZGVkIGZvcm0g
aW4gYSBbW2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGF0YV9VUklfc2NoZW1lXVtkYXRh
IHVyaV1dLgoKRmlyc3QgbGV0IHVzIHNlZSB3aGF0IHRoZSBlbmNvZGluZyBtZWFuczoKCiMrQkVH
SU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1lbmNvZGUtc3RyaW5nICI8IS0tIHRlc3QtLT4iKQoj
K0VORF9TUkMKIytSRVNVTFRTOgo6IFBDRXRMU0IwWlhOMExTMCsKCkFuZCBkZWNvZGluZzoKCiMr
QkVHSU5fU1JDIGVtYWNzLWxpc3AKKGJhc2U2NC1kZWNvZGUtc3RyaW5nICJQQ0V0TFNCMFpYTjBM
UzArIikKIytFTkRfU1JDCgojK1JFU1VMVFM6CjogPCEtLSB0ZXN0LS0+CgpUaGUgZW5jb2Rpbmcg
bG9va3MgcmFuZG9tLCBidXQgaXQgaXMgcmV2ZXJzaWJsZS4gTW9yZSBpbXBvcnRhbnRseSwgaXQg
cHJvYmFibHkgd2lsbCBub3QgaGF2ZSBhbnkgaHRtbCBsaWtlIGNoYXJhY3RlcnMgaW4gaXQgdGhh
dCBuZWVkIGVzY2FwZWQuIFRoZSBpZGVhIG9mIGEgZGF0YSB1cmkgaXMgdGhhdCB0aGUgZGF0YSBp
dCBzZXJ2ZXMgaXMgZW1iZWRkZWQgaW4gdGhlIFVSTCBocmVmIGF0dHJpYnV0ZS4gVGhpcyBpcyBi
YXNpY2FsbHkgaG93IHRvIG1ha2UgYSBkYXRhIHVyaS4gV2UgZ2l2ZSB0aGUgdXJsIGhlcmUgYSBj
bGFzcyBzbyB3ZSBjYW4gZmluZCBpdCBsYXRlci4KIytCRUdJTl9FWEFNUExFCjxhIGNsYXNzPSJz
b21lLW9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJO2Jh
c2U2NCxQQ0V0TFNCMFpYTjBMUzArIj5zb3VyY2U8L2E+CiMrRU5EX0VYQU1QTEUKCkhlcmUgaXMg
dGhlIGFjdHVhbCBodG1sIGZvciB0aGUgYnJvd3Nlci4gSWYgeW91IGNsaWNrIG9uIGl0LCB5b3Vy
IGJyb3dzZXIgYXV0b21hdGljYWxseSBkZWNvZGVzIGl0IGZvciB5b3UhCiMrQkVHSU5fSFRNTAo8
YSBjbGFzcz0ic29tZS1vcmctc291cmNlIiBocmVmPSJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsUENFdExTQjBaWE4wTFMwKyI+c291cmNlPC9hPgojK0VORF9IVE1MCgpT
bywgZHVyaW5nIHRoZSBibG9nIHB1Ymxpc2ggc3RlcCwgd2UganVzdCBuZWVkIHRvIGFkZCB0aGlz
IGxpdHRsZSBzdGVwIHRvIHRoZSBodG1sIGdlbmVyYXRpb24sIGFuZCBpdCB3aWxsIGJlIGluY2x1
ZGVkIGFzIGEgZGF0YSB1cmkuIEhlcmUgaXMgdGhlIGZ1bmN0aW9uIHRoYXQgZ2VuZXJhdGVzIHRo
ZSBkYXRhIHVyaSBmb3IgdXMsIGFuZCBleGFtcGxlIG9mIHVzaW5nIGl0LiBUaGUgZW5jb2RlZCBz
b3VyY2UgaXMgbm90IGF0IGFsbCBhdHRyYWN0aXZlIHRvIGxvb2sgYXQgaXQsIGJ1dCB5b3UgYWxt
b3N0IG5ldmVyIG5lZWQgdG8gbG9vayBhdCBpdCwgaXQgaXMgaW52aXNpYmxlIGluIHRoZSBicm93
c2VyLiBJbnRlcmVzdGluZ2x5LCBpZiB5b3UgY2xpY2sgb24gdGhlIGxpbmssIHlvdSB3aWxsIHNl
ZSB0aGUgb3JnIHNvdXJjZSByaWdodCBpbiB5b3VyIGJyb3dzZXIhCgojK0JFR0lOX1NSQyBlbWFj
cy1saXNwICA6cmVzdWx0cyBodG1sCihkZWZ1biBzb3VyY2UtZGF0YS11cmkgKHNvdXJjZSkKICAi
RW5jb2RlIHRoZSBzdHJpbmcgaW4gU09VUkNFIHRvIGEgZGF0YSB1cmkuIgogIChmb3JtYXQKICAg
IjxhIGNsYXNzPVwib3JnLXNvdXJjZVwiIGhyZWY9XCJkYXRhOnRleHQvcGxhaW47Y2hhcnNldD1V
Uy1BU0NJSTtiYXNlNjQsJXNcIj5zb3VyY2U8L2E+IgogICAoYmFzZTY0LWVuY29kZS1zdHJpbmcg
c291cmNlKSkpCgooc291cmNlLWRhdGEtdXJpIChidWZmZXItc3RyaW5nKSkKIytFTkRfU1JDCgoj
K1JFU1VMVFM6CiMrQkVHSU5fSFRNTAo8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0
ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtpQkJibTkwYUdWeUlHRndjSEp2WVdO
b0lIUnZJR1Z0WW1Wa1pHbHVaeUJ2Y21jdGMyOTFjbU5sSUdsdUlHaDBiV3dLU1c0Z2RHaHAKY3lC
YlcyaDBkSEE2THk5cmFYUmphR2x1WjNKdmRYQXVZMmhsYldVdVkyMTFMbVZrZFM5aWJHOW5Mekl3
TVRVdk1EVXZNRGt2UVc0dApZV3gwWlhKdVlYUnBkbVV0WVhCd2NtOWhZMmd0ZEc4dGFXNWpiSFZr
YVc1bkxXOXlaeTF6YjNWeVkyVXRhVzR0WW14dlp5MXdiM04wCmN5OWRXM0J2YzNSZFhTQkpJR1Y0
WVcxcGJtVmtJR0VnZDJGNUlIUnZJR1Z0WW1Wa0lIUm9aU0J2Y21jdGMyOTFjbU5sSUdsdUlHRWcK
WTI5dGJXVnVkQ0JwYmlCMGFHVWdhSFJ0YkNCdlppQjBhR1VnY0c5emRDd2dZVzVrSUdSbGRtVnNi
M0JsWkNCaElISmxZWE52Ym1GaQpiSGtnWTI5dWRtVnVhV1Z1ZENCM1lYa2dkRzhnWlhoMGNtRmpk
Q0IwYUdVZ2MyOTFjbU5sSUdsdUlHVnRZV056TGlCUGJtVWdaRzkzCmJuTnBaR1VnYjJZZ2RHaGxJ
R0Z3Y0hKdllXTm9JSGRoY3lCMGFHVWdibVZsWkNCMGJ5QmxjMk5oY0dVZ1lYUWdiR1ZoYzNRZ2RH
aGwKSUdSaGMyaGxjeXdnWVc1a0lIUm9aVzRnZFc1bGMyTmhjR1VnZEdobGJTQnZiaUJsZUhSeVlX
TjBhVzl1TGlCSklHTmhiV1VnWVdOeQpiM056SUdGdWIzUm9aWElnYVdSbFlTd2dkMmhwWTJnZ2FY
TWdkRzhnY0hWMElIUm9aU0J2Y21jdGMyOTFjbU5sSUdsdUlHSmhjMlUyCk5DQmxibU52WkdWa0lH
WnZjbTBnYVc0Z1lTQmJXMmgwZEhBNkx5OWxiaTUzYVd0cGNHVmthV0V1YjNKbkwzZHBhMmt2UkdG
MFlWOVYKVWtsZmMyTm9aVzFsWFZ0a1lYUmhJSFZ5YVYxZExnb0tSbWx5YzNRZ2JHVjBJSFZ6SUhO
bFpTQjNhR0YwSUhSb1pTQmxibU52WkdsdQpaeUJ0WldGdWN6b0tDaU1yUWtWSFNVNWZVMUpESUdW
dFlXTnpMV3hwYzNBS0tHSmhjMlUyTkMxbGJtTnZaR1V0YzNSeWFXNW5JQ0k4CklTMHRJSFJsYzNR
dExUNGlLUW9qSzBWT1JGOVRVa01LSXl0U1JWTlZURlJUT2dvNklGQkRSWFJNVTBJd1dsaE9NRXhU
TUNzS0NrRnUKWkNCa1pXTnZaR2x1WnpvS0NpTXJRa1ZIU1U1ZlUxSkRJR1Z0WVdOekxXeHBjM0FL
S0dKaGMyVTJOQzFrWldOdlpHVXRjM1J5YVc1bgpJQ0pRUTBWMFRGTkNNRnBZVGpCTVV6QXJJaWtL
SXl0RlRrUmZVMUpEQ2dvaksxSkZVMVZNVkZNNkNqb2dQQ0V0TFNCMFpYTjBMUzArCkNncEJibVFn
ZEdocGN5QnBjeUJpWVhOcFkyRnNiSGtnYUc5M0lIUnZJRzFoYTJVZ1lTQmtZWFJoSUhWeWFTNGdW
MlVnWjJsMlpTQjAKYUdVZ2RYSnNJR2hsY21VZ1lTQmpiR0Z6Y3lCemJ5QjNaU0JqWVc0Z1ptbHVa
Q0JwZENCc1lYUmxjaTRLSXl0Q1JVZEpUbDlGV0VGTgpVRXhGQ2p4aElHTnNZWE56UFNKdmNtY3Rj
MjkxY21ObElpQm9jbVZtUFNKa1lYUmhPblJsZUhRdmNHeGhhVzQ3WTJoaGNuTmxkRDFWClV5MUJV
ME5KU1R0aVlYTmxOalFzVUVORmRFeFRRakJhV0U0d1RGTXdLeUkrYzI5MWNtTmxQQzloUGdvaksw
Vk9SRjlGV0VGTlVFeEYKQ2dwSVpYSmxJR2x6SUhSb1pTQmhZM1IxWVd3Z2FIUnRiQ0JtYjNJZ2RH
aGxJR0p5YjNkelpYSTZJQW9qSzBKRlIwbE9YMGhVVFV3SwpQR0VnWTJ4aGMzTTlJbTl5WnkxemIz
VnlZMlVpSUdoeVpXWTlJbVJoZEdFNmRHVjRkQzl3YkdGcGJqdGphR0Z5YzJWMFBWVlRMVUZUClEw
bEpPMkpoYzJVMk5DeFFRMFYwVEZOQ01GcFlUakJNVXpBcklqNXpiM1Z5WTJVOEwyRStDaU1yUlU1
RVgwaFVUVXdLQ2xOdkxDQmsKZFhKcGJtY2dkR2hsSUdKc2IyY2djSFZpYkdsemFDQnpkR1Z3TENC
M1pTQnFkWE4wSUc1bFpXUWdkRzhnWVdSa0lIUm9hWE1nYkdsMApkR3hsSUhOMFpYQWdkRzhnZEdo
bElHaDBiV3dnWjJWdVpYSmhkR2x2Yml3Z1lXNWtJR2wwSUhkcGJHd2dZbVVnYVc1amJIVmtaV1Fn
CllYTWdZU0JrWVhSaElIVnlhUzRnU0dWeVpTQnBjeUIwYUdVZ1puVnVZM1JwYjI0Z2RHaGhkQ0Ju
Wlc1bGNtRjBaWE1nZEdobElHUmgKZEdFZ2RYSnBJR1p2Y2lCMWN5d2dZVzVrSUdWNFlXMXdiR1Vn
YjJZZ2RYTnBibWNnYVhRNkNnb2pLMEpGUjBsT1gxTlNReUJsYldGagpjeTFzYVhOd0lDQTZjbVZ6
ZFd4MGN5Qm9kRzFzQ2loa1pXWjFiaUJ6YjNWeVkyVXRaR0YwWVMxMWNta2dLSE52ZFhKalpTa0tJ
Q0FpClJXNWpiMlJsSUhSb1pTQnpkSEpwYm1jZ2FXNGdVMDlWVWtORklIUnZJR0VnWkdGMFlTQjFj
bWt1SWdvZ0lDaG1iM0p0WVhRS0lDQWcKSWp4aElHTnNZWE56UFZ3aWIzSm5MWE52ZFhKalpWd2lJ
R2h5WldZOVhDSmtZWFJoT25SbGVIUXZjR3hoYVc0N1kyaGhjbk5sZEQxVgpVeTFCVTBOSlNUdGlZ
WE5sTmpRc0pYTmNJaUJrYjNkdWJHOWhaRDFjSW5OdmRYSmpaUzV2Y21kY0lqNXpiM1Z5WTJVOEwy
RStJaUFLCklDQWdLR0poYzJVMk5DMWxibU52WkdVdGMzUnlhVzVuSUhOdmRYSmpaU2twS1FvS0tI
TnZkWEpqWlMxa1lYUmhMWFZ5YVNBb1luVm0KWm1WeUxYTjBjbWx1WnlrcENpTXJSVTVFWDFOU1F3
b0tDZ29LQ2dvSyIgZG93bmxvYWQ9InNvdXJjZS5vcmciPnNvdXJjZTwvYT4KIytFTkRfSFRNTAoK
Tm93LCB3ZSBpbnRlZ3JhdGUgaXQgaW50byB0aGUgYmxvZ29maWxlIGZ1bmN0aW9uOgoKIytCRUdJ
Tl9TUkMgZW1hY3MtbGlzcAooZGVmdW4gYmYtZ2V0LXBvc3QtaHRtbCAoKQogICJSZXR1cm4gYSBz
dHJpbmcgY29udGFpbmluZyB0aGUgWUFNTCBoZWFkZXIsIHRoZSBwb3N0IGh0bWwsIG15CmNvcHly
aWdodCBsaW5lLCBhbmQgYSBsaW5rIHRvIHRoZSBvcmctc291cmNlIGNvZGUuIgogIChpbnRlcmFj
dGl2ZSkKICAobGV0ICgob3JnLXNvdXJjZSAoYnVmZmVyLXN0cmluZykpCgkodXJsLXRvLW9yZyAo
YmYtZ2V0LXVybC10by1vcmctc291cmNlKSkKCSh5YW1sIChiZi1nZXQtWUFNTC1oZWFkaW5nKSkK
CShib2R5IChiZi1nZXQtSFRNTCkpKQoKICAgICh3aXRoLXRlbXAtYnVmZmVyCiAgICAgIChpbnNl
cnQgeWFtbCkKICAgICAgKGluc2VydCBib2R5KQogICAgICAoaW5zZXJ0CiAgICAgICAoZm9ybWF0
ICI8cD5Db3B5cmlnaHQgKEMpICVzIGJ5IEpvaG4gS2l0Y2hpbi4gU2VlIHRoZSA8YSBocmVmPVwi
L2NvcHlpbmcuaHRtbFwiPkxpY2Vuc2U8L2E+IGZvciBpbmZvcm1hdGlvbiBhYm91dCBjb3B5aW5n
LjxwPiIKCSAgICAgICAoZm9ybWF0LXRpbWUtc3RyaW5nICIlWSIpKSkKICAgICAgKGluc2VydCAo
Zm9ybWF0ICI8cD48YSBocmVmPVwiJXNcIj5vcmctbW9kZSBzb3VyY2U8L2E+PHA+IgoJCSAgICAg
IHVybC10by1vcmcpKQogICAgICAoaW5zZXJ0IChmb3JtYXQgIjxwPk9yZy1tb2RlIHZlcnNpb24g
PSAlczwvcD4iIChvcmctdmVyc2lvbikpKQogICAgICA7OyB0aGlzIGlzIHRoZSBvbmx5IG5ldyBj
b2RlIHdlIG5lZWQgdG8gYWRkLgogICAgICAoaW5zZXJ0IChzb3VyY2UtZGF0YS11cmkgb3JnLXNv
dXJjZSkpCiAgICAgIDs7IHJldHVybiB2YWx1ZQogICAgICAoYnVmZmVyLXN0cmluZykpKSkKIytF
TkRfU1JDCgpOb3cgd2UgbmVlZCBhIG5ldyBhZGFwdGF0aW9uIG9mIHRoZSBncmFiLW9yZy1zb3Vy
Y2UgZnVuY3Rpb24uIFdlIHN0aWxsIG5lZWQgYSByZWdleHAgc2VhcmNoIHRvIGdldCB0aGUgc291
cmNlLCBhbmQgd2Ugc3RpbGwgbmVlZCB0byBkZWNvZGUgaXQuCgojK0JFR0lOX1NSQyBlbWFjcy1s
aXNwCihkZWZ1biBncmFiLW9yZy1zb3VyY2UgKHVybCkKICAiRXh0cmFjdCBvcmctc291cmNlIGZy
b20gVVJMIHRvIGEgYnVmZmVyIG5hbWVkICpncmFiLW9yZy1zb3VyY2UqLiIKICAoaW50ZXJhY3Rp
dmUgInNVUkw6ICIpCiAgKHN3aXRjaC10by1idWZmZXIgKGdldC1idWZmZXItY3JlYXRlICIqZ3Jh
Yi1vcmctc291cmNlKiIpKQogIChlcmFzZS1idWZmZXIpCiAgKG9yZy1tb2RlKQogIChpbnNlcnQK
ICAgKHdpdGgtY3VycmVudC1idWZmZXIKICAgICAgICh1cmwtcmV0cmlldmUtc3luY2hyb25vdXNs
eSB1cmwpCiAgICAgKGxldCAoc3RhcnQpCiAgICAgICAocmUtc2VhcmNoLWZvcndhcmQKCSI8YSBj
bGFzcz1cIm9yZy1zb3VyY2VcIiBocmVmPVwiZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVND
SUk7YmFzZTY0LFxcKFteXCJdKlxcKVxcXCI+IiBuaWwgdCkKICAgICAgIChiYXNlNjQtZGVjb2Rl
LXN0cmluZyAgKG1hdGNoLXN0cmluZyAxKSkpKSkpCiMrRU5EX1NSQwoKV2hhdCBlbHNlIGNvdWxk
IHdlIGRvIHdpdGggdGhpcz8gT25lIGlkZWEgd291bGQgYmUgdG8gZ2VuZXJhdGUgZGF0YSB1cmlz
IGZvciBlYWNoIGNvZGUgYmxvY2sgdGhhdCB5b3UgY291bGQgb3BlbiBpbiB5b3VyIGJyb3dzZXIu
IEZvciBleGFtcGxlLCBoZXJlIHdlIGdlbmVyYXRlIGEgbGlzdCBvZiBkYXRhIHVyaXMgZm9yIGVh
Y2ggY29kZSBibG9jayBpbiB0aGUgYnVmZmVyLiBXZSBkb24ndCB0YWtlIGNhcmUgdG8gbGFiZWwg
dGhlbSBvciBtYWtlIGl0IGVhc3kgdG8gc2VlIHdoYXQgdGhleSBhcmUsIGJ1dCBpZiB5b3UgY2xp
Y2sgb24gb25lLCB5b3Ugc2hvdWxkIHNlZSBhIHBsYWluIHRleHQgdmVyc2lvbiBvZiB0aGUgYmxv
Y2suIElmIHRoaXMgaXMgZG9uZSBhIGxvdCwgaXQgbWlnaHQgZXZlbiBtYWtlIHNlbnNlIHRvIGNo
YW5nZSB0aGUgbWltZSB0eXBlIHRvIGRvd25sb2FkIHRoZSBjb2RlIGluIHNvbWUgbmF0aXZlIGFw
cC4KCiMrQkVHSU5fU1JDIGVtYWNzLWxpc3AgOnJlc3VsdHMgaHRtbAoob3JnLWVsZW1lbnQtbWFw
IChvcmctZWxlbWVudC1wYXJzZS1idWZmZXIpICdzcmMtYmxvY2sKICAobGFtYmRhIChzcmMtYmxv
Y2spCiAgICAoc291cmNlLWRhdGEtdXJpIChvcmctZWxlbWVudC1wcm9wZXJ0eSA6dmFsdWUgc3Jj
LWJsb2NrKSkpKQojK0VORF9TUkMKCiMrUkVTVUxUUzoKIytCRUdJTl9IVE1MCig8YSBjbGFzcz0i
b3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0
LEtHSmhjMlUyTkMxbGJtTnZaR1V0YzNSeWFXNW5JQ0k4SVMwdElIUmxjM1F0TFQ0aUtRbz0iPnNv
dXJjZTwvYT4gPGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFy
c2V0PVVTLUFTQ0lJO2Jhc2U2NCxLR0poYzJVMk5DMWtaV052WkdVdGMzUnlhVzVuSUNKUVEwVjBU
Rk5DTUZwWVRqQk1VekFySWlrSyI+c291cmNlPC9hPiA8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJl
Zj0iZGF0YTp0ZXh0L3BsYWluO2NoYXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtHUmxablZ1SUhOdmRY
SmpaUzFrWVhSaExYVnlhU0FvYzI5MWNtTmxLUW9nSUNKRmJtTnZaR1VnZEdobElITjBjbWx1WnlC
cGJpQlQKVDFWU1EwVWdkRzhnWVNCa1lYUmhJSFZ5YVM0aUNpQWdLR1p2Y20xaGRBb2dJQ0FpUEdF
Z1kyeGhjM005WENKdmNtY3RjMjkxY21ObApYQ0lnYUhKbFpqMWNJbVJoZEdFNmRHVjRkQzl3YkdG
cGJqdGphR0Z5YzJWMFBWVlRMVUZUUTBsSk8ySmhjMlUyTkN3bGMxd2lQbk52CmRYSmpaVHd2WVQ0
aUNpQWdJQ2hpWVhObE5qUXRaVzVqYjJSbExYTjBjbWx1WnlCemIzVnlZMlVwS1NrS0NpaHpiM1Z5
WTJVdFpHRjAKWVMxMWNta2dLR0oxWm1abGNpMXpkSEpwYm1jcEtRbz0iPnNvdXJjZTwvYT4gPGEg
Y2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVTLUFTQ0lJ
O2Jhc2U2NCxLR1JsWm5WdUlHSm1MV2RsZEMxd2IzTjBMV2gwYld3Z0tDa0tJQ0FpVW1WMGRYSnVJ
R0VnYzNSeWFXNW5JR052Ym5SaGFXNXBibWNnCmRHaGxJRmxCVFV3Z2FHVmhaR1Z5TENCMGFHVWdj
Rzl6ZENCb2RHMXNMQ0J0ZVFwamIzQjVjbWxuYUhRZ2JHbHVaU3dnWVc1a0lHRWcKYkdsdWF5QjBi
eUIwYUdVZ2IzSm5MWE52ZFhKalpTQmpiMlJsTGlJS0lDQW9hVzUwWlhKaFkzUnBkbVVwQ2lBZ0tH
eGxkQ0FvS0c5eQpaeTF6YjNWeVkyVWdLR0oxWm1abGNpMXpkSEpwYm1jcEtRb0pLSFZ5YkMxMGJ5
MXZjbWNnS0dKbUxXZGxkQzExY213dGRHOHRiM0puCkxYTnZkWEpqWlNrcENna29lV0Z0YkNBb1lt
WXRaMlYwTFZsQlRVd3RhR1ZoWkdsdVp5a3BDZ2tvWW05a2VTQW9ZbVl0WjJWMExVaFUKVFV3cEtT
a0tDaUFnSUNBb2QybDBhQzEwWlcxd0xXSjFabVpsY2dvZ0lDQWdJQ0FvYVc1elpYSjBJSGxoYld3
cENpQWdJQ0FnSUNocApibk5sY25RZ1ltOWtlU2tLSUNBZ0lDQWdLR2x1YzJWeWRBb2dJQ0FnSUNB
Z0tHWnZjbTFoZENBaVBIQStRMjl3ZVhKcFoyaDBJQ2hECktTQWxjeUJpZVNCS2IyaHVJRXRwZEdO
b2FXNHVJRk5sWlNCMGFHVWdQR0VnYUhKbFpqMWNJaTlqYjNCNWFXNW5MbWgwYld4Y0lqNU0KYVdO
bGJuTmxQQzloUGlCbWIzSWdhVzVtYjNKdFlYUnBiMjRnWVdKdmRYUWdZMjl3ZVdsdVp5NDhjRDRp
Q2drZ0lDQWdJQ0FnS0dadgpjbTFoZEMxMGFXMWxMWE4wY21sdVp5QWlKVmtpS1NrcENpQWdJQ0Fn
SUNocGJuTmxjblFnS0dadmNtMWhkQ0FpUEhBK1BHRWdhSEpsClpqMWNJaVZ6WENJK2IzSm5MVzF2
WkdVZ2MyOTFjbU5sUEM5aFBqeHdQaUlLQ1FrZ0lDQWdJQ0IxY213dGRHOHRiM0puS1NrS0lDQWcK
SUNBZ0tHbHVjMlZ5ZENBb1ptOXliV0YwSUNJOGNENVBjbWN0Ylc5a1pTQjJaWEp6YVc5dUlEMGdK
WE04TDNBK0lpQW9iM0puTFhabApjbk5wYjI0cEtTa0tJQ0FnSUNBZ096c2dkR2hwY3lCcGN5QjBh
R1VnYjI1c2VTQnVaWGNnWTI5a1pTQjNaU0J1WldWa0lIUnZJR0ZrClpDNEtJQ0FnSUNBZ0tHbHVj
MlZ5ZENBb2MyOTFjbU5sTFdSaGRHRXRkWEpwSUc5eVp5MXpiM1Z5WTJVcEtRb2dJQ0FnSUNBN095
QnkKWlhSMWNtNGdkbUZzZFdVS0lDQWdJQ0FnS0dKMVptWmxjaTF6ZEhKcGJtY3BLU2twQ2c9PSI+
c291cmNlPC9hPiA8YSBjbGFzcz0ib3JnLXNvdXJjZSIgaHJlZj0iZGF0YTp0ZXh0L3BsYWluO2No
YXJzZXQ9VVMtQVNDSUk7YmFzZTY0LEtHUmxablZ1SUdkeVlXSXRiM0puTFhOdmRYSmpaU0FvZFhK
c0tRb2dJQ0pGZUhSeVlXTjBJRzl5WnkxemIzVnlZMlVnWm5KdmJTQlYKVWt3Z2RHOGdZU0JpZFda
bVpYSWdibUZ0WldRZ0ttZHlZV0l0YjNKbkxYTnZkWEpqWlNvdUlnb2dJQ2hwYm5SbGNtRmpkR2wy
WlNBaQpjMVZTVERvZ0lpa0tJQ0FvYzNkcGRHTm9MWFJ2TFdKMVptWmxjaUFvWjJWMExXSjFabVps
Y2kxamNtVmhkR1VnSWlwbmNtRmlMVzl5Clp5MXpiM1Z5WTJVcUlpa3BDaUFnS0dWeVlYTmxMV0ox
Wm1abGNpa0tJQ0FvYjNKbkxXMXZaR1VwQ2lBZ0tHbHVjMlZ5ZEFvZ0lDQW8KZDJsMGFDMWpkWEp5
Wlc1MExXSjFabVpsY2dvZ0lDQWdJQ0FnS0hWeWJDMXlaWFJ5YVdWMlpTMXplVzVqYUhKdmJtOTFj
Mng1SUhWeQpiQ2tLSUNBZ0lDQW9iR1YwSUNoemRHRnlkQ2tLSUNBZ0lDQWdJQ2h5WlMxelpXRnlZ
Mmd0Wm05eWQyRnlaQW9KSWp4aElHTnNZWE56ClBWd2liM0puTFhOdmRYSmpaVndpSUdoeVpXWTlY
Q0prWVhSaE9uUmxlSFF2Y0d4aGFXNDdZMmhoY25ObGREMVZVeTFCVTBOSlNUdGkKWVhObE5qUXNY
RndvVzE1Y0lsMHFYRndwWEZ4Y0lqNGlJRzVwYkNCMEtRb2dJQ0FnSUNBZ0tHSmhjMlUyTkMxa1pX
TnZaR1V0YzNSeQphVzVuSUNBb2JXRjBZMmd0YzNSeWFXNW5JREVwS1NrcEtTa0siPnNvdXJjZTwv
YT4gPGEgY2xhc3M9Im9yZy1zb3VyY2UiIGhyZWY9ImRhdGE6dGV4dC9wbGFpbjtjaGFyc2V0PVVT
LUFTQ0lJO2Jhc2U2NCxLRzl5WnkxbGJHVnRaVzUwTFcxaGNDQW9iM0puTFdWc1pXMWxiblF0Y0dG
eWMyVXRZblZtWm1WeUtTQW5jM0pqTFdKc2IyTnJDaUFnCktHeGhiV0prWVNBb2MzSmpMV0pzYjJO
cktRb2dJQ0FnS0hOdmRYSmpaUzFrWVhSaExYVnlhU0FvYjNKbkxXVnNaVzFsYm5RdGNISnYKY0dW
eWRIa2dPblpoYkhWbElITnlZeTFpYkc5amF5a3BLU2tLIj5zb3VyY2U8L2E+KQojK0VORF9IVE1M
CgoKSSBhbSBub3Qgc3VyZSBpZiB0aGlzIGlzIGJldHRlciBvciB3b3JzZSB0aGFuIHRoZSBvdGhl
ciBhcHByb2FjaC4gSSBoYXZlIG5vdCB0ZXN0ZWQgaXQgdmVyeSB0aG9yb3VnaGx5LCBidXQgaXQg
c2VlbXMgbGlrZSBpdCBzaG91bGQgd29yayBwcmV0dHkgZ2VuZXJhbGx5LiBJIGltYWdpbmUgeW91
IGNvdWxkIGFsc28gZW1iZWQgb3RoZXIga2luZHMgb2YgZmlsZXMgaW4gdGhlIGh0bWwsIGlmIGZv
ciBzb21lIHJlYXNvbiB5b3UgZGlkIG5vdCB3YW50IHRvIHB1dCB0aGUgZmlsZXMgb24geW91ciBz
ZXJ2ZXIuIE92ZXJhbGwgdGhpcyBzZWVtcyB0byBsYWNrIHNvbWUgZWxlZ2FuY2UgaW4gc2VhcmNo
aW5nIGZvciBkYXRhLCBlLmcuIGxpa2UgW1todHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Vt
YmVkZGVkX1JERl1bUkRGXV0gb3IgW1todHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1JERmFd
W1JERmFdXSBpcyBzdXBwb3NlZCB0byBlbmFibGUsIGJ1dCBpdCBtaWdodCBiZSBhIHN0ZXAgaW4g
dGhhdCBkaXJlY3Rpb24sIHVzaW5nIG9yZy1tb2RlIGFuZCBFbWFjcyBhcyB0aGUgZWRpdG9yLgoK">source</a>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[An alternative approach to including org-source in blog posts]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts" />
    <id>http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts</id>
    <updated>2015-05-09T14:58:24Z</updated>
    <published>2015-05-09T13:50:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <summary type="html"><![CDATA[An alternative approach to including org-source in blog posts]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts"><![CDATA[


<p>
When you publish a Matlab m-file to HTML, Matlab includes the m-file source as an html comment in the output. They also provide a nice function called grabcode that will take a url, and open the source code in the editor. Today, we try a similar approach for org-mode.
</p>

<p>
This post is not totally self-contained. I have my own emacs-lisp module that converts org-mode to blogofile posts, and so far I have not made it broadly available. This is also a super exploratory idea, so I am just going to show the changes I need to make to my setup to get to the evaluation of the idea.
</p>

<p>
The idea is pretty simple, we just insert the current buffer string into an HTML comment. I just modify the bf-get-post-html function lightly to do that. This is a somewhat pathological example since there are html comments in the post! So, we will encode all the dashes to get around that.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">require</span> '<span style="color: #D0372D;">browse-url</span>)
(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">bf-get-post-html</span> ()
  <span style="color: #036A07;">"Return a string containing the YAML header, the post html, my</span>
<span style="color: #036A07;">copyright line, and a link to the org-source code."</span>
  (<span style="color: #0000FF;">interactive</span>)
  (<span style="color: #0000FF;">let</span> ((org-source (buffer-string))
        (url-to-org (bf-get-url-to-org-source))
        (yaml (bf-get-YAML-heading))
        (body (bf-get-HTML)))

    (<span style="color: #0000FF;">with-temp-buffer</span>
      (insert yaml)
      (insert body)
      (insert
       (format <span style="color: #008000;">"&lt;p&gt;Copyright (C) %s by John Kitchin. See the &lt;a href=\"/copying.html\"&gt;License&lt;/a&gt; for information about copying.&lt;p&gt;"</span>
               (format-time-string <span style="color: #008000;">"%Y"</span>)))
      (insert (format <span style="color: #008000;">"&lt;p&gt;&lt;a href=\"%s\"&gt;org-mode source&lt;/a&gt;&lt;p&gt;"</span>
                      url-to-org))
      (insert (format <span style="color: #008000;">"&lt;p&gt;Org-mode version = %s&lt;/p&gt;"</span> (org-version)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">this is the only new code we need to add.</span>
      (insert (format <span style="color: #008000;">"</span>
<span style="color: #008000;">&lt;!--</span>
<span style="color: #008000;">  ##### SOURCE BEGIN #####</span>
<span style="color: #008000;">%s</span>
<span style="color: #008000;">##### SOURCE END #####</span>
<span style="color: #008000;">--&gt;"</span> (browse-url-url-encode-chars org-source <span style="color: #008000;">"[-]"</span>)))
      <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">return value</span>
      (buffer-string))))
</pre>
</div>

<p>
By itself, that has limited value to me. So, let's also create a grab-org-source function to get the embedded source and open it in a buffer. This might be a naive approach, we just use a regexp to find the source boundaries and open it in a new buffer. We have to unescape the dashes, which appear as %2D in the comments. Here is our function.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">grab-org-source</span> (url)
  <span style="color: #036A07;">"Extract org-source from URL to a buffer named *grab-org-source*."</span>
  (<span style="color: #0000FF;">interactive</span> <span style="color: #008000;">"sURL: "</span>)
  (switch-to-buffer (get-buffer-create <span style="color: #008000;">"*grab-org-source*"</span>))
  (erase-buffer)
  (org-mode)
  (insert
   (<span style="color: #0000FF;">with-current-buffer</span>
       (url-retrieve-synchronously url)
     (<span style="color: #0000FF;">let</span> (start)
       (re-search-forward
        <span style="color: #008000;">"</span>
<span style="color: #008000;">&lt;!--</span>
<span style="color: #008000;">  ##### SOURCE BEGIN #####</span>
<span style="color: #008000;">"</span> nil t)
       (<span style="color: #0000FF;">setq</span> start (point))
       (re-search-forward <span style="color: #008000;">"##### SOURCE END #####</span>
<span style="color: #008000;">--&gt;"</span> nil t)
       (buffer-substring start (match-beginning 0)))))
  (goto-char (point-min))
  (<span style="color: #0000FF;">while</span> (search-forward <span style="color: #008000;">"%2D"</span> nil t)
    (replace-match <span style="color: #008000;">"-"</span>))
  (goto-char (point-min)))
</pre>
</div>

<p>
This concludes my basic proof of concept. I think there is a general escaping challenge in this approach, because it isn't clear if you can put really arbitrary stuff in an html comment, e.g. you cannot put &#x2013;&gt;! I am going to try incorporating this into my posts and see what other issues come up in the future.
</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/05/09/An-alternative-approach-to-including-org-source-in-blog-posts.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>
<!--
  ##### SOURCE BEGIN #####
* DONE An alternative approach to including org%2Dsource in blog posts
  CLOSED: [2015%2D05%2D09 Sat 13:57]
  :PROPERTIES:
  :categories: orgmode
  :date:     2015/05/09 13:50:18
  :updated:  2015/05/09 14:58:24
  :END:
When you publish a Matlab m%2Dfile to HTML, Matlab includes the m%2Dfile source as an html comment in the output. They also provide a nice function called grabcode that will take a url, and open the source code in the editor. Today, we try a similar approach for org%2Dmode.

This post is not totally self%2Dcontained. I have my own emacs%2Dlisp module that converts org%2Dmode to blogofile posts, and so far I have not made it broadly available. This is also a super exploratory idea, so I am just going to show the changes I need to make to my setup to get to the evaluation of the idea.

The idea is pretty simple, we just insert the current buffer string into an HTML comment. I just modify the bf%2Dget%2Dpost%2Dhtml function lightly to do that. This is a somewhat pathological example since there are html comments in the post! So, we will encode all the dashes to get around that.

#+BEGIN_SRC emacs%2Dlisp
(require 'browse%2Durl)
(defun bf%2Dget%2Dpost%2Dhtml ()
  "Return a string containing the YAML header, the post html, my
copyright line, and a link to the org%2Dsource code."
  (interactive)
  (let ((org%2Dsource (buffer%2Dstring))
	(url%2Dto%2Dorg (bf%2Dget%2Durl%2Dto%2Dorg%2Dsource))
	(yaml (bf%2Dget%2DYAML%2Dheading))
	(body (bf%2Dget%2DHTML)))

    (with%2Dtemp%2Dbuffer
      (insert yaml)
      (insert body)
      (insert
       (format "<p>Copyright (C) %s by John Kitchin. See the <a href=\"/copying.html\">License</a> for information about copying.<p>"
	       (format%2Dtime%2Dstring "%Y")))
      (insert (format "<p><a href=\"%s\">org%2Dmode source</a><p>"
		      url%2Dto%2Dorg))
      (insert (format "<p>Org%2Dmode version = %s</p>" (org%2Dversion)))
      ;; this is the only new code we need to add.
      (insert (format "
<!%2D%2D
  ##### SOURCE BEGIN #####
%s
##### SOURCE END #####
%2D%2D>" (browse%2Durl%2Durl%2Dencode%2Dchars org%2Dsource "[%2D]")))
      ;; return value
      (buffer%2Dstring))))
#+END_SRC

By itself, that has limited value to me. So, let's also create a grab%2Dorg%2Dsource function to get the embedded source and open it in a buffer. This might be a naive approach, we just use a regexp to find the source boundaries and open it in a new buffer. We have to unescape the dashes, which appear as %2D in the comments. Here is our function.

#+BEGIN_SRC emacs%2Dlisp
(defun grab%2Dorg%2Dsource (url)
  "Extract org%2Dsource from URL to a buffer named *grab%2Dorg%2Dsource*."
  (interactive "sURL: ")
  (switch%2Dto%2Dbuffer (get%2Dbuffer%2Dcreate "*grab%2Dorg%2Dsource*"))
  (erase%2Dbuffer)
  (org%2Dmode)
  (insert
   (with%2Dcurrent%2Dbuffer
       (url%2Dretrieve%2Dsynchronously url)
     (let (start)
       (re%2Dsearch%2Dforward
	"
<!%2D%2D
  ##### SOURCE BEGIN #####
" nil t)
       (setq start (point))
       (re%2Dsearch%2Dforward "##### SOURCE END #####
%2D%2D>" nil t)
       (buffer%2Dsubstring start (match%2Dbeginning 0)))))
  (goto%2Dchar (point%2Dmin))
  (while (search%2Dforward "%2D" nil t)
    (replace%2Dmatch "%2D"))
  (goto%2Dchar (point%2Dmin)))
#+END_SRC

This concludes my basic proof of concept. I think there is a general escaping challenge in this approach, because it isn't clear if you can put really arbitrary stuff in an html comment, e.g. you cannot put %2D%2D>! I am going to try incorporating this into my posts and see what other issues come up in the future.

##### SOURCE END #####
-->]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Restarting org-babel sessions in org-mode more effectively]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/03/19/Restarting-org-babel-sessions-in-org-mode-more-effectively" />
    <id>http://jkitchin.github.io/blog/2015/03/19/Restarting-org-babel-sessions-in-org-mode-more-effectively</id>
    <updated>2015-03-19T18:53:18Z</updated>
    <published>2015-03-19T18:53:18Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <summary type="html"><![CDATA[Restarting org-babel sessions in org-mode more effectively]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/03/19/Restarting-org-babel-sessions-in-org-mode-more-effectively"><![CDATA[



<p>
In a previous <a href="http://kitchingroup.cheme.cmu.edu/blog/2015/03/12/Making-org-mode-Python-sessions-look-better/">post</a> I eliminated one annoying problem with sessions, which was getting rid of extraneous Python interpreter characters in the output. Another thing that has bothered me is when you close Emacs, or even the session buffer, the session is, of course, lost. That means when you reopen the file, you have to run each block in order to continue your work. There does not seem to be a selective way to do this in org. So, in this post, we consider a simple approach to automate that. We want a function that will run all the blocks in a current session that are above the current point.
</p>


<p>
The idea is we will go to the beginning of the buffer, find all blocks that match the language of the block we are in, and in the session, and execute them. We can tell if a block is in a session by looking at the :parameters property of the block. Interestingly, if a block is not in a session, then session will be "none", if it is in an unnamed session, session will be nil, and otherwise, session will be the session name.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">scenario</th>
<th scope="col" class="left">:session value</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">no session</td>
<td class="left">"none"</td>
</tr>

<tr>
<td class="left">unnamed session</td>
<td class="left">nil</td>
</tr>

<tr>
<td class="left">named session</td>
<td class="left">"name"</td>
</tr>
</tbody>
</table>

<p>
Here is a function for testing if a block is in a session.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">src-block-in-session-p</span> (<span style="color: #6434A3;">&amp;optional</span> name)
  <span style="color: #036A07;">"Return if src-block is in a session of NAME.</span>
<span style="color: #036A07;">NAME may be nil for unnamed sessions."</span>
  (<span style="color: #0000FF;">let*</span> ((info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (body (nth 1 info))
         (params (nth 2 info))
         (session (cdr (assoc <span style="color: #006FE0;">:session</span> params))))

    (<span style="color: #0000FF;">cond</span>
     <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">unnamed session, both name and session are nil</span>
     ((and (null session)
           (null name))
      t)
     <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">Matching name and session</span>
     ((and
       (stringp name)
       (stringp session)
       (string= name session))
      t)
     <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">no match</span>
     (t nil))))
</pre>
</div>

<p>
Now, we need to get some information about the current point and block. We will want to run blocks that start before the current point, but not after. We will use org-element-map to find code blocks, and when the language and session of a code block matches the current block, and the block starts at a point earlier than the current point, then we will go to that block, and run it. Here is that code.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-babel-restart-session-to-point</span> (<span style="color: #6434A3;">&amp;optional</span> arg)
  <span style="color: #036A07;">"Restart session up to the src-block in the current point.</span>
<span style="color: #036A07;">Goes to beginning of buffer and executes each code block with</span>
<span style="color: #036A07;">`</span><span style="color: #D0372D;">org-babel-execute-src-block</span><span style="color: #036A07;">' that has the same language and</span>
<span style="color: #036A07;">session as the current block. ARG has same meaning as in</span>
<span style="color: #036A07;">`</span><span style="color: #D0372D;">org-babel-execute-src-block</span><span style="color: #036A07;">'."</span>
  (interactive <span style="color: #008000;">"P"</span>)
  (<span style="color: #0000FF;">unless</span> (org-in-src-block-p)
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You must be in a src-block to run this command"</span>))
  (<span style="color: #0000FF;">let*</span> ((current-point (point-marker))
         (info (org-babel-get-src-block-info))
         (lang (nth 0 info))
         (params (nth 2 info))
         (session (cdr (assoc <span style="color: #006FE0;">:session</span> params))))
    (<span style="color: #0000FF;">save-excursion</span>
      (goto-char (point-min))
      (<span style="color: #0000FF;">while</span> (re-search-forward org-babel-src-block-regexp nil t)
        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">goto start of block</span>
        (goto-char (match-beginning 0))
        (<span style="color: #0000FF;">let*</span> ((this-info (org-babel-get-src-block-info))
               (this-lang (nth 0 this-info))
               (this-params (nth 2 this-info))
               (this-session (cdr (assoc <span style="color: #006FE0;">:session</span> this-params))))
            (<span style="color: #0000FF;">when</span>
                (and
                 (&lt; (point) (marker-position current-point))
                 (string= lang this-lang)
                 (src-block-in-session-p session))
              (org-babel-execute-src-block arg)))
        <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">move forward so we can find the next block</span>
        (forward-line)))))
</pre>
</div>


<p>
In the course of testing this, I found this function a little helpful to kill the current session so we start fresh.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-babel-kill-session</span> ()
  <span style="color: #036A07;">"Kill session for current code block."</span>
  (interactive)
  (<span style="color: #0000FF;">unless</span> (org-in-src-block-p)
    (<span style="color: #ff0000; font-weight: bold;">error</span> <span style="color: #008000;">"You must be in a src-block to run this command"</span>))
  (<span style="color: #0000FF;">save-window-excursion</span>
    (org-babel-switch-to-session)
    (kill-buffer)))
</pre>
</div>

<p>
And also this one to remove all results in the buffer. This not at all selective, it removes results for session and non-session blocks.
</p>

<div class="org-src-container">

<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">org-babel-remove-result-buffer</span> ()
  <span style="color: #036A07;">"Remove results from every code block in buffer."</span>
  (interactive)
  (<span style="color: #0000FF;">save-excursion</span>
    (goto-char (point-min))
    (<span style="color: #0000FF;">while</span> (re-search-forward org-babel-src-block-regexp nil t)
      (org-babel-remove-result))))
</pre>
</div>

<p>
Ok, now for some testing. The rest of this post is pretty boring, just some blocks of mixed session and non-session to see if they get run. Skip to the <a href="#sec-1">1</a>.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">def</span> <span style="color: #006699;">f</span>(x):
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #BA36A5;">y</span> = 4 * x
<span style="color: #9B9B9B; background-color: #EDEDED;"> </span>   <span style="color: #0000FF;">return</span> y

<span style="color: #0000FF;">print</span>(f(d))
</pre>
</div>

<pre class="example">
16
</pre>

<p>
Let us put a non-session block in this buffer for testing.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #BA36A5;">a</span> = 5
<span style="color: #0000FF;">print</span>(a)
</pre>
</div>

<p>
Now, some more named session blocks.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">print</span> f(5)
</pre>
</div>

<pre class="example">
20
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">print</span> <span style="color: #008000;">'ok'</span>
</pre>
</div>

<pre class="example">
ok
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">print</span> 2
</pre>
</div>

<pre class="example">
2
</pre>

<p>
An unnamed session that should not get run in restarting the named test session.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">print</span> 886
</pre>
</div>


<div class="org-src-container">

<pre class="src src-python"><span style="color: #0000FF;">print</span> f(6)
</pre>
</div>

<pre class="example">
24
</pre>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
This works pretty well so far.  It would be nice to consider making C-c C-c do this automatically, if the session does not exist, and maybe to take a prefix arg that would restart the session. Maybe on another day ;)
</p>
</div>
</div>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/03/19/Restarting-org-babel-sessions-in-org-mode-more-effectively.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
  <entry>
    <author>
      <name></name>
      <uri>http://jkitchin.github.io/blog</uri>
    </author>
    <title type="html"><![CDATA[Update on org-ref - it is now all emacs-lisp]]></title>
    <link rel="alternate" type="text/html" href="http://jkitchin.github.io/blog/2015/03/16/Update-on-org-ref-it-is-now-all-emacs-lisp" />
    <id>http://jkitchin.github.io/blog/2015/03/16/Update-on-org-ref-it-is-now-all-emacs-lisp</id>
    <updated>2015-03-16T08:51:50Z</updated>
    <published>2015-03-16T08:51:50Z</published>
    <category scheme="http://jkitchin.github.io/blog" term="orgmode" />
    <category scheme="http://jkitchin.github.io/blog" term="orgref" />
    <category scheme="http://jkitchin.github.io/blog" term="emacs" />
    <summary type="html"><![CDATA[Update on org-ref - it is now all emacs-lisp]]></summary>
    <content type="html" xml:base="http://jkitchin.github.io/blog/2015/03/16/Update-on-org-ref-it-is-now-all-emacs-lisp"><![CDATA[



<p>
The <a href="https://github.com/jkitchin/org-ref">org-ref</a> code is finally all in emacs-lisp! This should make it much easier to install, and is another step closer to getting org-ref into MELPA. Previously, I had written the most significant code in org-mode source blocks that were intended to be tangled out. I found this was not really portable, because what gets tangled depends on your org-mode setup. I had to specifically set example blocks to not tangle, or org-ref would not work for other people, and if I forgot to set a block to tangle, it also would not work for others. That should not happen again now, since there is no more tangling.
</p>


<p>
There are some relatively new features in org-ref:
</p>
<ol class="org-ol">
<li>New colored org-ref links to differentiate them from other
org-links. Citations are greenish, refs and labels are maroonish.
</li>
<li>Context messages about links. With your cursor on a cite, ref or label link
you will get a context message, e.g. a formatted citation, some context about
the label a ref refers to, or a count of the labels in the mini-buffer.
</li>
<li>There is now an org-ref menu in the Org menu.
</li>
<li>There is a new org-ref-help function that opens an org-file of org-ref
documentation.
</li>
<li>Pretty thorough integration of helm throughout org-ref, and some integration
of hydra.
</li>
<li>A few utility libraries: doi-utils, isbn, wos, pubmed, arxiv, jmax-bibtex, sci-id,
x2bib. Not all these are new, but if you didn't know about them, check them out.
</li>
<li>Cask integration. This mostly provides access to testing and dependencies
right now. org-ref is also now tested continuously at
<a href="https://travis-ci.org/jkitchin/org-ref">https://travis-ci.org/jkitchin/org-ref</a> .
</li>
</ol>

<p>
org-ref is basically feature complete I think (which is to say that once again, I do not have any big ideas for new features ;). There are some places where it could be refactored a little, e.g. there are some bibtex only functions in org-ref.el that really should go into jmax-bibtex.el (which also could be renamed). This is a very low priority though, because things are working fine as far as I can tell.
</p>

<p>
What does it need before going into MELPA? Probably some tests would be a good idea. On Travis, all that is really tested is that it loads with no errors. I would like to see some stability on my end, e.g. at least a week where no commits get made, and no errors are reported. And finally, I would like to make sure I have some time to handle issues that come up when a broader audience is trying it out.
</p>

<p>
My target date to get this in MELPA is June 1, 2015. Try out the new org-ref, and let me know how it goes!</p>
<p>Copyright (C) 2015 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2015/03/16/Update-on-org-ref---it-is-now-all-emacs-lisp.org">org-mode source</a><p><p>Org-mode version = 8.2.10</p>]]></content>
  </entry>
</feed>
