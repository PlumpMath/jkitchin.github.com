<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Thu, 05 Jan 2017 18:22:28 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Scoring elfeed articles</title>
      <link>http://jkitchin.github.io/blog/2017/01/05/Scoring-elfeed-articles</link>
      <pubDate>Thu, 05 Jan 2017 11:18:29 EST</pubDate>
      <category><![CDATA[elfeed]]></category>
      <category><![CDATA[emacs]]></category>
      <guid isPermaLink="false">NBZRWOsJw4yDOAn4_m_OYu7AMz8=</guid>
      <description>Scoring elfeed articles</description>
      <content:encoded><![CDATA[


<p>
I use <a href="https://github.com/skeeto/elfeed">elfeed</a> to read RSS feeds of scientific journals, python, emacs, and lisp blogs, and the emacs stackexchange feed. Here are the current feeds I follow.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(mapcar 'list elfeed-feeds)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">(<a href="http://syndic8.scopus.com/getMessage?registrationId=ADEJAEEKHFESCDEOCDFOAHGSCDHSAKHREFMSADHNJA">http://syndic8.scopus.com/getMessage?registrationId=ADEJAEEKHFESCDEOCDFOAHGSCDHSAKHREFMSADHNJA</a> cmu)</td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/accacs">http://feeds.feedburner.com/acs/accacs</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/enfuem">http://feeds.feedburner.com/acs/enfuem</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/esthag">http://feeds.feedburner.com/acs/esthag</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jacsat">http://feeds.feedburner.com/acs/jacsat</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jpcbfk">http://feeds.feedburner.com/acs/jpcbfk</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jpccck">http://feeds.feedburner.com/acs/jpccck</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jpclcd">http://feeds.feedburner.com/acs/jpclcd</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/cmatex">http://feeds.feedburner.com/acs/cmatex</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jctcce">http://feeds.feedburner.com/acs/jctcce</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/jcisd8">http://feeds.feedburner.com/acs/jcisd8</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.feedburner.com/acs/iecred">http://feeds.feedburner.com/acs/iecred</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.aps.org/rss/recent/prl.xml">http://feeds.aps.org/rss/recent/prl.xml</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.aps.org/rss/recent/prb.xml">http://feeds.aps.org/rss/recent/prb.xml</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://www.sciencemag.org/rss/current.xml">http://www.sciencemag.org/rss/current.xml</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.nature.com/nature/rss/current">http://feeds.nature.com/nature/rss/current</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.nature.com/nmat/rss/current">http://feeds.nature.com/nmat/rss/current</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://feeds.nature.com/nchem/rss/current">http://feeds.nature.com/nchem/rss/current</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://rss.sciencedirect.com/publication/science/09270256">http://rss.sciencedirect.com/publication/science/09270256</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://onlinelibrary.wiley.com/rss/journal/10.1002/(ISSN)">http://onlinelibrary.wiley.com/rss/journal/10.1002/(ISSN)</a>1521-3773</td>
</tr>

<tr>
<td class="org-left"><a href="http://scitation.aip.org/rss/content/aip/journal/jcp/latestarticles;jsessionid=6k76xb11z253.x-aip-live-06?fmt=rss">http://scitation.aip.org/rss/content/aip/journal/jcp/latestarticles;jsessionid=6k76xb11z253.x-aip-live-06?fmt=rss</a></td>
</tr>

<tr>
<td class="org-left">(<a href="http://planetpython.org/rss20.xml">http://planetpython.org/rss20.xml</a> python)</td>
</tr>

<tr>
<td class="org-left">(<a href="http://planet.scipy.org/rss20.xml">http://planet.scipy.org/rss20.xml</a> python)</td>
</tr>

<tr>
<td class="org-left">(<a href="http://planet.emacsen.org/atom.xml">http://planet.emacsen.org/atom.xml</a> emacs)</td>
</tr>

<tr>
<td class="org-left"><a href="http://planet.lisp.org/rss20.xml">http://planet.lisp.org/rss20.xml</a></td>
</tr>

<tr>
<td class="org-left"><a href="http://catalysis-preprint-archive.github.io/updates.rss">http://catalysis-preprint-archive.github.io/updates.rss</a></td>
</tr>

<tr>
<td class="org-left"><a href="https://www.cmu.edu/policies/news/rss-feed.rss">https://www.cmu.edu/policies/news/rss-feed.rss</a></td>
</tr>

<tr>
<td class="org-left">(<a href="http://emacs.stackexchange.com/feeds">http://emacs.stackexchange.com/feeds</a> emacs)</td>
</tr>
</tbody>
</table>

<p>
I get a lot of articles this way. The current size of the database is:
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(elfeed-db-size)
</pre>
</div>

<pre class="example">
79721
</pre>

<p>
Elfeed tells me I have over 300 unread entries to review at the moment.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(elfeed-search--count-unread)
</pre>
</div>

<pre class="example">
341/363:24
</pre>

<p>
To deal with this deluge, I have done a couple of things. I set up some new key-bindings so I can alternate marking entries as read if the titles do not look interesting. These keybindings let me alternate fingers, so they do not get too tired (that really happens some days!).
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp"><span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">help me alternate fingers in marking entries as read</span>
(define-key elfeed-search-mode-map (kbd <span style="color: #008000;">"f"</span>) 'elfeed-search-untag-all-unread)
(define-key elfeed-search-mode-map (kbd <span style="color: #008000;">"j"</span>) 'elfeed-search-untag-all-unread)
</pre>
</div>

<p>
I also set up some auto-tagging of the emacs and python feeds, and setup some custom faces so these tags are highlighted so they are easy to see. Anything highlighted in blue is related to emacs, green is related to python, and pink is related to my department, and I can type s, then the tag to see only those entries.  Here is what my feed looks like:
</p>

<p>
<img src="/media/date-05-01-2017-time-08-42-33.png"> 
</p>



<p>
Today I want to explore adding tags to entries to further prioritize them. There is a way to tag entries that is described here: <a href="https://github.com/skeeto/elfeed#tag-hooks">https://github.com/skeeto/elfeed#tag-hooks</a> where you can create patterns to match an entry feed title, url, title or link. Basically, you create a function that takes an entry, amd have it add or remove a tag conditionally.
</p>

<p>
I want to tag entries that meet certain criteria, for example keywords, and set a tag based on the number of matches. Ideally, one day this would be integrated with machine learning so it could rank entries by other entries I have liked, but today we setup code that will create a score for an entry based on the number of matches, and then tag it so that it will get highlighted for me.  First, we define two custom faces and setup elfeed to use them. I will use two tags: important and relevant. relevant will be for entries that get a score of at least 1, and important for entries that get a score greater than 1.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defface</span> <span style="color: #BA36A5;">relevant-elfeed-entry</span>
  '((t <span style="color: #006FE0;">:background</span> (color-lighten-name <span style="color: #008000;">"orange1"</span> 40)))
  <span style="color: #036A07;">"Marks a relevant Elfeed entry."</span>)

(<span style="color: #0000FF;">defface</span> <span style="color: #BA36A5;">important-elfeed-entry</span>
  '((t <span style="color: #006FE0;">:background</span> (color-lighten-name <span style="color: #008000;">"OrangeRed2"</span> 40)))
  <span style="color: #036A07;">"Marks an important Elfeed entry."</span>)

(<span style="color: #0000FF;">push</span> '(relevant relevant-elfeed-entry)
      elfeed-search-face-alist)

(<span style="color: #0000FF;">push</span> '(important important-elfeed-entry)
      elfeed-search-face-alist)
</pre>
</div>

<p>
In elfeed, each entry is a structure, and we can access the title and content for matching. Here is an example of a simple scoring function. The idea is just to match patterns, and then add to the score if it matches. This is not as advanced as <a href="https://www.gnu.org/software/emacs/manual/html_node/gnus/Scoring.html#Scoring">gnus scoring</a>, but it is a good starting point.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(<span style="color: #0000FF;">defun</span> <span style="color: #006699;">score-elfeed-entry</span> (entry)
  (<span style="color: #0000FF;">let</span> ((title (elfeed-entry-title entry))
        (content (elfeed-deref (elfeed-entry-content entry)))
        (score 0))
    (<span style="color: #0000FF;">loop</span> for (pattern n) in '((<span style="color: #008000;">"alloy"</span> 1)
                               (<span style="color: #008000;">"machine learning</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">neural"</span> 1)
                               (<span style="color: #008000;">"database"</span> 1)
                               (<span style="color: #008000;">"reproducible"</span> 1)
                               (<span style="color: #008000;">"carbon dioxide</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">CO2"</span> 1)
                               (<span style="color: #008000;">"oxygen evolution</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">OER</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">electrolysis"</span> 1)
                               (<span style="color: #008000;">"perovskite</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">polymorph</span><span style="color: #008000; font-weight: bold;">\\</span><span style="color: #008000; font-weight: bold;">|</span><span style="color: #008000;">epitax"</span> 1)
                               (<span style="color: #008000;">"kitchin"</span> 2))
          if (string-match pattern title)
          do (<span style="color: #0000FF;">incf</span> score n)
          if (string-match pattern content)
          do (<span style="color: #0000FF;">incf</span> score n))
    (message <span style="color: #008000;">"%s - %s"</span> title score)

    <span style="color: #8D8D84;">;; </span><span style="color: #8D8D84; font-style: italic;">store score for later in case I ever integrate machine learning</span>
    (<span style="color: #0000FF;">setf</span> (elfeed-meta entry <span style="color: #006FE0;">:my/score</span>) score)

    (<span style="color: #0000FF;">cond</span>
     ((= score 1)
      (elfeed-tag entry 'relevant))
     ((&gt; score 1)
      (elfeed-tag entry 'important)))
    entry))

(add-hook 'elfeed-new-entry-hook 'score-elfeed-entry)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">score-elfeed-entry</td>
</tr>
</tbody>
</table>

<p>
Now, new entries automatically get tagged with relevant or important, depending on the score that function gives them, and they get color-coded. Now, the feed looks like this:
</p>

<p>
<img src="/media/date-05-01-2017-time-11-10-42.png"> 
</p>


<p>
I saved some bookmarks to see just the important or relevant ones (<a href="http://nullprogram.com/blog/2015/12/03/">http://nullprogram.com/blog/2015/12/03/</a>) so I can see new relevant entries with C-x r b and selecting the relevant bookmark. These work from anywhere in Emacs.
</p>

<pre class="example">
  @6-months-ago +unread +relev  @6-months-ago +unread +relevant
  elfeed @6-months-ago +unread  @6-months-ago +unread +important
</pre>

<p>
I usually access elfeed from a command that shows me everything. Here, I define key-bindings to show me just the important or relevant ones. I could not see a way to get an or in there to show me both of them. These keys make it a one key press to show only these entries, and then get back to the full list.
</p>

<div class="org-src-container">
<pre class="src src-emacs-lisp">(define-key elfeed-search-mode-map (kbd <span style="color: #008000;">"i"</span>)
  (<span style="color: #0000FF;">lambda</span> () (<span style="color: #0000FF;">interactive</span>)
    (elfeed-search-set-filter <span style="color: #008000;">"@6-months-ago +unread +important"</span>)))

(define-key elfeed-search-mode-map (kbd <span style="color: #008000;">"v"</span>)
  (<span style="color: #0000FF;">lambda</span> () (<span style="color: #0000FF;">interactive</span>)
    (elfeed-search-set-filter <span style="color: #008000;">"@6-months-ago +unread +relevant"</span>)))

(define-key elfeed-search-mode-map (kbd <span style="color: #008000;">"c"</span>)
  (<span style="color: #0000FF;">lambda</span> () (<span style="color: #0000FF;">interactive</span>)
    (elfeed-search-set-filter <span style="color: #008000;">"@6-months-ago +unread"</span>)))
</pre>
</div>


<p>
That summarizes the experiment of the day. There is clearly some room for improvement on the scoring function, e.g. moving the patterns out of the function and into a customizable variable, making the patterns be specific to either the title or content, etc. I am going to try this for a few days and see if it is actually helpful first though.
</p>
<p>Copyright (C) 2017 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p>
<p><a href="/org/2017/01/05/Scoring-elfeed-articles.org">org-mode source</a></p>
<p>Org-mode version = 9.0.3</p>]]></content:encoded>
    </item>
  </channel>
</rss>
