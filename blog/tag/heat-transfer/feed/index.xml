<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Sun, 10 Apr 2016 16:46:49 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Transient heat conduction - partial differential equations</title>
      <link>http://jkitchin.github.io/blog/2013/03/07/Transient-heat-conduction-partial-differential-equations</link>
      <pubDate>Thu, 07 Mar 2013 15:54:08 EST</pubDate>
      <category><![CDATA[pde]]></category>
      <guid isPermaLink="false">vYwQTXiPOjKla95AZ51ynjv57Cg=</guid>
      <description>Transient heat conduction - partial differential equations</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/21/transient-heat-conduction-partial-differential-equations/" >Matlab post</a>
adapated from <a href="http://msemac.redwoods.edu/~darnold/math55/DEproj/sp02/AbeRichards/slideshowdefinal.pdf" >http://msemac.redwoods.edu/~darnold/math55/DEproj/sp02/AbeRichards/slideshowdefinal.pdf</a>

</p>

<p>
We solved a steady state BVP modeling heat conduction. Today we examine the transient behavior of a rod at constant T put between two heat reservoirs at different temperatures, again T1 = 100, and T2 = 200. The rod will start at 150. Over time, we should expect a solution that approaches the steady state solution: a linear temperature profile from one side of the rod to the other.
</p>

<p>
\(\frac{\partial u}{\partial t} = k \frac{\partial^2 u}{\partial x^2}\)
</p>

<p>
at \(t=0\), in this example we have \(u_0(x) = 150\) as an initial condition. with boundary conditions \(u(0,t)=100\) and \(u(L,t)=200\).
</p>

<p>
In Matlab there is the pdepe command. There is not yet a PDE solver in scipy. Instead, we will utilze the method of lines to solve this problem. We discretize the rod into segments, and approximate the second derivative in the spatial dimension as \(\frac{\partial^2 u}{\partial x^2} = (u(x + h) - 2 u(x) + u(x-h))/ h^2\) at each node. This leads to a set of coupled ordinary differential equations that is easy to solve.
</p>

<p>
Let us say the rod has a length of 1, \(k=0.02\), and solve for the time-dependent temperature profiles.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> odeint
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

N = 100  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">number of points to discretize</span>
L = 1.0
X = np.linspace(0, L, N) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">position along the rod</span>
h = L / (N - 1)

k = 0.02

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">odefunc</span>(u, t):
    dudt = np.zeros(X.shape)

    dudt[0] = 0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">constant at boundary condition</span>
    dudt[-1] = 0

    <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">now for the internal nodes</span>
    <span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(1, N-1):
        dudt[i] = k * (u[i + 1] - 2*u[i] + u[i - 1]) / h**2

    <span style="color: #8b0000;">return</span> dudt

init = 150.0 * np.ones(X.shape) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial temperature</span>
init[0] = 100.0  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">one boundary condition</span>
init[-1] = 200.0 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the other boundary condition</span>

tspan = np.linspace(0.0, 5.0, 100)
sol = odeint(odefunc, init, tspan)


<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(0, <span style="color: #8b0000;">len</span>(tspan), 5):
    plt.plot(X, sol[i], label=<span style="color: #228b22;">'t={0:1.2f}'</span>.format(tspan[i]))

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">put legend outside the figure</span>
plt.legend(loc=<span style="color: #228b22;">'center left'</span>, bbox_to_anchor=(1, 0.5))
plt.xlabel(<span style="color: #228b22;">'X position'</span>)
plt.ylabel(<span style="color: #228b22;">'Temperature'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">adjust figure edges so the legend is in the figure</span>
plt.subplots_adjust(top=0.89, right=0.77)
plt.savefig(<span style="color: #228b22;">'images/pde-transient-heat-1.png'</span>)


<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">Make a 3d figure</span>
<span style="color: #8b0000;">from</span> mpl_toolkits.mplot3d <span style="color: #8b0000;">import</span> Axes3D
fig = plt.figure()
ax = fig.add_subplot(111, projection=<span style="color: #228b22;">'3d'</span>)

SX, ST = np.meshgrid(X, tspan)
ax.plot_surface(SX, ST, sol, cmap=<span style="color: #228b22;">'jet'</span>)
ax.set_xlabel(<span style="color: #228b22;">'X'</span>)
ax.set_ylabel(<span style="color: #228b22;">'time'</span>)
ax.set_zlabel(<span style="color: #228b22;">'T'</span>)
ax.view_init(elev=15, azim=-124) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">adjust view so it is easy to see</span>
plt.savefig(<span style="color: #228b22;">'images/pde-transient-heat-3d.png'</span>)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">animated solution. We will use imagemagick for this</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">we save each frame as an image, and use the imagemagick convert command to </span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">make an animated gif</span>
<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(len(tspan)):
    plt.clf()
    plt.plot(X, sol[i])
    plt.xlabel(<span style="color: #228b22;">'X'</span>)
    plt.ylabel(<span style="color: #228b22;">'T(X)'</span>)
    plt.title(<span style="color: #228b22;">'t = {0}'</span>.format(tspan[i]))
    plt.savefig(<span style="color: #228b22;">'___t{0:03d}.png'</span>.format(i))

<span style="color: #8b0000;">import</span> commands
<span style="color: #8b0000;">print</span> commands.getoutput(<span style="color: #228b22;">'convert -quality 100 ___t*.png images/transient_heat.gif'</span>)
<span style="color: #8b0000;">print</span> commands.getoutput(<span style="color: #228b22;">'rm ___t*.png'</span>) <span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">remove temp files</span>
</pre>
</div>

<pre class="example">
</pre>

<p>
This version of the graphical solution is not that easy to read, although with some study you can see the solution evolves from the initial condition which is flat, to the steady state solution which is a linear temperature ramp.
<p><img src="/img/./images/pde-transient-heat-1.png"><p>
</p>

<p>
The 3d version may be easier to interpret. The temperature profile starts out flat, and gradually changes to the linear ramp.
<p><img src="/img/./images/pde-transient-heat-3d.png"><p>
</p>

<p>
Finally, the animated solution.
</p>

<p><img src="/img/./images/transient_heat.gif"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/07/Transient-heat-conduction---partial-differential-equations.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Boundary value problem in heat conduction</title>
      <link>http://jkitchin.github.io/blog/2013/03/06/Boundary-value-problem-in-heat-conduction</link>
      <pubDate>Wed, 06 Mar 2013 19:35:39 EST</pubDate>
      <category><![CDATA[bvp]]></category>
      <guid isPermaLink="false">3aI5z4CyumczzU5swqki2i6aDhE=</guid>
      <description>Boundary value problem in heat conduction</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/11/boundary-value-problem-in-heat-conduction/" >Matlab post</a>
</p>

<p>
For steady state heat conduction the temperature distribution in one-dimension is governed by the Laplace equation:
</p>

<p>
$$ \nabla^2 T = 0$$
</p>

<p>
with boundary conditions that at \(T(x=a) = T_A\) and \(T(x=L) = T_B\).
</p>

<p>
The analytical solution is not difficult here: \(T = T_A-\frac{T_A-T_B}{L}x\), but we will solve this by finite differences.
</p>

<p>
For this problem, lets consider a slab that is defined by x=0 to x=L, with \(T(x=0) = 100\), and \(T(x=L) = 200\). We want to find the function T(x) inside the slab.
</p>

<p>
We approximate the second derivative by finite differences as
</p>

<p>
\( f''(x) \approx \frac{f(x-h) - 2 f(x) + f(x+h)}{h^2} \)
</p>

<p>
Since the second derivative in this case is equal to zero, we have at each discretized node \(0 = T_{i-1} - 2 T_i + T_{i+1}\). We know the values of \(T_{x=0} = \alpha\) and \(T_{x=L} = \beta\).
</p>

<p>
\[A = \left [ \begin{array}{ccccc} %
 -2         & 1 & 0                    & 0 & 0 \\
1           & -2& 1 & 0 & 0 \\
0                    & \ddots               & \ddots               & \ddots & 0 \\
0                    & 0                    & 1 & -2 & 1 \\
0                    & 0                    & 0  & 1  & -2  \end{array} \right ] \]
</p>

<p>
\[ x = \left [ \begin{array}{c} T_1 \\ \vdots \\ T_N \end{array} \right ] \]
</p>

<p>
\[ b = \left [ \begin{array}{c} -T(x=0) \\
0 \\
\vdots \\
0 \\
-T(x=L) \end{array} \right] \]
</p>

<p>
These are linear equations in the unknowns \(x\) that we can easily solve. Here, we evaluate the solution.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">we use the notation T(x1) = alpha and T(x2) = beta</span>
x1 = 0; alpha = 100
x2 = 5; beta = 200

npoints = 100

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">preallocate and shape the b vector and A-matrix</span>
b = np.zeros((npoints, 1));
b[0] = -alpha
b[-1] = -beta

A = np.zeros((npoints, npoints));

<span style="color: #ff0000; font-weight: bold;">#</span><span style="color: #ff0000; font-weight: bold;">now we populate the A-matrix and b vector elements</span>
<span style="color: #8b0000;">for</span> i <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints ):
    <span style="color: #8b0000;">for</span> j <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">range</span>(npoints):
        <span style="color: #8b0000;">if</span> j == i: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the diagonal</span>
            A[i,j] = -2
        <span style="color: #8b0000;">elif</span> j == i - 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">left of the diagonal</span>
            A[i,j] = 1
        <span style="color: #8b0000;">elif</span> j == i + 1: <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">right of the diagonal</span>
            A[i,j] = 1
 
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">solve the equations A*y = b for Y</span>
Y = np.linalg.solve(A,b)

x = np.linspace(x1, x2, npoints + 2)
y = np.hstack([alpha, Y[:,0], beta])

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot(x, y)

plt.plot(x, alpha + (beta - alpha)/(x2 - x1) * x, <span style="color: #228b22;">'r--'</span>)

plt.xlabel(<span style="color: #228b22;">'X'</span>)
plt.ylabel(<span style="color: #228b22;">'T(X)'</span>)
plt.legend((<span style="color: #228b22;">'finite difference'</span>, <span style="color: #228b22;">'analytical soln'</span>), loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/bvp-heat-conduction-1d.png'</span>)
</pre>
</div>

<p><img src="/img/./images/bvp-heat-conduction-1d.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/06/Boundary-value-problem-in-heat-conduction.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Finding the nth root of a periodic function</title>
      <link>http://jkitchin.github.io/blog/2013/03/05/Finding-the-nth-root-of-a-periodic-function</link>
      <pubDate>Tue, 05 Mar 2013 14:06:04 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">TjQQYRtTLiik-QWmqbwfFnxpj5M=</guid>
      <description>Finding the nth root of a periodic function</description>
      <content:encoded><![CDATA[



<p>
There is a heat transfer problem where one needs to find the n^th root of the following equation: \(x J_1(x) - Bi J_0(x)=0\) where \(J_0\) and \(J_1\) are the Bessel functions of zero and first order, and \(Bi\) is the Biot number. We examine an approach to finding these roots. 
</p>

<p>
First,  we plot the function.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

X = np.linspace(0, 30, 200)
plt.plot(X, f(X))
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-1.png'</span>)
</pre>
</div>

<p><img src="/img/./images/heat-transfer-roots-1.png"><p>

<p>
You can see there are many roots to this equation, and we want to be sure we get the n^{th} root. This function is pretty well behaved, so if you make a good guess about the solution you will get an answer, but if you make a bad guess, you may get the wrong root. We examine next a way to do it without guessing the solution. What we want is the solution to \(f(x) = 0\), but we want all the solutions in a given interval. We derive a new equation, \(f'(x) = 0\), with initial condition \(f(0) = f0\), and integrate the ODE with an event function that identifies all zeros of \(f\) for us. The derivative of our function is \(df/dx = d/dx(x J_1(x)) - Bi J'_0(x)\). It is known (<a href="http://www.markrobrien.com/besselfunct.pdf" >http://www.markrobrien.com/besselfunct.pdf</a>) that \(d/dx(x J_1(x)) = x J_0(x)\), and \(J'_0(x) = -J_1(x)\). All we have to do now is set up the problem and run it.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> pycse <span style="color: #8b0000;">import</span> *  <span style="color: #ff0000; font-weight: bold;"># contains the ode integrator with events</span>

<span style="color: #8b0000;">from</span> scipy.special <span style="color: #8b0000;">import</span> jn, jn_zeros
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
<span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

Bi = 1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">f</span>(x):
    <span style="color: #228b22;">"function we want roots for"</span>
    <span style="color: #8b0000;">return</span> x * jn(1, x) - Bi * jn(0, x)

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">fprime</span>(f, x):
    <span style="color: #228b22;">"df/dx"</span>
    <span style="color: #8b0000;">return</span> x * jn(0, x) - Bi * (-jn(1, x))

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">e1</span>(f, x):
    <span style="color: #228b22;">"event function to find zeros of f"</span>
    isterminal = <span style="color: #8b0000;">False</span>
    value = f
    direction = 0
    <span style="color: #8b0000;">return</span> value, isterminal, direction

f0 = f(0)
xspan = np.linspace(0, 30, 200)

x, fsol, XE, FE, IE = odelay(fprime, f0, xspan, events=[e1])

plt.plot(x, fsol, <span style="color: #228b22;">'.-'</span>, label=<span style="color: #228b22;">'Numerical solution'</span>)
plt.plot(xspan, f(xspan), <span style="color: #228b22;">'--'</span>, label=<span style="color: #228b22;">'Analytical function'</span>)
plt.plot(XE, FE, <span style="color: #228b22;">'ro'</span>, label=<span style="color: #228b22;">'roots'</span>)
plt.legend(loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/heat-transfer-roots-2.png'</span>)

<span style="color: #8b0000;">for</span> i, root <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(XE):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'root {0} is at {1}'</span>.format(i, root)

plt.show()
</pre>
</div>

<pre class="example">
root 0 is at 1.25578377377
root 1 is at 4.07947743741
root 2 is at 7.15579904465
root 3 is at 10.2709851256
root 4 is at 13.3983973869
root 5 is at 16.5311587137
root 6 is at 19.6667276775
root 7 is at 22.8039503455
root 8 is at 25.9422288192
root 9 is at 29.081221492
</pre>

<p><img src="/img/./images/heat-transfer-roots-2.png"><p>

<p>
You can work this out once, and then you have all the roots in the interval and you can select the one you want.
</p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/05/Finding-the-nth-root-of-a-periodic-function.org">org-mode source</a><p>]]></content:encoded>
    </item>
  </channel>
</rss>
