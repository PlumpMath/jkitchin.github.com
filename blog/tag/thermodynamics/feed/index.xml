<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:wfw="http://wellformedweb.org/CommentAPI/"
     >
  <channel>
    <title>The Kitchin Research Group</title>
    <link>http://jkitchin.github.io/blog</link>
    <description>Chemical Engineering at Carnegie Mellon University</description>
    <pubDate>Fri, 08 Aug 2014 22:54:24 GMT</pubDate>
    <generator>Blogofile</generator>
    <sy:updatePeriod>hourly</sy:updatePeriod>
    <sy:updateFrequency>1</sy:updateFrequency>
    <item>
      <title>Gibbs energy minimization and the NIST webbook</title>
      <link>http://jkitchin.github.io/blog/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook</link>
      <pubDate>Fri, 01 Mar 2013 13:11:58 EST</pubDate>
      <category><![CDATA[optimization]]></category>
      <guid isPermaLink="false">2cPyJ1dhosp_-EMfiMiuxmC2KMM=</guid>
      <description>Gibbs energy minimization and the NIST webbook</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/25/gibbs-energy-minimization-and-the-nist-webbook/" >Matlab post</a>
In Post 1536 we used the NIST webbook to compute a temperature dependent Gibbs energy of reaction, and then used a reaction extent variable to compute the equilibrium concentrations of each species for the water gas shift reaction.
</p>

<p>
Today, we look at the direct minimization of the Gibbs free energy of the species, with no assumptions about stoichiometry of reactions. We only apply the constraint of conservation of atoms. We use the NIST Webbook to provide the data for the Gibbs energy of each species.
</p>

<p>
As a reminder we consider equilibrium between the species \(CO\), \(H_2O\), \(CO_2\) and \(H_2\), at 1000K, and 10 atm total pressure with an initial equimolar molar flow rate of \(CO\) and \(H_2O\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

T = 1000  <span style="color: #ff0000; font-weight: bold;"># K</span>
R = 8.314e-3 <span style="color: #ff0000; font-weight: bold;"># kJ/mol/K</span>

P = 10.0 <span style="color: #ff0000; font-weight: bold;"># atm, this is the total pressure in the reactor</span>
Po = 1.0 <span style="color: #ff0000; font-weight: bold;"># atm, this is the standard state pressure</span>
</pre>
</div>

<p>
We are going to store all the data and calculations in vectors, so we need to assign each position in the vector to a species. Here are the definitions we use in this work.
</p>

<pre class="example">
1  CO
2  H2O
3  CO2
4  H2
</pre>

<div class="org-src-container">

<pre class="src src-python">species = [<span style="color: #228b22;">'CO'</span>, <span style="color: #228b22;">'H2O'</span>, <span style="color: #228b22;">'CO2'</span>, <span style="color: #228b22;">'H2'</span>]

<span style="color: #ff0000; font-weight: bold;"># Heats of formation at 298.15 K</span>

Hf298 = [
    -110.53,  <span style="color: #ff0000; font-weight: bold;"># CO</span>
    -241.826, <span style="color: #ff0000; font-weight: bold;"># H2O</span>
    -393.51,  <span style="color: #ff0000; font-weight: bold;"># CO2</span>
       0.0]   <span style="color: #ff0000; font-weight: bold;"># H2</span>

<span style="color: #ff0000; font-weight: bold;"># Shomate parameters for each species</span>
<span style="color: #ff0000; font-weight: bold;">#           A          B           C          D          E            F          G       H</span>
WB = [[25.56759,  6.096130,     4.054656,  -2.671301,  0.131021, -118.0089, 227.3665,   -110.5271],  <span style="color: #ff0000; font-weight: bold;"># CO</span>
      [30.09200,  6.832514,     6.793435,  -2.534480,  0.082139, -250.8810, 223.3967,   -241.8264],  <span style="color: #ff0000; font-weight: bold;"># H2O</span>
      [24.99735,  55.18696,   -33.69137,    7.948387, -0.136638, -403.6075, 228.2431,   -393.5224],  <span style="color: #ff0000; font-weight: bold;"># CO2</span>
      [33.066178, -11.363417,  11.432816,  -2.772874, -0.158558, -9.980797, 172.707974,    0.0]]     <span style="color: #ff0000; font-weight: bold;"># H2</span>

WB = np.array(WB)

<span style="color: #ff0000; font-weight: bold;"># Shomate equations</span>
t = T/1000
T_H = np.array([t,  t**2 / 2.0, t**3 / 3.0, t**4 / 4.0, -1.0 / t, 1.0, 0.0, -1.0])
T_S = np.array([np.log(t), t,  t**2 / 2.0,  t**3 / 3.0, -1.0 / (2.0 * t**2), 0.0, 1.0, 0.0])

H = np.dot(WB, T_H)        <span style="color: #ff0000; font-weight: bold;"># (H - H_298.15) kJ/mol</span>
S = np.dot(WB, T_S/1000.0) <span style="color: #ff0000; font-weight: bold;"># absolute entropy kJ/mol/K</span>

Gjo = Hf298 + H - T*S      <span style="color: #ff0000; font-weight: bold;"># Gibbs energy of each component at 1000 K</span>
</pre>
</div>

<p>
Now, construct the Gibbs free energy function, accounting for the change in activity due to concentration changes (ideal mixing).
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(nj):
    nj = np.array(nj)
    Enj = np.sum(nj);
    Gj =  Gjo / (R * T) + np.log(nj / Enj * P / Po)
    <span style="color: #8b0000;">return</span> np.dot(nj, Gj)
</pre>
</div>

<p>
We impose the constraint that all atoms are conserved from the initial conditions to the equilibrium distribution of species. These constraints are in the form of \(A_{eq} n = b_{eq}\), where \(n\) is the vector of mole numbers for each species.
</p>

<div class="org-src-container">

<pre class="src src-python">Aeq = np.array([[ 1,    0,    1,    0],  <span style="color: #ff0000; font-weight: bold;"># C balance</span>
                [ 1,    1,    2,    0],  <span style="color: #ff0000; font-weight: bold;"># O balance</span>
                [ 0,    2,    0,    2]]) <span style="color: #ff0000; font-weight: bold;"># H balance</span>

<span style="color: #ff0000; font-weight: bold;"># equimolar feed of 1 mol H2O and 1 mol CO</span>
beq = np.array([1,  <span style="color: #ff0000; font-weight: bold;"># mol C fed</span>
                2,  <span style="color: #ff0000; font-weight: bold;"># mol O fed</span>
                2]) <span style="color: #ff0000; font-weight: bold;"># mol H fed</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ec1</span>(nj):
    <span style="color: #228b22;">'conservation of atoms constraint'</span>
    <span style="color: #8b0000;">return</span> np.dot(Aeq, nj) - beq
</pre>
</div>

<p>
Now we are ready to solve the problem. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fmin_slsqp

n0 = [0.5, 0.5, 0.5, 0.5]  <span style="color: #ff0000; font-weight: bold;"># initial guesses</span>
N = fmin_slsqp(func, n0, f_eqcons=ec1)
<span style="color: #8b0000;">print</span> N
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; Optimization terminated successfully.    (Exit mode 0)
            Current function value: -91.204832308
            Iterations: 2
            Function evaluations: 13
            Gradient evaluations: 2
[ 0.45502309  0.45502309  0.54497691  0.54497691]
</pre>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Compute mole fractions and partial pressures</h2>
<div class="outline-text-2" id="text-1">
<p>
The pressures here are in good agreement with the pressures found by other methods. The minor disagreement (in the third or fourth decimal place) is likely due to convergence tolerances in the different algorithms used.
</p>

<div class="org-src-container">

<pre class="src src-python">yj = N / np.sum(N)
Pj = yj * P

<span style="color: #8b0000;">for</span> s, y, p <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(species, yj, Pj):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0:10s}: {1:1.2f} {2:1.2f}'</span>.format(s, y, p)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; ... ... CO        : 0.23 2.28
H2O       : 0.23 2.28
CO2       : 0.27 2.72
H2        : 0.27 2.72
</pre>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Computing equilibrium constants</h2>
<div class="outline-text-2" id="text-2">
<p>
We can compute the equilibrium constant for the reaction \(CO + H_2O \rightleftharpoons CO_2 + H_2\). Compared to the value of K = 1.44 we found at the end of Post 1536 , the agreement is excellent. Note, that to define an equilibrium constant it is necessary to specify a reaction, even though it is not necessary to even consider a reaction to obtain the equilibrium distribution of species!
</p>

<div class="org-src-container">

<pre class="src src-python">nuj = np.array([-1, -1, 1, 1])  <span style="color: #ff0000; font-weight: bold;"># stoichiometric coefficients of the reaction</span>
K = np.prod(yj**nuj)
<span style="color: #8b0000;">print</span> K
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; 1.43446295961
</pre>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/01/Gibbs-energy-minimization-and-the-NIST-webbook.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Finding equilibrium composition by direct minimization of Gibbs free energy on mole numbers</title>
      <link>http://jkitchin.github.io/blog/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers</link>
      <pubDate>Fri, 01 Mar 2013 12:27:48 EST</pubDate>
      <category><![CDATA[optimization]]></category>
      <guid isPermaLink="false">j0YUTyQ_GaQ-VsNlprCKzxr8qH8=</guid>
      <description>Finding equilibrium composition by direct minimization of Gibbs free energy on mole numbers</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/25/finding-equilibrium-composition-by-direct-minimization-of-gibbs-free-energy-on-mole-numbers/" >Matlab post</a>
Adapted from problem 4.5 in Cutlip and Shacham
Ethane and steam are fed to a steam cracker at a total pressure of 1 atm and at 1000K at a ratio of 4 mol H2O to 1 mol ethane. Estimate the equilibrium distribution of products (CH4, C2H4, C2H2, CO2, CO, O2, H2, H2O, and C2H6).
</p>

<p>
Solution method: We will construct a Gibbs energy function for the mixture, and obtain the equilibrium composition by minimization of the function subject to elemental mass balance constraints.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

R = 0.00198588 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">kcal/mol/K</span>
T = 1000 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">K</span>

species = [<span style="color: #228b22;">'CH4'</span>, <span style="color: #228b22;">'C2H4'</span>, <span style="color: #228b22;">'C2H2'</span>, <span style="color: #228b22;">'CO2'</span>, <span style="color: #228b22;">'CO'</span>, <span style="color: #228b22;">'O2'</span>, <span style="color: #228b22;">'H2'</span>, <span style="color: #228b22;">'H2O'</span>, <span style="color: #228b22;">'C2H6'</span>]

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">$G_^\circ for each species. These are the heats of formation for each</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">species.</span>
Gjo = np.array([4.61, 28.249, 40.604, -94.61, -47.942, 0, 0, -46.03, 26.13]) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">kcal/mol</span>
</pre>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The Gibbs energy of a mixture</h2>
<div class="outline-text-2" id="text-1">
<p>
We start with \(G=\sum\limits_j n_j \mu_j\). Recalling that we define \(\mu_j = G_j^\circ + RT \ln a_j\), and in the ideal gas limit, \(a_j = y_j P/P^\circ\), and that \(y_j = \frac{n_j}{\sum n_j}\). Since in this problem, P = 1 atm, this leads to the function \(\frac{G}{RT} = \sum\limits_{j=1}^n n_j\left(\frac{G_j^\circ}{RT} + \ln \frac{n_j}{\sum n_j}\right)\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(nj):
    nj = np.array(nj)
    Enj = np.sum(nj);
    G = np.sum(nj * (Gjo / R / T + np.log(nj / Enj)))
    <span style="color: #8b0000;">return</span> G
</pre>
</div>
</div>
</div>
<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Linear equality constraints for atomic mass conservation</h2>
<div class="outline-text-2" id="text-2">
<p>
The total number of each type of atom must be the same as what entered the reactor. These form equality constraints on the equilibrium composition. We express these constraints as: \(A_{eq} n = b\) where \(n\) is a vector of the moles of each species present in the mixture. CH4 C2H4 C2H2 CO2 CO O2 H2 H2O C2H6
</p>

<div class="org-src-container">

<pre class="src src-python">Aeq = np.array([[0,   0,    0,   2,   1,  2,  0,  1,   0],      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">oxygen balance</span>
                [4,   4,    2,   0,   0,  0,  2,  2,   6],      <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">hydrogen balance</span>
                [1,   2,    2,   1,   1,  0,  0,  0,   2]])     <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">carbon balance</span>

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">the incoming feed was 4 mol H2O and 1 mol ethane</span>
beq = np.array([4,  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">moles of oxygen atoms coming in</span>
                14, <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">moles of hydrogen atoms coming in</span>
                2]) <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">moles of carbon atoms coming in</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">ec1</span>(n):
    <span style="color: #228b22;">'equality constraint'</span>
    <span style="color: #8b0000;">return</span> np.dot(Aeq, n) - beq
</pre>
</div>

<p>
Now we solve the problem.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">initial guess suggested in the example</span>
n0 = [1e-3, 1e-3, 1e-3, 0.993, 1.0, 1e-4, 5.992, 1.0, 1e-3] 

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fmin_slsqp

X = fmin_slsqp(func, n0, f_eqcons=ec1, iter=300, acc=1e-12)

<span style="color: #8b0000;">for</span> s,x <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(species, X):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'{0:10s} {1:1.4g}'</span>.format(s, x)

<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">check that constraints were met</span>
<span style="color: #8b0000;">print</span> np.dot(Aeq, X) - beq
<span style="color: #8b0000;">print</span> np.all( np.abs( np.dot(Aeq, X) - beq) &lt; 1e-12)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; Optimization terminated successfully.    (Exit mode 0)
            Current function value: -104.403947663
            Iterations: 217
            Function evaluations: 2937
            Gradient evaluations: 217
&gt;&gt;&gt; ... ... CH4        0.06694
C2H4       8.108e-08
C2H2       5.174e-08
CO2        0.5441
CO         1.389
O2         1.222e-14
H2         5.343
H2O        1.523
C2H6       8.44e-08
... [ -1.66977543e-13   1.77635684e-15   4.44089210e-16]
True
</pre>

<p>
I found it necessary to tighten the accuracy parameter to get pretty good matches to the solutions found in Matlab. It was also necessary to increase the number of iterations. Even still, not all of the numbers match well, especially the very small numbers. You can, however, see that the constraints were satisfied pretty well.
</p>


<p>
Interestingly there is a distribution of products! That is interesting because only steam and ethane enter the reactor, but a small fraction of methane is formed! The main product is hydrogen. The stoichiometry of steam reforming is ideally \(C_2H_6 + 4H_2O \rightarrow 2CO_2 + 7 H2\). Even though nearly all the ethane is consumed, we do not get the full yield of hydrogen. It appears that another equilibrium, one between CO, CO2, H2O and H2, may be limiting that, since the rest of the hydrogen is largely in the water. It is also of great importance that we have not said anything about reactions, i.e. how these products were formed. 
</p>

<p>
The water gas shift reaction is: \(CO + H_2O \rightleftharpoons CO_2 + H_2\). We can compute the Gibbs free energy of the reaction from the heats of formation of each species. Assuming these are the formation energies at 1000K, this is the reaction free energy at 1000K.
</p>

<div class="org-src-container">

<pre class="src src-python">G_wgs = Gjo[3] + Gjo[6] - Gjo[4] - Gjo[7]
<span style="color: #8b0000;">print</span> G_wgs

K = np.exp(-G_wgs / (R*T))
<span style="color: #8b0000;">print</span> K
</pre>
</div>

<pre class="example">
-0.638
&gt;&gt;&gt; &gt;&gt;&gt; 1.37887528109
</pre>
</div>
</div>
<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Equilibrium constant based on mole numbers</h2>
<div class="outline-text-2" id="text-3">
<p>
One normally uses activities to define the equilibrium constant. Since there are the same number of moles on each side of the reaction all factors that convert mole numbers to activity, concentration or pressure cancel, so we simply consider the ratio of mole numbers here.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">print</span> (X[3] * X[6]) / (X[4] * X[7])
</pre>
</div>

<pre class="example">
1.37450039394
</pre>

<p>
This is close, but not exactly the same as the equilibrium constant computed above. I think they should be exactly the same, and the difference is due to convergence errors in the solution to the problem.
</p>

<p>
Clearly, there is an equilibrium between these species that prevents the complete reaction of steam reforming.
</p>
</div>
</div>
<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Summary</h2>
<div class="outline-text-2" id="text-4">
<p>
This is an appealing way to minimize the Gibbs energy of a mixture. No assumptions about reactions are necessary, and the constraints are easy to identify. The Gibbs energy function is especially easy to code.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/03/01/Finding-equilibrium-composition-by-direct-minimization-of-Gibbs-free-energy-on-mole-numbers.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Meet the steam tables</title>
      <link>http://jkitchin.github.io/blog/2013/02/28/Meet-the-steam-tables</link>
      <pubDate>Thu, 28 Feb 2013 22:09:29 EST</pubDate>
      <category><![CDATA[uncategorized]]></category>
      <guid isPermaLink="false">a9q2uEoIwVNXU6iFwbuJlBvHks4=</guid>
      <description>Meet the steam tables</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Starting point in the Rankine cycle in condenser.</a></li>
<li><a href="#sec-2">2. Isentropic compression of liquid to point 2</a></li>
<li><a href="#sec-3">3. Isobaric heating to T3 in boiler where we make steam</a></li>
<li><a href="#sec-4">4. Isentropic expansion through turbine to point 4</a></li>
<li><a href="#sec-5">5. To get from point 4 to point 1</a></li>
<li><a href="#sec-6">6. Efficiency</a></li>
<li><a href="#sec-7">7. Entropy-temperature chart</a></li>
<li><a href="#sec-8">8. Summary</a></li>
</ul>
</div>
</div>
<p>
<a href="http://matlab.cheme.cmu.edu/2011/10/31/matlab-meets-the-steam-tables/">Matlab post</a>
</p>

<p>
We will use the <a href="https://pypi.python.org/pypi/iapws">iapws</a> module. Install it like this:
</p>

<div class="org-src-container">

<pre class="src src-sh">pip install iapws
</pre>
</div>

<p>
Problem statement: A Rankine cycle operates using steam with the condenser at 100 degC, a pressure of 3.0 MPa and temperature of 600 degC in the boiler. Assuming the compressor and turbine operate reversibly, estimate the efficiency of the cycle.
</p>

<p>
Starting point in the Rankine cycle in condenser.
</p>

<p>
we have saturated liquid here, and we get the thermodynamic properties for the given temperature. In this python module, these properties are all in attributes of an IAPWS object created at a set of conditions.
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Starting point in the Rankine cycle in condenser.</h2>
<div class="outline-text-2" id="text-1">
<p>
We have saturated liquid here, and we get the thermodynamic properties for the given temperature.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> iapws <span style="color: #8b0000;">import</span> IAPWS97

T1 = 100 + 273.15 <span style="color: #ff0000; font-weight: bold;">#in K</span>

sat_liquid1  = IAPWS97(T=T1, x=0) <span style="color: #ff0000; font-weight: bold;"># x is the steam quality. 0 = liquid</span>

P1 = sat_liquid1.P
s1 = sat_liquid1.s
h1 = sat_liquid1.h
v1 = sat_liquid1.v
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Isentropic compression of liquid to point 2</h2>
<div class="outline-text-2" id="text-2">
<p>
The final pressure is given, and we need to compute the new temperatures, and enthalpy.
</p>

<div class="org-src-container">

<pre class="src src-python">P2 = 3.0 <span style="color: #ff0000; font-weight: bold;"># MPa</span>
s2 = s1 <span style="color: #ff0000; font-weight: bold;"># this is what isentropic means</span>

sat_liquid2 = IAPWS97(P=P2, s=s1)
T2, = sat_liquid2.T
h2 = sat_liquid2.h

<span style="color: #ff0000; font-weight: bold;"># work done to compress liquid. This is an approximation, since the</span>
<span style="color: #ff0000; font-weight: bold;"># volume does change a little with pressure, but the overall work here</span>
<span style="color: #ff0000; font-weight: bold;"># is pretty small so we neglect the volume change.</span>
WdotP = v1*(P2 - P1);
<span style="color: #8b0000;">print</span>
<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The compressor work is: {0:1.4f} kJ/kg'</span>.format(WdotP))
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... &gt;&gt;&gt;
The compressor work is: 0.0030 kJ/kg
</pre>

<p>
The compression work is almost negligible. This number is 1000 times smaller than we computed with Xsteam. I wonder what the units of v1 actually are.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Isobaric heating to T3 in boiler where we make steam</h2>
<div class="outline-text-2" id="text-3">
<div class="org-src-container">

<pre class="src src-python">T3 = 600 + 273.15 <span style="color: #ff0000; font-weight: bold;"># K</span>
P3 = P2 <span style="color: #ff0000; font-weight: bold;"># definition of isobaric</span>
steam = IAPWS97(P=P3, T=T3)

h3 = steam.h
s3 = steam.s

Qb, = h3 - h2 <span style="color: #ff0000; font-weight: bold;"># heat required to make the steam</span>

<span style="color: #8b0000;">print</span>
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The boiler heat duty is: {0:1.2f} kJ/kg'</span>.format(Qb)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;
The boiler heat duty is: 3260.69 kJ/kg
</pre>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Isentropic expansion through turbine to point 4</h2>
<div class="outline-text-2" id="text-4">
<div class="org-src-container">

<pre class="src src-python">steam =  IAPWS97(P=P1, s=s3)
T4, = steam.T
h4 = steam.h
s4 = s3 <span style="color: #ff0000; font-weight: bold;"># isentropic</span>
Qc, = h4 - h1 <span style="color: #ff0000; font-weight: bold;"># work required to cool from T4 to T1</span>
<span style="color: #8b0000;">print</span> 
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The condenser heat duty is {0:1.2f} kJ/kg'</span>.format(Qc)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt;
The condenser heat duty is 2317.00 kJ/kg
</pre>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> To get from point 4 to point 1</h2>
<div class="outline-text-2" id="text-5">
<div class="org-src-container">

<pre class="src src-python">WdotTurbine, = h4 - h3 <span style="color: #ff0000; font-weight: bold;"># work extracted from the expansion</span>
<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The turbine work is: {0:1.2f} kJ/kg'</span>.format(WdotTurbine))
</pre>
</div>

<pre class="example">
The turbine work is: -946.71 kJ/kg
</pre>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Efficiency</h2>
<div class="outline-text-2" id="text-6">
<p>
This is a ratio of the work put in to make the steam, and the net work obtained from the turbine. The answer here agrees with the efficiency calculated in Sandler on page 135.
</p>

<div class="org-src-container">

<pre class="src src-python">eta = -(WdotTurbine - WdotP) / Qb
<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'The overall efficiency is {0:1.2%}.'</span>.format(eta))
</pre>
</div>

<pre class="example">
The overall efficiency is 29.03%.
</pre>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Entropy-temperature chart</h2>
<div class="outline-text-2" id="text-7">
<p>
The IAPWS module makes it pretty easy to generate figures of the steam tables. Here we generate an entropy-Temperature graph. We do this to illustrate the path of the Rankine cycle. We need to compute the values of steam entropy for a range of pressures and temperatures.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.figure()
plt.clf()
T = np.linspace(300, 372+273, 200) <span style="color: #ff0000; font-weight: bold;"># range of temperatures</span>
<span style="color: #8b0000;">for</span> P <span style="color: #8b0000;">in</span> [0.1, 1, 2, 5, 10, 20]: <span style="color: #ff0000; font-weight: bold;">#MPa</span>
    steam = [IAPWS97(T=t, P=P) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> T]
    S = [s.s <span style="color: #8b0000;">for</span> s <span style="color: #8b0000;">in</span> steam]
    plt.plot(S, T, <span style="color: #228b22;">'k-'</span>)

<span style="color: #ff0000; font-weight: bold;"># saturated vapor and liquid entropy lines</span>
svap = [s.s <span style="color: #8b0000;">for</span> s <span style="color: #8b0000;">in</span> [IAPWS97(T=t, x=1) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> T]]
sliq = [s.s <span style="color: #8b0000;">for</span> s <span style="color: #8b0000;">in</span> [IAPWS97(T=t, x=0) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> T]]

plt.plot(svap, T, <span style="color: #228b22;">'r-'</span>)
plt.plot(sliq, T, <span style="color: #228b22;">'b-'</span>)

plt.xlabel(<span style="color: #228b22;">'Entropy (kJ/(kg K)'</span>)
plt.ylabel(<span style="color: #228b22;">'Temperature (K)'</span>)
plt.savefig(<span style="color: #228b22;">'images/iawps-steam.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &lt;matplotlib.figure.Figure object at 0x000000000638BC18&gt;
&gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... [&lt;matplotlib.lines.Line2D object at 0x0000000007F9C208&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9C400&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9C8D0&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9CD30&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9E1D0&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9E630&gt;]
... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0000000001FDCEB8&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000007F9EA90&gt;]
&gt;&gt;&gt; &lt;matplotlib.text.Text object at 0x0000000007F7BE48&gt;
&lt;matplotlib.text.Text object at 0x0000000007F855F8&gt;
</pre>


<p><img src="/img/./images/iawps-steam.png"><p>


<p>
We can plot our Rankine cycle path like this. We compute the entropies along the non-isentropic paths.
</p>

<div class="org-src-container">

<pre class="src src-python">T23 = np.linspace(T2, T3)
S23 = [s.s <span style="color: #8b0000;">for</span> s <span style="color: #8b0000;">in</span> [IAPWS97(P=P2, T=t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> T23]]

T41 = np.linspace(T4, T1 - 0.01) <span style="color: #ff0000; font-weight: bold;"># subtract a tiny bit to make sure we get a liquid</span>
S41 = [s.s <span style="color: #8b0000;">for</span> s <span style="color: #8b0000;">in</span> [IAPWS97(P=P1, T=t) <span style="color: #8b0000;">for</span> t <span style="color: #8b0000;">in</span> T41]]
</pre>
</div>

<p>
And then we plot the paths.
</p>

<div class="org-src-container">

<pre class="src src-python">plt.plot([s1, s2], [T1, T2], <span style="color: #228b22;">'r-'</span>, lw=4) <span style="color: #ff0000; font-weight: bold;"># Path 1 to 2</span>
plt.plot(S23, T23, <span style="color: #228b22;">'b-'</span>, lw=4) <span style="color: #ff0000; font-weight: bold;"># path from 2 to 3 is isobaric</span>
plt.plot([s3, s4], [T3, T4], <span style="color: #228b22;">'g-'</span>, lw=4) <span style="color: #ff0000; font-weight: bold;"># path from 3 to 4 is isentropic</span>
plt.plot(S41, T41, <span style="color: #228b22;">'k-'</span>, lw=4) <span style="color: #ff0000; font-weight: bold;"># and from 4 to 1 is isobaric</span>
plt.savefig(<span style="color: #228b22;">'images/iawps-steam-2.png'</span>)
plt.savefig(<span style="color: #228b22;">'images/iawps-steam-2.svg'</span>)
</pre>
</div>

<pre class="example">
[&lt;matplotlib.lines.Line2D object at 0x0000000008350908&gt;]
[&lt;matplotlib.lines.Line2D object at 0x00000000083358D0&gt;]
[&lt;matplotlib.lines.Line2D object at 0x000000000835BEB8&gt;]
[&lt;matplotlib.lines.Line2D object at 0x0000000008357160&gt;]
</pre>

<p><img src="/img/./images/iawps-steam-2.png"><p>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> Summary</h2>
<div class="outline-text-2" id="text-8">
<p>
This was an interesting exercise. On one hand, the tedium of interpolating the steam tables is gone. On the other hand, you still have to know exactly what to ask for to get an answer that is correct. The iapws interface is a little clunky, and takes some getting used to. It does not seem as robust as the Xsteam module I used in Matlab.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/28/Meet-the-steam-tables.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Reading parameter database text files in python</title>
      <link>http://jkitchin.github.io/blog/2013/02/27/Reading-parameter-database-text-files-in-python</link>
      <pubDate>Wed, 27 Feb 2013 10:52:22 EST</pubDate>
      <category><![CDATA[io]]></category>
      <guid isPermaLink="false">n66LCHdthWBW60A44kRyS5yJa3w=</guid>
      <description>Reading parameter database text files in python</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/10/reading-parameter-database-text-files-in-matlab/" >Matlab post</a>
</p>

<p>
The datafile at <a href="http://terpconnect.umd.edu/~nsw/ench250/antoine.dat" >http://terpconnect.umd.edu/~nsw/ench250/antoine.dat</a> (dead link) contains data that can be used to estimate the vapor pressure of about 700 pure compounds using the Antoine equation
</p>

<p>
The data file has the following contents:
</p>

<pre class="example">
Antoine Coefficients
  log(P) = A-B/(T+C) where P is in mmHg and T is in Celsius
Source of data: Yaws and Yang (Yaws, C.  L.  and Yang, H.  C.,
"To estimate vapor pressure easily. antoine coefficients relate vapor pressure to temperature for almost 700 major organic compounds", Hydrocarbon Processing, 68(10), p65-68, 1989.

ID  formula  compound name                  A       B       C     Tmin Tmax ??    ?
-----------------------------------------------------------------------------------
  1 CCL4     carbon-tetrachloride        6.89410 1219.580 227.170  -20  101 Y2    0
  2 CCL3F    trichlorofluoromethane      6.88430 1043.010 236.860  -33   27 Y2    0
  3 CCL2F2   dichlorodifluoromethane     6.68619  782.072 235.377 -119  -30 Y6    0
</pre>

<p>
To use this data, you find the line that has the compound you want, and read off the data. You could do that manually for each component you want but that is tedious, and error prone. Today we will see how to retrieve the file, then read the data into python to create a database we can use to store and retrieve the data.
</p>

<p>
We will use the data to find the temperature at which the vapor pressure of acetone is 400 mmHg. 
</p>

<p>
We use numpy.loadtxt to read the file, and tell the function the format of each column. This creates a special kind of record array which we can access data by field name.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

data = np.loadtxt(<span style="color: #228b22;">'data/antoine_data.dat'</span>,
                  dtype=[(<span style="color: #228b22;">'id'</span>, np.int),
                         (<span style="color: #228b22;">'formula'</span>, <span style="color: #228b22;">'S8'</span>),
                         (<span style="color: #228b22;">'name'</span>, <span style="color: #228b22;">'S28'</span>),
                         (<span style="color: #228b22;">'A'</span>, np.float),
                         (<span style="color: #228b22;">'B'</span>, np.float),
                         (<span style="color: #228b22;">'C'</span>, np.float),
                         (<span style="color: #228b22;">'Tmin'</span>, np.float),
                         (<span style="color: #228b22;">'Tmax'</span>, np.float),
                         (<span style="color: #228b22;">'??'</span>, <span style="color: #228b22;">'S4'</span>),
                         (<span style="color: #228b22;">'?'</span>, <span style="color: #228b22;">'S4'</span>)],
                  skiprows=7)

names = data[<span style="color: #228b22;">'name'</span>]

acetone, = data[names == <span style="color: #228b22;">'acetone'</span>]

<span style="color: #ff0000; font-weight: bold;"># for readability we unpack the array into variables</span>
id, formula, name, A, B, C, Tmin, Tmax, u1, u2 = acetone

T = np.linspace(Tmin, Tmax)
P = 10**(A - B / ( T + C))
plt.plot(T, P)
plt.xlabel(<span style="color: #228b22;">'T ($^\circ$C)'</span>)
plt.ylabel(<span style="color: #228b22;">'P$_{vap}$ (mmHg)'</span>)

<span style="color: #ff0000; font-weight: bold;"># Find T at which Pvap = 400 mmHg</span>
<span style="color: #ff0000; font-weight: bold;"># from our graph we might guess T ~ 40 ^{\circ}C</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">objective</span>(T):
    <span style="color: #8b0000;">return</span> 400 - 10**(A - B / (T + C))

<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve
Tsol, = fsolve(objective, 40)
<span style="color: #8b0000;">print</span> Tsol
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The vapor pressure is 400 mmHg at T = {0:1.1f} degC'</span>.format(Tsol)

<span style="color: #ff0000; font-weight: bold;">#Plot CRC data http://en.wikipedia.org/wiki/Acetone_%28data_page%29#Vapor_pressure_of_liquid</span>
<span style="color: #ff0000; font-weight: bold;"># We only include the data for the range where the Antoine fit is valid.</span>

Tcrc  = [-59.4,         -31.1,  -9.4,   7.7,    39.5,   56.5]
Pcrc = [        1,      10,     40,     100,    400,    760]

plt.plot(Tcrc, Pcrc, <span style="color: #228b22;">'bo'</span>)
plt.legend([<span style="color: #228b22;">'Antoine'</span>,<span style="color: #228b22;">'CRC Handbook'</span>], loc=<span style="color: #228b22;">'best'</span>)
plt.savefig(<span style="color: #228b22;">'images/antoine-2.png'</span>)
</pre>
</div>

<pre class="example">
38.6138198197
The vapor pressure is 400 mmHg at T = 38.6 degC
</pre>

<p><img src="/img/images/antoine-1.png"><p>

<p>
This result is close to the value reported <a href="http://en.wikipedia.org/wiki/Acetone_(data_page)#Vapor_pressure_of_liquid" > here</a> (39.5 degC), from the CRC Handbook. The difference is probably that the value reported in the CRC is an actual experimental number.
</p>

<p><img src="/img/./images/antoine-2.png"><p>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/27/Reading-parameter-database-text-files-in-python.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Calculating a bubble point pressure of a mixture</title>
      <link>http://jkitchin.github.io/blog/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture</link>
      <pubDate>Mon, 18 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[nonlinear algebra]]></category>
      <guid isPermaLink="false">pRZlFP3yQwJs7jwDKG2E5hSQrsU=</guid>
      <description>Calculating a bubble point pressure of a mixture</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/15/calculating-a-bubble-point-pressure/" >Matlab post</a>
</p>

<p>
Adapted from <a href="http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm" >http://terpconnect.umd.edu/~nsw/ench250/bubpnt.htm</a> (dead link)
</p>

<p>
We previously learned to read a datafile containing lots of Antoine coefficients into a database, and use the coefficients to estimate vapor pressure of a single compound. Here we use those coefficents to compute a bubble point pressure of a mixture. 
</p>

<p>
The bubble point is the temperature at which the sum of the component vapor pressures is equal to the the total pressure. This is where a bubble of vapor will first start forming, and the mixture starts to boil.
</p>

<p>
Consider an equimolar mixture of benzene, toluene, chloroform, acetone and methanol. Compute the bubble point at 760 mmHg, and the gas phase composition. The gas phase composition is given by: \(y_i = x_i*P_i/P_T\).
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #ff0000; font-weight: bold;"># load our thermodynamic data</span>
data = np.loadtxt(<span style="color: #228b22;">'data/antoine_data.dat'</span>,
                  dtype=[(<span style="color: #228b22;">'id'</span>, np.int),
                         (<span style="color: #228b22;">'formula'</span>, <span style="color: #228b22;">'S8'</span>),
                         (<span style="color: #228b22;">'name'</span>, <span style="color: #228b22;">'S28'</span>),
                         (<span style="color: #228b22;">'A'</span>, np.float),
                         (<span style="color: #228b22;">'B'</span>, np.float),
                         (<span style="color: #228b22;">'C'</span>, np.float),
                         (<span style="color: #228b22;">'Tmin'</span>, np.float),
                         (<span style="color: #228b22;">'Tmax'</span>, np.float),
                         (<span style="color: #228b22;">'??'</span>, <span style="color: #228b22;">'S4'</span>),
                         (<span style="color: #228b22;">'?'</span>, <span style="color: #228b22;">'S4'</span>)],
                  skiprows=7)

compounds = [<span style="color: #228b22;">'benzene'</span>, <span style="color: #228b22;">'toluene'</span>, <span style="color: #228b22;">'chloroform'</span>, <span style="color: #228b22;">'acetone'</span>, <span style="color: #228b22;">'methanol'</span>]

<span style="color: #ff0000; font-weight: bold;"># extract the data we want</span>
A = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'A'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
B = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'B'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
C = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'C'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
Tmin = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'Tmin'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])
Tmax = np.array([data[data[<span style="color: #228b22;">'name'</span>] == x][<span style="color: #228b22;">'Tmax'</span>][0] <span style="color: #8b0000;">for</span> x <span style="color: #8b0000;">in</span> compounds])


<span style="color: #ff0000; font-weight: bold;"># we have an equimolar mixture</span>
x = np.array([0.2, 0.2, 0.2, 0.2, 0.2])

<span style="color: #ff0000; font-weight: bold;"># Given a T, we can compute the pressure of each species like this:</span>

T = 67 <span style="color: #ff0000; font-weight: bold;"># degC</span>
P = 10**(A - B / (T + C))
<span style="color: #8b0000;">print</span> P
<span style="color: #8b0000;">print</span> np.dot(x, P)  <span style="color: #ff0000; font-weight: bold;"># total mole-fraction weighted pressure</span>

Tguess = 67
Ptotal = 760

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">func</span>(T):
    P = 10**(A - B / (T + C))
    <span style="color: #8b0000;">return</span> Ptotal - np.dot(x, P)
    
Tbubble, = fsolve(func, Tguess)

<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The bubble point is {0:1.2f} degC'</span>.format(Tbubble)

<span style="color: #ff0000; font-weight: bold;"># double check answer is in a valid T range</span>
<span style="color: #8b0000;">if</span> np.any(Tbubble &lt; Tmin) <span style="color: #8b0000;">or</span> np.any(Tbubble &gt; Tmax):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'T_bubble is out of range!'</span>

<span style="color: #ff0000; font-weight: bold;"># print gas phase composition</span>
y = x * 10**(A - B / (Tbubble + C))/Ptotal

<span style="color: #8b0000;">for</span> cmpd, yi <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">zip</span>(compounds, y):
    <span style="color: #8b0000;">print</span> <span style="color: #228b22;">'y_{0:&lt;10s} = {1:1.3f}'</span>.format(cmpd, yi)
</pre>
</div>

<pre class="example">
[  498.4320267    182.16010994   898.31061294  1081.48181768   837.88860027]
699.654633507
The bubble point is 69.46 degC
y_benzene    = 0.142
y_toluene    = 0.053
y_chloroform = 0.255
y_acetone    = 0.308
y_methanol   = 0.242
</pre>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/Calculating-a-bubble-point-pressure-of-a-mixture.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>The Gibbs free energy of a reacting mixture and the equilibrium composition</title>
      <link>http://jkitchin.github.io/blog/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition</link>
      <pubDate>Mon, 18 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[optimization]]></category>
      <guid isPermaLink="false">6p4az1VK91uyv4s50T5N3Bl2Do4=</guid>
      <description>The Gibbs free energy of a reacting mixture and the equilibrium composition</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2011/12/20/the-gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition/" >Matlab post</a>
</p>

<p>
In this post we derive the equations needed to find the equilibrium composition of a reacting mixture. We use the method of direct minimization of the Gibbs free energy of the reacting mixture.
</p>

<p>
The Gibbs free energy of a mixture is defined as \(G = \sum\limits_j \mu_j n_j\) where \(\mu_j\) is the chemical potential of species \(j\), and it is temperature and pressure dependent, and \(n_j\) is the number of moles of species \(j\).
</p>

<p>
We define the chemical potential as \(\mu_j = G_j^\circ + RT\ln a_j\), where \(G_j^\circ\) is the Gibbs energy in a standard state, and \(a_j\) is the activity of species \(j\) if the pressure and temperature are not at standard state conditions.
</p>

<p>
If a reaction is occurring, then the number of moles of each species are related to each other through the reaction extent \(\epsilon\) and stoichiometric coefficients: \(n_j = n_{j0} + \nu_j \epsilon\). Note that the reaction extent has units of moles.
</p>

<p>
Combining these three equations and expanding the terms leads to:
</p>

<p>
$$G = \sum\limits_j n_{j0}G_j^\circ +\sum\limits_j \nu_j G_j^\circ \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j $$
</p>

<p>
The first term is simply the initial Gibbs free energy that is present before any reaction begins, and it is a constant. It is difficult to evaluate, so we will move it to the left side of the equation in the next step, because it does not matter what its value is since it is a constant. The second term is related to the Gibbs free energy of reaction: \(\Delta_rG = \sum\limits_j \nu_j G_j^\circ\). With these observations we rewrite the equation as:
</p>

<p>
$$G - \sum\limits_j n_{j0}G_j^\circ = \Delta_rG \epsilon +RT\sum\limits_j(n_{j0} + \nu_j\epsilon)\ln a_j $$
</p>

<p>
Now, we have an equation that allows us to compute the change in Gibbs free energy as a function of the reaction extent, initial number of moles of each species, and the activities of each species. This difference in Gibbs free energy has no natural scale, and depends on the size of the system, i.e. on \(n_{j0}\). It is desirable to avoid this, so we now rescale the equation by the total initial moles present, \(n_{T0}\) and define a new variable \(\epsilon' = \epsilon/n_{T0}\), which is dimensionless. This leads to:
</p>

<p>
$$ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \Delta_rG \epsilon' + RT \sum\limits_j(y_{j0} + \nu_j\epsilon')\ln a_j $$
</p>

<p>
where \(y_{j0}\) is the initial mole fraction of species \(j\) present. The mole fractions are intensive properties that do not depend on the system size. Finally, we need to address \(a_j\). For an ideal gas, we know that \(A_j = \frac{y_j P}{P^\circ}\), where the numerator is the partial pressure of species \(j\) computed from the mole fraction of species \(j\) times the total pressure. To get the mole fraction we note:
</p>

<p>
$$y_j = \frac{n_j}{n_T} = \frac{n_{j0} + \nu_j \epsilon}{n_{T0} + \epsilon \sum\limits_j \nu_j} = \frac{y_{j0} + \nu_j \epsilon'}{1 + \epsilon'\sum\limits_j \nu_j} $$
</p>

<p>
This finally leads us to an equation that we can evaluate as a function of reaction extent:
</p>

<p>
$$ \frac{G - \sum\limits_j n_{j0}G_j^\circ}{n_{T0}} = \widetilde{\widetilde{G}} = \Delta_rG \epsilon' + RT\sum\limits_j(y_{j0} + \nu_j\epsilon') \ln\left(\frac{y_{j0}+\nu_j\epsilon'}{1+\epsilon'\sum\limits_j\nu_j} \frac{P}{P^\circ}\right) $$
</p>

<p>
we use a double tilde notation to distinguish this quantity from the quantity derived by Rawlings and Ekerdt which is further normalized by a factor of \(RT\). This additional scaling makes the quantities dimensionless, and makes the quantity have a magnitude of order unity, but otherwise has no effect on the shape of the graph.
</p>

<p>
Finally, if we know the initial mole fractions, the initial total pressure, the Gibbs energy of reaction, and the stoichiometric coefficients, we can plot the scaled reacting mixture energy as a function of reaction extent. At equilibrium, this energy will be a minimum. We consider the example in Rawlings and Ekerdt where isobutane (I) reacts with 1-butene (B) to form 2,2,3-trimethylpentane (P). The reaction occurs at a total pressure of 2.5 atm at 400K, with equal molar amounts of I and B. The standard Gibbs free energy of reaction at 400K is -3.72 kcal/mol. Compute the equilibrium composition.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

R = 8.314
P = 250000  <span style="color: #ff0000; font-weight: bold;"># Pa</span>
P0 = 100000 <span style="color: #ff0000; font-weight: bold;"># Pa, approximately 1 atm</span>
T = 400 <span style="color: #ff0000; font-weight: bold;"># K</span>

Grxn = -15564.0 <span style="color: #ff0000; font-weight: bold;">#J/mol</span>
yi0 = 0.5; yb0 = 0.5; yp0 = 0.0; <span style="color: #ff0000; font-weight: bold;"># initial mole fractions</span>

yj0 = np.array([yi0, yb0, yp0])
nu_j = np.array([-1.0, -1.0, 1.0])   <span style="color: #ff0000; font-weight: bold;"># stoichiometric coefficients</span>

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">Gwigglewiggle</span>(extentp):
    diffg = Grxn * extentp
    sum_nu_j = np.sum(nu_j)
    <span style="color: #8b0000;">for</span> i,y <span style="color: #8b0000;">in</span> <span style="color: #8b0000;">enumerate</span>(yj0):
        x1 = yj0[i] + nu_j[i] * extentp
        x2 = x1 / (1.0 + extentp*sum_nu_j)
        diffg += R * T * x1 * np.log(x2 * P / P0)
    <span style="color: #8b0000;">return</span> diffg
</pre>
</div>

<p>
There are bounds on how large \(\epsilon'\) can be. Recall that \(n_j = n_{j0} + \nu_j \epsilon\), and that \(n_j \ge 0\). Thus, \(\epsilon_{max} = -n_{j0}/\nu_j\), and the maximum value that \(\epsilon'\) can have is therefore \(-y_{j0}/\nu_j\) where \(y_{j0}>0\). When there are multiple species, you need the smallest \(epsilon'_{max}\) to avoid getting negative mole numbers.
</p>

<div class="org-src-container">

<pre class="src src-python">epsilonp_<span style="color: #8b0000;">max</span> = <span style="color: #8b0000;">min</span>(-yj0[yj0 &gt; 0] / nu_j[yj0 &gt; 0])
epsilonp = np.linspace(1e-6, epsilonp_max, 1000);

<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

plt.plot(epsilonp,Gwigglewiggle(epsilonp))
plt.xlabel(<span style="color: #228b22;">'$\epsilon$'</span>)
plt.ylabel(<span style="color: #228b22;">'Gwigglewiggle'</span>)
plt.savefig(<span style="color: #228b22;">'images/gibbs-minim-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x10a8bf50&gt;]
&lt;matplotlib.text.Text object at 0x10608190&gt;
&lt;matplotlib.text.Text object at 0x10609d10&gt;
</pre>

<p><img src="/img/./images/gibbs-minim-1.png"><p>

<p>
Now we simply minimize our Gwigglewiggle function. Based on the figure above, the miminum is near 0.45.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fminbound

epsilonp_eq = fminbound(Gwigglewiggle, 0, 0.45)

plt.plot([extmin], [Gwigglewiggle(epsilonp_eq)], <span style="color: #228b22;">'ro'</span>)
plt.savefig(<span style="color: #228b22;">'images/gibbs-minim-2.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x10a8b5d0&gt;]
</pre>

<p><img src="/img/./images/gibbs-minim-2.png"><p>

<p>
To compute equilibrium mole fractions we do this:
</p>
<div class="org-src-container">

<pre class="src src-python">yi = (yi0 + nu_j[0]*epsilonp_eq) / (1.0 + epsilonp_eq*np.sum(nu_j))
yb = (yb0 + nu_j[1]*epsilonp_eq) / (1.0 + epsilonp_eq*np.sum(nu_j))
yp = (yp0 + nu_j[2]*epsilonp_eq) / (1.0 + epsilonp_eq*np.sum(nu_j))

<span style="color: #8b0000;">print</span> yi, yb, yp

<span style="color: #ff0000; font-weight: bold;"># or this</span>
y_j = (yj0 + np.dot(nu_j, epsilonp_eq)) / (1.0 + epsilonp_eq*np.sum(nu_j))
<span style="color: #8b0000;">print</span> y_j
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.0573226598476 0.0573226598476 0.885354680305
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [ 0.05732266  0.05732266  0.88535468]
</pre>

<p>
\(K = \frac{a_P}{a_I a_B} = \frac{y_p P/P^\circ}{y_i P/P^\circ y_b P/P^\circ} = \frac{y_P}{y_i y_b}\frac{P^\circ}{P}\).
</p>

<p>
We can express the equilibrium constant like this :\(K = \prod\limits_j a_j^{\nu_j}\), and compute it with a single line of code.
</p>

<div class="org-src-container">

<pre class="src src-python">K = np.exp(-Grxn/R/T)
<span style="color: #8b0000;">print</span> K
<span style="color: #8b0000;">print</span> yp / (yi * yb) * P0 / P

<span style="color: #8b0000;">print</span> np.prod((y_j * P / P0)**nu_j)
</pre>
</div>

<pre class="example">
107.776294742
107.776632714
&gt;&gt;&gt; 107.776632714
</pre>

<p>
These results are very close, and only disagree because of the default tolerance used in identifying the minimum of our function. you could tighten the tolerances by setting options to the fminbnd function.
</p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
In this post we derived an equation for the Gibbs free energy of a reacting mixture and used it to find the equilibrium composition. In future posts we will examine some alternate forms of the equations that may be more useful in some circumstances.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/18/The-Gibbs-free-energy-of-a-reacting-mixture-and-the-equilibrium-composition.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>The equal area method for the van der Waals equation</title>
      <link>http://jkitchin.github.io/blog/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation</link>
      <pubDate>Fri, 15 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[plotting]]></category>
      <guid isPermaLink="false">y4-e4AzPJtxZMR6YOH6t_k2TGdk=</guid>
      <description>The equal area method for the van der Waals equation</description>
      <content:encoded><![CDATA[


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Compute areas</a></li>
</ul>
</div>
</div>
<p>
<a href="http://matlab.cheme.cmu.edu/2011/09/11/the-equal-area-method-for-the-van-der-waals-equation/">Matlab post</a> 
</p>

<p>
When a gas is below its Tc the van der Waal equation oscillates. In the portion of the isotherm where \(\partial P_R/\partial V_r > 0\), the isotherm fails to describe real materials, which phase separate into a liquid and gas in this region.
</p>

<p>
Maxwell proposed to replace this region by a flat line, where the area above and below the curves are equal. Today, we examine how to identify where that line should be.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b008b;">Tr</span> = 0.9 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">A Tr below Tc:  Tr = T/Tc</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">analytical equation for Pr. This is the reduced form of the van der Waal</span>
<span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">equation.</span>
<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">Prfh</span>(Vr):
    <span style="color: #8b0000;">return</span>  8.0 / 3.0 * Tr / (Vr - 1.0 / 3.0) - 3.0 / (Vr**2)

<span style="color: #8b008b;">Vr</span> = np.linspace(0.5, 4, 100)  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">vector of reduced volume</span>
<span style="color: #8b008b;">Pr</span> = Prfh(Vr)                 <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">vector of reduced pressure</span>

plt.plot(Vr,Pr)
plt.ylim([0, 2])
plt.xlabel(<span style="color: #228b22;">'$V_R$'</span>)
plt.ylabel(<span style="color: #228b22;">'$P_R$'</span>)
plt.savefig(<span style="color: #228b22;">'images/maxwell-eq-area-1.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x042FDAF0&gt;]
(0, 2)
&lt;matplotlib.text.Text object at 0x04237CB0&gt;
&lt;matplotlib.text.Text object at 0x042DC030&gt;
</pre>


<div class="figure">
<p><p><img src="/img/./images/maxwell-eq-area-1.png"><p>
</p>
</div>

<p>
The idea is to pick a Pr and draw a line through the EOS. We want the areas between the line and EOS to be equal on each side of the middle intersection. Let us draw a line on the figure at y = 0.65.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">y</span> = 0.65

plt.plot([0.5, 4.0], [y, y], <span style="color: #228b22;">'k--'</span>)
plt.savefig(<span style="color: #228b22;">'images/maxwell-eq-area-2.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x042FDCD0&gt;]
</pre>


<div class="figure">
<p><p><img src="/img/./images/maxwell-eq-area-2.png"><p>
</p>
</div>

<p>
To find the areas, we need to know where the intersection of the vdW eqn with the horizontal line. This is the same as asking what are the roots of the vdW equation at that Pr. We need all three intersections so we can integrate from the first root to the middle root, and then the middle root to the third root. We take advantage of the polynomial nature of the vdW equation, which allows us to use the roots command to get all the roots at once. The polynomial is \(V_R^3 - \frac{1}{3}(1+8 T_R/P_R) + 3/P_R - 1/P_R = 0\). We use the coefficients t0 get the roots like this.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">vdWp</span> = [1.0, -1. / 3.0 * (1.0 + 8.0 * Tr / y), 3.0 / y, - 1.0 / y]
<span style="color: #8b008b;">v</span> = np.roots(vdWp)
v.sort()
<span style="color: #8b0000;">print</span> v

plt.plot(v[0], y, <span style="color: #228b22;">'bo'</span>, v[1], y, <span style="color: #228b22;">'bo'</span>, v[2], y, <span style="color: #228b22;">'bo'</span>)
plt.savefig(<span style="color: #228b22;">'images/maxwell-eq-area-3.png'</span>)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [ 0.60286812  1.09743234  2.32534056]
&gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x0439C570&gt;, &lt;matplotlib.lines.Line2D object at 0x043933B0&gt;, &lt;matplotlib.lines.Line2D object at 0x04393CB0&gt;]
</pre>


<div class="figure">
<p><p><img src="/img/./images/maxwell-eq-area-3.png"><p>
</p>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Compute areas</h2>
<div class="outline-text-2" id="text-1">
<p>
for A1, we need the area under the line minus the area under the vdW curve. That is the area between the curves. For A2, we want the area under the vdW curve minus the area under the line. The area under the line between root 2 and root 1 is just the width (root2 - root1)*y
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.integrate <span style="color: #8b0000;">import</span> quad

<span style="color: #8b008b;">A1</span>, <span style="color: #8b008b;">e1</span> = (v[1] - v[0]) * y - quad(Prfh,  v[0], v[1])
<span style="color: #8b008b;">A2</span>, <span style="color: #8b008b;">e2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1])* y 

<span style="color: #8b0000;">print</span> A1, A2
<span style="color: #8b0000;">print</span> e1, e2  <span style="color: #ff0000; font-weight: bold;"># </span><span style="color: #ff0000; font-weight: bold;">interesting these look so large</span>
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.063225945606 0.0580212098122
0.321466743765 -0.798140339268
</pre>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">equal_area</span>(y):
    <span style="color: #8b008b;">Tr</span> = 0.9
    <span style="color: #8b008b;">vdWp</span> = [1, -1.0 / 3 * ( 1.0 + 8.0 * Tr / y), 3.0 / y,  -1.0 / y]
    <span style="color: #8b008b;">v</span> = np.roots(vdWp)
    v.sort()
    <span style="color: #8b008b;">A1</span> = (v[1] - v[0]) * y - quad(Prfh, v[0], v[1])
    <span style="color: #8b008b;">A2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1]) * y
    <span style="color: #8b0000;">return</span>  A1 - A2

y_eq, = fsolve(equal_area, 0.65)
<span style="color: #8b0000;">print</span> y_eq

<span style="color: #8b008b;">Tr</span> = 0.9
<span style="color: #8b008b;">vdWp</span> = [1, -1.0 / 3 * ( 1.0 + 8.0 * Tr / y_eq), 3.0 / y_eq,  -1.0 / y_eq]
<span style="color: #8b008b;">v</span> = np.roots(vdWp)
v.sort()

<span style="color: #8b008b;">A1</span>, <span style="color: #8b008b;">e1</span> = (v[1] - v[0]) * y_eq - quad(Prfh,  v[0], v[1])
<span style="color: #8b008b;">A2</span>, <span style="color: #8b008b;">e2</span> = quad(Prfh, v[1], v[2]) - (v[2] - v[1]) * y_eq

<span style="color: #8b0000;">print</span> A1, A2
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; ... ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; 0.646998351872
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; 0.0617526473994 0.0617526473994
</pre>

<p>
Now let us plot the equal areas and indicate them by shading.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b008b;">fig</span> = plt.gcf()
<span style="color: #8b008b;">ax</span> = fig.add_subplot(111)

ax.plot(Vr,Pr)

<span style="color: #8b008b;">hline</span> = np.ones(Vr.size) * y_eq

ax.plot(Vr, hline)
ax.fill_between(Vr, hline, Pr, where=(Vr &gt;= v[0]) &amp; (Vr &lt;= v[1]), facecolor=<span style="color: #228b22;">'gray'</span>)
ax.fill_between(Vr, hline, Pr, where=(Vr &gt;= v[1]) &amp; (Vr &lt;= v[2]), facecolor=<span style="color: #228b22;">'gray'</span>)

plt.text(v[0], 1, <span style="color: #228b22;">'A1 = {0}'</span>.<span style="color: #cd0000;">format</span>(A1))
plt.text(v[2], 1, <span style="color: #228b22;">'A2 = {0}'</span>.<span style="color: #cd0000;">format</span>(A2))
plt.xlabel(<span style="color: #228b22;">'$V_R$'</span>)
plt.ylabel(<span style="color: #228b22;">'$P_R$'</span>)
plt.title(<span style="color: #228b22;">'$T_R$ = 0.9'</span>)

plt.savefig(<span style="color: #228b22;">'images/maxwell-eq-area-4.png'</span>)
plt.savefig(<span style="color: #228b22;">'images/maxwell-eq-area-4.svg'</span>)
</pre>
</div>


<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x043939D0&gt;]
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; [&lt;matplotlib.lines.Line2D object at 0x043A7230&gt;]
&lt;matplotlib.collections.PolyCollection object at 0x047ADE70&gt;
&lt;matplotlib.collections.PolyCollection object at 0x047ADAB0&gt;
&gt;&gt;&gt; &lt;matplotlib.text.Text object at 0x0438E730&gt;
&lt;matplotlib.text.Text object at 0x047B7930&gt;
&lt;matplotlib.text.Text object at 0x04237CB0&gt;
&lt;matplotlib.text.Text object at 0x042DC030&gt;
&lt;matplotlib.text.Text object at 0x042EBCD0&gt;
</pre>


<div class="figure">
<p><p><img src="/img/./images/maxwell-eq-area-4.png"><p></p>
</div>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/15/The-equal-area-method-for-the-van-der-Waals-equation.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Constrained minimization to find equilibrium compositions</title>
      <link>http://jkitchin.github.io/blog/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions</link>
      <pubDate>Tue, 05 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[optimization]]></category>
      <guid isPermaLink="false">HB-uY8lu7q22beBW__fqM0My8HY=</guid>
      <description>Constrained minimization to find equilibrium compositions</description>
      <content:encoded><![CDATA[



<p>
adapated from Chemical Reactor analysis and design fundamentals, Rawlings and Ekerdt, appendix A.2.3.
</p>

<p>
<a href="http://matlab.cheme.cmu.edu/2011/08/12/constrained-minimization-to-find-equilibrium-compositions/" >Matlab post</a>
</p>

<p>
The equilibrium composition of a reaction is the one that minimizes the total Gibbs free energy. The Gibbs free energy of a reacting ideal gas mixture depends on the mole fractions of each species, which are determined by the initial mole fractions of each species, the extent of reactions that convert each species, and the equilibrium constants.
</p>

<p>
Reaction 1: \(I + B \rightleftharpoons P1\)
</p>

<p>
Reaction 2: \(I + B \rightleftharpoons P2\)
</p>

<p>
Here we define the Gibbs free energy of the mixture as a function of the reaction extents.
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">gibbs</span>(E):
    <span style="color: #228b22;">'function defining Gibbs free energy as a function of reaction extents'</span>
    e1 = E[0]
    e2 = E[1]
    <span style="color: #ff0000; font-weight: bold;"># known equilibrium constants and initial amounts</span>
    K1 = 108; K2 = 284; P = 2.5;
    yI0 = 0.5; yB0 = 0.5; yP10 = 0.0; yP20 = 0.0;
    <span style="color: #ff0000; font-weight: bold;"># compute mole fractions</span>
    d = 1 - e1 - e2;
    yI = (yI0 - e1 - e2) / d;
    yB = (yB0 - e1 - e2) / d;
    yP1 = (yP10 + e1) / d;
    yP2 = (yP20 + e2) / d;
    G = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
         d * np.log(P) + yI * d * np.log(yI) + 
         yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
    <span style="color: #8b0000;">return</span> G
</pre>
</div>

<p>
The equilibrium constants for these reactions are known, and we seek to find the equilibrium reaction extents so we can determine equilibrium compositions. The equilibrium reaction extents are those that minimize the Gibbs free energy.  We have the following constraints, written in standard less than or equal to form:
</p>

<p>
\(-\epsilon_1 \le 0\)
</p>

<p>
\(-\epsilon_2 \le 0\)
</p>

<p>
\(\epsilon_1 + \epsilon_2 \le 0.5\)
</p>

<p>
In Matlab we express this in matrix form as Ax=b where \(A = \left[ \begin{array}{cc} -1 & 0 \\ 0 & -1 \\ 1 & 1 \end{array} \right]\) and \(b = \left[ \begin{array}{c} 0 \\ 0 \\ 0.5\end{array} \right]\)
</p>

<p>
Unlike in Matlab, in python we construct the inequality constraints as functions that are greater than or equal to zero when the constraint is met.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">def</span> <span style="color: #8b2323;">constraint1</span>(E):
    e1 = E[0]
    <span style="color: #8b0000;">return</span> e1

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">constraint2</span>(E):
    e2 = E[1]
    <span style="color: #8b0000;">return</span> e2

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">constraint3</span>(E):
    e1 = E[0]
    e2 = E[1]
    <span style="color: #8b0000;">return</span> 0.5 - (e1 + e2)
</pre>
</div>

<p>
Now, we minimize.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fmin_slsqp

X0 = [0.133, 0.351]
X = fmin_slsqp(gibbs, X0, ieqcons=[constraint1, constraint2, constraint3])
<span style="color: #8b0000;">print</span> X

<span style="color: #8b0000;">print</span> gibbs(X)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; Optimization terminated successfully.    (Exit mode 0)
            Current function value: -2.55942338611
            Iterations: 1
            Function evaluations: 8
            Gradient evaluations: 1
[ 0.1330313   0.35101555]
&gt;&gt;&gt; -2.55942338611
</pre>


<p>
One way we can verify our solution is to plot the gibbs function and see where the minimum is, and whether there is more than one minimum. We start by making grids over the range of 0 to 0.5. Note we actually start slightly above zero because at zero there are some numerical imaginary elements of the gibbs function or it is numerically not defined since there are logs of zero there. We also set all elements where the sum of the two extents is greater than 0.5 to near zero, since those regions violate the constraints. 
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np
<span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt

<span style="color: #8b0000;">def</span> <span style="color: #8b2323;">gibbs</span>(E):
    <span style="color: #228b22;">'function defining Gibbs free energy as a function of reaction extents'</span>
    e1 = E[0]
    e2 = E[1]
    <span style="color: #ff0000; font-weight: bold;"># known equilibrium constants and initial amounts</span>
    K1 = 108; K2 = 284; P = 2.5;
    yI0 = 0.5; yB0 = 0.5; yP10 = 0.0; yP20 = 0.0;
    <span style="color: #ff0000; font-weight: bold;"># compute mole fractions</span>
    d = 1 - e1 - e2;
    yI = (yI0 - e1 - e2)/d;
    yB = (yB0 - e1 - e2)/d;
    yP1 = (yP10 + e1)/d;
    yP2 = (yP20 + e2)/d;
    G = (-(e1 * np.log(K1) + e2 * np.log(K2)) +
         d * np.log(P) + yI * d * np.log(yI) + 
         yB * d * np.log(yB) + yP1 * d * np.log(yP1) + yP2 * d * np.log(yP2))
    <span style="color: #8b0000;">return</span> G


a = np.linspace(0.001, 0.5, 100)
E1, E2 = np.meshgrid(a,a)

sumE = E1 + E2
E1[sumE &gt;= 0.5] = 0.00001
E2[sumE &gt;= 0.5] = 0.00001

<span style="color: #ff0000; font-weight: bold;"># now evaluate gibbs</span>
G = np.zeros(E1.shape)
m,n = E1.shape

G = gibbs([E1, E2])

CS = plt.contour(E1, E2, G, levels=np.linspace(G.min(),G.max(),100))
plt.xlabel(<span style="color: #228b22;">'$\epsilon_1$'</span>)
plt.ylabel(<span style="color: #228b22;">'$\epsilon_2$'</span>)
plt.colorbar()

plt.plot([ 0.1330313],   [0.35101555], <span style="color: #228b22;">'ro'</span>)

plt.savefig(<span style="color: #228b22;">'images/gibbs-minimization-1.png'</span>)
plt.savefig(<span style="color: #228b22;">'images/gibbs-minimization-1.svg'</span>)
plt.show()
</pre>
</div>

<p><img src="/img/./images/gibbs-minimization-1.png"><p>

<p>
You can see we found the minimum. We can compute the mole fractions pretty easily.
</p>

<div class="org-src-container">

<pre class="src src-python">e1 = X[0];
e2 = X[1];

yI0 = 0.5; yB0 = 0.5; yP10 = 0; yP20 = 0; <span style="color: #ff0000; font-weight: bold;">#initial mole fractions</span>

d = 1 - e1 - e2;
yI = (yI0 - e1 - e2)/d;
yB = (yB0 - e1 - e2)/d;
yP1 = (yP10 + e1)/d;
yP2 = (yP20 + e2)/d;

<span style="color: #8b0000;">print</span>(<span style="color: #228b22;">'y_I = {0:1.3f} y_B = {1:1.3f} y_P1 = {2:1.3f} y_P2 = {3:1.3f}'</span>.format(yI,yB,yP1,yP2))
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; y_I = 0.031 y_B = 0.031 y_P1 = 0.258 y_P2 = 0.680
</pre>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> summary</h2>
<div class="outline-text-2" id="text-1">
<p>
I found setting up the constraints in this example to be more confusing than the Matlab syntax.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/05/Constrained-minimization-to-find-equilibrium-compositions.org">org-mode source</a><p>]]></content:encoded>
    </item>
    <item>
      <title>Estimating the boiling point of water</title>
      <link>http://jkitchin.github.io/blog/2013/02/04/Estimating-the-boiling-point-of-water</link>
      <pubDate>Mon, 04 Feb 2013 09:00:00 EST</pubDate>
      <category><![CDATA[uncategorized]]></category>
      <guid isPermaLink="false">COTcdDHZhHVGtw1uWV6EAzpjRwg=</guid>
      <description>Estimating the boiling point of water</description>
      <content:encoded><![CDATA[


<p>
<a href="http://matlab.cheme.cmu.edu/2012/01/01/estimating-the-boiling-point-of-water/" >Matlab post</a>
</p>

<p>
I got distracted looking for Shomate parameters for ethane today, and came across this <a href="http://senese.wordpress.com/2010/01/26/notebook-3-2-predicting-boiling-points-from-liquidvapor-gibbs-free-energy-functions/" >website</a> on predicting the boiling point of water using the Shomate equations. The basic idea is to find the temperature where the Gibbs energy of water as a vapor is equal to the Gibbs energy of the liquid.
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> matplotlib.pyplot <span style="color: #8b0000;">as</span> plt
</pre>
</div>

<p>
Liquid water (\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=2#Thermo-Condensed})
</p>
<div class="org-src-container">

<pre class="src src-python"><span style="color: #ff0000; font-weight: bold;"># valid over 298-500</span>

Hf_liq = -285.830   <span style="color: #ff0000; font-weight: bold;"># kJ/mol</span>
S_liq = 0.06995     <span style="color: #ff0000; font-weight: bold;"># kJ/mol/K</span>
shomateL = [-203.6060,
            1523.290,
           -3196.413,
            2474.455,
               3.855326,
            -256.5478,
            -488.7163,
            -285.8304]
</pre>
</div>

<p>
Gas phase water (\url{http://webbook.nist.gov/cgi/cbook.cgi?ID=C7732185&Units=SI&Mask=1&Type=JANAFG&Table=on#JANAFG})
</p>

<p>
Interestingly, these parameters are listed as valid only above 500K. That means we have to extrapolate the values down to 298K. That is risky for polynomial models, as they can deviate substantially outside the region they were fitted to.
</p>

<div class="org-src-container">

<pre class="src src-python">Hf_gas = -241.826  <span style="color: #ff0000; font-weight: bold;"># kJ/mol</span>
S_gas = 0.188835   <span style="color: #ff0000; font-weight: bold;"># kJ/mol/K</span>

shomateG = [30.09200,
             6.832514,
             6.793435,
            -2.534480,
             0.082139,
          -250.8810,
           223.3967,
          -241.8264]
</pre>
</div>

<p>
Now, we wan to compute G for each phase as a function of T
</p>

<div class="org-src-container">

<pre class="src src-python"><span style="color: #8b0000;">import</span> numpy <span style="color: #8b0000;">as</span> np

T = np.linspace(0, 200) + 273.15
t = T / 1000.0

sTT = np.vstack([np.log(t),
                 t,
                 (t**2) / 2.0,
                 (t**3) / 3.0,
                 -1.0 / (2*t**2),
                 0 * t,
                 t**0,
                 0 * t**0]).T / 1000.0

hTT = np.vstack([t,
                 (t**2)/2.0,
                 (t**3)/3.0,
                 (t**4)/4.0,
                 -1.0 / t,
                 1 * t**0,
                 0 * t**0,
                 -1 * t**0]).T

Gliq = Hf_liq + np.dot(hTT, shomateL) - T*(np.dot(sTT, shomateL))
Ggas = Hf_gas + np.dot(hTT, shomateG) - T*(np.dot(sTT, shomateG))
                 
<span style="color: #8b0000;">from</span> scipy.interpolate <span style="color: #8b0000;">import</span> interp1d
<span style="color: #8b0000;">from</span> scipy.optimize <span style="color: #8b0000;">import</span> fsolve

f = interp1d(T, Gliq - Ggas)
bp, = fsolve(f, 373)
<span style="color: #8b0000;">print</span> <span style="color: #228b22;">'The boiling point is {0} K'</span>.format(bp)
</pre>
</div>

<pre class="example">
&gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; ... ... ... ... ... ... ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; ... &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; &gt;&gt;&gt; The boiling point is 373.206081312 K
</pre>

<div class="org-src-container">

<pre class="src src-python">plt.figure(); plt.clf()
plt.plot(T-273.15, Gliq, T-273.15, Ggas)
plt.legend([<span style="color: #228b22;">'liquid water'</span>, <span style="color: #228b22;">'steam'</span>])

plt.xlabel(<span style="color: #228b22;">'Temperature $^\circ$C'</span>)
plt.ylabel(<span style="color: #228b22;">'$\Delta G$ (kJ/mol)'</span>)
plt.title(<span style="color: #228b22;">'The boiling point is approximately {0:1.2f} $^\circ$C'</span>.format(bp-273.15))
plt.savefig(<span style="color: #228b22;">'images/boiling-water.png'</span>)
</pre>
</div>

<pre class="example">
&lt;matplotlib.figure.Figure object at 0x050D2E30&gt;
[&lt;matplotlib.lines.Line2D object at 0x051AB610&gt;, &lt;matplotlib.lines.Line2D object at 0x051B4C90&gt;]
&lt;matplotlib.legend.Legend object at 0x051B9030&gt;
&gt;&gt;&gt; &lt;matplotlib.text.Text object at 0x0519E390&gt;
&lt;matplotlib.text.Text object at 0x050FB390&gt;
&lt;matplotlib.text.Text object at 0x050FBFB0&gt;
</pre>

<p><img src="/img/./images/boiling-water.png"><p>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Summary</h2>
<div class="outline-text-2" id="text-1">
<p>
The answer we get us 0.05 K too high, which is not bad considering we estimated it using parameters that were fitted to thermodynamic data and that had finite precision and extrapolated the steam properties below the region the parameters were stated to be valid for.
</p>
</div>
</div>
<p>Copyright (C) 2013 by John Kitchin. See the <a href="/copying.html">License</a> for information about copying.<p><p><a href="/org/2013/02/04/Estimating-the-boiling-point-of-water.org">org-mode source</a><p>]]></content:encoded>
    </item>
  </channel>
</rss>
