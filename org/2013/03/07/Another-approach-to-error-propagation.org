** Another approach to error propagation
   :PROPERTIES:
   :categories: statistics
   :date:     2013/03/07 09:26:06
   :updated:  2013/03/07 09:26:06
   :END:
In the previous section we examined an analytical approach to error propagation, and a simulation based approach. There is another approach to error propagation, using the uncertainties module (https://pypi.python.org/pypi/uncertainties/). You have to install this package, e.g. =pip install uncertainties=. After that, the module provides new classes of numbers and functions that incorporate uncertainty and propagate the uncertainty through the functions. In the examples that follow, we repeat the calculations from the previous section using the uncertainties module. 

_Addition and subtraction_
#+BEGIN_SRC python :session
import uncertainties as u

A = u.ufloat((2.5, 0.4))
B = u.ufloat((4.1, 0.3))
print A + B
print A - B
#+END_SRC

#+RESULTS:
: 
: >>> >>> >>> 6.6+/-0.5
: -1.6+/-0.5

_Multiplication and division_
#+BEGIN_SRC python :session
F = u.ufloat((25, 1))
x = u.ufloat((6.4, 0.4))

t = F * x
print t

d = F / x
print d
#+END_SRC

#+RESULTS:
: 
: >>> >>> >>> 160.0+/-11.8726576637
: >>> >>> 3.90625+/-0.289859806243

_Exponentiation_
#+BEGIN_SRC python :session
t = u.ufloat((2.03, 0.0203))
print t**5

from uncertainties.umath import sqrt
A = u.ufloat((16.07, 0.06))
print sqrt(A)
# print np.sqrt(A) # this does not work

from uncertainties import unumpy as unp
print unp.sqrt(A)
#+END_SRC

#+RESULTS:
: 
: 34.4730881243+/-1.72365440621
: >>> >>> >>> >>> 4.00874045057+/-0.00748364738749
: ... >>> >>> 4.00874045057+/-0.00748364738749

Note in the last example, we had to either import a function from uncertainties.umath or import a special version of numpy that handles uncertainty. This may be a limitation of teh uncertainties package as not all functions in arbitrary modules can be covered. Note, however, that you can wrap a function to make it handle uncertainty like this.

#+BEGIN_SRC python :session
import numpy as np

wrapped_sqrt = u.wrap(np.sqrt)
print wrapped_sqrt(A)
#+END_SRC

#+RESULTS:
: 
: >>> >>> 4.00874045057+/-0.00748364738774

_Propagation of errors in an integral_
#+BEGIN_SRC python :session
import numpy as np
import uncertainties as u

x = np.array([u.ufloat((1, 0.01)), 
              u.ufloat((2, 0.1)),
              u.ufloat((3, 0.1))])

y = 2 * x

print np.trapz(x, y)

#+END_SRC
#+RESULTS:
: 
: >>> >>> ... ... >>> >>> >>> >>> 8.0+/-0.600333240792

_Chain rule in error propagation_
#+BEGIN_SRC python :session
v0 = u.ufloat((1.2, 0.02))
a = u.ufloat((3.0, 0.3))
t = u.ufloat((12.0, 0.12))

v = v0 + a * t
print v
#+END_SRC

#+RESULTS:
: 
: >>> >>> >>> >>> 37.2+/-3.61801050303

_A real example?_
This is what I would setup for a real working example. Unfortunately, it does not work, and it is not clear why.
#+BEGIN_SRC python :session
from scipy.optimize import fsolve

Fa0 = u.ufloat((5.0, 0.05))
v0 = u.ufloat((10., 0.1))

V = u.ufloat((66000.0, 100))  # reactor volume L^3
k = u.ufloat((3.0, 0.2))      # rate constant L/mol/h

def func(Ca):
    "Mole balance for a CSTR. Solve this equation for func(Ca)=0"
    Fa = v0 * Ca     # exit molar flow of A
    ra = -k * Ca**2  # rate of reaction of A L/mol/h
    return Fa0 - Fa + V * ra

# CA guess that that 90 % is reacted away
CA_guess = 0.1 * Fa0 / v0

wrapped_fsolve = u.wrap(fsolve)
CA_sol = wrapped_fsolve(func, CA_guess)

print 'The exit concentration is {0} mol/L'.format(CA_sol)
#+END_SRC

#+RESULTS:
: 
: >>> >>> >>> >>> >>> >>> >>> ... ... ... ... ... >>> ... >>> >>> >>> <function fsolve at 0x148f25f0>
: >>> >>> The exit concentration is NotImplemented mol/L




*** Summary
The uncertainties module is pretty amazing. It automatically propagates errors through a pretty broad range of computations. I was not able to use it on a nonlinear algebra solution, and it was not clear why. Maybe there is a better approach to that.

Read more about the package at http://pythonhosted.org/uncertainties/index.html.
